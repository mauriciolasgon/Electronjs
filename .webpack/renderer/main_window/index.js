/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),\n/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   UNSAFE_getResolveToMatches: () => (/* binding */ getResolveToMatches),\n/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),\n/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename)\n/* harmony export */ });\n/**\n * @remix-run/router v1.16.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action[\"Push\"] = \"PUSH\";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window.location.hash.substr(1));\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    // Treating this as a full URL will strip any trailing spaces so we need to\n    // pre-encode them since they might be part of a matching splat param from\n    // an ancestor route\n    href = href.replace(/ $/, \"%20\");\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType[\"data\"] = \"data\";\n  ResultType[\"deferred\"] = \"deferred\";\n  ResultType[\"redirect\"] = \"redirect\";\n  ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch(branches[i], decoded);\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it's the last segment\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, \"\");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = undefined;\n    } else {\n      memo[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, params];\n}\nfunction decodePath(value) {\n  try {\n    return value.split(\"/\").map(v => decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n  } catch (error) {\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n  let pathMatches = getPathContributingMatches(matches);\n  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n  // match so we include splat values for \".\" links.  See:\n  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n  }\n  return pathMatches.map(match => match.pathnameBase);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    // With relative=\"route\" (the default), each leading .. segment means\n    // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n    // difference from how <a href> works and a major reason we call this a\n    // \"to\" value instead of a \"href\".\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let dataStrategyImpl = init.unstable_dataStrategy || defaultDataStrategy;\n  // Config driven behavior flags\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false,\n    unstable_skipActionErrorRevalidation: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized;\n  let hasLazyRoutes = initialMatches.some(m => m.route.lazy);\n  let hasLoaders = initialMatches.some(m => m.route.loader);\n  if (hasLazyRoutes) {\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    initialized = false;\n  } else if (!hasLoaders) {\n    // If we've got no loaders to run, then we're good to go\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    // If partial hydration is enabled, we're initialized so long as we were\n    // provided with hydrationData for every route with a loader, and no loaders\n    // were marked for explicit hydration\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    let isRouteInitialized = m => {\n      // No loader, nothing to initialize\n      if (!m.route.loader) {\n        return true;\n      }\n      // Explicitly opting-in to running on hydration\n      if (typeof m.route.loader === \"function\" && m.route.loader.hydrate === true) {\n        return false;\n      }\n      // Otherwise, initialized if hydrated with data or an error\n      return loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined;\n    };\n    // If errors exist, don't consider routes below the boundary\n    if (errors) {\n      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);\n      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);\n    } else {\n      initialized = initialMatches.every(isRouteInitialized);\n    }\n  } else {\n    // Without partial hydration - we're initialized if we were provided any\n    // hydrationData - which is expected to be complete\n    initialized = init.hydrationData != null;\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions = new Map();\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener = null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map();\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don't update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach(subscriber => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach(key => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach(key => deleteFetcher(key));\n    }\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === Action.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionResult;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingActionResult = [findNearestBoundary(matches).route.id, {\n        type: ResultType.error,\n        error: opts.pendingError\n      }];\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionResult = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionResult.shortCircuited) {\n        return;\n      }\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      // Create a GET request for the loaders\n      request = createClientSideRequest(init.history, request.url, request.signal);\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, getActionDataForCommit(pendingActionResult), {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      let results = await callDataStrategy(\"action\", request, [actionMatch], matches);\n      result = results[0];\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        let location = normalizeRedirectLocation(result.response.headers.get(\"Location\"), new URL(request.url), basename);\n        replace = location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        pendingActionResult: [boundaryMatch.route.id, result]\n      };\n    }\n    return {\n      pendingActionResult: [actionMatch.route.id, result]\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.unstable_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null\n      }, getActionDataForCommit(pendingActionResult), updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    // If we have partialHydration enabled, then don't update the state for the\n    // initial data load since it's not a \"navigation\"\n    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData;\n      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n        // This is cast to `any` currently because `RouteData`uses any and it\n        // would be a breaking change to use any.\n        // TODO: v7 - change `RouteData` to use `unknown` instead of `any`\n        actionData = {\n          [pendingActionResult[0]]: pendingActionResult[1].data\n        };\n      } else if (state.actionData) {\n        if (Object.keys(state.actionData).length === 0) {\n          actionData = null;\n        } else {\n          actionData = state.actionData;\n        }\n      }\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData !== undefined ? {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect([...loaderResults, ...fetcherResults]);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(request, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    // During partial hydration, preserve SSR errors for routes that don't re-run\n    if (future.v7_partialHydration && initialHydration && state.errors) {\n      Object.entries(state.errors).filter(_ref2 => {\n        let [id] = _ref2;\n        return !matchesToLoad.some(m => m.route.id === id);\n      }).forEach(_ref3 => {\n        let [routeId, error] = _ref3;\n        errors = Object.assign(errors || {}, {\n          [routeId]: error\n        });\n      });\n    }\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResults = await callDataStrategy(\"action\", fetchRequest, [match], requestMatches);\n    let actionResult = actionResults[0];\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n    // or redirects processed for unmounted fetchers so we just revert them to\n    // idle\n    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      }\n      // Let SuccessResult's fall through for revalidation\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          // A new navigation was kicked off after our action started, so that\n          // should take precedence over this redirect navigation.  We already\n          // set isRevalidationRequired so all loaders for the new route should\n          // fire unless opted out via shouldRevalidate\n          updateFetcherState(key, getDoneFetcher(undefined));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, {\n            fetcherSubmission: submission\n          });\n        }\n      }\n      // Process any non-redirect errors thrown\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.unstable_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect([...loaderResults, ...fetcherResults]);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(revalidationRequest, redirect.result);\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n      flushSync\n    });\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let results = await callDataStrategy(\"loader\", fetchRequest, [match], matches);\n    let result = results[0];\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    // We don't want errors bubbling up or redirects followed for unmounted\n    // fetchers, so short circuit here if it was removed from the UI\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result);\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(request, redirect, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n    let location = redirect.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(location, new URL(request.url), basename);\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true\n    });\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.response.headers.has(\"X-Remix-Reload-Document\")) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(location)) {\n        const url = init.history.createURL(location);\n        isDocumentReload =\n        // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  // Utility wrapper for calling dataStrategy client-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(type, request, matchesToLoad, matches) {\n    try {\n      let results = await callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties);\n      return await Promise.all(results.map((result, i) => {\n        if (isRedirectHandlerResult(result)) {\n          let response = result.result;\n          return {\n            type: ResultType.redirect,\n            response: normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath)\n          };\n        }\n        return convertHandlerResultToDataResult(result);\n      }));\n    } catch (e) {\n      // If the outer dataStrategy method throws, just return the error for all\n      // matches - and it'll naturally bubble to the root\n      return matchesToLoad.map(() => ({\n        type: ResultType.error,\n        error: e\n      }));\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    let [loaderResults, ...fetcherResults] = await Promise.all([matchesToLoad.length ? callDataStrategy(\"loader\", request, matchesToLoad, matches) : [], ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        let fetcherRequest = createClientSideRequest(init.history, f.path, f.controller.signal);\n        return callDataStrategy(\"loader\", fetcherRequest, [f.match], f.matches).then(r => r[0]);\n      } else {\n        return Promise.resolve({\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        });\n      }\n    })]);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref4) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref4;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Config driven behavior flags\n  let future = _extends({\n    v7_relativeSplatPath: false,\n    v7_throwAbortReason: false\n  }, opts ? opts.future : null);\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   *\n   * - `opts.requestContext` is an optional server context that will be passed\n   *   to actions/loaders in the `context` parameter\n   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent\n   *   the bubbling of errors which allows single-fetch-type implementations\n   *   where the client will handle the bubbling and we may need to return data\n   *   for the handling route\n   */\n  async function query(request, _temp3) {\n    let {\n      requestContext,\n      skipLoaderErrorBubbling,\n      unstable_dataStrategy\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext, unstable_dataStrategy || null, skipLoaderErrorBubbling === true, null);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   *\n   * - `opts.routeId` allows you to specify the specific route handler to call.\n   *   If not provided the handler will determine the proper route by matching\n   *   against `request.url`\n   * - `opts.requestContext` is an optional server context that will be passed\n   *    to actions/loaders in the `context` parameter\n   */\n  async function queryRoute(request, _temp4) {\n    let {\n      routeId,\n      requestContext\n    } = _temp4 === void 0 ? {} : _temp4;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, null, false, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch) {\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction for a\n      // `queryRoute` call, we throw the `HandlerResult` to bail out early\n      // and then return or throw the raw Response here accordingly\n      if (isHandlerResult(e) && isResponse(e.result)) {\n        if (e.type === ResultType.error) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      let results = await callDataStrategy(\"action\", request, [actionMatch], matches, isRouteRequest, requestContext, unstable_dataStrategy);\n      result = results[0];\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest, future);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(loaderRequest, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, null, [boundaryMatch.route.id, result]);\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    let context = await loadRouteData(loaderRequest, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, null);\n    return _extends({}, context, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      }\n    }, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionHeaders: result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {}\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, unstable_dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await callDataStrategy(\"loader\", request, matchesToLoad, matches, isRouteRequest, requestContext, unstable_dataStrategy);\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest, future);\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  // Utility wrapper for calling dataStrategy server-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, unstable_dataStrategy) {\n    let results = await callDataStrategyImpl(unstable_dataStrategy || defaultDataStrategy, type, request, matchesToLoad, matches, manifest, mapRouteProperties, requestContext);\n    return await Promise.all(results.map((result, i) => {\n      if (isRedirectHandlerResult(result)) {\n        let response = result.result;\n        // Throw redirects and let the server handle them with an HTTP redirect\n        throw normalizeRelativeRoutingRedirectResponse(response, request, matchesToLoad[i].route.id, matches, basename, future.v7_relativeSplatPath);\n      }\n      if (isResponse(result.result) && isRouteRequest) {\n        // For SSR single-route requests, we want to hand Responses back\n        // directly without unwrapping\n        throw result;\n      }\n      return convertHandlerResultToDataResult(result);\n    }));\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest, future) {\n  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\n    throw request.signal.reason;\n  }\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don't already have one\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref5) => {\n        let [name, value] = _ref5;\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\n      }, \"\") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {\n  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[0] : undefined;\n  let boundaryMatches = boundaryId ? getLoaderMatchesUntilBoundary(matches, boundaryId) : matches;\n  // Don't revalidate loaders by default after action 4xx/5xx responses\n  // when the flag is enabled.  They can still opt-into revalidation via\n  // `shouldRevalidate` via `actionResult`\n  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : undefined;\n  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    let {\n      route\n    } = match;\n    if (route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (route.loader == null) {\n      return false;\n    }\n    if (isInitialLoad) {\n      if (typeof route.loader !== \"function\" || route.loader.hydrate) {\n        return true;\n      }\n      return state.loaderData[route.id] === undefined && (\n      // Don't re-run if the loader ran and threw an error\n      !state.errors || state.errors[route.id] === undefined);\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      unstable_actionStatus: actionStatus,\n      defaultShouldRevalidate: shouldSkipRevalidation ? false :\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate:\n    //  - on initial load (shouldn't be any fetchers then anyway)\n    //  - if fetcher won't be present in the subsequent render\n    //    - no longer matches the URL (v7_fetcherPersist=false)\n    //    - was unmounted but persisted due to v7_fetcherPersist=true\n    if (isInitialLoad || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        unstable_actionStatus: actionStatus,\n        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\n// Default implementation of `dataStrategy` which fetches all loaders in parallel\nfunction defaultDataStrategy(opts) {\n  return Promise.all(opts.matches.map(m => m.resolve()));\n}\nasync function callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, manifest, mapRouteProperties, requestContext) {\n  let routeIdsToLoad = matchesToLoad.reduce((acc, m) => acc.add(m.route.id), new Set());\n  let loadedMatches = new Set();\n  // Send all matches here to allow for a middleware-type implementation.\n  // handler will be a no-op for unneeded routes and we filter those results\n  // back out below.\n  let results = await dataStrategyImpl({\n    matches: matches.map(match => {\n      let shouldLoad = routeIdsToLoad.has(match.route.id);\n      // `resolve` encapsulates the route.lazy, executing the\n      // loader/action, and mapping return values/thrown errors to a\n      // HandlerResult.  Users can pass a callback to take fine-grained control\n      // over the execution of the loader/action\n      let resolve = handlerOverride => {\n        loadedMatches.add(match.route.id);\n        return shouldLoad ? callLoaderOrAction(type, request, match, manifest, mapRouteProperties, handlerOverride, requestContext) : Promise.resolve({\n          type: ResultType.data,\n          result: undefined\n        });\n      };\n      return _extends({}, match, {\n        shouldLoad,\n        resolve\n      });\n    }),\n    request,\n    params: matches[0].params,\n    context: requestContext\n  });\n  // Throw if any loadRoute implementations not called since they are what\n  // ensures a route is fully loaded\n  matches.forEach(m => invariant(loadedMatches.has(m.route.id), \"`match.resolve()` was not called for route id \\\"\" + m.route.id + \"\\\". \" + \"You must call `match.resolve()` on every match passed to \" + \"`dataStrategy` to ensure all routes are properly loaded.\"));\n  // Filter out any middleware-only matches for which we didn't need to run handlers\n  return results.filter((_, i) => routeIdsToLoad.has(matches[i].route.id));\n}\n// Default logic for calling a loader/action is the user has no specified a dataStrategy\nasync function callLoaderOrAction(type, request, match, manifest, mapRouteProperties, handlerOverride, staticContext) {\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    // This will never resolve so safe to type it as Promise<HandlerResult> to\n    // satisfy the function return value\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    let actualHandler = ctx => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(new Error(\"You cannot call the handler for a route which defines a boolean \" + (\"\\\"\" + type + \"\\\" [routeId: \" + match.route.id + \"]\")));\n      }\n      return handler({\n        request,\n        params: match.params,\n        context: staticContext\n      }, ...(ctx !== undefined ? [ctx] : []));\n    };\n    let handlerPromise;\n    if (handlerOverride) {\n      handlerPromise = handlerOverride(ctx => actualHandler(ctx));\n    } else {\n      handlerPromise = (async () => {\n        try {\n          let val = await actualHandler();\n          return {\n            type: \"data\",\n            result: val\n          };\n        } catch (e) {\n          return {\n            type: \"error\",\n            result: e\n          };\n        }\n      })();\n    }\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let [value] = await Promise.all([\n        // If the handler throws, don't let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        if (handlerError !== undefined) {\n          throw handlerError;\n        }\n        result = value;\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still runs even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            result: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result.result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    // We should already be catching and converting normal handler executions to\n    // HandlerResults and returning them, so anything that throws here is an\n    // unexpected error we still need to wrap\n    return {\n      type: ResultType.error,\n      result: e\n    };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  return result;\n}\nasync function convertHandlerResultToDataResult(handlerResult) {\n  let {\n    result,\n    type,\n    status\n  } = handlerResult;\n  if (isResponse(result)) {\n    let data;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      // Check between word boundaries instead of startsWith() due to the last\n      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        if (result.body == null) {\n          data = null;\n        } else {\n          data = await result.json();\n        }\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n    if (type === ResultType.error) {\n      return {\n        type: ResultType.error,\n        error: new ErrorResponseImpl(result.status, result.statusText, data),\n        statusCode: result.status,\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (type === ResultType.error) {\n    return {\n      type: ResultType.error,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : status\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result,\n    statusCode: status\n  };\n}\n// Support relative routing in internal redirects\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {\n  let location = response.headers.get(\"Location\");\n  invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n  if (!ABSOLUTE_URL_REGEX.test(location)) {\n    let trimmedMatches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1);\n    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);\n    response.headers.set(\"Location\", location);\n  }\n  return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n  if (ABSOLUTE_URL_REGEX.test(location)) {\n    // Strip off the protocol+origin for same-origin + same-basename absolute redirects\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : undefined;\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError !== undefined) {\n        error = pendingError;\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        // Look upwards from the matched route for the closest ancestor error\n        // boundary, defaulting to the root match.  Prefer higher error values\n        // if lower errors bubble to the same boundary\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      } else {\n        loaderData[id] = result.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (result.statusCode && result.statusCode !== 200 && !foundError) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      }\n    }\n  });\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError !== undefined && pendingActionResult) {\n    errors = {\n      [pendingActionResult[0]]: pendingError\n    };\n    loaderData[pendingActionResult[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingActionResult, activeDeferreds, false // This method is only called client side so we always want to bubble\n  );\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1]) ? {\n    // Clear out prior actionData on errors\n    actionData: {}\n  } : {\n    actionData: {\n      [pendingActionResult[0]]: pendingActionResult[1].data\n    }\n  };\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isHandlerResult(result) {\n  return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === ResultType.data || result.type === ResultType.error);\n}\nfunction isRedirectHandlerResult(result) {\n  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yb3V0ZXIvZGlzdC9yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdDQUF3QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCO0FBQzNCLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUMsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdDQUF3QztBQUM5RTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUNBQWlDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcz8xZTkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHJlbWl4LXJ1bi9yb3V0ZXIgdjEuMTYuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cbiAqL1xudmFyIEFjdGlvbjtcbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBBY3Rpb25bXCJQb3BcIl0gPSBcIlBPUFwiO1xuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBBY3Rpb25bXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIC8qKlxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXG4gICAqL1xuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5jb25zdCBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgbGV0IHtcbiAgICBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIHY1Q29tcGF0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzOyAvLyBEZWNsYXJlIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSBjcmVhdGVNZW1vcnlMb2NhdGlvblxuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKChlbnRyeSwgaW5kZXgpID0+IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKGVudHJ5LCB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsIGluZGV4ID09PSAwID8gXCJkZWZhdWx0XCIgOiB1bmRlZmluZWQpKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleCk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUsIGtleSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLCB0bywgc3RhdGUsIGtleSk7XG4gICAgd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLCBcInJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogXCIgKyBKU09OLnN0cmluZ2lmeSh0bykpO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIGRlbHRhOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgZGVsdGE6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICBkZWx0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFwiXCIsIHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0sXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLCBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3csIHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVCcm93c2VyTG9jYXRpb24sIGNyZWF0ZUJyb3dzZXJIcmVmLCBudWxsLCBvcHRpb25zKTtcbn1cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIlxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcbiAgICAvLyBIYXNoIFVSTCBzaG91bGQgYWx3YXlzIGhhdmUgYSBsZWFkaW5nIC8ganVzdCBsaWtlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgIC8vIGRvZXMsIHNvIGlmIGFuIGFwcCBlbmRzIHVwIGF0IGEgcm91dGUgbGlrZSAvI3NvbWV0aGluZyB0aGVuIHdlIGFkZCBhXG4gICAgLy8gbGVhZGluZyBzbGFzaCBzbyBhbGwgb2Ygb3VyIHBhdGgtbWF0Y2hpbmcgYmVoYXZlcyB0aGUgc2FtZSBhcyBpZiBpdCB3b3VsZFxuICAgIC8vIGluIGEgYnJvd3NlciByb3V0ZXIuICBUaGlzIGlzIHBhcnRpY3VsYXJseSBpbXBvcnRhbnQgd2hlbiB0aGVyZSBleGlzdHMgYVxuICAgIC8vIHJvb3Qgc3BsYXQgcm91dGUgKDxSb3V0ZSBwYXRoPVwiKlwiPikgc2luY2UgdGhhdCBtYXRjaGVzIGludGVybmFsbHkgYWdhaW5zdFxuICAgIC8vIFwiLypcIiBhbmQgd2UnZCBleHBlY3QgLyNzb21ldGhpbmcgdG8gNDA0IGluIGEgaGFzaCByb3V0ZXIgYXBwLlxuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcIlwiLCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9LFxuICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93LCB0bykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIik7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVIYXNoTG9jYXRpb24sIGNyZWF0ZUhhc2hIcmVmLCB2YWxpZGF0ZUhhc2hMb2NhdGlvbiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2UsIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuLyoqXG4gKiBGb3IgYnJvd3Nlci1iYXNlZCBoaXN0b3JpZXMsIHdlIGNvbWJpbmUgdGhlIHN0YXRlIGFuZCBrZXkgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlLCBrZXkpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IG51bGw7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gX2V4dGVuZHMoe1xuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxuICAgIHNlYXJjaDogXCJcIixcbiAgICBoYXNoOiBcIlwiXG4gIH0sIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfSk7XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXRoKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IF9yZWY7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIikgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gXCIjXCIpIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZiwgdmFsaWRhdGVMb2NhdGlvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGxldCB7XG4gICAgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsXG4gICAgdjVDb21wYXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIC8vIEluZGV4IHNob3VsZCBvbmx5IGJlIG51bGwgd2hlbiB3ZSBpbml0aWFsaXplLiBJZiBub3QsIGl0J3MgYmVjYXVzZSB0aGVcbiAgLy8gdXNlciBjYWxsZWQgaGlzdG9yeS5wdXNoU3RhdGUgb3IgaGlzdG9yeS5yZXBsYWNlU3RhdGUgZGlyZWN0bHksIGluIHdoaWNoXG4gIC8vIGNhc2Ugd2Ugc2hvdWxkIGxvZyBhIHdhcm5pbmcgYXMgaXQgd2lsbCByZXN1bHQgaW4gYnVncy5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7XG4gICAgICBpZHg6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgIGRlbHRhXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xuICAgICAgLy8gb3V0d2FyZHMganVzdCBsaWtlIGEgcmVwbGFjZSBjYWxsIHdvdWxkIHNvIHRoZSBkZXYga25vd3MgdGhlIGNhdXNlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9uYXYtaGlzdG9yeS1hcGlzLmh0bWwjc2hhcmVkLWhpc3RvcnktcHVzaC9yZXBsYWNlLXN0YXRlLXN0ZXBzXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgLy8gVHJlYXRpbmcgdGhpcyBhcyBhIGZ1bGwgVVJMIHdpbGwgc3RyaXAgYW55IHRyYWlsaW5nIHNwYWNlcyBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gcHJlLWVuY29kZSB0aGVtIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFydCBvZiBhIG1hdGNoaW5nIHNwbGF0IHBhcmFtIGZyb21cbiAgICAvLyBhbiBhbmNlc3RvciByb3V0ZVxuICAgIGhyZWYgPSBocmVmLnJlcGxhY2UoLyAkLywgXCIlMjBcIik7XG4gICAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6IFwiICsgaHJlZik7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbnZhciBSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChSZXN1bHRUeXBlKSB7XG4gIFJlc3VsdFR5cGVbXCJkYXRhXCJdID0gXCJkYXRhXCI7XG4gIFJlc3VsdFR5cGVbXCJkZWZlcnJlZFwiXSA9IFwiZGVmZXJyZWRcIjtcbiAgUmVzdWx0VHlwZVtcInJlZGlyZWN0XCJdID0gXCJyZWRpcmVjdFwiO1xuICBSZXN1bHRUeXBlW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShSZXN1bHRUeXBlIHx8IChSZXN1bHRUeXBlID0ge30pKTtcbmNvbnN0IGltbXV0YWJsZVJvdXRlS2V5cyA9IG5ldyBTZXQoW1wibGF6eVwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJwYXRoXCIsIFwiaWRcIiwgXCJpbmRleFwiLCBcImNoaWxkcmVuXCJdKTtcbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3NhcnksIHNvIHdlIGFyZSB3b3JraW5nXG4vLyBzb2xlbHkgd2l0aCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCdzIHdpdGhpbiB0aGUgUm91dGVyXG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCBwYXJlbnRQYXRoLCBtYW5pZmVzdCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG4gIGlmIChtYW5pZmVzdCA9PT0gdm9pZCAwKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgfVxuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChyb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sIFwiQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVcIik7XG4gICAgaW52YXJpYW50KCFtYW5pZmVzdFtpZF0sIFwiRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXFxcIlwiICsgaWQgKyBcIlxcXCIuICBSb3V0ZSBcIiArIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCIpO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGUuY2hpbGRyZW4sIG1hcFJvdXRlUHJvcGVydGllcywgdHJlZVBhdGgsIG1hbmlmZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXJvdXRlc1xuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IHZvaWQgMCkge1xuICAgIGJhc2VuYW1lID0gXCIvXCI7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBJbmNvbWluZyBwYXRobmFtZXMgYXJlIGdlbmVyYWxseSBlbmNvZGVkIGZyb20gZWl0aGVyIHdpbmRvdy5sb2NhdGlvblxuICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAvLyBwYXRocyBpbiB0aGUgcm91dGUgZGVmaW5pdGlvbnMuICBNZW1vcnkgcm91dGVyIGxvY2F0aW9ucyB3b24ndCBiZVxuICAgIC8vIGVuY29kZWQgaGVyZSBidXQgdGhlcmUgYWxzbyBzaG91bGRuJ3QgYmUgYW55dGhpbmcgdG8gZGVjb2RlIHNvIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAvLyBoaXN0b3J5LWF3YXJlLlxuICAgIGxldCBkZWNvZGVkID0gZGVjb2RlUGF0aChwYXRobmFtZSk7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goYnJhbmNoZXNbaV0sIGRlY29kZWQpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobWF0Y2gsIGxvYWRlckRhdGEpIHtcbiAgbGV0IHtcbiAgICByb3V0ZSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXNcbiAgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMocm91dGVzLCBicmFuY2hlcywgcGFyZW50c01ldGEsIHBhcmVudFBhdGgpIHtcbiAgaWYgKGJyYW5jaGVzID09PSB2b2lkIDApIHtcbiAgICBicmFuY2hlcyA9IFtdO1xuICB9XG4gIGlmIChwYXJlbnRzTWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50c01ldGEgPSBbXTtcbiAgfVxuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFwiXCI7XG4gIH1cbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChyb3V0ZSwgaW5kZXgsIHJlbGF0aXZlUGF0aCkgPT4ge1xuICAgIGxldCBtZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLCBcIkFic29sdXRlIHJvdXRlIHBhdGggXFxcIlwiICsgbWV0YS5yZWxhdGl2ZVBhdGggKyBcIlxcXCIgbmVzdGVkIHVuZGVyIHBhdGggXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBcIikgKyBcIm11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuXCIpO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLCBcIkluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBcIiArIChcImFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIuXCIpKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIHZhciBfcm91dGUkcGF0aDtcbiAgICAvLyBjb2Fyc2UtZ3JhaW4gY2hlY2sgZm9yIG9wdGlvbmFsIHBhcmFtc1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICEoKF9yb3V0ZSRwYXRoID0gcm91dGUucGF0aCkgIT0gbnVsbCAmJiBfcm91dGUkcGF0aC5pbmNsdWRlcyhcIj9cIikpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbi8qKlxuICogQ29tcHV0ZXMgYWxsIGNvbWJpbmF0aW9ucyBvZiBvcHRpb25hbCBwYXRoIHNlZ21lbnRzIGZvciBhIGdpdmVuIHBhdGgsXG4gKiBleGNsdWRpbmcgY29tYmluYXRpb25zIHRoYXQgYXJlIGFtYmlndW91cyBhbmQgb2YgbG93ZXIgcHJpb3JpdHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGAvb25lLzp0d28/L3RocmVlLzpmb3VyPy86Zml2ZT9gIGV4cGxvZGVzIHRvOlxuICogLSBgL29uZS90aHJlZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS90aHJlZS86Zm91ci86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91ci86Zml2ZWBcbiAqL1xuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEludGVwcmV0IGVtcHR5IHN0cmluZyBhcyBvbWl0dGluZyBhbiBvcHRpb25hbCBzZWdtZW50XG4gICAgLy8gYFtcIm9uZVwiLCBcIlwiLCBcInRocmVlXCJdYCBjb3JyZXNwb25kcyB0byBvbWl0dGluZyBgOnR3b2AgZnJvbSBgL29uZS86dHdvPy90aHJlZWAgLT4gYC9vbmUvdGhyZWVgXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiwgc28gd2UgZ2V0IGNvbnNpc3RlbnQgb3JkZXJpbmcgd2hlcmUgdGhlXG4gIC8vIHBhcmVudCBvcHRpb25hbCBhc3BlY3QgaXMgcHJlZmVycmVkIGFzIHJlcXVpcmVkLiAgT3RoZXJ3aXNlLCB3ZSBjYW4gZ2V0XG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXG4gIC8vIHBhcmVudCBvcHRpb25hbCBzZWdtZW50cywgd2hlcmUgZm9yIGV4YW1wbGUsIC86dHdvIHdvdWxkIGV4cGxvZGUgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZC5tYXAoc3VicGF0aCA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpKSk7XG4gIC8vIFRoZW4sIGlmIHRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIGFkZCBhbGwgY2hpbGQgdmVyc2lvbnMgd2l0aG91dFxuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcChleHBsb2RlZCA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZCk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gIDogY29tcGFyZUluZGV4ZXMoYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksIGIucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpKSk7XG59XG5jb25zdCBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSBzID0+IHMgPT09IFwiKlwiO1xuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGgsIGluZGV4KSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKHMgPT4gIWlzU3BsYXQocykpLnJlZHVjZSgoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLCBpbml0aWFsU2NvcmUpO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgP1xuICAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV0gOlxuICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAwO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lKSB7XG4gIGxldCB7XG4gICAgcm91dGVzTWV0YVxuICB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aCh7XG4gICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVuZFxuICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG9yaWdpbmFsUGF0aCwgcGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gcCA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAvLyBvbmx5IGFwcGx5IHRoZSBzcGxhdCBpZiBpdCdzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtc1tzdGFyXSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW1xcdy1dKykoXFw/PykkLyk7XG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleV07XG4gICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIFwiTWlzc2luZyBcXFwiOlwiICsga2V5ICsgXCJcXFwiIHBhcmFtXCIpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pXG4gIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAuZmlsdGVyKHNlZ21lbnQgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0ge1xuICAgICAgcGF0aDogcGF0dGVybixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgZW5kOiB0cnVlXG4gICAgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKHBhdHRlcm4ucGF0aCwgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLCBwYXR0ZXJuLmVuZCk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZSgobWVtbywgX3JlZiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1OYW1lLFxuICAgICAgaXNPcHRpb25hbFxuICAgIH0gPSBfcmVmO1xuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVtb1twYXJhbU5hbWVdID0gKHZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoLyUyRi9nLCBcIi9cIik7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgsIGNhc2VTZW5zaXRpdmUsIGVuZCkge1xuICBpZiAoY2FzZVNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRydWU7XG4gIH1cbiAgd2FybmluZyhwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgLnJlcGxhY2UoL1xcLzooW1xcdy1dKykoXFw/KT8vZywgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZSxcbiAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgfSk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZTogXCIqXCJcbiAgICB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCwgc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIDtcbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbXNdO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF0aCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdChcIi9cIikubWFwKHYgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHYpLnJlcGxhY2UoL1xcLy9nLCBcIiUyRlwiKSkuam9pbihcIi9cIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhmYWxzZSwgXCJUaGUgVVJMIHBhdGggXFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBpcyBhIFwiICsgXCJtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgXCIgKyAoXCJlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIikgPyBiYXNlbmFtZS5sZW5ndGggLSAxIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0bywgZnJvbVBhdGhuYW1lKSB7XG4gIGlmIChmcm9tUGF0aG5hbWUgPT09IHZvaWQgMCkge1xuICAgIGZyb21QYXRobmFtZSA9IFwiL1wiO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gXCJDYW5ub3QgaW5jbHVkZSBhICdcIiArIGNoYXIgKyBcIicgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIFwiICsgKFwiYHRvLlwiICsgZmllbGQgKyBcImAgZmllbGQgW1wiICsgSlNPTi5zdHJpbmdpZnkocGF0aCkgKyBcIl0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBcIikgKyAoXCJgdG8uXCIgKyBkZXN0ICsgXCJgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIFwiKSArIFwiYSBzdHJpbmcgaW4gPExpbmsgdG89XFxcIi4uLlxcXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5cIjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IGluZGV4ID09PSAwIHx8IG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwKTtcbn1cbi8vIFJldHVybiB0aGUgYXJyYXkgb2YgcGF0aG5hbWVzIGZvciB0aGUgY3VycmVudCByb3V0ZSBtYXRjaGVzIC0gdXNlZCB0b1xuLy8gZ2VuZXJhdGUgdGhlIHJvdXRlUGF0aG5hbWVzIGlucHV0IGZvciByZXNvbHZlVG8oKVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgLy8gV2hlbiB2N19yZWxhdGl2ZVNwbGF0UGF0aCBpcyBlbmFibGVkLCB1c2UgdGhlIGZ1bGwgcGF0aG5hbWUgZm9yIHRoZSBsZWFmXG4gIC8vIG1hdGNoIHNvIHdlIGluY2x1ZGUgc3BsYXQgdmFsdWVzIGZvciBcIi5cIiBsaW5rcy4gIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzExMDUyI2lzc3VlY29tbWVudC0xODM2NTg5MzI5XG4gIGlmICh2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xuICAgIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAoKG1hdGNoLCBpZHgpID0+IGlkeCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxID8gbWF0Y2gucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2UpO1xuICB9XG4gIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUpIHtcbiAgaWYgKGlzUGF0aFJlbGF0aXZlID09PSB2b2lkIDApIHtcbiAgICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IF9leHRlbmRzKHt9LCB0b0FyZyk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKSk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bykpO1xuICAgIGludmFyaWFudCghdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcbiAgICAvLyBXaXRoIHJlbGF0aXZlPVwicm91dGVcIiAodGhlIGRlZmF1bHQpLCBlYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFuc1xuICAgIC8vIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZSBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleVxuICAgIC8vIGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGEgbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhXG4gICAgLy8gXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICBpZiAoIWlzUGF0aFJlbGF0aXZlICYmIHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPSB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPSAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bykge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lIDogdG8ucGF0aG5hbWU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGpvaW5QYXRocyA9IHBhdGhzID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IHBhdGhuYW1lID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IHNlYXJjaCA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSBoYXNoID0+ICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5jb25zdCBqc29uID0gZnVuY3Rpb24ganNvbihkYXRhLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0ge307XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8ge1xuICAgIHN0YXR1czogaW5pdFxuICB9IDogaW5pdDtcbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgX2V4dGVuZHMoe30sIHJlc3BvbnNlSW5pdCwge1xuICAgIGhlYWRlcnNcbiAgfSkpO1xufTtcbmNsYXNzIEFib3J0ZWREZWZlcnJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmNsYXNzIERlZmVycmVkRGF0YSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlc3BvbnNlSW5pdCkge1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRlZmVycmVkS2V5cyA9IFtdO1xuICAgIGludmFyaWFudChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLCBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIik7XG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgX3JlZjIpID0+IHtcbiAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICBba2V5XTogdGhpcy50cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBBbGwgaW5jb21pbmcgdmFsdWVzIHdlcmUgcmVzb2x2ZWRcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XG4gIH1cbiAgdHJhY2tQcm9taXNlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmFkZChrZXkpO1xuICAgIC8vIFdlIHN0b3JlIGEgbGl0dGxlIHdyYXBwZXIgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aFxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XG4gICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJhY2UoW3ZhbHVlLCB0aGlzLmFib3J0UHJvbWlzZV0pLnRoZW4oZGF0YSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgdW5kZWZpbmVkLCBkYXRhKSwgZXJyb3IgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yKSk7XG4gICAgLy8gUmVnaXN0ZXIgcmVqZWN0aW9uIGxpc3RlbmVycyB0byBhdm9pZCB1bmNhdWdodCBwcm9taXNlIHJlamVjdGlvbnMgb25cbiAgICAvLyBlcnJvcnMgb3IgYWJvcnRlZCBkZWZlcnJlZCB2YWx1ZXNcbiAgICBwcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBvblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJiBlcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yKSB7XG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZXJyb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gYWJvcnQhXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkL3JlamVjdGVkIHdpdGggdW5kZWZpbmVkLCB3ZSdsbCB0aHJvdyBhbiBlcnJvciBhcyB5b3VcbiAgICAvLyBzaG91bGQgYWx3YXlzIHJlc29sdmUgd2l0aCBhIHZhbHVlIG9yIG51bGxcbiAgICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB1bmRlZmluZWRFcnJvciA9IG5ldyBFcnJvcihcIkRlZmVycmVkIGRhdGEgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmVzb2x2ZWQvcmVqZWN0ZWQgd2l0aCBgdW5kZWZpbmVkYCwgXCIgKyBcInlvdSBtdXN0IHJlc29sdmUvcmVqZWN0IHdpdGggYSB2YWx1ZSBvciBgbnVsbGAuXCIpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWRFcnJvclxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodW5kZWZpbmVkRXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgIGdldDogKCkgPT4gZGF0YVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBlbWl0KGFib3J0ZWQsIHNldHRsZWRLZXkpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuICBzdWJzY3JpYmUoZm4pIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrKSk7XG4gICAgdGhpcy5lbWl0KHRydWUpO1xuICB9XG4gIGFzeW5jIHJlc29sdmVEYXRhKHNpZ25hbCkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIGxldCBvbkFib3J0ID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGFib3J0ZWQgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cbiAgZ2V0IGRvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgdW53cmFwcGVkRGF0YSgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSwgXCJDYW4gb25seSB1bndyYXAgZGF0YSBvbiBpbml0aWFsaXplZCBhbmQgc2V0dGxlZCBkZWZlcnJlZHNcIik7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKChhY2MsIF9yZWYzKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjM7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgW2tleV06IHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlKVxuICAgICAgfSk7XG4gICAgfSwge30pO1xuICB9XG4gIGdldCBwZW5kaW5nS2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlICYmIHZhbHVlLl90cmFja2VkID09PSB0cnVlO1xufVxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpIHtcbiAgaWYgKCFpc1RyYWNrZWRQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cbmNvbnN0IGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoZGF0YSwgaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IHt9O1xuICB9XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICBzdGF0dXM6IGluaXRcbiAgfSA6IGluaXQ7XG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuY29uc3QgcmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdCh1cmwsIGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSAzMDI7XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgc3RhdHVzOiByZXNwb25zZUluaXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIF9leHRlbmRzKHt9LCByZXNwb25zZUluaXQsIHtcbiAgICBoZWFkZXJzXG4gIH0pKTtcbn07XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UgdGhhdCB3aWxsIGZvcmNlIGEgZG9jdW1lbnQgcmVsb2FkIHRvIHRoZSBuZXcgbG9jYXRpb24uXG4gKiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuY29uc3QgcmVkaXJlY3REb2N1bWVudCA9ICh1cmwsIGluaXQpID0+IHtcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcbiAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKlxuICogV2UgZG9uJ3QgZXhwb3J0IHRoZSBjbGFzcyBmb3IgcHVibGljIHVzZSBzaW5jZSBpdCdzIGFuIGltcGxlbWVudGF0aW9uXG4gKiBkZXRhaWwsIGJ1dCB3ZSBleHBvcnQgdGhlIGludGVyZmFjZSBhYm92ZSBzbyBmb2xrcyBjYW4gYnVpbGQgdGhlaXIgb3duXG4gKiBhYnN0cmFjdGlvbnMgYXJvdW5kIGluc3RhbmNlcyB2aWEgaXNSb3V0ZUVycm9yUmVzcG9uc2UoKVxuICovXG5jbGFzcyBFcnJvclJlc3BvbnNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSwgaW50ZXJuYWwpIHtcbiAgICBpZiAoaW50ZXJuYWwgPT09IHZvaWQgMCkge1xuICAgICAgaW50ZXJuYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJiBcImRhdGFcIiBpbiBlcnJvcjtcbn1cbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzQXJyID0gW1wicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCIsIFwiZGVsZXRlXCJdO1xuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0KHZhbGlkTXV0YXRpb25NZXRob2RzQXJyKTtcbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIgPSBbXCJnZXRcIiwgLi4udmFsaWRNdXRhdGlvbk1ldGhvZHNBcnJdO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kcyA9IG5ldyBTZXQodmFsaWRSZXF1ZXN0TWV0aG9kc0Fycik7XG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmNvbnN0IHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwNywgMzA4XSk7XG5jb25zdCBJRExFX05BVklHQVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkXG59O1xuY29uc3QgSURMRV9GRVRDSEVSID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkXG59O1xuY29uc3QgSURMRV9CTE9DS0VSID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICByZXNldDogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkXG59O1xuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuY29uc3QgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gIGhhc0Vycm9yQm91bmRhcnk6IEJvb2xlYW4ocm91dGUuaGFzRXJyb3JCb3VuZGFyeSlcbn0pO1xuY29uc3QgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkgPSBcInJlbWl4LXJvdXRlci10cmFuc2l0aW9uc1wiO1xuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVJvdXRlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlIGEgcm91dGVyIGFuZCBsaXN0ZW4gdG8gaGlzdG9yeSBQT1AgbmF2aWdhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQpIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiByb3V0ZXJXaW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGlzU2VydmVyID0gIWlzQnJvd3NlcjtcbiAgaW52YXJpYW50KGluaXQucm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCIpO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBpZiAoaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMpIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBpbml0Lm1hcFJvdXRlUHJvcGVydGllcztcbiAgfSBlbHNlIGlmIChpbml0LmRldGVjdEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB0aGV5IGFyZSBzdGlsbCB1c2luZyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uLCB3cmFwIGl0IHdpdGggdGhlIG5ldyBBUElcbiAgICBsZXQgZGV0ZWN0RXJyb3JCb3VuZGFyeSA9IGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeTtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSByb3V0ZSA9PiAoe1xuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZGV0ZWN0RXJyb3JCb3VuZGFyeShyb3V0ZSlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9XG4gIC8vIFJvdXRlcyBrZXllZCBieSBJRFxuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgLy8gUm91dGVzIGluIHRyZWUgZm9ybWF0IGZvciBtYXRjaGluZ1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoaW5pdC5yb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XG4gIGxldCBpbkZsaWdodERhdGFSb3V0ZXM7XG4gIGxldCBiYXNlbmFtZSA9IGluaXQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhU3RyYXRlZ3lJbXBsID0gaW5pdC51bnN0YWJsZV9kYXRhU3RyYXRlZ3kgfHwgZGVmYXVsdERhdGFTdHJhdGVneTtcbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X2ZldGNoZXJQZXJzaXN0OiBmYWxzZSxcbiAgICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBmYWxzZSxcbiAgICB2N19wYXJ0aWFsSHlkcmF0aW9uOiBmYWxzZSxcbiAgICB2N19wcmVwZW5kQmFzZW5hbWU6IGZhbHNlLFxuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZSxcbiAgICB1bnN0YWJsZV9za2lwQWN0aW9uRXJyb3JSZXZhbGlkYXRpb246IGZhbHNlXG4gIH0sIGluaXQuZnV0dXJlKTtcbiAgLy8gQ2xlYW51cCBmdW5jdGlvbiBmb3IgaGlzdG9yeVxuICBsZXQgdW5saXN0ZW5IaXN0b3J5ID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbnMgdG8gY2FsbCBvbiBhbGwgc3RhdGUgY2hhbmdlc1xuICBsZXQgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgb2JqZWN0IHRvIGhvbGQgc2Nyb2xsIHJlc3RvcmF0aW9uIGxvY2F0aW9ucyBkdXJpbmcgcm91dGluZ1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBzY3JvbGwgcmVzdG9yYXRpb24ga2V5c1xuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAvLyBPbmUtdGltZSBmbGFnIHRvIGNvbnRyb2wgdGhlIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbi4gIEJlY2F1c2VcbiAgLy8gd2UgZG9uJ3QgZ2V0IHRoZSBzYXZlZCBwb3NpdGlvbnMgZnJvbSA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gdW50aWwgX2FmdGVyX1xuICAvLyB0aGUgaW5pdGlhbCByZW5kZXIsIHdlIG5lZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBhIHNlcGFyYXRlIHVwZGF0ZVN0YXRlIHRvXG4gIC8vIHNlbmQgYWxvbmcgdGhlIHJlc3RvcmVTY3JvbGxQb3NpdGlvblxuICAvLyBTZXQgdG8gdHJ1ZSBpZiB3ZSBoYXZlIGBoeWRyYXRpb25EYXRhYCBzaW5jZSB3ZSBhc3N1bWUgd2Ugd2VyZSBTU1InZCBhbmQgdGhhdFxuICAvLyBTU1IgZGlkIHRoZSBpbml0aWFsIHNjcm9sbCByZXN0b3JhdGlvbi5cbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBpbml0Lmhpc3RvcnkubG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgbGV0IGluaXRpYWxFcnJvcnMgPSBudWxsO1xuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgIH0pO1xuICAgIGxldCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgcm91dGVcbiAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHtcbiAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgfTtcbiAgfVxuICBsZXQgaW5pdGlhbGl6ZWQ7XG4gIGxldCBoYXNMYXp5Um91dGVzID0gaW5pdGlhbE1hdGNoZXMuc29tZShtID0+IG0ucm91dGUubGF6eSk7XG4gIGxldCBoYXNMb2FkZXJzID0gaW5pdGlhbE1hdGNoZXMuc29tZShtID0+IG0ucm91dGUubG9hZGVyKTtcbiAgaWYgKGhhc0xhenlSb3V0ZXMpIHtcbiAgICAvLyBBbGwgaW5pdGlhbE1hdGNoZXMgbmVlZCB0byBiZSBsb2FkZWQgYmVmb3JlIHdlJ3JlIHJlYWR5LiAgSWYgd2UgaGF2ZSBsYXp5XG4gICAgLy8gZnVuY3Rpb25zIGFyb3VuZCBzdGlsbCB0aGVuIHdlJ2xsIG5lZWQgdG8gcnVuIHRoZW0gaW4gaW5pdGlhbGl6ZSgpXG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICghaGFzTG9hZGVycykge1xuICAgIC8vIElmIHdlJ3ZlIGdvdCBubyBsb2FkZXJzIHRvIHJ1biwgdGhlbiB3ZSdyZSBnb29kIHRvIGdvXG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uKSB7XG4gICAgLy8gSWYgcGFydGlhbCBoeWRyYXRpb24gaXMgZW5hYmxlZCwgd2UncmUgaW5pdGlhbGl6ZWQgc28gbG9uZyBhcyB3ZSB3ZXJlXG4gICAgLy8gcHJvdmlkZWQgd2l0aCBoeWRyYXRpb25EYXRhIGZvciBldmVyeSByb3V0ZSB3aXRoIGEgbG9hZGVyLCBhbmQgbm8gbG9hZGVyc1xuICAgIC8vIHdlcmUgbWFya2VkIGZvciBleHBsaWNpdCBoeWRyYXRpb25cbiAgICBsZXQgbG9hZGVyRGF0YSA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIDogbnVsbDtcbiAgICBsZXQgZXJyb3JzID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyA6IG51bGw7XG4gICAgbGV0IGlzUm91dGVJbml0aWFsaXplZCA9IG0gPT4ge1xuICAgICAgLy8gTm8gbG9hZGVyLCBub3RoaW5nIHRvIGluaXRpYWxpemVcbiAgICAgIGlmICghbS5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBFeHBsaWNpdGx5IG9wdGluZy1pbiB0byBydW5uaW5nIG9uIGh5ZHJhdGlvblxuICAgICAgaWYgKHR5cGVvZiBtLnJvdXRlLmxvYWRlciA9PT0gXCJmdW5jdGlvblwiICYmIG0ucm91dGUubG9hZGVyLmh5ZHJhdGUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBpbml0aWFsaXplZCBpZiBoeWRyYXRlZCB3aXRoIGRhdGEgb3IgYW4gZXJyb3JcbiAgICAgIHJldHVybiBsb2FkZXJEYXRhICYmIGxvYWRlckRhdGFbbS5yb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCB8fCBlcnJvcnMgJiYgZXJyb3JzW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvLyBJZiBlcnJvcnMgZXhpc3QsIGRvbid0IGNvbnNpZGVyIHJvdXRlcyBiZWxvdyB0aGUgYm91bmRhcnlcbiAgICBpZiAoZXJyb3JzKSB7XG4gICAgICBsZXQgaWR4ID0gaW5pdGlhbE1hdGNoZXMuZmluZEluZGV4KG0gPT4gZXJyb3JzW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWQpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5zbGljZSgwLCBpZHggKyAxKS5ldmVyeShpc1JvdXRlSW5pdGlhbGl6ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxNYXRjaGVzLmV2ZXJ5KGlzUm91dGVJbml0aWFsaXplZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdpdGhvdXQgcGFydGlhbCBoeWRyYXRpb24gLSB3ZSdyZSBpbml0aWFsaXplZCBpZiB3ZSB3ZXJlIHByb3ZpZGVkIGFueVxuICAgIC8vIGh5ZHJhdGlvbkRhdGEgLSB3aGljaCBpcyBleHBlY3RlZCB0byBiZSBjb21wbGV0ZVxuICAgIGluaXRpYWxpemVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG4gIH1cbiAgbGV0IHJvdXRlcjtcbiAgbGV0IHN0YXRlID0ge1xuICAgIGhpc3RvcnlBY3Rpb246IGluaXQuaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBtYXRjaGVzOiBpbml0aWFsTWF0Y2hlcyxcbiAgICBpbml0aWFsaXplZCxcbiAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgLy8gRG9uJ3QgcmVzdG9yZSBvbiBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgaWYgd2Ugd2VyZSBTU1InZFxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwgPyBmYWxzZSA6IG51bGwsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgIGxvYWRlckRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmFjdGlvbkRhdGEgfHwgbnVsbCxcbiAgICBlcnJvcnM6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzIHx8IGluaXRpYWxFcnJvcnMsXG4gICAgZmV0Y2hlcnM6IG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogbmV3IE1hcCgpXG4gIH07XG4gIC8vIC0tIFN0YXRlZnVsIGludGVybmFsIHZhcmlhYmxlcyB0byBtYW5hZ2UgbmF2aWdhdGlvbnMgLS1cbiAgLy8gQ3VycmVudCBuYXZpZ2F0aW9uIGluIHByb2dyZXNzICh0byBiZSBjb21taXR0ZWQgaW4gY29tcGxldGVOYXZpZ2F0aW9uKVxuICBsZXQgcGVuZGluZ0FjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIC8vIFNob3VsZCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHByZXZlbnQgdGhlIHNjcm9sbCByZXNldCBpZiBzY3JvbGwgY2Fubm90XG4gIC8vIGJlIHJlc3RvcmVkP1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAvLyBBYm9ydENvbnRyb2xsZXIgZm9yIHRoZSBhY3RpdmUgbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBlbmFibGUgZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbj9cbiAgbGV0IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgLy8gU3RvcmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIHNvIHdlIGNhbiBhcHBseSB0aGVtIG9uIFBPUFxuICBsZXQgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcbiAgLy8gQ2xlYW51cCBmdW5jdGlvbiBmb3IgcGVyc2lzdGluZyBhcHBsaWVkIHRyYW5zaXRpb25zIHRvIHNlc3Npb25TdG9yYWdlXG4gIGxldCByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuICAvLyBXZSB1c2UgdGhpcyB0byBhdm9pZCB0b3VjaGluZyBoaXN0b3J5IGluIGNvbXBsZXRlTmF2aWdhdGlvbiBpZiBhXG4gIC8vIHJldmFsaWRhdGlvbiBpcyBlbnRpcmVseSB1bmludGVycnVwdGVkXG4gIGxldCBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgZmxhZyB0byBmb3JjZSByZXZhbGlkYXRpb24gb2YgYWxsIGxvYWRlcnM6XG4gIC8vICAtIHN1Ym1pc3Npb25zIChjb21wbGV0ZWQgb3IgaW50ZXJydXB0ZWQpXG4gIC8vICAtIHVzZVJldmFsaWRhdG9yKClcbiAgLy8gIC0gWC1SZW1peC1SZXZhbGlkYXRlIChmcm9tIHJlZGlyZWN0KVxuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIHJvdXRlcyB0aGF0IHJlcXVpcmUgcmV2YWxpZGF0aW9uIGR1ZVxuICAvLyB0byBhIGNhbmNlbGxlZCBkZWZlcnJlZCBvbiBhY3Rpb24gc3VibWlzc2lvblxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMgPSBbXTtcbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSBmZXRjaGVyIGxvYWRzIHRoYXQgd2VyZSBjYW5jZWxsZWQgYnkgYW5cbiAgLy8gYWN0aW9uIG5hdmlnYXRpb24gYW5kIHJlcXVpcmUgcmV2YWxpZGF0aW9uXG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSBbXTtcbiAgLy8gQWJvcnRDb250cm9sbGVycyBmb3IgYW55IGluLWZsaWdodCBmZXRjaGVyc1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgbG9hZHMgYmFzZWQgb24gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgc3RhcnRlZFxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcbiAgLy8gVHJhY2sgdGhlIG91dHN0YW5kaW5nIHBlbmRpbmcgbmF2aWdhdGlvbiBkYXRhIGxvYWQgdG8gYmUgY29tcGFyZWQgYWdhaW5zdFxuICAvLyB0aGUgZ2xvYmFsbHkgaW5jcmVtZW50aW5nIGxvYWQgd2hlbiBhIGZldGNoZXIgbG9hZCBsYW5kcyBhZnRlciBhIGNvbXBsZXRlZFxuICAvLyBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCBkYXRhIHJlbG9hZHMgYXMgYSByZXN1bHQgb2YgdGhlaXIgYWN0aW9uc1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwKCk7XG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIHJlZGlyZWN0IG5hdmlnYXRpb25zXG4gIGxldCBmZXRjaFJlZGlyZWN0SWRzID0gbmV3IFNldCgpO1xuICAvLyBNb3N0IHJlY2VudCBocmVmL21hdGNoIGZvciBmZXRjaGVyLmxvYWQgY2FsbHMgZm9yIGZldGNoZXJzXG4gIGxldCBmZXRjaExvYWRNYXRjaGVzID0gbmV3IE1hcCgpO1xuICAvLyBSZWYtY291bnQgbW91bnRlZCBmZXRjaGVycyBzbyB3ZSBrbm93IHdoZW4gaXQncyBvayB0byBjbGVhbiB0aGVtIHVwXG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IG5ldyBNYXAoKTtcbiAgLy8gRmV0Y2hlcnMgdGhhdCBoYXZlIHJlcXVlc3RlZCBhIGRlbGV0ZSB3aGVuIHVzaW5nIHY3X2ZldGNoZXJQZXJzaXN0LFxuICAvLyB0aGV5J2xsIGJlIG9mZmljaWFsbHkgcmVtb3ZlZCBhZnRlciB0aGV5IHJldHVybiB0byBpZGxlXG4gIGxldCBkZWxldGVkRmV0Y2hlcnMgPSBuZXcgU2V0KCk7XG4gIC8vIFN0b3JlIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgZm9yIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLiAgV2hlbiBhXG4gIC8vIHJvdXRlIGxvYWRlciByZXR1cm5zIGRlZmVyKCkgd2Ugc3RpY2sgb25lIGluIGhlcmUuICBUaGVuLCB3aGVuIGEgbmVzdGVkXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxuICAvLyBjYW5jZWwgYWN0aXZlIGRlZmVycmVkcyBmb3IgZWxpbWluYXRlZCByb3V0ZXMuXG4gIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwKCk7XG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIHRoZXkgY2hhbmdlXG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxuICAvLyBhIFBPUCBuYXZpZ2F0aW9uIHRoYXQgd2FzIGJsb2NrZWQgYnkgdGhlIHVzZXIgd2l0aG91dCB0b3VjaGluZyByb3V0ZXIgc3RhdGVcbiAgbGV0IGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG4gIC8vIEluaXRpYWxpemUgdGhlIHJvdXRlciwgYWxsIHNpZGUgZWZmZWN0cyBzaG91bGQgYmUga2lja2VkIG9mZiBmcm9tIGhlcmUuXG4gIC8vIEltcGxlbWVudGVkIGFzIGEgRmx1ZW50IEFQSSBmb3IgZWFzZSBvZjpcbiAgLy8gICBsZXQgcm91dGVyID0gY3JlYXRlUm91dGVyKGluaXQpLmluaXRpYWxpemUoKTtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBJZiBoaXN0b3J5IGluZm9ybXMgdXMgb2YgYSBQT1AgbmF2aWdhdGlvbiwgc3RhcnQgdGhlIG5hdmlnYXRpb24gYnV0IGRvIG5vdCB1cGRhdGVcbiAgICAvLyBzdGF0ZS4gIFdlJ2xsIHVwZGF0ZSBvdXIgb3duIHN0YXRlIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGlvbjogaGlzdG9yeUFjdGlvbixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIGRlbHRhXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIC8vIElnbm9yZSB0aGlzIGV2ZW50IGlmIGl0IHdhcyBqdXN0IHVzIHJlc2V0dGluZyB0aGUgVVJMIGZyb20gYVxuICAgICAgLy8gYmxvY2tlZCBQT1AgbmF2aWdhdGlvblxuICAgICAgaWYgKGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlKSB7XG4gICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgYmxvY2tlciBvbiBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gXCIgKyBcInRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbi4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbmF2aWdhdGluZyBvdXRzaWRlIHRoZSByb3V0ZXIgXCIgKyBcInZpYSBgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYC9gd2luZG93LmxvY2F0aW9uLmhhc2hgIGluc3RlYWQgb2YgdXNpbmcgXCIgKyBcInJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIFwiICsgXCJjcmVhdGVIYXNoUm91dGVyIGFuZCB0aGUgdXNlciBtYW51YWxseSBjaGFuZ2VzIHRoZSBVUkwuXCIpO1xuICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgVVJMIHRvIG1hdGNoIHRoZSBjdXJyZW50IFVJLCBidXQgZG9uJ3QgdXBkYXRlIHJvdXRlciBzdGF0ZVxuICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBsb2NhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZS1kbyB0aGUgc2FtZSBQT1AgbmF2aWdhdGlvbiB3ZSBqdXN0IGJsb2NrZWRcbiAgICAgICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICAgIGJsb2NrZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICB9KTtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAvLyBGSVhNRTogVGhpcyBmZWVscyBncm9zcy4gIEhvdyBjYW4gd2UgY2xlYW51cCB0aGUgbGluZXMgYmV0d2VlblxuICAgICAgLy8gc2Nyb2xsUmVzdG9yYXRpb24vYXBwbGllZFRyYW5zaXRpb25zIHBlcnNpc3RhbmNlP1xuICAgICAgcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhyb3V0ZXJXaW5kb3csIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMpO1xuICAgICAgbGV0IF9zYXZlQXBwbGllZFRyYW5zaXRpb25zID0gKCkgPT4gcGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyhyb3V0ZXJXaW5kb3csIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMpO1xuICAgICAgcm91dGVyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiByb3V0ZXJXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICB9XG4gICAgLy8gS2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWQgaWYgbmVlZGVkLiAgVXNlIFBvcCB0byBhdm9pZCBtb2RpZnlpbmcgaGlzdG9yeVxuICAgIC8vIE5vdGUgd2UgZG9uJ3QgZG8gYW55IGhhbmRsaW5nIG9mIGxhenkgaGVyZS4gIEZvciBTUEEncyBpdCdsbCBnZXQgaGFuZGxlZFxuICAgIC8vIGluIHRoZSBub3JtYWwgbmF2aWdhdGlvbiBmbG93LiAgRm9yIFNTUiBpdCdzIGV4cGVjdGVkIHRoYXQgbGF6eSBtb2R1bGVzIGFyZVxuICAgIC8vIHJlc29sdmVkIHByaW9yIHRvIHJvdXRlciBjcmVhdGlvbiBzaW5jZSB3ZSBjYW4ndCBnbyBpbnRvIGEgZmFsbGJhY2tFbGVtZW50XG4gICAgLy8gVUkgZm9yIFNTUidkIGFwcHNcbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oQWN0aW9uLlBvcCwgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgc3RhdGUuYmxvY2tlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVCbG9ja2VyKGtleSkpO1xuICB9XG4gIC8vIFN1YnNjcmliZSB0byBzdGF0ZSB1cGRhdGVzIGZvciB0aGUgcm91dGVyXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIG5ld1N0YXRlKTtcbiAgICAvLyBQcmVwIGZldGNoZXIgY2xlYW51cCBzbyB3ZSBjYW4gdGVsbCB0aGUgVUkgd2hpY2ggZmV0Y2hlciBkYXRhIGVudHJpZXNcbiAgICAvLyBjYW4gYmUgcmVtb3ZlZFxuICAgIGxldCBjb21wbGV0ZWRGZXRjaGVycyA9IFtdO1xuICAgIGxldCBkZWxldGVkRmV0Y2hlcnNLZXlzID0gW107XG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIFVubW91bnRlZCBmcm9tIHRoZSBVSSBhbmQgY2FuIGJlIHRvdGFsbHkgcmVtb3ZlZFxuICAgICAgICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybmVkIHRvIGlkbGUgYnV0IHN0aWxsIG1vdW50ZWQgaW4gdGhlIFVJLCBzbyBzZW1pLXJlbWFpbnMgZm9yXG4gICAgICAgICAgICAvLyByZXZhbGlkYXRpb25zIGFuZCBzdWNoXG4gICAgICAgICAgICBjb21wbGV0ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGEgbG9jYWwgY29weSBzbyB0aGF0IGlmIGZsdXNoU3luYyBpcyB1c2VkIGFuZCB3ZSBlbmQgdXBcbiAgICAvLyByZW1vdmluZyBhbmQgYWRkaW5nIGEgbmV3IHN1YnNjcmliZXIgZHVlIHRvIHRoZSB1c2VDYWxsYmFjayBkZXBlbmRlbmNpZXMsXG4gICAgLy8gd2UgZG9uJ3QgZ2V0IG91cnNlbHZlcyBpbnRvIGEgbG9vcCBjYWxsaW5nIHRoZSBuZXcgc3Vic2NyaWJlciBpbW1lZGlhdGVseVxuICAgIFsuLi5zdWJzY3JpYmVyc10uZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoc3RhdGUsIHtcbiAgICAgIGRlbGV0ZWRGZXRjaGVyczogZGVsZXRlZEZldGNoZXJzS2V5cyxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0czogb3B0cy52aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgfSkpO1xuICAgIC8vIFJlbW92ZSBpZGxlIGZldGNoZXJzIGZyb20gc3RhdGUgc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IGluLWZsaWdodCBmZXRjaGVycy5cbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBjb21wbGV0ZWRGZXRjaGVycy5mb3JFYWNoKGtleSA9PiBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KSk7XG4gICAgICBkZWxldGVkRmV0Y2hlcnNLZXlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgfVxuICB9XG4gIC8vIENvbXBsZXRlIGEgbmF2aWdhdGlvbiByZXR1cm5pbmcgdGhlIHN0YXRlLm5hdmlnYXRpb24gYmFjayB0byB0aGUgSURMRV9OQVZJR0FUSU9OXG4gIC8vIGFuZCBzZXR0aW5nIHN0YXRlLltoaXN0b3J5QWN0aW9uL2xvY2F0aW9uL21hdGNoZXNdIHRvIHRoZSBuZXcgcm91dGUuXG4gIC8vIC0gTG9jYXRpb24gaXMgYSByZXF1aXJlZCBwYXJhbVxuICAvLyAtIE5hdmlnYXRpb24gd2lsbCBhbHdheXMgYmUgc2V0IHRvIElETEVfTkFWSUdBVElPTlxuICAvLyAtIENhbiBwYXNzIGFueSBvdGhlciBzdGF0ZSBpbiBuZXdTdGF0ZVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIG5ld1N0YXRlLCBfdGVtcCkge1xuICAgIHZhciBfbG9jYXRpb24kc3RhdGUsIF9sb2NhdGlvbiRzdGF0ZTI7XG4gICAgbGV0IHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9IHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJiBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgKChfbG9jYXRpb24kc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZS5faXNSZWRpcmVjdCkgIT09IHRydWU7XG4gICAgbGV0IGFjdGlvbkRhdGE7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW1wdHkgYWN0aW9uRGF0YSAtPiBjbGVhciBwcmlvciBhY3Rpb25EYXRhIGR1ZSB0byBhbiBhY3Rpb24gZXJyb3JcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBkYXRhIGlmIHdlJ3JlIHdyYXBwaW5nIHVwIHRoZSBhY3Rpb24gcmVsb2FkXG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgYWN0aW9uRGF0YSBvbiBhbnkgb3RoZXIgY29tcGxldGVkIG5hdmlnYXRpb25zXG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQWx3YXlzIHByZXNlcnZlIGFueSBleGlzdGluZyBsb2FkZXJEYXRhIGZyb20gcmUtdXNlZCByb3V0ZXNcbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGEgPyBtZXJnZUxvYWRlckRhdGEoc3RhdGUubG9hZGVyRGF0YSwgbmV3U3RhdGUubG9hZGVyRGF0YSwgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSwgbmV3U3RhdGUuZXJyb3JzKSA6IHN0YXRlLmxvYWRlckRhdGE7XG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuICAgIC8vIEFsd2F5cyByZXNwZWN0IHRoZSB1c2VyIGZsYWcuICBPdGhlcndpc2UgZG9uJ3QgcmVzZXQgb24gbXV0YXRpb25cbiAgICAvLyBzdWJtaXNzaW9uIG5hdmlnYXRpb25zIHVubGVzcyB0aGV5IHJlZGlyZWN0XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHwgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmICgoX2xvY2F0aW9uJHN0YXRlMiA9IGxvY2F0aW9uLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2xvY2F0aW9uJHN0YXRlMi5faXNSZWRpcmVjdCkgIT09IHRydWU7XG4gICAgaWYgKGluRmxpZ2h0RGF0YVJvdXRlcykge1xuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgO2Vsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5Qb3ApIDtlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xuICAgIC8vIE9uIFBPUCwgZW5hYmxlIHRyYW5zaXRpb25zIGlmIHRoZXkgd2VyZSBlbmFibGVkIG9uIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIEZvcndhcmQgdGFrZXMgcHJlY2VkZW5jZSBzbyB0aGV5IGJlaGF2ZSBsaWtlIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgcHJpb3JQYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChwcmlvclBhdGhzICYmIHByaW9yUGF0aHMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcHJldmlvdXMgZm9yd2FyZCBuYXYsIGFzc3VtZSB3ZSdyZSBwb3BwaW5nIGJhY2sgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBsb2NhdGlvbiBhbmQgZW5hYmxlIGlmIHRoYXQgbG9jYXRpb24gcHJldmlvdXNseSBlbmFibGVkXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhcHBsaWVkIHRyYW5zaXRpb24gb24gUFVTSC9SRVBMQUNFXG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHt9LCBuZXdTdGF0ZSwge1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcyksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2Vyc1xuICAgIH0pLCB7XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgdG8sIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mcm9tUm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCBmYWxzZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0gX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwgaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbikpO1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkgO2Vsc2UgaWYgKHN1Ym1pc3Npb24gIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiYgc3VibWlzc2lvbi5mb3JtQWN0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgLy8gQnkgZGVmYXVsdCBvbiBzdWJtaXNzaW9ucyB0byB0aGUgY3VycmVudCBsb2NhdGlvbiB3ZSBSRVBMQUNFIHNvIHRoYXRcbiAgICAgIC8vIHVzZXJzIGRvbid0IGhhdmUgdG8gZG91YmxlLWNsaWNrIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgdG8gdGhlIHByaW9yXG4gICAgICAvLyBsb2NhdGlvbi4gIElmIHRoZSB1c2VyIHJlZGlyZWN0cyB0byBhIGRpZmZlcmVudCBsb2NhdGlvbiBmcm9tIHRoZVxuICAgICAgLy8gYWN0aW9uL2xvYWRlciB0aGlzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIHJlZGlyZWN0IHdpbGwgYmUgYSBQVVNIXG4gICAgICBoaXN0b3J5QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgfVxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0cyA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIDogdW5kZWZpbmVkO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLnVuc3RhYmxlX2ZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICBibG9ja2Vyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBuZXh0TG9jYXRpb24sIHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXG4gICAgICAvLyByZW5kZXIgYXQgdGhlIHJpZ2h0IGVycm9yIGJvdW5kYXJ5IGFmdGVyIHdlIG1hdGNoIHJvdXRlc1xuICAgICAgcGVuZGluZ0Vycm9yOiBlcnJvcixcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlcGxhY2U6IG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IG9wdHMgJiYgb3B0cy51bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICB9XG4gIC8vIFJldmFsaWRhdGUgYWxsIGN1cnJlbnQgbG9hZGVycy4gIElmIGEgbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzcyBvciBpZiB0aGlzXG4gIC8vIGlzIGludGVycnVwdGVkIGJ5IGEgbmF2aWdhdGlvbiwgYWxsb3cgdGhpcyB0byBcInN1Y2NlZWRcIiBieSBjYWxsaW5nIGFsbFxuICAvLyBsb2FkZXJzIGR1cmluZyB0aGUgbmV4dCBsb2FkZXIgcm91bmRcbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIHJldmFsaWRhdGlvbjogXCJsb2FkaW5nXCJcbiAgICB9KTtcbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgc3VibWl0dGluZyBhbiBhY3Rpb24sIHdlIGRvbid0IG5lZWQgdG8gc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uLCB3ZSdsbCBqdXN0IGxldCB0aGUgZm9sbG93IHVwIGxvYWRlciBleGVjdXRpb24gY2FsbCBhbGwgbG9hZGVyc1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcInN1Ym1pdHRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW4gYW4gaWRsZSBzdGF0ZSwgc3RhcnQgYSBuZXcgbmF2aWdhdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAgICAvLyBhY3Rpb24vbG9jYXRpb24gYW5kIG1hcmsgaXQgYXMgdW5pbnRlcnJ1cHRlZCwgd2hpY2ggd2lsbCBza2lwIHRoZSBoaXN0b3J5XG4gICAgLy8gdXBkYXRlIGluIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgaWYgd2UncmUgY3VycmVudGx5IGluIGEgbG9hZGluZyBzdGF0ZSwganVzdCBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24gdG8gdGhlIG5hdmlnYXRpb24ubG9jYXRpb24gYnV0IGRvIG5vdCB0cmlnZ2VyIGFuIHVuaW50ZXJydXB0ZWRcbiAgICAvLyByZXZhbGlkYXRpb24gc28gdGhhdCBoaXN0b3J5IGNvcnJlY3RseSB1cGRhdGVzIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgc3RhcnROYXZpZ2F0aW9uKHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbiwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhcnQgYSBuYXZpZ2F0aW9uIHRvIHRoZSBnaXZlbiBhY3Rpb24vbG9jYXRpb24uICBDYW4gb3B0aW9uYWxseSBwcm92aWRlIGFcbiAgLy8gb3ZlcnJpZGVOYXZpZ2F0aW9uIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIG5vcm1hbExvYWQgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdFxuICAvLyBuYXZpZ2F0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgb3B0cykge1xuICAgIC8vIEFib3J0IGFueSBpbi1wcm9ncmVzcyBuYXZpZ2F0aW9ucyBhbmQgc3RhcnQgYSBuZXcgb25lLiBVbnNldCBhbnkgb25nb2luZ1xuICAgIC8vIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9ucyB1bmxlc3MgdG9sZCBvdGhlcndpc2UsIHNpbmNlIHdlIHdhbnQgdGhpc1xuICAgIC8vIG5ldyBuYXZpZ2F0aW9uIHRvIHVwZGF0ZSBoaXN0b3J5IG5vcm1hbGx5XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgcGVuZGluZ0FjdGlvbiA9IGhpc3RvcnlBY3Rpb247XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGV2ZXJ5IHRpbWUgd2Ugc3RhcnQgYSBuZXcgbmF2aWdhdGlvbixcbiAgICAvLyBhbmQgdHJhY2sgd2hldGhlciB3ZSBzaG91bGQgcmVzZXQgc2Nyb2xsIG9uIGNvbXBsZXRpb25cbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IChvcHRzICYmIG9wdHMuZW5hYmxlVmlld1RyYW5zaXRpb24pID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgd2l0aCBhIDQwNCBvbiB0aGUgcm9vdCBlcnJvciBib3VuZGFyeSBpZiB3ZSBtYXRjaCBub3RoaW5nXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzVG9Vc2UpO1xuICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIGRlZmVycmVkIG9uIDQwNHMgc2luY2Ugd2UgZG9uJ3Qga2VlcCBhbnkgcm91dGVzXG4gICAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaXQncyBvbmx5IGEgaGFzaCBjaGFuZ2UgYW5kIG5vdCBhIHJldmFsaWRhdGlvbiBvclxuICAgIC8vIG11dGF0aW9uIHN1Ym1pc3Npb24uXG4gICAgLy9cbiAgICAvLyBJZ25vcmUgb24gaW5pdGlhbCBwYWdlIGxvYWRzIGJlY2F1c2Ugc2luY2UgdGhlIGluaXRpYWwgbG9hZCB3aWxsIGFsd2F5c1xuICAgIC8vIGJlIFwic2FtZSBoYXNoXCIuICBGb3IgZXhhbXBsZSwgb24gL3BhZ2UjaGFzaCBhbmQgc3VibWl0IGEgPEZvcm0gbWV0aG9kPVwicG9zdFwiPlxuICAgIC8vIHdoaWNoIHdpbGwgZGVmYXVsdCB0byBhIG5hdmlnYXRpb24gdG8gL3BhZ2VcbiAgICBpZiAoc3RhdGUuaW5pdGlhbGl6ZWQgJiYgIWlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgJiYgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlc1xuICAgICAgfSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBjb250cm9sbGVyL1JlcXVlc3QgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgbG9jYXRpb24sIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwsIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICBsZXQgcGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBlbmRpbmdFcnJvciwgaXQgbWVhbnMgdGhlIHVzZXIgYXR0ZW1wdGVkIGEgR0VUIHN1Ym1pc3Npb25cbiAgICAgIC8vIHdpdGggYmluYXJ5IEZvcm1EYXRhIHNvIGFzc2lnbiBoZXJlIGFuZCBza2lwIHRvIGhhbmRsZUxvYWRlcnMuICBUaGF0XG4gICAgICAvLyB3YXkgd2UgaGFuZGxlIGNhbGxpbmcgbG9hZGVycyBhYm92ZSB0aGUgYm91bmRhcnkgZXRjLiAgSXQncyBub3QgcmVhbGx5XG4gICAgICAvLyBkaWZmZXJlbnQgZnJvbSBhbiBhY3Rpb25FcnJvciBpbiB0aGF0IHNlbnNlLlxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdCA9IFtmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkLCB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBvcHRzLnBlbmRpbmdFcnJvclxuICAgICAgfV07XG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgLy8gQ2FsbCBhY3Rpb24gaWYgd2UgcmVjZWl2ZWQgYW4gYWN0aW9uIHN1Ym1pc3Npb25cbiAgICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIG9wdHMuc3VibWlzc2lvbiwgbWF0Y2hlcywge1xuICAgICAgICByZXBsYWNlOiBvcHRzLnJlcGxhY2UsXG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIG9wdHMuc3VibWlzc2lvbik7XG4gICAgICBmbHVzaFN5bmMgPSBmYWxzZTtcbiAgICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgICAgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgcmVxdWVzdC51cmwsIHJlcXVlc3Quc2lnbmFsKTtcbiAgICB9XG4gICAgLy8gQ2FsbCBsb2FkZXJzXG4gICAgbGV0IHtcbiAgICAgIHNob3J0Q2lyY3VpdGVkLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCBsb2FkaW5nTmF2aWdhdGlvbiwgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sIG9wdHMgJiYgb3B0cy5mZXRjaGVyU3VibWlzc2lvbiwgb3B0cyAmJiBvcHRzLnJlcGxhY2UsIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLCBmbHVzaFN5bmMsIHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCBub3cgdGhhdCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZlxuICAgIC8vIHdlIHNob3J0IGNpcmN1aXRlZCBiZWNhdXNlIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciB3aWxsIGhhdmUgYWxyZWFkeVxuICAgIC8vIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgY29udHJvbGxlciBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICBtYXRjaGVzXG4gICAgfSwgZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSwge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0pKTtcbiAgfVxuICAvLyBDYWxsIHRoZSBhY3Rpb24gbWF0Y2hlZCBieSB0aGUgbGVhZiByb3V0ZSBmb3IgdGhpcyBuYXZpZ2F0aW9uIGFuZCBoYW5kbGVcbiAgLy8gcmVkaXJlY3RzL2Vycm9yc1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgLy8gUHV0IHVzIGluIGEgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBuYXZpZ2F0aW9uID0gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIG5hdmlnYXRpb25cbiAgICB9LCB7XG4gICAgICBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgfSk7XG4gICAgLy8gQ2FsbCBvdXIgYWN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXCJhY3Rpb25cIiwgcmVxdWVzdCwgW2FjdGlvbk1hdGNoXSwgbWF0Y2hlcyk7XG4gICAgICByZXN1bHQgPSByZXN1bHRzWzBdO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgcmVwbGFjZTtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2UgPSBvcHRzLnJlcGxhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBkaWRuJ3QgZXhwbGljaXR5IGluZGljYXRlIHJlcGxhY2UgYmVoYXZpb3IsIHJlcGxhY2UgaWZcbiAgICAgICAgLy8gd2UgcmVkaXJlY3RlZCB0byB0aGUgZXhhY3Qgc2FtZSBsb2NhdGlvbiB3ZSdyZSBjdXJyZW50bHkgYXQgdG8gYXZvaWRcbiAgICAgICAgLy8gZG91YmxlIGJhY2stYnV0dG9uc1xuICAgICAgICBsZXQgbG9jYXRpb24gPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpLCBuZXcgVVJMKHJlcXVlc3QudXJsKSwgYmFzZW5hbWUpO1xuICAgICAgICByZXBsYWNlID0gbG9jYXRpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVzdWx0LCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICAvLyBCeSBkZWZhdWx0LCBhbGwgc3VibWlzc2lvbnMgYXJlIFJFUExBQ0UgbmF2aWdhdGlvbnMsIGJ1dCBpZiB0aGVcbiAgICAgIC8vIGFjdGlvbiB0aHJldyBhbiBlcnJvciB0aGF0J2xsIGJlIHJlbmRlcmVkIGluIGFuIGVycm9yRWxlbWVudCwgd2UgZmFsbFxuICAgICAgLy8gYmFjayB0byBQVVNIIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0aGUgYmFjayBidXR0b24gdG8gZ2V0IGJhY2sgdG9cbiAgICAgIC8vIHRoZSBwcmUtc3VibWlzc2lvbiBmb3JtIGxvY2F0aW9uIHRvIHRyeSBhZ2FpblxuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYWN0aW9uTWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICB9O1xuICB9XG4gIC8vIENhbGwgYWxsIGFwcGxpY2FibGUgbG9hZGVycyBmb3IgdGhlIGdpdmVuIG1hdGNoZXMsIGhhbmRsaW5nIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlcnMocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIG92ZXJyaWRlTmF2aWdhdGlvbiwgc3VibWlzc2lvbiwgZmV0Y2hlclN1Ym1pc3Npb24sIHJlcGxhY2UsIGluaXRpYWxIeWRyYXRpb24sIGZsdXNoU3luYywgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHJpZ2h0IG5hdmlnYXRpb24gd2Ugd2FudCB0byB1c2UgZm9yIGRhdGEgbG9hZGluZ1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG92ZXJyaWRlTmF2aWdhdGlvbiB8fCBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgLy8gSWYgdGhpcyB3YXMgYSByZWRpcmVjdCBmcm9tIGFuIGFjdGlvbiB3ZSBkb24ndCBoYXZlIGEgXCJzdWJtaXNzaW9uXCIgYnV0XG4gICAgLy8gd2UgaGF2ZSBpdCBvbiB0aGUgbG9hZGluZyBuYXZpZ2F0aW9uIHNvIHVzZSB0aGF0IGlmIGF2YWlsYWJsZVxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbiB8fCBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obG9hZGluZ05hdmlnYXRpb24pO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChpbml0Lmhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBhY3RpdmVTdWJtaXNzaW9uLCBsb2NhdGlvbiwgZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gJiYgaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSwgZnV0dXJlLnVuc3RhYmxlX3NraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZGVsZXRlZEZldGNoZXJzLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgIC8vIENhbmNlbCBwZW5kaW5nIGRlZmVycmVkcyBmb3Igbm8tbG9uZ2VyLW1hdGNoZWQgcm91dGVzIG9yIHJvdXRlcyB3ZSdyZVxuICAgIC8vIGFib3V0IHRvIHJlbG9hZC4gIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGFuIGFjdGlvbiByZWxvYWQgd2Ugd291bGQgaGF2ZVxuICAgIC8vIGFscmVhZHkgY2FuY2VsbGVkIGFsbCBwZW5kaW5nIGRlZmVycmVkcyBzbyB0aGlzIHdvdWxkIGJlIGEgbm8tb3BcbiAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMocm91dGVJZCA9PiAhKG1hdGNoZXMgJiYgbWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkpIHx8IG1hdGNoZXNUb0xvYWQgJiYgbWF0Y2hlc1RvTG9hZC5zb21lKG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgX2V4dGVuZHMoe1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHtcbiAgICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3JcbiAgICAgICAgfSA6IG51bGxcbiAgICAgIH0sIGdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCksIHVwZGF0ZWRGZXRjaGVycyA/IHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9IDoge30pLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiwgd2UgcmVtYWluIGluIG91ciBjdXJyZW50IGlkbGVcbiAgICAvLyBzdGF0ZS4gIElmIG5vdCwgd2UgbmVlZCB0byBzd2l0Y2ggdG8gb3VyIGxvYWRpbmcgc3RhdGUgYW5kIGxvYWQgZGF0YSxcbiAgICAvLyBwcmVzZXJ2aW5nIGFueSBuZXcgYWN0aW9uIGRhdGEgb3IgZXhpc3RpbmcgYWN0aW9uIGRhdGEgKGluIHRoZSBjYXNlIG9mXG4gICAgLy8gYSByZXZhbGlkYXRpb24gaW50ZXJydXB0aW5nIGFuIGFjdGlvblJlbG9hZClcbiAgICAvLyBJZiB3ZSBoYXZlIHBhcnRpYWxIeWRyYXRpb24gZW5hYmxlZCwgdGhlbiBkb24ndCB1cGRhdGUgdGhlIHN0YXRlIGZvciB0aGVcbiAgICAvLyBpbml0aWFsIGRhdGEgbG9hZCBzaW5jZSBpdCdzIG5vdCBhIFwibmF2aWdhdGlvblwiXG4gICAgaWYgKCFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gJiYgKCFmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiB8fCAhaW5pdGlhbEh5ZHJhdGlvbikpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4ge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChyZi5rZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHVuZGVmaW5lZCwgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgfSk7XG4gICAgICBsZXQgYWN0aW9uRGF0YTtcbiAgICAgIGlmIChwZW5kaW5nQWN0aW9uUmVzdWx0ICYmICFpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgY2FzdCB0byBgYW55YCBjdXJyZW50bHkgYmVjYXVzZSBgUm91dGVEYXRhYHVzZXMgYW55IGFuZCBpdFxuICAgICAgICAvLyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZSB0byB1c2UgYW55LlxuICAgICAgICAvLyBUT0RPOiB2NyAtIGNoYW5nZSBgUm91dGVEYXRhYCB0byB1c2UgYHVua25vd25gIGluc3RlYWQgb2YgYGFueWBcbiAgICAgICAgYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGUoX2V4dGVuZHMoe1xuICAgICAgICBuYXZpZ2F0aW9uOiBsb2FkaW5nTmF2aWdhdGlvblxuICAgICAgfSwgYWN0aW9uRGF0YSAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgICBhY3Rpb25EYXRhXG4gICAgICB9IDoge30sIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDAgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhyZi5rZXkpKSB7XG4gICAgICAgIGFib3J0RmV0Y2hlcihyZi5rZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgLy8gRmV0Y2hlcnMgdXNlIGFuIGluZGVwZW5kZW50IEFib3J0Q29udHJvbGxlciBzbyB0aGF0IGFib3J0aW5nIGEgZmV0Y2hlclxuICAgICAgICAvLyAodmlhIGRlbGV0ZUZldGNoZXIpIGRvZXMgbm90IGFib3J0IHRoZSB0cmlnZ2VyaW5nIG5hdmlnYXRpb24gdGhhdFxuICAgICAgICAvLyB0cmlnZ2VyZWQgdGhlIHJldmFsaWRhdGlvblxuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChyZi5rZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFByb3h5IG5hdmlnYXRpb24gYWJvcnQgdGhyb3VnaCB0byByZXZhbGlkYXRpb24gZmV0Y2hlcnNcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChmID0+IGFib3J0RmV0Y2hlcihmLmtleSkpO1xuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXF1ZXN0KTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG4gICAgLy8gSWYgYW55IGxvYWRlcnMgcmV0dXJuZWQgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KFsuLi5sb2FkZXJSZXN1bHRzLCAuLi5mZXRjaGVyUmVzdWx0c10pO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgaWYgKHJlZGlyZWN0LmlkeCA+PSBtYXRjaGVzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJlZGlyZWN0IGNhbWUgZnJvbSBhIGZldGNoZXIgbWFrZSBzdXJlIHdlIG1hcmsgaXQgaW5cbiAgICAgICAgLy8gZmV0Y2hSZWRpcmVjdElkcyBzbyBpdCBkb2Vzbid0IGdldCByZXZhbGlkYXRlZCBvbiB0aGUgbmV4dCBzZXQgb2ZcbiAgICAgICAgLy8gbG9hZGVyIGV4ZWN1dGlvbnNcbiAgICAgICAgbGV0IGZldGNoZXJLZXkgPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0LnJlc3VsdCwge1xuICAgICAgICByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKGFib3J0ZWQgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gRHVyaW5nIHBhcnRpYWwgaHlkcmF0aW9uLCBwcmVzZXJ2ZSBTU1IgZXJyb3JzIGZvciByb3V0ZXMgdGhhdCBkb24ndCByZS1ydW5cbiAgICBpZiAoZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gJiYgaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHN0YXRlLmVycm9ycykuZmlsdGVyKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IFtpZF0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuICFtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSBpZCk7XG4gICAgICB9KS5mb3JFYWNoKF9yZWYzID0+IHtcbiAgICAgICAgbGV0IFtyb3V0ZUlkLCBlcnJvcl0gPSBfcmVmMztcbiAgICAgICAgZXJyb3JzID0gT2JqZWN0LmFzc2lnbihlcnJvcnMgfHwge30sIHtcbiAgICAgICAgICBbcm91dGVJZF06IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPSB1cGRhdGVkRmV0Y2hlcnMgfHwgZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9LCBzaG91bGRVcGRhdGVGZXRjaGVycyA/IHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0gOiB7fSk7XG4gIH1cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChrZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpIHtcbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyBhIHVzZUZldGNoZXIoKSBtZXRob2QgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICsgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCIpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMudW5zdGFibGVfZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcywgYmFzZW5hbWUsIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsIGhyZWYsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCwgcm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgsIGJhc2VuYW1lKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBub3JtYWxpemVkUGF0aFxuICAgICAgfSksIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCB0cnVlLCBub3JtYWxpemVkUGF0aCwgb3B0cyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBwYXRoKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdG9yZSBvZmYgdGhlIG1hdGNoIHNvIHdlIGNhbiBjYWxsIGl0J3Mgc2hvdWxkUmV2YWxpZGF0ZSBvbiBzdWJzZXF1ZW50XG4gICAgLy8gcmV2YWxpZGF0aW9uc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGZsdXNoU3luYywgc3VibWlzc2lvbik7XG4gIH1cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgbWF0Y2hlZCBmZXRjaGVyLnN1Ym1pdCgpLCBhbmQgdGhlbiBoYW5kbGUgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGFuZCByZXZhbGlkYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCByZXF1ZXN0TWF0Y2hlcywgZmx1c2hTeW5jLCBzdWJtaXNzaW9uKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGlmICghbWF0Y2gucm91dGUuYWN0aW9uICYmICFtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlSWRcbiAgICAgIH0pO1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3Mgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpLCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBmZXRjaGVyXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBwYXRoLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLCBzdWJtaXNzaW9uKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBhY3Rpb25SZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcImFjdGlvblwiLCBmZXRjaFJlcXVlc3QsIFttYXRjaF0sIHJlcXVlc3RNYXRjaGVzKTtcbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYWN0aW9uUmVzdWx0c1swXTtcbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc28gbG9uZyBhcyB3ZSB3ZXJlbid0IGFib3J0ZWQgYnkgb3VyIG93biBmZXRjaGVyXG4gICAgICAvLyByZS1zdWJtaXQgd2hpY2ggd291bGQgaGF2ZSBwdXQgX25ld18gY29udHJvbGxlciBpcyBpbiBmZXRjaENvbnRyb2xsZXJzXG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdoZW4gdXNpbmcgdjdfZmV0Y2hlclBlcnNpc3QsIHdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIHRvIHRoZSBVSVxuICAgIC8vIG9yIHJlZGlyZWN0cyBwcm9jZXNzZWQgZm9yIHVubW91bnRlZCBmZXRjaGVycyBzbyB3ZSBqdXN0IHJldmVydCB0aGVtIHRvXG4gICAgLy8gaWRsZVxuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QgJiYgZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpIHx8IGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gTGV0IFN1Y2Nlc3NSZXN1bHQncyBmYWxsIHRocm91Z2ggZm9yIHJldmFsaWRhdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgYWN0aW9uIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgICAvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdGhpcyByZWRpcmVjdCBuYXZpZ2F0aW9uLiAgV2UgYWxyZWFkeVxuICAgICAgICAgIC8vIHNldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHNvIGFsbCBsb2FkZXJzIGZvciB0aGUgbmV3IHJvdXRlIHNob3VsZFxuICAgICAgICAgIC8vIGZpcmUgdW5sZXNzIG9wdGVkIG91dCB2aWEgc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oZmV0Y2hSZXF1ZXN0LCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBuZXh0TG9jYXRpb24sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChpbml0Lmhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBuZXh0TG9jYXRpb24sIGZhbHNlLCBmdXR1cmUudW5zdGFibGVfc2tpcEFjdGlvbkVycm9yUmV2YWxpZGF0aW9uLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgW21hdGNoLnJvdXRlLmlkLCBhY3Rpb25SZXN1bHRdKTtcbiAgICAvLyBQdXQgYWxsIHJldmFsaWRhdGluZyBmZXRjaGVycyBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlLCBleGNlcHQgZm9yIHRoZVxuICAgIC8vIGN1cnJlbnQgZmV0Y2hlciB3aGljaCB3ZSB3YW50IHRvIGtlZXAgaW4gaXQncyBjdXJyZW50IGxvYWRpbmcgc3RhdGUgd2hpY2hcbiAgICAvLyBjb250YWlucyBpdCdzIGFjdGlvbiBzdWJtaXNzaW9uIGluZm8gKyBhY3Rpb24gZGF0YVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZpbHRlcihyZiA9PiByZi5rZXkgIT09IGtleSkuZm9yRWFjaChyZiA9PiB7XG4gICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHN0YWxlS2V5KSkge1xuICAgICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXZhbGlkYXRpb25SZXF1ZXN0KTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHIgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QoWy4uLmxvYWRlclJlc3VsdHMsIC4uLmZldGNoZXJSZXN1bHRzXSk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJldmFsaWRhdGlvblJlcXVlc3QsIHJlZGlyZWN0LnJlc3VsdCk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIHN0YXRlLm1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGxvYWRlclJlc3VsdHMsIHVuZGVmaW5lZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzLCBhY3RpdmVEZWZlcnJlZHMpO1xuICAgIC8vIFNpbmNlIHdlIGxldCByZXZhbGlkYXRpb25zIGNvbXBsZXRlIGV2ZW4gaWYgdGhlIHN1Ym1pdHRpbmcgZmV0Y2hlciB3YXNcbiAgICAvLyBkZWxldGVkLCBvbmx5IHB1dCBpdCBiYWNrIHRvIGlkbGUgaWYgaXQgaGFzbid0IGJlZW4gZGVsZXRlZFxuICAgIGlmIChzdGF0ZS5mZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIoYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgICBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBuYXZpZ2F0aW9uIGxvYWRpbmcgc3RhdGUgYW5kIHRoaXMgZmV0Y2hlciBpc1xuICAgIC8vIG1vcmUgcmVjZW50IHRoYW4gdGhlIG5hdmlnYXRpb24sIHdlIHdhbnQgdGhlIG5ld2VyIGRhdGEgc28gYWJvcnQgdGhlXG4gICAgLy8gbmF2aWdhdGlvbiBhbmQgY29tcGxldGUgaXQgd2l0aCB0aGUgZmV0Y2hlciBkYXRhXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHdpdGggdGhlIGZldGNoZXIgZGF0YSwgcHJlc2VydmluZyBhbnkgZXhpc3RpbmdcbiAgICAgIC8vIGxvYWRlckRhdGEgZm9yIGxvYWRlcnMgdGhhdCBkaWQgbm90IG5lZWQgdG8gcmVsb2FkLiAgV2UgaGF2ZSB0b1xuICAgICAgLy8gbWFudWFsbHkgbWVyZ2UgaGVyZSBzaW5jZSB3ZSBhcmVuJ3QgZ29pbmcgdGhyb3VnaCBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoc3RhdGUubG9hZGVyRGF0YSwgbG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQ2FsbCB0aGUgbWF0Y2hlZCBsb2FkZXIgZm9yIGZldGNoZXIubG9hZCgpLCBoYW5kbGluZyByZWRpcmVjdHMsIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGZsdXNoU3luYywgc3VibWlzc2lvbikge1xuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIC8vIENhbGwgdGhlIGxvYWRlciBmb3IgdGhpcyBmZXRjaGVyIHJvdXRlIG1hdGNoXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBwYXRoLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcImxvYWRlclwiLCBmZXRjaFJlcXVlc3QsIFttYXRjaF0sIG1hdGNoZXMpO1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzWzBdO1xuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdXIgb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIG9yIHJlZGlyZWN0cyBmb2xsb3dlZCBmb3IgdW5tb3VudGVkXG4gICAgLy8gZmV0Y2hlcnMsIHNvIHNob3J0IGNpcmN1aXQgaGVyZSBpZiBpdCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBVSVxuICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbG9hZGVyIHRocmV3IGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGxvYWRlciBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb25cbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIHJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudCghaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpLCBcIlVuaGFuZGxlZCBmZXRjaGVyIGRlZmVycmVkIGRhdGFcIik7XG4gICAgLy8gUHV0IHRoZSBmZXRjaGVyIGJhY2sgaW50byBhbiBpZGxlIHN0YXRlXG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpKTtcbiAgfVxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cbiAgICogTm9ybWFsbHksIGEgcmVkaXJlY3QgXCJyZXBsYWNlc1wiIHRoZSBuYXZpZ2F0aW9uIHRoYXQgdHJpZ2dlcmVkIGl0LiAgU28sIGZvclxuICAgKiBleGFtcGxlOlxuICAgKlxuICAgKiAgLSB1c2VyIGlzIG9uIC9hXG4gICAqICAtIHVzZXIgY2xpY2tzIGEgbGluayB0byAvYlxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xuICAgKlxuICAgKiBJbiBhIG5vbi1KUyBhcHAgdGhlIGJyb3dzZXIgd291bGQgdHJhY2sgdGhlIGluLWZsaWdodCBuYXZpZ2F0aW9uIHRvIC9iIGFuZFxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXG4gICAqIHRoZSBlbmQgaXQgd291bGQgb25seSBldmVyIHVwZGF0ZSB0aGUgVVJMIGJhciB3aXRoIC9jLlxuICAgKlxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXG4gICAqIHRoaXMgYmVoYXZpb3IgYW5kIHdlIGFsc28gZG8gbm90IHVwZGF0ZSBoaXN0b3J5IHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gICAqIG5hdmlnYXRpb24gKGluY2x1ZGluZyBwcm9jZXNzZWQgcmVkaXJlY3RzKS4gIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZXZlclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXG4gICAqIHRoZSBoaXN0b3J5IGFjdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uIChQVVNIIG9yIFJFUExBQ0UpLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QsIF90ZW1wMikge1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICByZXBsYWNlXG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgaWYgKHJlZGlyZWN0LnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGxvY2F0aW9uID0gcmVkaXJlY3QucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICBpbnZhcmlhbnQobG9jYXRpb24sIFwiRXhwZWN0ZWQgYSBMb2NhdGlvbiBoZWFkZXIgb24gdGhlIHJlZGlyZWN0IFJlc3BvbnNlXCIpO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbiwgbmV3IFVSTChyZXF1ZXN0LnVybCksIGJhc2VuYW1lKTtcbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICBsZXQgaXNEb2N1bWVudFJlbG9hZCA9IGZhbHNlO1xuICAgICAgaWYgKHJlZGlyZWN0LnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikpIHtcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCBYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9IHJlcGxhY2UgPT09IHRydWUgPyBBY3Rpb24uUmVwbGFjZSA6IEFjdGlvbi5QdXNoO1xuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGVcbiAgICB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3QucmVzcG9uc2Uuc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiBfZXh0ZW5kcyh7fSwgYWN0aXZlU3VibWlzc2lvbiwge1xuICAgICAgICAgIGZvcm1BY3Rpb246IGxvY2F0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24ocmVkaXJlY3RMb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIFV0aWxpdHkgd3JhcHBlciBmb3IgY2FsbGluZyBkYXRhU3RyYXRlZ3kgY2xpZW50LXNpZGUgd2l0aG91dCBoYXZpbmcgdG9cbiAgLy8gcGFzcyBhcm91bmQgdGhlIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneSh0eXBlLCByZXF1ZXN0LCBtYXRjaGVzVG9Mb2FkLCBtYXRjaGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5SW1wbCwgdHlwZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoKHJlc3VsdCwgaSkgPT4ge1xuICAgICAgICBpZiAoaXNSZWRpcmVjdEhhbmRsZXJSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgICAgICByZXNwb25zZTogbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZCwgbWF0Y2hlcywgYmFzZW5hbWUsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0SGFuZGxlclJlc3VsdFRvRGF0YVJlc3VsdChyZXN1bHQpO1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSBvdXRlciBkYXRhU3RyYXRlZ3kgbWV0aG9kIHRocm93cywganVzdCByZXR1cm4gdGhlIGVycm9yIGZvciBhbGxcbiAgICAgIC8vIG1hdGNoZXMgLSBhbmQgaXQnbGwgbmF0dXJhbGx5IGJ1YmJsZSB0byB0aGUgcm9vdFxuICAgICAgcmV0dXJuIG1hdGNoZXNUb0xvYWQubWFwKCgpID0+ICh7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShjdXJyZW50TWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICBsZXQgW2xvYWRlclJlc3VsdHMsIC4uLmZldGNoZXJSZXN1bHRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFttYXRjaGVzVG9Mb2FkLmxlbmd0aCA/IGNhbGxEYXRhU3RyYXRlZ3koXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcykgOiBbXSwgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4ge1xuICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICBsZXQgZmV0Y2hlclJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGYucGF0aCwgZi5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgIHJldHVybiBjYWxsRGF0YVN0cmF0ZWd5KFwibG9hZGVyXCIsIGZldGNoZXJSZXF1ZXN0LCBbZi5tYXRjaF0sIGYubWF0Y2hlcykudGhlbihyID0+IHJbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBmLnBhdGhcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KV0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtyZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCBsb2FkZXJSZXN1bHRzLm1hcCgoKSA9PiByZXF1ZXN0LnNpZ25hbCksIGZhbHNlLCBzdGF0ZS5sb2FkZXJEYXRhKSwgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhjdXJyZW50TWF0Y2hlcywgZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4gZi5tYXRjaCksIGZldGNoZXJSZXN1bHRzLCBmZXRjaGVyc1RvTG9hZC5tYXAoZiA9PiBmLmNvbnRyb2xsZXIgPyBmLmNvbnRyb2xsZXIuc2lnbmFsIDogbnVsbCksIHRydWUpXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG4gICAgLy8gQWJvcnQgaW4tZmxpZ2h0IGZldGNoZXIgbG9hZHNcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLnB1c2goa2V5KTtcbiAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0sIHtcbiAgICAgIGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgKyAxKTtcbiAgICAgIC8vIElmIHRoaXMgZmV0Y2hlciB3YXMgcHJldmlvdXNseSBtYXJrZWQgZm9yIGRlbGV0aW9uLCB1bm1hcmsgaXQgc2luY2Ugd2VcbiAgICAgIC8vIGhhdmUgYSBuZXcgaW5zdGFuY2VcbiAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBEb24ndCBhYm9ydCB0aGUgY29udHJvbGxlciBpZiB0aGlzIGlzIGEgZGVsZXRpb24gb2YgYSBmZXRjaGVyLnN1Ym1pdCgpXG4gICAgLy8gaW4gaXQncyBsb2FkaW5nIHBoYXNlIHNpbmNlIC0gd2UgZG9uJ3Qgd2FudCB0byBhYm9ydCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHJldmFsaWRhdGlvbiBhbmQgd2FudCB0aGVtIHRvIGNvbXBsZXRlIGFuZCBsYW5kXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlKGtleSkge1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIFwiRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogXCIgKyBrZXkpO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIFwiRXhwZWN0ZWQgZmV0Y2hlcjogXCIgKyBrZXkpO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gICAgcmV0dXJuIHVwZGF0ZWRGZXRjaGVycztcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgXCJFeHBlY3RlZCBmZXRjaGVyOiBcIiArIGtleSk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5LCBuZXdCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcbiAgICAvLyBodHRwczovL21lcm1haWQubGl2ZS9lZGl0I3Bha286ZU5xVmtjOU93ekFNeGw4bDhubmpBWXJFdERJT0hFQklnd3ZLSlRSZUd5M19sRHBJcU8yN2s2YXdNRzBYY3JMbG56ODdud2RvbkVTb2dLWFhCdUU3OXJxNzVYWk8zLXlIZHMwUkpWdXY3MFlyUGxVckNFZTJIZnJPUlMzcnVicVpmdWh0cGc1Qzl3azV0WjRWS2NSVXE4OHE5WjhSUzAtNDhjRTFpSEprTDB1Z2JIdUZMdXM5TDZzcFp5OG5YOU1QMkNOZG9tVmFwb3NxdTNmR2F5VDhUOC1qSlF3aGVwb19VdHBnQlFhREVVb20wNGRaaEFOMWFKQkRsVUtKQnhFMWNlQjJTbWowTWxuLUlCVzVBRlUyZHdVaWt0dF8yUWFxMmRCZmFLZEV1cDg1VVY3WWQtZEtqbG5rYWJsMlB2cjBEVGtUcmVNXG4gICAgaW52YXJpYW50KGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLCBcIkludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiBcIiArIGJsb2NrZXIuc3RhdGUgKyBcIiAtPiBcIiArIG5ld0Jsb2NrZXIuc3RhdGUpO1xuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGJsb2NrZXJzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9ID0gX3JlZjQ7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuICAgIGlmIChibG9ja2VyICYmIGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB7XG4gICAgICAvLyBJZiB0aGUgYmxvY2tlciBpcyBjdXJyZW50bHkgcHJvY2VlZGluZywgd2UgZG9uJ3QgbmVlZCB0byByZS1jaGVja1xuICAgICAgLy8gaXQgYW5kIGNhbiBsZXQgdGhpcyBuYXZpZ2F0aW9uIGNvbnRpbnVlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGJsb2NrZXJLZXk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhwcmVkaWNhdGUpIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHMgPSBbXTtcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUocm91dGVJZCkpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWZlcnJlZCAtIGJ1dCBkbyBub3QgcmVtb3ZlIGZyb20gYWN0aXZlRGVmZXJyZWRzIGhlcmUgLVxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxuICAgICAgICAvLyBjbGVhbnVwIHZpYSBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHNcbiAgICAgICAgZGZkLmNhbmNlbCgpO1xuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxsZWRSb3V0ZUlkcztcbiAgfVxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHBvc2l0aW9ucywgZ2V0UG9zaXRpb24sIGdldEtleSkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcy5tYXAobSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSkpO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlcykge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhuZXdSb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaCxcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiB0byA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246IHRvID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyOiBkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUsXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xuICBpbnZhcmlhbnQocm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiKTtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZSxcbiAgICB2N190aHJvd0Fib3J0UmVhc29uOiBmYWxzZVxuICB9LCBvcHRzID8gb3B0cy5mdXR1cmUgOiBudWxsKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICpcbiAgICogLSBgb3B0cy5yZXF1ZXN0Q29udGV4dGAgaXMgYW4gb3B0aW9uYWwgc2VydmVyIGNvbnRleHQgdGhhdCB3aWxsIGJlIHBhc3NlZFxuICAgKiAgIHRvIGFjdGlvbnMvbG9hZGVycyBpbiB0aGUgYGNvbnRleHRgIHBhcmFtZXRlclxuICAgKiAtIGBvcHRzLnNraXBMb2FkZXJFcnJvckJ1YmJsaW5nYCBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCB3aWxsIHByZXZlbnRcbiAgICogICB0aGUgYnViYmxpbmcgb2YgZXJyb3JzIHdoaWNoIGFsbG93cyBzaW5nbGUtZmV0Y2gtdHlwZSBpbXBsZW1lbnRhdGlvbnNcbiAgICogICB3aGVyZSB0aGUgY2xpZW50IHdpbGwgaGFuZGxlIHRoZSBidWJibGluZyBhbmQgd2UgbWF5IG5lZWQgdG8gcmV0dXJuIGRhdGFcbiAgICogICBmb3IgdGhlIGhhbmRsaW5nIHJvdXRlXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShyZXF1ZXN0LCBfdGVtcDMpIHtcbiAgICBsZXQge1xuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneVxuICAgIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCB1bnN0YWJsZV9kYXRhU3RyYXRlZ3kgfHwgbnVsbCwgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsIG51bGwpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXG4gICAgLy8gc2luY2Ugd2UgbmVlZCBpdCBmb3IgUmVhY3QgQ29udGV4dC4gIEJ1dCB0aGlzIGhlbHBzIGtlZXAgb3VyIHN1Ym1pdCBhbmRcbiAgICAvLyBsb2FkUm91dGVEYXRhIG9wZXJhdGluZyBvbiBhIFJlcXVlc3QgaW5zdGVhZCBvZiBhIExvY2F0aW9uXG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgYmFzZW5hbWVcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcXVlcnlSb3V0ZSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdGFyZ2V0ZWQgcm91dGUgcmVxdWVzdHMsIGVpdGhlclxuICAgKiBmb3IgZmV0Y2ggP19kYXRhIHJlcXVlc3RzIG9yIHJlc291cmNlIHJvdXRlIHJlcXVlc3RzLiAgSW4gdGhpcyBjYXNlLCB3ZVxuICAgKiBhcmUgb25seSBldmVyIGNhbGxpbmcgYSBzaW5nbGUgYWN0aW9uIG9yIGxvYWRlciwgYW5kIHdlIGFyZSByZXR1cm5pbmcgdGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGRpcmVjdGx5LiAgSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIGEgUmVzcG9uc2UgcmV0dXJuZWRcbiAgICogZnJvbSB0aGUgYWN0aW9uL2xvYWRlciwgYnV0IGl0IG1heSBiZSBhIHByaW1pdGl2ZSBvciBvdGhlciB2YWx1ZSBhcyB3ZWxsIC1cbiAgICogYW5kIGluIHN1Y2ggY2FzZXMgdGhlIGNhbGxpbmcgY29udGV4dCBzaG91bGQgaGFuZGxlIHRoYXQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIFdlIGRvIHJlc3BlY3QgdGhlIHRocm93L3JldHVybiBkaWZmZXJlbnRpYXRpb24sIHNvIGlmIGFuIGFjdGlvbi9sb2FkZXJcbiAgICogdGhyb3dzLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgdGhlIHZhbHVlLiAgVGhpcyBpcyBpbXBvcnRhbnQgc28gd2VcbiAgICogY2FuIGRvIHByb3BlciBib3VuZGFyeSBpZGVudGlmaWNhdGlvbiBpbiBSZW1peCB3aGVyZSBhIHRocm93biBSZXNwb25zZVxuICAgKiBtdXN0IGdvIHRvIHRoZSBDYXRjaCBCb3VuZGFyeSBidXQgYSByZXR1cm5lZCBSZXNwb25zZSBpcyBoYXBweS1wYXRoLlxuICAgKlxuICAgKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0IGFueSBSb3V0ZXItaW5pdGlhdGVkIEVycm9ycyB0aGF0IG1ha2Ugc2Vuc2VcbiAgICogdG8gYXNzb2NpYXRlIHdpdGggYSBzdGF0dXMgY29kZSB3aWxsIGJlIHRocm93biBhcyBhbiBFcnJvclJlc3BvbnNlXG4gICAqIGluc3RhbmNlIHdoaWNoIGluY2x1ZGUgdGhlIHJhdyBFcnJvciwgc3VjaCB0aGF0IHRoZSBjYWxsaW5nIGNvbnRleHQgY2FuXG4gICAqIHNlcmlhbGl6ZSB0aGUgZXJyb3IgYXMgdGhleSBzZWUgZml0IHdoaWxlIGluY2x1ZGluZyB0aGUgcHJvcGVyIHJlc3BvbnNlXG4gICAqIGNvZGUuICBFeGFtcGxlcyBoZXJlIGFyZSA0MDQgYW5kIDQwNSBlcnJvcnMgdGhhdCBvY2N1ciBwcmlvciB0byByZWFjaGluZ1xuICAgKiBhbnkgdXNlci1kZWZpbmVkIGxvYWRlcnMuXG4gICAqXG4gICAqIC0gYG9wdHMucm91dGVJZGAgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSBzcGVjaWZpYyByb3V0ZSBoYW5kbGVyIHRvIGNhbGwuXG4gICAqICAgSWYgbm90IHByb3ZpZGVkIHRoZSBoYW5kbGVyIHdpbGwgZGV0ZXJtaW5lIHRoZSBwcm9wZXIgcm91dGUgYnkgbWF0Y2hpbmdcbiAgICogICBhZ2FpbnN0IGByZXF1ZXN0LnVybGBcbiAgICogLSBgb3B0cy5yZXF1ZXN0Q29udGV4dGAgaXMgYW4gb3B0aW9uYWwgc2VydmVyIGNvbnRleHQgdGhhdCB3aWxsIGJlIHBhc3NlZFxuICAgKiAgICB0byBhY3Rpb25zL2xvYWRlcnMgaW4gdGhlIGBjb250ZXh0YCBwYXJhbWV0ZXJcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5Um91dGUocmVxdWVzdCwgX3RlbXA0KSB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgIH0gPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0O1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIiAmJiBtZXRob2QgIT09IFwiT1BUSU9OU1wiKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2RcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHJvdXRlSWQgPyBtYXRjaGVzLmZpbmQobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSA6IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAocm91dGVJZCAmJiAhbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAzLCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2gpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhpdCBJIGRvbid0IHRoaW5rP1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIG51bGwsIGZhbHNlLCBtYXRjaCk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBiYWNrIHJlc3VsdC5lcnJvcnMsIHRoYXQgbWVhbnMgdGhlIGxvYWRlci9hY3Rpb24gdGhyZXdcbiAgICAgIC8vIF9zb21ldGhpbmdfIHRoYXQgd2Fzbid0IGEgUmVzcG9uc2UsIGJ1dCBpdCdzIG5vdCBndWFyYW50ZWVkL3JlcXVpcmVkXG4gICAgICAvLyB0byBiZSBhbiBgaW5zdGFuY2VvZiBFcnJvcmAgZWl0aGVyLCBzbyB3ZSBoYXZlIHRvIHVzZSB0aHJvdyBoZXJlIHRvXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGUgXCJlcnJvclwiIHN0YXRlIG91dHNpZGUgb2YgcXVlcnlJbXBsLlxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICB2YXIgX3Jlc3VsdCRhY3RpdmVEZWZlcnJlO1xuICAgICAgbGV0IGRhdGEgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5sb2FkZXJEYXRhKVswXTtcbiAgICAgIGlmICgoX3Jlc3VsdCRhY3RpdmVEZWZlcnJlID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkcykgIT0gbnVsbCAmJiBfcmVzdWx0JGFjdGl2ZURlZmVycmVbbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgIGRhdGFbVU5TQUZFX0RFRkVSUkVEX1NZTUJPTF0gPSByZXN1bHQuYWN0aXZlRGVmZXJyZWRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuc3RhYmxlX2RhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gpIHtcbiAgICBpbnZhcmlhbnQocmVxdWVzdC5zaWduYWwsIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIik7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksIHJlcXVlc3RDb250ZXh0LCB1bnN0YWJsZV9kYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoICE9IG51bGwpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuc3RhYmxlX2RhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gpO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IF9leHRlbmRzKHt9LCByZXN1bHQsIHtcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHRocmV3L3JldHVybmVkIGEgUmVzcG9uc2UgaW4gY2FsbExvYWRlck9yQWN0aW9uIGZvciBhXG4gICAgICAvLyBgcXVlcnlSb3V0ZWAgY2FsbCwgd2UgdGhyb3cgdGhlIGBIYW5kbGVyUmVzdWx0YCB0byBiYWlsIG91dCBlYXJseVxuICAgICAgLy8gYW5kIHRoZW4gcmV0dXJuIG9yIHRocm93IHRoZSByYXcgUmVzcG9uc2UgaGVyZSBhY2NvcmRpbmdseVxuICAgICAgaWYgKGlzSGFuZGxlclJlc3VsdChlKSAmJiBpc1Jlc3BvbnNlKGUucmVzdWx0KSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gUmVkaXJlY3RzIGFyZSBhbHdheXMgcmV0dXJuZWQgc2luY2UgdGhleSBkb24ndCBwcm9wYWdhdGUgdG8gY2F0Y2hcbiAgICAgIC8vIGJvdW5kYXJpZXNcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZSkpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgYWN0aW9uTWF0Y2gsIHJlcXVlc3RDb250ZXh0LCB1bnN0YWJsZV9kYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBpc1JvdXRlUmVxdWVzdCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFhY3Rpb25NYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIWFjdGlvbk1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFwiYWN0aW9uXCIsIHJlcXVlc3QsIFthY3Rpb25NYXRjaF0sIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCwgdW5zdGFibGVfZGF0YVN0cmF0ZWd5KTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHNbMF07XG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QsIGZ1dHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFVoaGhoIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgYWx3YXlzIHRocm93IHRoZXNlIGZyb21cbiAgICAgIC8vIGNhbGxMb2FkZXJPckFjdGlvbiwgYnV0IHRoZSB0eXBlIG5hcnJvd2luZyBoZXJlIGtlZXBzIFRTIGhhcHB5IGFuZCB3ZVxuICAgICAgLy8gY2FuIGdldCBiYWNrIG9uIHRoZSBcInRocm93IGFsbCByZWRpcmVjdCByZXNwb25zZXNcIiB0cmFpbiBoZXJlIHNob3VsZFxuICAgICAgLy8gdGhpcyBldmVyIGhhcHBlbiA6L1xuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQucmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICB0eXBlOiBcImRlZmVyLWFjdGlvblwiXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgLy8gTm90ZTogVGhpcyBzaG91bGQgb25seSBiZSBub24tUmVzcG9uc2UgdmFsdWVzIGlmIHdlIGdldCBoZXJlLCBzaW5jZVxuICAgICAgLy8gaXNSb3V0ZVJlcXVlc3Qgc2hvdWxkIHRocm93IGFueSBSZXNwb25zZSByZWNlaXZlZCBpbiBjYWxsTG9hZGVyT3JBY3Rpb25cbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgIC8vIE5vdGU6IHN0YXR1c0NvZGUgKyBoZWFkZXJzIGFyZSB1bnVzZWQgaGVyZSBzaW5jZSBxdWVyeVJvdXRlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugb3IgdmFsdWVcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgbGV0IGxvYWRlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBwZW5kaW5nIGVycm9yIC0gd2UgdXNlIGl0IHRvIGRldGVybWluZSB3aGljaCBsb2FkZXJzXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gYWN0aW9uTWF0Y2ggOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShsb2FkZXJSZXF1ZXN0LCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgdW5zdGFibGVfZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgbnVsbCwgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWQsIHJlc3VsdF0pO1xuICAgICAgLy8gYWN0aW9uIHN0YXR1cyBjb2RlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc3RhdHVzIGNvZGVzXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsID8gcmVzdWx0LnN0YXR1c0NvZGUgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuaGVhZGVyc1xuICAgICAgICB9IDoge30pXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKGxvYWRlclJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCB1bnN0YWJsZV9kYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBudWxsKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgIH1cbiAgICB9LCByZXN1bHQuc3RhdHVzQ29kZSA/IHtcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXNDb2RlXG4gICAgfSA6IHt9LCB7XG4gICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH0gOiB7fVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuc3RhYmxlX2RhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgcGVuZGluZ0FjdGlvblJlc3VsdFswXSkgOiBtYXRjaGVzO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gcmVxdWVzdE1hdGNoZXMuZmlsdGVyKG0gPT4gbS5yb3V0ZS5sb2FkZXIgfHwgbS5yb3V0ZS5sYXp5KTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5KCkpXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICAvLyBBZGQgYSBudWxsIGZvciBhbGwgbWF0Y2hlZCByb3V0ZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgICAgICBsb2FkZXJEYXRhOiBtYXRjaGVzLnJlZHVjZSgoYWNjLCBtKSA9PiBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFttLnJvdXRlLmlkXTogbnVsbFxuICAgICAgICB9KSwge30pLFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHtcbiAgICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3JcbiAgICAgICAgfSA6IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFwibG9hZGVyXCIsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCwgdW5zdGFibGVfZGF0YVN0cmF0ZWd5KTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGNvbnRleHQgPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdBY3Rpb25SZXN1bHQsIGFjdGl2ZURlZmVycmVkcywgc2tpcExvYWRlckVycm9yQnViYmxpbmcpO1xuICAgIC8vIEFkZCBhIG51bGwgZm9yIGFueSBub24tbG9hZGVyIG1hdGNoZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0KG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IG1hdGNoLnJvdXRlLmlkKSk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb250ZXh0LCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzOiBhY3RpdmVEZWZlcnJlZHMuc2l6ZSA+IDAgPyBPYmplY3QuZnJvbUVudHJpZXMoYWN0aXZlRGVmZXJyZWRzLmVudHJpZXMoKSkgOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgLy8gVXRpbGl0eSB3cmFwcGVyIGZvciBjYWxsaW5nIGRhdGFTdHJhdGVneSBzZXJ2ZXItc2lkZSB3aXRob3V0IGhhdmluZyB0b1xuICAvLyBwYXNzIGFyb3VuZCB0aGUgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBjYWxsRGF0YVN0cmF0ZWd5KHR5cGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGlzUm91dGVSZXF1ZXN0LCByZXF1ZXN0Q29udGV4dCwgdW5zdGFibGVfZGF0YVN0cmF0ZWd5KSB7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbCh1bnN0YWJsZV9kYXRhU3RyYXRlZ3kgfHwgZGVmYXVsdERhdGFTdHJhdGVneSwgdHlwZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgcmVxdWVzdENvbnRleHQpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLm1hcCgocmVzdWx0LCBpKSA9PiB7XG4gICAgICBpZiAoaXNSZWRpcmVjdEhhbmRsZXJSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQucmVzdWx0O1xuICAgICAgICAvLyBUaHJvdyByZWRpcmVjdHMgYW5kIGxldCB0aGUgc2VydmVyIGhhbmRsZSB0aGVtIHdpdGggYW4gSFRUUCByZWRpcmVjdFxuICAgICAgICB0aHJvdyBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlLCByZXF1ZXN0LCBtYXRjaGVzVG9Mb2FkW2ldLnJvdXRlLmlkLCBtYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIC8vIEZvciBTU1Igc2luZ2xlLXJvdXRlIHJlcXVlc3RzLCB3ZSB3YW50IHRvIGhhbmQgUmVzcG9uc2VzIGJhY2tcbiAgICAgICAgLy8gZGlyZWN0bHkgd2l0aG91dCB1bndyYXBwaW5nXG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb252ZXJ0SGFuZGxlclJlc3VsdFRvRGF0YVJlc3VsdChyZXN1bHQpO1xuICAgIH0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZVxuICB9O1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhlbHBlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXG4gKiBwcm92aWRlIGFuIHVwZGF0ZWQgU3RhdGljSGFuZGxlckNvbnRleHQgc3VpdGFibGUgZm9yIGEgc2Vjb25kIFNTUiByZW5kZXJcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihyb3V0ZXMsIGNvbnRleHQsIGVycm9yKSB7XG4gIGxldCBuZXdDb250ZXh0ID0gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvclxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuZnVuY3Rpb24gdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpIHtcbiAgaWYgKGZ1dHVyZS52N190aHJvd0Fib3J0UmVhc29uICYmIHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgXCIoKSBjYWxsIGFib3J0ZWQ6IFwiICsgcmVxdWVzdC5tZXRob2QgKyBcIiBcIiArIHJlcXVlc3QudXJsKTtcbn1cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwgfHwgXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUbyhsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIHByZXBlbmRCYXNlbmFtZSwgdG8sIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8gPyB0byA6IFwiLlwiLCBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCksIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcbiAgLy8gV2hlbiBgdG9gIGlzIG5vdCBzcGVjaWZpZWQgd2UgaW5oZXJpdCBzZWFyY2gvaGFzaCBmcm9tIHRoZSBjdXJyZW50XG4gIC8vIGxvY2F0aW9uLCB1bmxpa2Ugd2hlbiB0bz1cIi5cIiBhbmQgd2UganVzdCBpbmhlcml0IHRoZSBwYXRoLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICAvLyBBZGQgYW4gP2luZGV4IHBhcmFtIGZvciBtYXRjaGVkIGluZGV4IHJvdXRlcyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICgodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmIGFjdGl2ZVJvdXRlTWF0Y2ggJiYgYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiAhaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKSkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lLiAgSWZcbiAgLy8gdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93c1xuICAvLyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaFxuICAvLyBvbiByb290IGFjdGlvbnNcbiAgaWYgKHByZXBlbmRCYXNlbmFtZSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbi8vIE5vcm1hbGl6ZSBuYXZpZ2F0aW9uIG9wdGlvbnMgYnkgY29udmVydGluZyBmb3JtTWV0aG9kPUdFVCBmb3JtRGF0YSBvYmplY3RzIHRvXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhub3JtYWxpemVGb3JtTWV0aG9kLCBpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAob3B0cy5mb3JtTWV0aG9kICYmICFpc1ZhbGlkTWV0aG9kKG9wdHMuZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgdHlwZTogXCJpbnZhbGlkLWJvZHlcIlxuICAgIH0pXG4gIH0pO1xuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kID8gcmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIDogcmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIHRleHQgb25seSBzdXBwb3J0IFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgP1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKChhY2MsIF9yZWY1KSA9PiB7XG4gICAgICAgIGxldCBbbmFtZSwgdmFsdWVdID0gX3JlZjU7XG4gICAgICAgIHJldHVybiBcIlwiICsgYWNjICsgbmFtZSArIFwiPVwiICsgdmFsdWUgKyBcIlxcblwiO1xuICAgICAgfSwgXCJcIikgOiBTdHJpbmcob3B0cy5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIC8vIGpzb24gb25seSBzdXBwb3J0cyBQT1NUL1BVVC9QQVRDSC9ERUxFVEUgc3VibWlzc2lvbnNcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZhcmlhbnQodHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICBsZXQgc2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvblxuICAgIH07XG4gIH1cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcbiAgLy8gcmVzdWx0aW5nIGxvY2F0aW9uIHNpbmNlIGFsbCBsb2FkZXJzIHdpbGwgcnVuLiAgQnV0IGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zXG4gIC8vIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciBzbyB3ZSBuZWVkIHRvIHByZXNlcnZlIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IFwiP1wiICsgc2VhcmNoUGFyYW1zO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksXG4gICAgc3VibWlzc2lvblxuICB9O1xufVxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCkge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBpc0luaXRpYWxMb2FkLCBza2lwQWN0aW9uRXJyb3JSZXZhbGlkYXRpb24sIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsIGRlbGV0ZWRGZXRjaGVycywgZmV0Y2hMb2FkTWF0Y2hlcywgZmV0Y2hSZWRpcmVjdElkcywgcm91dGVzVG9Vc2UsIGJhc2VuYW1lLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ID8gaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3IgOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGEgOiB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RhdGUubG9jYXRpb24pO1xuICBsZXQgbmV4dFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcbiAgLy8gUGljayBuYXZpZ2F0aW9uIG1hdGNoZXMgdGhhdCBhcmUgbmV0LW5ldyBvciBxdWFsaWZ5IGZvciByZXZhbGlkYXRpb25cbiAgbGV0IGJvdW5kYXJ5SWQgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdIDogdW5kZWZpbmVkO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gYm91bmRhcnlJZCA/IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpIDogbWF0Y2hlcztcbiAgLy8gRG9uJ3QgcmV2YWxpZGF0ZSBsb2FkZXJzIGJ5IGRlZmF1bHQgYWZ0ZXIgYWN0aW9uIDR4eC81eHggcmVzcG9uc2VzXG4gIC8vIHdoZW4gdGhlIGZsYWcgaXMgZW5hYmxlZC4gIFRoZXkgY2FuIHN0aWxsIG9wdC1pbnRvIHJldmFsaWRhdGlvbiB2aWFcbiAgLy8gYHNob3VsZFJldmFsaWRhdGVgIHZpYSBgYWN0aW9uUmVzdWx0YFxuICBsZXQgYWN0aW9uU3RhdHVzID0gcGVuZGluZ0FjdGlvblJlc3VsdCA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uc3RhdHVzQ29kZSA6IHVuZGVmaW5lZDtcbiAgbGV0IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPSBza2lwQWN0aW9uRXJyb3JSZXZhbGlkYXRpb24gJiYgYWN0aW9uU3RhdHVzICYmIGFjdGlvblN0YXR1cyA+PSA0MDA7XG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCB7XG4gICAgICByb3V0ZVxuICAgIH0gPSBtYXRjaDtcbiAgICBpZiAocm91dGUubGF6eSkge1xuICAgICAgLy8gV2UgaGF2ZW4ndCBsb2FkZWQgdGhpcyByb3V0ZSB5ZXQgc28gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIGdvdCBhIGxvYWRlciFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocm91dGUubG9hZGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygcm91dGUubG9hZGVyICE9PSBcImZ1bmN0aW9uXCIgfHwgcm91dGUubG9hZGVyLmh5ZHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAvLyBEb24ndCByZS1ydW4gaWYgdGhlIGxvYWRlciByYW4gYW5kIHRocmV3IGFuIGVycm9yXG4gICAgICAhc3RhdGUuZXJyb3JzIHx8IHN0YXRlLmVycm9yc1tyb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBsb2FkZXIgb24gbmV3IHJvdXRlIGluc3RhbmNlcyBhbmQgcGVuZGluZyBkZWZlciBjYW5jZWxsYXRpb25zXG4gICAgaWYgKGlzTmV3TG9hZGVyKHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaCkgfHwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMuc29tZShpZCA9PiBpZCA9PT0gbWF0Y2gucm91dGUuaWQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igd2hlbiB3ZSByZXZhbGlkYXRlLiAgSWYgdGhlIHJvdXRlXG4gICAgLy8gcHJvdmlkZXMgaXQncyBvd24gaW1wbGVtZW50YXRpb24sIHRoZW4gd2UgZ2l2ZSB0aGVtIGZ1bGwgY29udHJvbCBidXRcbiAgICAvLyBwcm92aWRlIHRoaXMgdmFsdWUgc28gdGhleSBjYW4gbGV2ZXJhZ2UgaXQgaWYgbmVlZGVkIGFmdGVyIHRoZXkgY2hlY2tcbiAgICAvLyB0aGVpciBvd24gc3BlY2lmaWMgdXNlIGNhc2VzXG4gICAgbGV0IGN1cnJlbnRSb3V0ZU1hdGNoID0gc3RhdGUubWF0Y2hlc1tpbmRleF07XG4gICAgbGV0IG5leHRSb3V0ZU1hdGNoID0gbWF0Y2g7XG4gICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIF9leHRlbmRzKHtcbiAgICAgIGN1cnJlbnRVcmwsXG4gICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICBuZXh0VXJsLFxuICAgICAgbmV4dFBhcmFtczogbmV4dFJvdXRlTWF0Y2gucGFyYW1zXG4gICAgfSwgc3VibWlzc2lvbiwge1xuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgdW5zdGFibGVfYWN0aW9uU3RhdHVzOiBhY3Rpb25TdGF0dXMsXG4gICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDpcbiAgICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGVcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHwgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PSBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHxcbiAgICAgIC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2ggfHwgaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRSb3V0ZU1hdGNoLCBuZXh0Um91dGVNYXRjaClcbiAgICB9KSk7XG4gIH0pO1xuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVycyA9IFtdO1xuICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKGYsIGtleSkgPT4ge1xuICAgIC8vIERvbid0IHJldmFsaWRhdGU6XG4gICAgLy8gIC0gb24gaW5pdGlhbCBsb2FkIChzaG91bGRuJ3QgYmUgYW55IGZldGNoZXJzIHRoZW4gYW55d2F5KVxuICAgIC8vICAtIGlmIGZldGNoZXIgd29uJ3QgYmUgcHJlc2VudCBpbiB0aGUgc3Vic2VxdWVudCByZW5kZXJcbiAgICAvLyAgICAtIG5vIGxvbmdlciBtYXRjaGVzIHRoZSBVUkwgKHY3X2ZldGNoZXJQZXJzaXN0PWZhbHNlKVxuICAgIC8vICAgIC0gd2FzIHVubW91bnRlZCBidXQgcGVyc2lzdGVkIGR1ZSB0byB2N19mZXRjaGVyUGVyc2lzdD10cnVlXG4gICAgaWYgKGlzSW5pdGlhbExvYWQgfHwgIW1hdGNoZXMuc29tZShtID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkgfHwgZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZXRjaGVyTWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBmLnBhdGgsIGJhc2VuYW1lKTtcbiAgICAvLyBJZiB0aGUgZmV0Y2hlciBwYXRoIG5vIGxvbmdlciBtYXRjaGVzLCBwdXNoIGl0IGluIHdpdGggbnVsbCBtYXRjaGVzIHNvXG4gICAgLy8gd2UgY2FuIHRyaWdnZXIgYSA0MDQgaW4gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhLiAgTm90ZSB0aGlzIGlzXG4gICAgLy8gY3VycmVudGx5IG9ubHkgYSB1c2UtY2FzZSBmb3IgUmVtaXggSE1SIHdoZXJlIHRoZSByb3V0ZSB0cmVlIGNhbiBjaGFuZ2VcbiAgICAvLyBhdCBydW50aW1lIGFuZCByZW1vdmUgYSByb3V0ZSBwcmV2aW91c2x5IGxvYWRlZCB2aWEgYSBmZXRjaGVyXG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXG4gICAgICAgIG1hdGNoOiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmV2YWxpZGF0aW5nIGZldGNoZXJzIGFyZSBkZWNvdXBsZWQgZnJvbSB0aGUgcm91dGUgbWF0Y2hlcyBzaW5jZSB0aGV5XG4gICAgLy8gbG9hZCBmcm9tIGEgc3RhdGljIGhyZWYuICBUaGV5IHJldmFsaWRhdGUgYmFzZWQgb24gZXhwbGljaXQgcmV2YWxpZGF0aW9uXG4gICAgLy8gKHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGUpXG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlck1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2goZmV0Y2hlck1hdGNoZXMsIGYucGF0aCk7XG4gICAgbGV0IHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICBpZiAoZmV0Y2hSZWRpcmVjdElkcy5oYXMoa2V5KSkge1xuICAgICAgLy8gTmV2ZXIgdHJpZ2dlciBhIHJldmFsaWRhdGlvbiBvZiBhbiBhY3RpdmVseSByZWRpcmVjdGluZyBmZXRjaGVyXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgLy8gQWx3YXlzIHJldmFsaWRhdGUgaWYgdGhlIGZldGNoZXIgd2FzIGNhbmNlbGxlZFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgIT09IFwiaWRsZVwiICYmIGZldGNoZXIuZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB0aGUgZmV0Y2hlciBoYXNuJ3QgZXZlciBjb21wbGV0ZWQgbG9hZGluZyB5ZXQsIHRoZW4gdGhpcyBpc24ndCBhXG4gICAgICAvLyByZXZhbGlkYXRpb24sIGl0IHdvdWxkIGp1c3QgYmUgYSBicmFuZCBuZXcgbG9hZCBpZiBhbiBleHBsaWNpdFxuICAgICAgLy8gcmV2YWxpZGF0aW9uIGlzIHJlcXVpcmVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gaXNSZXZhbGlkYXRpb25SZXF1aXJlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGZhbGwgYmFjayBvbiBhbnkgdXNlci1kZWZpbmVkIHNob3VsZFJldmFsaWRhdGUsIGRlZmF1bHRpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0IHJldmFsaWRhdGlvbnMgb25seVxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCBfZXh0ZW5kcyh7XG4gICAgICAgIGN1cnJlbnRVcmwsXG4gICAgICAgIGN1cnJlbnRQYXJhbXM6IHN0YXRlLm1hdGNoZXNbc3RhdGUubWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAgIG5leHRVcmwsXG4gICAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXNcbiAgICAgIH0sIHN1Ym1pc3Npb24sIHtcbiAgICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgICB1bnN0YWJsZV9hY3Rpb25TdGF0dXM6IGFjdGlvblN0YXR1cyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgbWF0Y2g6IGZldGNoZXJNYXRjaCxcbiAgICAgICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW25hdmlnYXRpb25NYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVyc107XG59XG5mdW5jdGlvbiBpc05ld0xvYWRlcihjdXJyZW50TG9hZGVyRGF0YSwgY3VycmVudE1hdGNoLCBtYXRjaCkge1xuICBsZXQgaXNOZXcgPVxuICAvLyBbYV0gLT4gW2EsIGJdXG4gICFjdXJyZW50TWF0Y2ggfHxcbiAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkO1xuICAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBoYXZlIGRhdGEgZm9yIGEgcmUtdXNlZCByb3V0ZSwgcG90ZW50aWFsbHlcbiAgLy8gZnJvbSBhIHByaW9yIGVycm9yIG9yIGZyb20gYSBjYW5jZWxsZWQgcGVuZGluZyBkZWZlcnJlZFxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8XG4gICAgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIGN1cnJlbnRQYXRoICE9IG51bGwgJiYgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGxvYWRlck1hdGNoLCBhcmcpIHtcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgcm91dGVDaG9pY2UgPSBsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKGFyZyk7XG4gICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cbi8qKlxuICogRXhlY3V0ZSByb3V0ZS5sYXp5KCkgbWV0aG9kcyB0byBsYXppbHkgbG9hZCByb3V0ZSBtb2R1bGVzIChsb2FkZXIsIGFjdGlvbixcbiAqIHNob3VsZFJldmFsaWRhdGUpIGFuZCB1cGRhdGUgdGhlIHJvdXRlTWFuaWZlc3QgaW4gcGxhY2Ugd2hpY2ggc2hhcmVzIG9iamVjdHNcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTGF6eVJvdXRlTW9kdWxlKHJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KSB7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICAvLyBJZiB0aGUgbGF6eSByb3V0ZSBmdW5jdGlvbiB3YXMgZXhlY3V0ZWQgYW5kIHJlbW92ZWQgYnkgYW5vdGhlciBwYXJhbGxlbFxuICAvLyBjYWxsIHRoZW4gd2UgY2FuIHJldHVybiAtIGZpcnN0IGxhenkoKSB0byBmaW5pc2ggd2lucyBiZWNhdXNlIHRoZSByZXR1cm5cbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCByb3V0ZVRvVXBkYXRlID0gbWFuaWZlc3Rbcm91dGUuaWRdO1xuICBpbnZhcmlhbnQocm91dGVUb1VwZGF0ZSwgXCJObyByb3V0ZSBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAvLyB3ZSBjb3VsZCB5ZXQgYmUgc2l0dGluZyBvbiB0aGlzIHJvdXRlIGFzIHdlIGNhbid0IGdldCB0aGVyZSB3aXRob3V0XG4gIC8vIHJlc29sdmluZyBsYXp5KCkgZmlyc3QuXG4gIC8vXG4gIC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIEhNUiBcInVwZGF0ZVwiIHVzZS1jYXNlIHdoZXJlIHdlIG1heSBhY3RpdmVseSBiZVxuICAvLyBvbiB0aGUgcm91dGUgYmVpbmcgdXBkYXRlZC4gIFRoZSBtYWluIGNvbmNlcm4gYm9pbHMgZG93biB0byBcImRvZXMgdGhpc1xuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xuICAvLyB2YWx1ZXM/XCIuICBJZiBub3QsIGl0IHNob3VsZCBiZSBzYWZlIHRvIHVwZGF0ZSBpbiBwbGFjZS5cbiAgbGV0IHJvdXRlVXBkYXRlcyA9IHt9O1xuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9IHJvdXRlVG9VcGRhdGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgIGxldCBpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgPSBzdGF0aWNSb3V0ZVZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgIGxhenlSb3V0ZVByb3BlcnR5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICB3YXJuaW5nKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsIFwiUm91dGUgXFxcIlwiICsgcm91dGVUb1VwZGF0ZS5pZCArIFwiXFxcIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgXCIgKyBcImRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFwiICsgKFwiVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgd2lsbCBiZSBpZ25vcmVkLlwiKSk7XG4gICAgaWYgKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiYgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkpKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID0gbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgLy8gTXV0YXRlIHRoZSByb3V0ZSB3aXRoIHRoZSBwcm92aWRlZCB1cGRhdGVzLiAgRG8gdGhpcyBmaXJzdCBzbyB3ZSBwYXNzXG4gIC8vIHRoZSB1cGRhdGVkIHZlcnNpb24gdG8gbWFwUm91dGVQcm9wZXJ0aWVzXG4gIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgcm91dGVVcGRhdGVzKTtcbiAgLy8gTXV0YXRlIHRoZSBgaGFzRXJyb3JCb3VuZGFyeWAgcHJvcGVydHkgb24gdGhlIHJvdXRlIGJhc2VkIG9uIHRoZSByb3V0ZVxuICAvLyB1cGRhdGVzIGFuZCByZW1vdmUgdGhlIGBsYXp5YCBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNvbHZlIHRoZSBsYXp5XG4gIC8vIHJvdXRlIGFnYWluLlxuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIF9leHRlbmRzKHt9LCBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGVUb1VwZGF0ZSksIHtcbiAgICBsYXp5OiB1bmRlZmluZWRcbiAgfSkpO1xufVxuLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgZGF0YVN0cmF0ZWd5YCB3aGljaCBmZXRjaGVzIGFsbCBsb2FkZXJzIGluIHBhcmFsbGVsXG5mdW5jdGlvbiBkZWZhdWx0RGF0YVN0cmF0ZWd5KG9wdHMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKG9wdHMubWF0Y2hlcy5tYXAobSA9PiBtLnJlc29sdmUoKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5SW1wbCwgdHlwZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgcmVxdWVzdENvbnRleHQpIHtcbiAgbGV0IHJvdXRlSWRzVG9Mb2FkID0gbWF0Y2hlc1RvTG9hZC5yZWR1Y2UoKGFjYywgbSkgPT4gYWNjLmFkZChtLnJvdXRlLmlkKSwgbmV3IFNldCgpKTtcbiAgbGV0IGxvYWRlZE1hdGNoZXMgPSBuZXcgU2V0KCk7XG4gIC8vIFNlbmQgYWxsIG1hdGNoZXMgaGVyZSB0byBhbGxvdyBmb3IgYSBtaWRkbGV3YXJlLXR5cGUgaW1wbGVtZW50YXRpb24uXG4gIC8vIGhhbmRsZXIgd2lsbCBiZSBhIG5vLW9wIGZvciB1bm5lZWRlZCByb3V0ZXMgYW5kIHdlIGZpbHRlciB0aG9zZSByZXN1bHRzXG4gIC8vIGJhY2sgb3V0IGJlbG93LlxuICBsZXQgcmVzdWx0cyA9IGF3YWl0IGRhdGFTdHJhdGVneUltcGwoe1xuICAgIG1hdGNoZXM6IG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICAgIGxldCBzaG91bGRMb2FkID0gcm91dGVJZHNUb0xvYWQuaGFzKG1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIC8vIGByZXNvbHZlYCBlbmNhcHN1bGF0ZXMgdGhlIHJvdXRlLmxhenksIGV4ZWN1dGluZyB0aGVcbiAgICAgIC8vIGxvYWRlci9hY3Rpb24sIGFuZCBtYXBwaW5nIHJldHVybiB2YWx1ZXMvdGhyb3duIGVycm9ycyB0byBhXG4gICAgICAvLyBIYW5kbGVyUmVzdWx0LiAgVXNlcnMgY2FuIHBhc3MgYSBjYWxsYmFjayB0byB0YWtlIGZpbmUtZ3JhaW5lZCBjb250cm9sXG4gICAgICAvLyBvdmVyIHRoZSBleGVjdXRpb24gb2YgdGhlIGxvYWRlci9hY3Rpb25cbiAgICAgIGxldCByZXNvbHZlID0gaGFuZGxlck92ZXJyaWRlID0+IHtcbiAgICAgICAgbG9hZGVkTWF0Y2hlcy5hZGQobWF0Y2gucm91dGUuaWQpO1xuICAgICAgICByZXR1cm4gc2hvdWxkTG9hZCA/IGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgaGFuZGxlck92ZXJyaWRlLCByZXF1ZXN0Q29udGV4dCkgOiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG1hdGNoLCB7XG4gICAgICAgIHNob3VsZExvYWQsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHJlcXVlc3QsXG4gICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICBjb250ZXh0OiByZXF1ZXN0Q29udGV4dFxuICB9KTtcbiAgLy8gVGhyb3cgaWYgYW55IGxvYWRSb3V0ZSBpbXBsZW1lbnRhdGlvbnMgbm90IGNhbGxlZCBzaW5jZSB0aGV5IGFyZSB3aGF0XG4gIC8vIGVuc3VyZXMgYSByb3V0ZSBpcyBmdWxseSBsb2FkZWRcbiAgbWF0Y2hlcy5mb3JFYWNoKG0gPT4gaW52YXJpYW50KGxvYWRlZE1hdGNoZXMuaGFzKG0ucm91dGUuaWQpLCBcImBtYXRjaC5yZXNvbHZlKClgIHdhcyBub3QgY2FsbGVkIGZvciByb3V0ZSBpZCBcXFwiXCIgKyBtLnJvdXRlLmlkICsgXCJcXFwiLiBcIiArIFwiWW91IG11c3QgY2FsbCBgbWF0Y2gucmVzb2x2ZSgpYCBvbiBldmVyeSBtYXRjaCBwYXNzZWQgdG8gXCIgKyBcImBkYXRhU3RyYXRlZ3lgIHRvIGVuc3VyZSBhbGwgcm91dGVzIGFyZSBwcm9wZXJseSBsb2FkZWQuXCIpKTtcbiAgLy8gRmlsdGVyIG91dCBhbnkgbWlkZGxld2FyZS1vbmx5IG1hdGNoZXMgZm9yIHdoaWNoIHdlIGRpZG4ndCBuZWVkIHRvIHJ1biBoYW5kbGVyc1xuICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoKF8sIGkpID0+IHJvdXRlSWRzVG9Mb2FkLmhhcyhtYXRjaGVzW2ldLnJvdXRlLmlkKSk7XG59XG4vLyBEZWZhdWx0IGxvZ2ljIGZvciBjYWxsaW5nIGEgbG9hZGVyL2FjdGlvbiBpcyB0aGUgdXNlciBoYXMgbm8gc3BlY2lmaWVkIGEgZGF0YVN0cmF0ZWd5XG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24odHlwZSwgcmVxdWVzdCwgbWF0Y2gsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGhhbmRsZXJPdmVycmlkZSwgc3RhdGljQ29udGV4dCkge1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q7XG4gIGxldCBydW5IYW5kbGVyID0gaGFuZGxlciA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0O1xuICAgIC8vIFRoaXMgd2lsbCBuZXZlciByZXNvbHZlIHNvIHNhZmUgdG8gdHlwZSBpdCBhcyBQcm9taXNlPEhhbmRsZXJSZXN1bHQ+IHRvXG4gICAgLy8gc2F0aXNmeSB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgbGV0IGFjdHVhbEhhbmRsZXIgPSBjdHggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCB0aGUgaGFuZGxlciBmb3IgYSByb3V0ZSB3aGljaCBkZWZpbmVzIGEgYm9vbGVhbiBcIiArIChcIlxcXCJcIiArIHR5cGUgKyBcIlxcXCIgW3JvdXRlSWQ6IFwiICsgbWF0Y2gucm91dGUuaWQgKyBcIl1cIikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYW5kbGVyKHtcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIGNvbnRleHQ6IHN0YXRpY0NvbnRleHRcbiAgICAgIH0sIC4uLihjdHggIT09IHVuZGVmaW5lZCA/IFtjdHhdIDogW10pKTtcbiAgICB9O1xuICAgIGxldCBoYW5kbGVyUHJvbWlzZTtcbiAgICBpZiAoaGFuZGxlck92ZXJyaWRlKSB7XG4gICAgICBoYW5kbGVyUHJvbWlzZSA9IGhhbmRsZXJPdmVycmlkZShjdHggPT4gYWN0dWFsSGFuZGxlcihjdHgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB2YWwgPSBhd2FpdCBhY3R1YWxIYW5kbGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgcmVzdWx0OiB2YWxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHJlc3VsdDogZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2hhbmRsZXJQcm9taXNlLCBhYm9ydFByb21pc2VdKTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IFt2YWx1ZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIHRocm93cywgZG9uJ3QgbGV0IGl0IGltbWVkaWF0ZWx5IGJ1YmJsZSBvdXQsXG4gICAgICAgIC8vIHNpbmNlIHdlIG5lZWQgdG8gbGV0IHRoZSBsYXp5KCkgZXhlY3V0aW9uIGZpbmlzaCBzbyB3ZSBrbm93IGlmIHRoaXNcbiAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICBydW5IYW5kbGVyKGhhbmRsZXIpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgIH0pLCBsb2FkTGF6eVJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KV0pO1xuICAgICAgICBpZiAoaGFuZGxlckVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb2FkIGxhenkgcm91dGUgbW9kdWxlLCB0aGVuIHJ1biBhbnkgcmV0dXJuZWQgaGFuZGxlclxuICAgICAgICBhd2FpdCBsb2FkTGF6eVJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KTtcbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIC8vIEhhbmRsZXIgc3RpbGwgcnVucyBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXp5KCkgcm91dGUgaGFzIG5vIGxvYWRlciB0byBydW4uICBTaG9ydCBjaXJjdWl0IGhlcmUgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoaXQgdGhlIGludmFyaWFudCBiZWxvdyB0aGF0IGVycm9ycyBvbiByZXR1cm5pbmcgdW5kZWZpbmVkLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQocmVzdWx0LnJlc3VsdCAhPT0gdW5kZWZpbmVkLCBcIllvdSBkZWZpbmVkIFwiICsgKHR5cGUgPT09IFwiYWN0aW9uXCIgPyBcImFuIGFjdGlvblwiIDogXCJhIGxvYWRlclwiKSArIFwiIGZvciByb3V0ZSBcIiArIChcIlxcXCJcIiArIG1hdGNoLnJvdXRlLmlkICsgXCJcXFwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZyb20geW91ciBgXCIgKyB0eXBlICsgXCJgIFwiKSArIFwiZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBgbnVsbGAuXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGFscmVhZHkgYmUgY2F0Y2hpbmcgYW5kIGNvbnZlcnRpbmcgbm9ybWFsIGhhbmRsZXIgZXhlY3V0aW9ucyB0b1xuICAgIC8vIEhhbmRsZXJSZXN1bHRzIGFuZCByZXR1cm5pbmcgdGhlbSwgc28gYW55dGhpbmcgdGhhdCB0aHJvd3MgaGVyZSBpcyBhblxuICAgIC8vIHVuZXhwZWN0ZWQgZXJyb3Igd2Ugc3RpbGwgbmVlZCB0byB3cmFwXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICByZXN1bHQ6IGVcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRIYW5kbGVyUmVzdWx0VG9EYXRhUmVzdWx0KGhhbmRsZXJSZXN1bHQpIHtcbiAgbGV0IHtcbiAgICByZXN1bHQsXG4gICAgdHlwZSxcbiAgICBzdGF0dXNcbiAgfSA9IGhhbmRsZXJSZXN1bHQ7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvbnRlbnRUeXBlID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgLy8gQ2hlY2sgYmV0d2VlbiB3b3JkIGJvdW5kYXJpZXMgaW5zdGVhZCBvZiBzdGFydHNXaXRoKCkgZHVlIHRvIHRoZSBsYXN0XG4gICAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEpLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICBlcnJvcjogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdC5zdGF0dXMgOiBzdGF0dXNcbiAgICB9O1xuICB9XG4gIGlmIChpc0RlZmVycmVkRGF0YShyZXN1bHQpKSB7XG4gICAgdmFyIF9yZXN1bHQkaW5pdCwgX3Jlc3VsdCRpbml0MjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZCxcbiAgICAgIGRlZmVycmVkRGF0YTogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogKF9yZXN1bHQkaW5pdCA9IHJlc3VsdC5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdCRpbml0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6ICgoX3Jlc3VsdCRpbml0MiA9IHJlc3VsdC5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdCRpbml0Mi5oZWFkZXJzKSAmJiBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0LFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c1xuICB9O1xufVxuLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSwgcmVxdWVzdCwgcm91dGVJZCwgbWF0Y2hlcywgYmFzZW5hbWUsIHY3X3JlbGF0aXZlU3BsYXRQYXRoKSB7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGludmFyaWFudChsb2NhdGlvbiwgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiKTtcbiAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICBsZXQgdHJpbW1lZE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKTtcbiAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZVRvKG5ldyBVUkwocmVxdWVzdC51cmwpLCB0cmltbWVkTWF0Y2hlcywgYmFzZW5hbWUsIHRydWUsIGxvY2F0aW9uLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCk7XG4gICAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbiwgY3VycmVudFVybCwgYmFzZW5hbWUpIHtcbiAgaWYgKEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgcHJvdG9jb2wrb3JpZ2luIGZvciBzYW1lLW9yaWdpbiArIHNhbWUtYmFzZW5hbWUgYWJzb2x1dGUgcmVkaXJlY3RzXG4gICAgbGV0IG5vcm1hbGl6ZWRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIGxldCB1cmwgPSBub3JtYWxpemVkTG9jYXRpb24uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgbm9ybWFsaXplZExvY2F0aW9uKSA6IG5ldyBVUkwobm9ybWFsaXplZExvY2F0aW9uKTtcbiAgICBsZXQgaXNTYW1lQmFzZW5hbWUgPSBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpICE9IG51bGw7XG4gICAgaWYgKHVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIGlzU2FtZUJhc2VuYW1lKSB7XG4gICAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG9jYXRpb247XG59XG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXG4vLyBjbGllbnQtc2lkZSBuYXZpZ2F0aW9ucyBhbmQgZmV0Y2hlcy4gIER1cmluZyBTU1Igd2Ugd2lsbCBhbHdheXMgaGF2ZSBhXG4vLyBSZXF1ZXN0IGluc3RhbmNlIGZyb20gdGhlIHN0YXRpYyBoYW5kbGVyIChxdWVyeS9xdWVyeVJvdXRlKVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHtcbiAgICBzaWduYWxcbiAgfTtcbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtRW5jVHlwZVxuICAgIH0gPSBzdWJtaXNzaW9uO1xuICAgIC8vIERpZG4ndCB0aGluayB3ZSBuZWVkZWQgdGhpcyBidXQgaXQgdHVybnMgb3V0IHVubGlrZSBvdGhlciBtZXRob2RzLCBwYXRjaFxuICAgIC8vIHdvbid0IGJlIHByb3Blcmx5IG5vcm1hbGl6ZWQgdG8gdXBwZXJjYXNlIGFuZCByZXN1bHRzIGluIGEgNDA1IGVycm9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kXG4gICAgaW5pdC5tZXRob2QgPSBmb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaW5pdC5oZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBmb3JtRW5jVHlwZVxuICAgICAgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24udGV4dDtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmIHN1Ym1pc3Npb24uZm9ybURhdGEpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY29udmVydGluZy1hbi1lbnRyeS1saXN0LXRvLWEtbGlzdC1vZi1uYW1lLXZhbHVlLXBhaXJzXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCBhY3RpdmVEZWZlcnJlZHMsIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nKSB7XG4gIC8vIEZpbGwgaW4gbG9hZGVyRGF0YS9lcnJvcnMgZnJvbSBvdXIgbG9hZGVyc1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIGxldCBwZW5kaW5nRXJyb3IgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogdW5kZWZpbmVkO1xuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KCFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCIpO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nIGFjdGlvbiBlcnJvciwgd2UgcmVwb3J0IGl0IGF0IHRoZSBoaWdoZXN0LXJvdXRlXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcbiAgICAgIC8vIGl0IHdhcyBjb25zdW1lZFxuICAgICAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yID0gcGVuZGluZ0Vycm9yO1xuICAgICAgICBwZW5kaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBlcnJvcnMgPSBlcnJvcnMgfHwge307XG4gICAgICBpZiAoc2tpcExvYWRlckVycm9yQnViYmxpbmcpIHtcbiAgICAgICAgZXJyb3JzW2lkXSA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9vayB1cHdhcmRzIGZyb20gdGhlIG1hdGNoZWQgcm91dGUgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yXG4gICAgICAgIC8vIGJvdW5kYXJ5LCBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoLiAgUHJlZmVyIGhpZ2hlciBlcnJvciB2YWx1ZXNcbiAgICAgICAgLy8gaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxuICAgICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gdW5kZWZpbmVkO1xuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zZXQoaWQsIHJlc3VsdC5kZWZlcnJlZERhdGEpO1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YTtcbiAgICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsICYmIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiYgIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGF0YTtcbiAgICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzQ29kZSAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XG4gICAgICAgICAgc3RhdHVzQ29kZSA9IHJlc3VsdC5zdGF0dXNDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvLyBJZiB3ZSBkaWRuJ3QgY29uc3VtZSB0aGUgcGVuZGluZyBhY3Rpb24gZXJyb3IgKGkuZS4sIGFsbCBsb2FkZXJzXG4gIC8vIHJlc29sdmVkKSwgdGhlbiBjb25zdW1lIGl0IGhlcmUuICBBbHNvIGNsZWFyIG91dCBhbnkgbG9hZGVyRGF0YSBmb3IgdGhlXG4gIC8vIHRocm93aW5nIHJvdXRlXG4gIGlmIChwZW5kaW5nRXJyb3IgIT09IHVuZGVmaW5lZCAmJiBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgZXJyb3JzID0ge1xuICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nRXJyb3JcbiAgICB9O1xuICAgIGxvYWRlckRhdGFbcGVuZGluZ0FjdGlvblJlc3VsdFswXV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9ycyxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcbiAgICBsb2FkZXJIZWFkZXJzXG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzLCBhY3RpdmVEZWZlcnJlZHMpIHtcbiAgbGV0IHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9yc1xuICB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCBhY3RpdmVEZWZlcnJlZHMsIGZhbHNlIC8vIFRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIGNsaWVudCBzaWRlIHNvIHdlIGFsd2F5cyB3YW50IHRvIGJ1YmJsZVxuICApO1xuICAvLyBQcm9jZXNzIHJlc3VsdHMgZnJvbSBvdXIgcmV2YWxpZGF0aW5nIGZldGNoZXJzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgbWF0Y2gsXG4gICAgICBjb250cm9sbGVyXG4gICAgfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoZmV0Y2hlclJlc3VsdHMgIT09IHVuZGVmaW5lZCAmJiBmZXRjaGVyUmVzdWx0c1tpbmRleF0gIT09IHVuZGVmaW5lZCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuICAgIC8vIFByb2Nlc3MgZmV0Y2hlciBub24tcmVkaXJlY3QgZXJyb3JzXG4gICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgYWJvcnRlZCBmZXRjaGVyc1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0gX2V4dGVuZHMoe30sIGVycm9ycywge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcbiAgICAgIC8vIGtlZXAgdGhpcyB0byB0eXBlIG5hcnJvdyB0byBhIHN1Y2Nlc3MgcmVzdWx0IGluIHRoZSBlbHNlXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0gX2V4dGVuZHMoe30sIG5ld0xvYWRlckRhdGEpO1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKG5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAobmV3TG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCAmJiBtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIC8vIFByZXNlcnZlIGV4aXN0aW5nIGtleXMgbm90IGluY2x1ZGVkIGluIG5ld0xvYWRlckRhdGEgYW5kIHdoZXJlIGEgbG9hZGVyXG4gICAgICAvLyB3YXNuJ3QgcmVtb3ZlZCBieSBITVJcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gRG9uJ3Qga2VlcCBhbnkgbG9hZGVyIGRhdGEgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5mdW5jdGlvbiBnZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgaWYgKCFwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgIC8vIENsZWFyIG91dCBwcmlvciBhY3Rpb25EYXRhIG9uIGVycm9yc1xuICAgIGFjdGlvbkRhdGE6IHt9XG4gIH0gOiB7XG4gICAgYWN0aW9uRGF0YToge1xuICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGFcbiAgICB9XG4gIH07XG59XG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKSB7XG4gIGxldCBlbGlnaWJsZU1hdGNoZXMgPSByb3V0ZUlkID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSkgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQobSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8IG1hdGNoZXNbMF07XG59XG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlcykge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPSByb3V0ZXMubGVuZ3RoID09PSAxID8gcm91dGVzWzBdIDogcm91dGVzLmZpbmQociA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgIGlkOiBcIl9fc2hpbS1lcnJvci1yb3V0ZV9fXCJcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbe1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgcm91dGVcbiAgICB9XSxcbiAgICByb3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihzdGF0dXMsIF90ZW1wNSkge1xuICBsZXQge1xuICAgIHBhdGhuYW1lLFxuICAgIHJvdXRlSWQsXG4gICAgbWV0aG9kLFxuICAgIHR5cGVcbiAgfSA9IF90ZW1wNSA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDU7XG4gIGxldCBzdGF0dXNUZXh0ID0gXCJVbmtub3duIFNlcnZlciBFcnJvclwiO1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIEByZW1peC1ydW4vcm91dGVyIGVycm9yXCI7XG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIllvdSBtYWRlIGEgXCIgKyBtZXRob2QgKyBcIiByZXF1ZXN0IHRvIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiIGJ1dCBcIiArIChcImRpZCBub3QgcHJvdmlkZSBhIGBsb2FkZXJgIGZvciByb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiLCBcIikgKyBcInNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlZmVyLWFjdGlvblwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcImRlZmVyKCkgaXMgbm90IHN1cHBvcnRlZCBpbiBhY3Rpb25zXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIlVuYWJsZSB0byBlbmNvZGUgc3VibWlzc2lvbiBib2R5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gXCJSb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiIGRvZXMgbm90IG1hdGNoIFVSTCBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIlwiO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gXCJObyByb3V0ZSBtYXRjaGVzIFVSTCBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIlwiO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIllvdSBtYWRlIGEgXCIgKyBtZXRob2QudG9VcHBlckNhc2UoKSArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGFuIGBhY3Rpb25gIGZvciByb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiLCBcIikgKyBcInNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCI7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiSW52YWxpZCByZXF1ZXN0IG1ldGhvZCBcXFwiXCIgKyBtZXRob2QudG9VcHBlckNhc2UoKSArIFwiXFxcIlwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cyB8fCA1MDAsIHN0YXR1c1RleHQsIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCB0cnVlKTtcbn1cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QocmVzdWx0cykge1xuICBmb3IgKGxldCBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgaWR4OiBpXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoX2V4dGVuZHMoe30sIHBhcnNlZFBhdGgsIHtcbiAgICBoYXNoOiBcIlwiXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYSwgYikge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEuaGFzaCA9PT0gXCJcIikge1xuICAgIC8vIC9wYWdlIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gYi5oYXNoICE9PSBcIlwiO1xuICB9IGVsc2UgaWYgKGEuaGFzaCA9PT0gYi5oYXNoKSB7XG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNoYXNoXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYi5oYXNoICE9PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNvdGhlclxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIHRoZSBoYXNoIGlzIHJlbW92ZWQgdGhlIGJyb3dzZXIgd2lsbCByZS1wZXJmb3JtIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyXG4gIC8vIC9wYWdlI2hhc2ggLT4gL3BhZ2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNIYW5kbGVyUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiByZXN1bHQgJiYgXCJyZXN1bHRcIiBpbiByZXN1bHQgJiYgKHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdEhhbmRsZXJSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3VsdC5yZXN1bHQuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5kZWZlcnJlZDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcjtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiAocmVzdWx0ICYmIHJlc3VsdC50eXBlKSA9PT0gUmVzdWx0VHlwZS5yZWRpcmVjdDtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWREYXRhKHZhbHVlKSB7XG4gIGxldCBkZWZlcnJlZCA9IHZhbHVlO1xuICByZXR1cm4gZGVmZXJyZWQgJiYgdHlwZW9mIGRlZmVycmVkID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBkZWZlcnJlZC5kYXRhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBkZWZlcnJlZC5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmZXJyZWQuY2FuY2VsID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmVycmVkLnJlc29sdmVEYXRhID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzdWx0KSB7XG4gIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgcmV0dXJuIHN0YXR1cyA+PSAzMDAgJiYgc3RhdHVzIDw9IDM5OSAmJiBsb2NhdGlvbiAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkUmVxdWVzdE1ldGhvZHMuaGFzKG1ldGhvZC50b0xvd2VyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZE11dGF0aW9uTWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhjdXJyZW50TWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmVzdWx0cywgc2lnbmFscywgaXNGZXRjaGVyLCBjdXJyZW50TG9hZGVyRGF0YSkge1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hlc1RvTG9hZFtpbmRleF07XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHdlIGNhbiBoYXZlIGEgZGVmZXJyZWQgcmVzdWx0IHRvIGRvXG4gICAgLy8gYW55dGhpbmcgd2l0aC4gIFRoaXMgaXMgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVycyB3aGVyZSB0aGUgcm91dGUgd2FzXG4gICAgLy8gcmVtb3ZlZCBkdXJpbmcgSE1SXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBjdXJyZW50TWF0Y2ggPSBjdXJyZW50TWF0Y2hlcy5maW5kKG0gPT4gbS5yb3V0ZS5pZCA9PT0gbWF0Y2gucm91dGUuaWQpO1xuICAgIGxldCBpc1JldmFsaWRhdGluZ0xvYWRlciA9IGN1cnJlbnRNYXRjaCAhPSBudWxsICYmICFpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkgJiYgKGN1cnJlbnRMb2FkZXJEYXRhICYmIGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSkgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpICYmIChpc0ZldGNoZXIgfHwgaXNSZXZhbGlkYXRpbmdMb2FkZXIpKSB7XG4gICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgaGF2ZSB0byB0b3VjaCBhY3RpdmVEZWZlcnJlZHMgaGVyZSBzaW5jZSB3ZSByYWNlIHRoZW1cbiAgICAgIC8vIGFnYWluc3QgdGhlIHNpZ25hbCBpbiByZXNvbHZlRGVmZXJyZWREYXRhIGFuZCB0aGV5J2xsIGdldCBhYm9ydGVkXG4gICAgICAvLyB0aGVyZSBpZiBuZWVkZWRcbiAgICAgIGxldCBzaWduYWwgPSBzaWduYWxzW2luZGV4XTtcbiAgICAgIGludmFyaWFudChzaWduYWwsIFwiRXhwZWN0ZWQgYW4gQWJvcnRTaWduYWwgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVyIGRlZmVycmVkIHJlc3VsdFwiKTtcbiAgICAgIGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIGlzRmV0Y2hlcikudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQgfHwgcmVzdWx0c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgdW53cmFwKSB7XG4gIGlmICh1bndyYXAgPT09IHZvaWQgMCkge1xuICAgIHVud3JhcCA9IGZhbHNlO1xuICB9XG4gIGxldCBhYm9ydGVkID0gYXdhaXQgcmVzdWx0LmRlZmVycmVkRGF0YS5yZXNvbHZlRGF0YShzaWduYWwpO1xuICBpZiAoYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodW53cmFwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS51bndyYXBwZWREYXRhXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEhhbmRsZSBhbnkgVHJhY2tlZFByb21pc2UuX2Vycm9yIHZhbHVlcyBlbmNvdW50ZXJlZCB3aGlsZSB1bndyYXBwaW5nXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSh2ID0+IHYgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pIHtcbiAgbGV0IHNlYXJjaCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xuICBpZiAobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4ICYmIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2ggfHwgXCJcIikpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGxlYWYgaW5kZXggcm91dGUgd2hlbiBpbmRleCBpcyBwcmVzZW50XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvLyBPdGhlcndpc2UgZ3JhYiB0aGUgZGVlcGVzdCBcInBhdGggY29udHJpYnV0aW5nXCIgbWF0Y2ggKGlnbm9yaW5nIGluZGV4IGFuZFxuICAvLyBwYXRobGVzcyBsYXlvdXQgcm91dGVzKVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKG5hdmlnYXRpb24pIHtcbiAgbGV0IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGUsXG4gICAgdGV4dCxcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uXG4gIH0gPSBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBkYXRhKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGEpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgZGF0YVxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IF93aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSk7XG4gICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhqc29uIHx8IHt9KSkge1xuICAgICAgICBpZiAodiAmJiBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbnMuc2V0KGssIG5ldyBTZXQodiB8fCBbXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIGlmICh0cmFuc2l0aW9ucy5zaXplID4gMCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShqc29uKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlIChcIiArIGVycm9yICsgXCIpLlwiKTtcbiAgICB9XG4gIH1cbn1cbi8vI2VuZHJlZ2lvblxuXG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQWN0aW9uLCBJRExFX0JMT0NLRVIsIElETEVfRkVUQ0hFUiwgSURMRV9OQVZJR0FUSU9OLCBVTlNBRkVfREVGRVJSRURfU1lNQk9MLCBEZWZlcnJlZERhdGEgYXMgVU5TQUZFX0RlZmVycmVkRGF0YSwgRXJyb3JSZXNwb25zZUltcGwgYXMgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLCBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCBhcyBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMgYXMgVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsIGdldFJlc29sdmVUb01hdGNoZXMgYXMgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMsIGludmFyaWFudCBhcyBVTlNBRkVfaW52YXJpYW50LCB3YXJuaW5nIGFzIFVOU0FGRV93YXJuaW5nLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZVBhdGgsIGNyZWF0ZVJvdXRlciwgY3JlYXRlU3RhdGljSGFuZGxlciwgZGVmZXIsIGdlbmVyYXRlUGF0aCwgZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciwgZ2V0VG9QYXRobmFtZSwgaXNEZWZlcnJlZERhdGEsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqb2luUGF0aHMsIGpzb24sIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIG5vcm1hbGl6ZVBhdGhuYW1lLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXNvbHZlUGF0aCwgcmVzb2x2ZVRvLCBzdHJpcEJhc2VuYW1lIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@remix-run/router/dist/router.js\n");

/***/ }),

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = ansiHTML;\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar _regANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/;\nvar _defColors = {\n  reset: ['fff', '000'],\n  // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n};\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n};\nvar _openTags = {\n  '1': 'font-weight:bold',\n  // bold\n  '2': 'opacity:0.5',\n  // dim\n  '3': '<i>',\n  // italic\n  '4': '<u>',\n  // underscore\n  '8': 'display:none',\n  // hidden\n  '9': '<del>' // delete\n};\nvar _closeTags = {\n  '23': '</i>',\n  // reset italic\n  '24': '</u>',\n  // reset underscore\n  '29': '</del>' // reset delete\n};\n[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>';\n});\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML(text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!_regANSI.test(text)) {\n    return text;\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = [];\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)m/g, function (match, seq) {\n    var ot = _openTags[seq];\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) {\n        // eslint-disable-line no-extra-boolean-cast\n        ansiCodes.pop();\n        return '</span>';\n      }\n      // Open tag.\n      ansiCodes.push(seq);\n      return ot[0] === '<' ? ot : '<span style=\"' + ot + ';\">';\n    }\n    var ct = _closeTags[seq];\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop();\n      return ct;\n    }\n    return '';\n  });\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length;\n  l > 0 && (ret += Array(l + 1).join('</span>'));\n  return ret;\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors !== 'object') {\n    throw new Error('`colors` parameter must be an Object.');\n  }\n  var _finalColors = {};\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null;\n    if (!hex) {\n      _finalColors[key] = _defColors[key];\n      continue;\n    }\n    if ('reset' === key) {\n      if (typeof hex === 'string') {\n        hex = [hex];\n      }\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\n        return typeof h !== 'string';\n      })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');\n      }\n      var defHexColor = _defColors[key];\n      if (!hex[0]) {\n        hex[0] = defHexColor[0];\n      }\n      if (hex.length === 1 || !hex[1]) {\n        hex = [hex[0]];\n        hex.push(defHexColor[1]);\n      }\n      hex = hex.slice(0, 2);\n    } else if (typeof hex !== 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');\n    }\n    _finalColors[key] = hex;\n  }\n  _setTags(_finalColors);\n};\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function () {\n  _setTags(_defColors);\n};\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {};\nif (Object.defineProperty) {\n  Object.defineProperty(ansiHTML.tags, 'open', {\n    get: function () {\n      return _openTags;\n    }\n  });\n  Object.defineProperty(ansiHTML.tags, 'close', {\n    get: function () {\n      return _closeTags;\n    }\n  });\n} else {\n  ansiHTML.tags.open = _openTags;\n  ansiHTML.tags.close = _closeTags;\n}\nfunction _setTags(colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey;\n  for (var code in _styles) {\n    var color = _styles[code];\n    var oriColor = colors[color] || '000';\n    _openTags[code] = 'color:#' + oriColor;\n    code = parseInt(code);\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor;\n  }\n}\nansiHTML.reset();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sLWNvbW11bml0eS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBLG1EQUFtRCxJQUFJLFNBQVMsTUFBTSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVLCtCQUErQjtBQUNoRjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwtY29tbXVuaXR5L2luZGV4LmpzP2M0MjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MO1xuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS87XG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLFxuICAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59O1xudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufTtcbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLFxuICAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JyxcbiAgLy8gZGltXG4gICczJzogJzxpPicsXG4gIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLFxuICAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsXG4gIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59O1xudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JyxcbiAgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JyxcbiAgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn07XG5bMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nO1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdO1xuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKW0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXTtcbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKTtcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPic7XG4gICAgfVxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXTtcbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpO1xuICAgICAgcmV0dXJuIGN0O1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aDtcbiAgbCA+IDAgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpO1xuICB9XG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGw7XG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJztcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XTtcbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdO1xuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXTtcbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pO1xuICAgICAgfVxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpO1xuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleDtcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpO1xufTtcblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKTtcbn07XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fTtcbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9vcGVuVGFncztcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9jbG9zZVRhZ3M7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFncztcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3M7XG59XG5mdW5jdGlvbiBfc2V0VGFncyhjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV07XG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF07XG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXk7XG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV07XG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJztcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvcjtcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSk7XG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvcjtcbiAgfVxufVxuYW5zaUhUTUwucmVzZXQoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ansi-html-community/index.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    ;\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mMGY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGw7XG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJyA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG59O1xudmFyIFJlZmxlY3RPd25LZXlzO1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5cztcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcic7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7ZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICsgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbn07XG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7XG4gICAgZmlyZWQ6IGZhbHNlLFxuICAgIHdyYXBGbjogdW5kZWZpbmVkLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSB7XG4gICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHBvc2l0aW9uID0gLTE7XG4gICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAocG9zaXRpb24gPT09IDApIGxpc3Quc2hpZnQoKTtlbHNlIHtcbiAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcbiAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgO1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar named_references_1 = __webpack_require__(/*! ./named-references */ \"./node_modules/html-entities/lib/named-references.js\");\nvar numeric_unicode_map_1 = __webpack_require__(/*! ./numeric-unicode-map */ \"./node_modules/html-entities/lib/numeric-unicode-map.js\");\nvar surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ \"./node_modules/html-entities/lib/surrogate-pairs.js\");\nvar allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {\n  all: named_references_1.namedReferences.html5\n});\nfunction replaceUsingRegExp(macroText, macroRegExp, macroReplacer) {\n  macroRegExp.lastIndex = 0;\n  var replaceMatch = macroRegExp.exec(macroText);\n  var replaceResult;\n  if (replaceMatch) {\n    replaceResult = \"\";\n    var replaceLastIndex = 0;\n    do {\n      if (replaceLastIndex !== replaceMatch.index) {\n        replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);\n      }\n      var replaceInput = replaceMatch[0];\n      replaceResult += macroReplacer(replaceInput);\n      replaceLastIndex = replaceMatch.index + replaceInput.length;\n    } while (replaceMatch = macroRegExp.exec(macroText));\n    if (replaceLastIndex !== macroText.length) {\n      replaceResult += macroText.substring(replaceLastIndex);\n    }\n  } else {\n    replaceResult = macroText;\n  }\n  return replaceResult;\n}\nvar encodeRegExps = {\n  specialChars: /[<>'\"&]/g,\n  nonAscii: /[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  nonAsciiPrintable: /[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  nonAsciiPrintableOnly: /[\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  extensive: /[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g\n};\nvar defaultEncodeOptions = {\n  mode: \"specialChars\",\n  level: \"all\",\n  numeric: \"decimal\"\n};\nfunction encode(text, _a) {\n  var _b = _a === void 0 ? defaultEncodeOptions : _a,\n    _c = _b.mode,\n    mode = _c === void 0 ? \"specialChars\" : _c,\n    _d = _b.numeric,\n    numeric = _d === void 0 ? \"decimal\" : _d,\n    _e = _b.level,\n    level = _e === void 0 ? \"all\" : _e;\n  if (!text) {\n    return \"\";\n  }\n  var encodeRegExp = encodeRegExps[mode];\n  var references = allNamedReferences[level].characters;\n  var isHex = numeric === \"hexadecimal\";\n  return replaceUsingRegExp(text, encodeRegExp, function (input) {\n    var result = references[input];\n    if (!result) {\n      var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);\n      result = (isHex ? \"&#x\" + code.toString(16) : \"&#\" + code) + \";\";\n    }\n    return result;\n  });\n}\nexports.encode = encode;\nvar defaultDecodeOptions = {\n  scope: \"body\",\n  level: \"all\"\n};\nvar strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nvar attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\nvar baseDecodeRegExps = {\n  xml: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.xml\n  },\n  html4: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.html4\n  },\n  html5: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.html5\n  }\n};\nvar decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {\n  all: baseDecodeRegExps.html5\n});\nvar fromCharCode = String.fromCharCode;\nvar outOfBoundsChar = fromCharCode(65533);\nvar defaultDecodeEntityOptions = {\n  level: \"all\"\n};\nfunction getDecodedEntity(entity, references, isAttribute, isStrict) {\n  var decodeResult = entity;\n  var decodeEntityLastChar = entity[entity.length - 1];\n  if (isAttribute && decodeEntityLastChar === \"=\") {\n    decodeResult = entity;\n  } else if (isStrict && decodeEntityLastChar !== \";\") {\n    decodeResult = entity;\n  } else {\n    var decodeResultByReference = references[entity];\n    if (decodeResultByReference) {\n      decodeResult = decodeResultByReference;\n    } else if (entity[0] === \"&\" && entity[1] === \"#\") {\n      var decodeSecondChar = entity[2];\n      var decodeCode = decodeSecondChar == \"x\" || decodeSecondChar == \"X\" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));\n      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);\n    }\n  }\n  return decodeResult;\n}\nfunction decodeEntity(entity, _a) {\n  var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level,\n    level = _b === void 0 ? \"all\" : _b;\n  if (!entity) {\n    return \"\";\n  }\n  return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);\n}\nexports.decodeEntity = decodeEntity;\nfunction decode(text, _a) {\n  var _b = _a === void 0 ? defaultDecodeOptions : _a,\n    _c = _b.level,\n    level = _c === void 0 ? \"all\" : _c,\n    _d = _b.scope,\n    scope = _d === void 0 ? level === \"xml\" ? \"strict\" : \"body\" : _d;\n  if (!text) {\n    return \"\";\n  }\n  var decodeRegExp = decodeRegExps[level][scope];\n  var references = allNamedReferences[level].entities;\n  var isAttribute = scope === \"attribute\";\n  var isStrict = scope === \"strict\";\n  return replaceUsingRegExp(text, decodeRegExp, function (entity) {\n    return getDecodedEntity(entity, references, isAttribute, isStrict);\n  });\n}\nexports.decode = decode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ3JELDRCQUE0QixtQkFBTyxDQUFDLHNGQUF1QjtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDbkQsNkNBQTZDO0FBQzdDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBZ0Q7QUFDcEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9pbmRleC5qcz80OWJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX19hc3NpZ24gPSB0aGlzICYmIHRoaXMuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBuYW1lZF9yZWZlcmVuY2VzXzEgPSByZXF1aXJlKFwiLi9uYW1lZC1yZWZlcmVuY2VzXCIpO1xudmFyIG51bWVyaWNfdW5pY29kZV9tYXBfMSA9IHJlcXVpcmUoXCIuL251bWVyaWMtdW5pY29kZS1tYXBcIik7XG52YXIgc3Vycm9nYXRlX3BhaXJzXzEgPSByZXF1aXJlKFwiLi9zdXJyb2dhdGUtcGFpcnNcIik7XG52YXIgYWxsTmFtZWRSZWZlcmVuY2VzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG5hbWVkX3JlZmVyZW5jZXNfMS5uYW1lZFJlZmVyZW5jZXMpLCB7XG4gIGFsbDogbmFtZWRfcmVmZXJlbmNlc18xLm5hbWVkUmVmZXJlbmNlcy5odG1sNVxufSk7XG5mdW5jdGlvbiByZXBsYWNlVXNpbmdSZWdFeHAobWFjcm9UZXh0LCBtYWNyb1JlZ0V4cCwgbWFjcm9SZXBsYWNlcikge1xuICBtYWNyb1JlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgcmVwbGFjZU1hdGNoID0gbWFjcm9SZWdFeHAuZXhlYyhtYWNyb1RleHQpO1xuICB2YXIgcmVwbGFjZVJlc3VsdDtcbiAgaWYgKHJlcGxhY2VNYXRjaCkge1xuICAgIHJlcGxhY2VSZXN1bHQgPSBcIlwiO1xuICAgIHZhciByZXBsYWNlTGFzdEluZGV4ID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAocmVwbGFjZUxhc3RJbmRleCAhPT0gcmVwbGFjZU1hdGNoLmluZGV4KSB7XG4gICAgICAgIHJlcGxhY2VSZXN1bHQgKz0gbWFjcm9UZXh0LnN1YnN0cmluZyhyZXBsYWNlTGFzdEluZGV4LCByZXBsYWNlTWF0Y2guaW5kZXgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlcGxhY2VJbnB1dCA9IHJlcGxhY2VNYXRjaFswXTtcbiAgICAgIHJlcGxhY2VSZXN1bHQgKz0gbWFjcm9SZXBsYWNlcihyZXBsYWNlSW5wdXQpO1xuICAgICAgcmVwbGFjZUxhc3RJbmRleCA9IHJlcGxhY2VNYXRjaC5pbmRleCArIHJlcGxhY2VJbnB1dC5sZW5ndGg7XG4gICAgfSB3aGlsZSAocmVwbGFjZU1hdGNoID0gbWFjcm9SZWdFeHAuZXhlYyhtYWNyb1RleHQpKTtcbiAgICBpZiAocmVwbGFjZUxhc3RJbmRleCAhPT0gbWFjcm9UZXh0Lmxlbmd0aCkge1xuICAgICAgcmVwbGFjZVJlc3VsdCArPSBtYWNyb1RleHQuc3Vic3RyaW5nKHJlcGxhY2VMYXN0SW5kZXgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXBsYWNlUmVzdWx0ID0gbWFjcm9UZXh0O1xuICB9XG4gIHJldHVybiByZXBsYWNlUmVzdWx0O1xufVxudmFyIGVuY29kZVJlZ0V4cHMgPSB7XG4gIHNwZWNpYWxDaGFyczogL1s8PidcIiZdL2csXG4gIG5vbkFzY2lpOiAvWzw+J1wiJlxcdTAwODAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS9nLFxuICBub25Bc2NpaVByaW50YWJsZTogL1s8PidcIiZcXHgwMS1cXHgwOFxceDExLVxceDE1XFx4MTctXFx4MUZcXHg3Zi1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL2csXG4gIG5vbkFzY2lpUHJpbnRhYmxlT25seTogL1tcXHgwMS1cXHgwOFxceDExLVxceDE1XFx4MTctXFx4MUZcXHg3Zi1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL2csXG4gIGV4dGVuc2l2ZTogL1tcXHgwMS1cXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4MmNcXHgyZS1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3ZFxceDdmLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vZ1xufTtcbnZhciBkZWZhdWx0RW5jb2RlT3B0aW9ucyA9IHtcbiAgbW9kZTogXCJzcGVjaWFsQ2hhcnNcIixcbiAgbGV2ZWw6IFwiYWxsXCIsXG4gIG51bWVyaWM6IFwiZGVjaW1hbFwiXG59O1xuZnVuY3Rpb24gZW5jb2RlKHRleHQsIF9hKSB7XG4gIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyBkZWZhdWx0RW5jb2RlT3B0aW9ucyA6IF9hLFxuICAgIF9jID0gX2IubW9kZSxcbiAgICBtb2RlID0gX2MgPT09IHZvaWQgMCA/IFwic3BlY2lhbENoYXJzXCIgOiBfYyxcbiAgICBfZCA9IF9iLm51bWVyaWMsXG4gICAgbnVtZXJpYyA9IF9kID09PSB2b2lkIDAgPyBcImRlY2ltYWxcIiA6IF9kLFxuICAgIF9lID0gX2IubGV2ZWwsXG4gICAgbGV2ZWwgPSBfZSA9PT0gdm9pZCAwID8gXCJhbGxcIiA6IF9lO1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB2YXIgZW5jb2RlUmVnRXhwID0gZW5jb2RlUmVnRXhwc1ttb2RlXTtcbiAgdmFyIHJlZmVyZW5jZXMgPSBhbGxOYW1lZFJlZmVyZW5jZXNbbGV2ZWxdLmNoYXJhY3RlcnM7XG4gIHZhciBpc0hleCA9IG51bWVyaWMgPT09IFwiaGV4YWRlY2ltYWxcIjtcbiAgcmV0dXJuIHJlcGxhY2VVc2luZ1JlZ0V4cCh0ZXh0LCBlbmNvZGVSZWdFeHAsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciByZXN1bHQgPSByZWZlcmVuY2VzW2lucHV0XTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdmFyIGNvZGUgPSBpbnB1dC5sZW5ndGggPiAxID8gc3Vycm9nYXRlX3BhaXJzXzEuZ2V0Q29kZVBvaW50KGlucHV0LCAwKSA6IGlucHV0LmNoYXJDb2RlQXQoMCk7XG4gICAgICByZXN1bHQgPSAoaXNIZXggPyBcIiYjeFwiICsgY29kZS50b1N0cmluZygxNikgOiBcIiYjXCIgKyBjb2RlKSArIFwiO1wiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xudmFyIGRlZmF1bHREZWNvZGVPcHRpb25zID0ge1xuICBzY29wZTogXCJib2R5XCIsXG4gIGxldmVsOiBcImFsbFwiXG59O1xudmFyIHN0cmljdCA9IC8mKD86I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKTsvZztcbnZhciBhdHRyaWJ1dGUgPSAvJig/OiNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKylbOz1dPy9nO1xudmFyIGJhc2VEZWNvZGVSZWdFeHBzID0ge1xuICB4bWw6IHtcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICBib2R5OiBuYW1lZF9yZWZlcmVuY2VzXzEuYm9keVJlZ0V4cHMueG1sXG4gIH0sXG4gIGh0bWw0OiB7XG4gICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgYm9keTogbmFtZWRfcmVmZXJlbmNlc18xLmJvZHlSZWdFeHBzLmh0bWw0XG4gIH0sXG4gIGh0bWw1OiB7XG4gICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgYm9keTogbmFtZWRfcmVmZXJlbmNlc18xLmJvZHlSZWdFeHBzLmh0bWw1XG4gIH1cbn07XG52YXIgZGVjb2RlUmVnRXhwcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlRGVjb2RlUmVnRXhwcyksIHtcbiAgYWxsOiBiYXNlRGVjb2RlUmVnRXhwcy5odG1sNVxufSk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBvdXRPZkJvdW5kc0NoYXIgPSBmcm9tQ2hhckNvZGUoNjU1MzMpO1xudmFyIGRlZmF1bHREZWNvZGVFbnRpdHlPcHRpb25zID0ge1xuICBsZXZlbDogXCJhbGxcIlxufTtcbmZ1bmN0aW9uIGdldERlY29kZWRFbnRpdHkoZW50aXR5LCByZWZlcmVuY2VzLCBpc0F0dHJpYnV0ZSwgaXNTdHJpY3QpIHtcbiAgdmFyIGRlY29kZVJlc3VsdCA9IGVudGl0eTtcbiAgdmFyIGRlY29kZUVudGl0eUxhc3RDaGFyID0gZW50aXR5W2VudGl0eS5sZW5ndGggLSAxXTtcbiAgaWYgKGlzQXR0cmlidXRlICYmIGRlY29kZUVudGl0eUxhc3RDaGFyID09PSBcIj1cIikge1xuICAgIGRlY29kZVJlc3VsdCA9IGVudGl0eTtcbiAgfSBlbHNlIGlmIChpc1N0cmljdCAmJiBkZWNvZGVFbnRpdHlMYXN0Q2hhciAhPT0gXCI7XCIpIHtcbiAgICBkZWNvZGVSZXN1bHQgPSBlbnRpdHk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlID0gcmVmZXJlbmNlc1tlbnRpdHldO1xuICAgIGlmIChkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZSkge1xuICAgICAgZGVjb2RlUmVzdWx0ID0gZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2U7XG4gICAgfSBlbHNlIGlmIChlbnRpdHlbMF0gPT09IFwiJlwiICYmIGVudGl0eVsxXSA9PT0gXCIjXCIpIHtcbiAgICAgIHZhciBkZWNvZGVTZWNvbmRDaGFyID0gZW50aXR5WzJdO1xuICAgICAgdmFyIGRlY29kZUNvZGUgPSBkZWNvZGVTZWNvbmRDaGFyID09IFwieFwiIHx8IGRlY29kZVNlY29uZENoYXIgPT0gXCJYXCIgPyBwYXJzZUludChlbnRpdHkuc3Vic3RyKDMpLCAxNikgOiBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpKTtcbiAgICAgIGRlY29kZVJlc3VsdCA9IGRlY29kZUNvZGUgPj0gMTExNDExMSA/IG91dE9mQm91bmRzQ2hhciA6IGRlY29kZUNvZGUgPiA2NTUzNSA/IHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoZGVjb2RlQ29kZSkgOiBmcm9tQ2hhckNvZGUobnVtZXJpY191bmljb2RlX21hcF8xLm51bWVyaWNVbmljb2RlTWFwW2RlY29kZUNvZGVdIHx8IGRlY29kZUNvZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjb2RlUmVzdWx0O1xufVxuZnVuY3Rpb24gZGVjb2RlRW50aXR5KGVudGl0eSwgX2EpIHtcbiAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyBkZWZhdWx0RGVjb2RlRW50aXR5T3B0aW9ucyA6IF9hKS5sZXZlbCxcbiAgICBsZXZlbCA9IF9iID09PSB2b2lkIDAgPyBcImFsbFwiIDogX2I7XG4gIGlmICghZW50aXR5KSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIGdldERlY29kZWRFbnRpdHkoZW50aXR5LCBhbGxOYW1lZFJlZmVyZW5jZXNbbGV2ZWxdLmVudGl0aWVzLCBmYWxzZSwgZmFsc2UpO1xufVxuZXhwb3J0cy5kZWNvZGVFbnRpdHkgPSBkZWNvZGVFbnRpdHk7XG5mdW5jdGlvbiBkZWNvZGUodGV4dCwgX2EpIHtcbiAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IGRlZmF1bHREZWNvZGVPcHRpb25zIDogX2EsXG4gICAgX2MgPSBfYi5sZXZlbCxcbiAgICBsZXZlbCA9IF9jID09PSB2b2lkIDAgPyBcImFsbFwiIDogX2MsXG4gICAgX2QgPSBfYi5zY29wZSxcbiAgICBzY29wZSA9IF9kID09PSB2b2lkIDAgPyBsZXZlbCA9PT0gXCJ4bWxcIiA/IFwic3RyaWN0XCIgOiBcImJvZHlcIiA6IF9kO1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB2YXIgZGVjb2RlUmVnRXhwID0gZGVjb2RlUmVnRXhwc1tsZXZlbF1bc2NvcGVdO1xuICB2YXIgcmVmZXJlbmNlcyA9IGFsbE5hbWVkUmVmZXJlbmNlc1tsZXZlbF0uZW50aXRpZXM7XG4gIHZhciBpc0F0dHJpYnV0ZSA9IHNjb3BlID09PSBcImF0dHJpYnV0ZVwiO1xuICB2YXIgaXNTdHJpY3QgPSBzY29wZSA9PT0gXCJzdHJpY3RcIjtcbiAgcmV0dXJuIHJlcGxhY2VVc2luZ1JlZ0V4cCh0ZXh0LCBkZWNvZGVSZWdFeHAsIGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICByZXR1cm4gZ2V0RGVjb2RlZEVudGl0eShlbnRpdHksIHJlZmVyZW5jZXMsIGlzQXR0cmlidXRlLCBpc1N0cmljdCk7XG4gIH0pO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/index.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/named-references.js":
/*!************************************************************!*\
  !*** ./node_modules/html-entities/lib/named-references.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bodyRegExps = {\n  xml: /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n  html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n  html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g\n};\nexports.namedReferences = {\n  xml: {\n    entities: {\n      \"&lt;\": \"<\",\n      \"&gt;\": \">\",\n      \"&quot;\": '\"',\n      \"&apos;\": \"'\",\n      \"&amp;\": \"&\"\n    },\n    characters: {\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&apos;\",\n      \"&\": \"&amp;\"\n    }\n  },\n  html4: {\n    entities: {\n      \"&apos;\": \"'\",\n      \"&nbsp\": \"\",\n      \"&nbsp;\": \"\",\n      \"&iexcl\": \"\",\n      \"&iexcl;\": \"\",\n      \"&cent\": \"\",\n      \"&cent;\": \"\",\n      \"&pound\": \"\",\n      \"&pound;\": \"\",\n      \"&curren\": \"\",\n      \"&curren;\": \"\",\n      \"&yen\": \"\",\n      \"&yen;\": \"\",\n      \"&brvbar\": \"\",\n      \"&brvbar;\": \"\",\n      \"&sect\": \"\",\n      \"&sect;\": \"\",\n      \"&uml\": \"\",\n      \"&uml;\": \"\",\n      \"&copy\": \"\",\n      \"&copy;\": \"\",\n      \"&ordf\": \"\",\n      \"&ordf;\": \"\",\n      \"&laquo\": \"\",\n      \"&laquo;\": \"\",\n      \"&not\": \"\",\n      \"&not;\": \"\",\n      \"&shy\": \"\",\n      \"&shy;\": \"\",\n      \"&reg\": \"\",\n      \"&reg;\": \"\",\n      \"&macr\": \"\",\n      \"&macr;\": \"\",\n      \"&deg\": \"\",\n      \"&deg;\": \"\",\n      \"&plusmn\": \"\",\n      \"&plusmn;\": \"\",\n      \"&sup2\": \"\",\n      \"&sup2;\": \"\",\n      \"&sup3\": \"\",\n      \"&sup3;\": \"\",\n      \"&acute\": \"\",\n      \"&acute;\": \"\",\n      \"&micro\": \"\",\n      \"&micro;\": \"\",\n      \"&para\": \"\",\n      \"&para;\": \"\",\n      \"&middot\": \"\",\n      \"&middot;\": \"\",\n      \"&cedil\": \"\",\n      \"&cedil;\": \"\",\n      \"&sup1\": \"\",\n      \"&sup1;\": \"\",\n      \"&ordm\": \"\",\n      \"&ordm;\": \"\",\n      \"&raquo\": \"\",\n      \"&raquo;\": \"\",\n      \"&frac14\": \"\",\n      \"&frac14;\": \"\",\n      \"&frac12\": \"\",\n      \"&frac12;\": \"\",\n      \"&frac34\": \"\",\n      \"&frac34;\": \"\",\n      \"&iquest\": \"\",\n      \"&iquest;\": \"\",\n      \"&Agrave\": \"\",\n      \"&Agrave;\": \"\",\n      \"&Aacute\": \"\",\n      \"&Aacute;\": \"\",\n      \"&Acirc\": \"\",\n      \"&Acirc;\": \"\",\n      \"&Atilde\": \"\",\n      \"&Atilde;\": \"\",\n      \"&Auml\": \"\",\n      \"&Auml;\": \"\",\n      \"&Aring\": \"\",\n      \"&Aring;\": \"\",\n      \"&AElig\": \"\",\n      \"&AElig;\": \"\",\n      \"&Ccedil\": \"\",\n      \"&Ccedil;\": \"\",\n      \"&Egrave\": \"\",\n      \"&Egrave;\": \"\",\n      \"&Eacute\": \"\",\n      \"&Eacute;\": \"\",\n      \"&Ecirc\": \"\",\n      \"&Ecirc;\": \"\",\n      \"&Euml\": \"\",\n      \"&Euml;\": \"\",\n      \"&Igrave\": \"\",\n      \"&Igrave;\": \"\",\n      \"&Iacute\": \"\",\n      \"&Iacute;\": \"\",\n      \"&Icirc\": \"\",\n      \"&Icirc;\": \"\",\n      \"&Iuml\": \"\",\n      \"&Iuml;\": \"\",\n      \"&ETH\": \"\",\n      \"&ETH;\": \"\",\n      \"&Ntilde\": \"\",\n      \"&Ntilde;\": \"\",\n      \"&Ograve\": \"\",\n      \"&Ograve;\": \"\",\n      \"&Oacute\": \"\",\n      \"&Oacute;\": \"\",\n      \"&Ocirc\": \"\",\n      \"&Ocirc;\": \"\",\n      \"&Otilde\": \"\",\n      \"&Otilde;\": \"\",\n      \"&Ouml\": \"\",\n      \"&Ouml;\": \"\",\n      \"&times\": \"\",\n      \"&times;\": \"\",\n      \"&Oslash\": \"\",\n      \"&Oslash;\": \"\",\n      \"&Ugrave\": \"\",\n      \"&Ugrave;\": \"\",\n      \"&Uacute\": \"\",\n      \"&Uacute;\": \"\",\n      \"&Ucirc\": \"\",\n      \"&Ucirc;\": \"\",\n      \"&Uuml\": \"\",\n      \"&Uuml;\": \"\",\n      \"&Yacute\": \"\",\n      \"&Yacute;\": \"\",\n      \"&THORN\": \"\",\n      \"&THORN;\": \"\",\n      \"&szlig\": \"\",\n      \"&szlig;\": \"\",\n      \"&agrave\": \"\",\n      \"&agrave;\": \"\",\n      \"&aacute\": \"\",\n      \"&aacute;\": \"\",\n      \"&acirc\": \"\",\n      \"&acirc;\": \"\",\n      \"&atilde\": \"\",\n      \"&atilde;\": \"\",\n      \"&auml\": \"\",\n      \"&auml;\": \"\",\n      \"&aring\": \"\",\n      \"&aring;\": \"\",\n      \"&aelig\": \"\",\n      \"&aelig;\": \"\",\n      \"&ccedil\": \"\",\n      \"&ccedil;\": \"\",\n      \"&egrave\": \"\",\n      \"&egrave;\": \"\",\n      \"&eacute\": \"\",\n      \"&eacute;\": \"\",\n      \"&ecirc\": \"\",\n      \"&ecirc;\": \"\",\n      \"&euml\": \"\",\n      \"&euml;\": \"\",\n      \"&igrave\": \"\",\n      \"&igrave;\": \"\",\n      \"&iacute\": \"\",\n      \"&iacute;\": \"\",\n      \"&icirc\": \"\",\n      \"&icirc;\": \"\",\n      \"&iuml\": \"\",\n      \"&iuml;\": \"\",\n      \"&eth\": \"\",\n      \"&eth;\": \"\",\n      \"&ntilde\": \"\",\n      \"&ntilde;\": \"\",\n      \"&ograve\": \"\",\n      \"&ograve;\": \"\",\n      \"&oacute\": \"\",\n      \"&oacute;\": \"\",\n      \"&ocirc\": \"\",\n      \"&ocirc;\": \"\",\n      \"&otilde\": \"\",\n      \"&otilde;\": \"\",\n      \"&ouml\": \"\",\n      \"&ouml;\": \"\",\n      \"&divide\": \"\",\n      \"&divide;\": \"\",\n      \"&oslash\": \"\",\n      \"&oslash;\": \"\",\n      \"&ugrave\": \"\",\n      \"&ugrave;\": \"\",\n      \"&uacute\": \"\",\n      \"&uacute;\": \"\",\n      \"&ucirc\": \"\",\n      \"&ucirc;\": \"\",\n      \"&uuml\": \"\",\n      \"&uuml;\": \"\",\n      \"&yacute\": \"\",\n      \"&yacute;\": \"\",\n      \"&thorn\": \"\",\n      \"&thorn;\": \"\",\n      \"&yuml\": \"\",\n      \"&yuml;\": \"\",\n      \"&quot\": '\"',\n      \"&quot;\": '\"',\n      \"&amp\": \"&\",\n      \"&amp;\": \"&\",\n      \"&lt\": \"<\",\n      \"&lt;\": \"<\",\n      \"&gt\": \">\",\n      \"&gt;\": \">\",\n      \"&OElig;\": \"\",\n      \"&oelig;\": \"\",\n      \"&Scaron;\": \"\",\n      \"&scaron;\": \"\",\n      \"&Yuml;\": \"\",\n      \"&circ;\": \"\",\n      \"&tilde;\": \"\",\n      \"&ensp;\": \"\",\n      \"&emsp;\": \"\",\n      \"&thinsp;\": \"\",\n      \"&zwnj;\": \"\",\n      \"&zwj;\": \"\",\n      \"&lrm;\": \"\",\n      \"&rlm;\": \"\",\n      \"&ndash;\": \"\",\n      \"&mdash;\": \"\",\n      \"&lsquo;\": \"\",\n      \"&rsquo;\": \"\",\n      \"&sbquo;\": \"\",\n      \"&ldquo;\": \"\",\n      \"&rdquo;\": \"\",\n      \"&bdquo;\": \"\",\n      \"&dagger;\": \"\",\n      \"&Dagger;\": \"\",\n      \"&permil;\": \"\",\n      \"&lsaquo;\": \"\",\n      \"&rsaquo;\": \"\",\n      \"&euro;\": \"\",\n      \"&fnof;\": \"\",\n      \"&Alpha;\": \"\",\n      \"&Beta;\": \"\",\n      \"&Gamma;\": \"\",\n      \"&Delta;\": \"\",\n      \"&Epsilon;\": \"\",\n      \"&Zeta;\": \"\",\n      \"&Eta;\": \"\",\n      \"&Theta;\": \"\",\n      \"&Iota;\": \"\",\n      \"&Kappa;\": \"\",\n      \"&Lambda;\": \"\",\n      \"&Mu;\": \"\",\n      \"&Nu;\": \"\",\n      \"&Xi;\": \"\",\n      \"&Omicron;\": \"\",\n      \"&Pi;\": \"\",\n      \"&Rho;\": \"\",\n      \"&Sigma;\": \"\",\n      \"&Tau;\": \"\",\n      \"&Upsilon;\": \"\",\n      \"&Phi;\": \"\",\n      \"&Chi;\": \"\",\n      \"&Psi;\": \"\",\n      \"&Omega;\": \"\",\n      \"&alpha;\": \"\",\n      \"&beta;\": \"\",\n      \"&gamma;\": \"\",\n      \"&delta;\": \"\",\n      \"&epsilon;\": \"\",\n      \"&zeta;\": \"\",\n      \"&eta;\": \"\",\n      \"&theta;\": \"\",\n      \"&iota;\": \"\",\n      \"&kappa;\": \"\",\n      \"&lambda;\": \"\",\n      \"&mu;\": \"\",\n      \"&nu;\": \"\",\n      \"&xi;\": \"\",\n      \"&omicron;\": \"\",\n      \"&pi;\": \"\",\n      \"&rho;\": \"\",\n      \"&sigmaf;\": \"\",\n      \"&sigma;\": \"\",\n      \"&tau;\": \"\",\n      \"&upsilon;\": \"\",\n      \"&phi;\": \"\",\n      \"&chi;\": \"\",\n      \"&psi;\": \"\",\n      \"&omega;\": \"\",\n      \"&thetasym;\": \"\",\n      \"&upsih;\": \"\",\n      \"&piv;\": \"\",\n      \"&bull;\": \"\",\n      \"&hellip;\": \"\",\n      \"&prime;\": \"\",\n      \"&Prime;\": \"\",\n      \"&oline;\": \"\",\n      \"&frasl;\": \"\",\n      \"&weierp;\": \"\",\n      \"&image;\": \"\",\n      \"&real;\": \"\",\n      \"&trade;\": \"\",\n      \"&alefsym;\": \"\",\n      \"&larr;\": \"\",\n      \"&uarr;\": \"\",\n      \"&rarr;\": \"\",\n      \"&darr;\": \"\",\n      \"&harr;\": \"\",\n      \"&crarr;\": \"\",\n      \"&lArr;\": \"\",\n      \"&uArr;\": \"\",\n      \"&rArr;\": \"\",\n      \"&dArr;\": \"\",\n      \"&hArr;\": \"\",\n      \"&forall;\": \"\",\n      \"&part;\": \"\",\n      \"&exist;\": \"\",\n      \"&empty;\": \"\",\n      \"&nabla;\": \"\",\n      \"&isin;\": \"\",\n      \"&notin;\": \"\",\n      \"&ni;\": \"\",\n      \"&prod;\": \"\",\n      \"&sum;\": \"\",\n      \"&minus;\": \"\",\n      \"&lowast;\": \"\",\n      \"&radic;\": \"\",\n      \"&prop;\": \"\",\n      \"&infin;\": \"\",\n      \"&ang;\": \"\",\n      \"&and;\": \"\",\n      \"&or;\": \"\",\n      \"&cap;\": \"\",\n      \"&cup;\": \"\",\n      \"&int;\": \"\",\n      \"&there4;\": \"\",\n      \"&sim;\": \"\",\n      \"&cong;\": \"\",\n      \"&asymp;\": \"\",\n      \"&ne;\": \"\",\n      \"&equiv;\": \"\",\n      \"&le;\": \"\",\n      \"&ge;\": \"\",\n      \"&sub;\": \"\",\n      \"&sup;\": \"\",\n      \"&nsub;\": \"\",\n      \"&sube;\": \"\",\n      \"&supe;\": \"\",\n      \"&oplus;\": \"\",\n      \"&otimes;\": \"\",\n      \"&perp;\": \"\",\n      \"&sdot;\": \"\",\n      \"&lceil;\": \"\",\n      \"&rceil;\": \"\",\n      \"&lfloor;\": \"\",\n      \"&rfloor;\": \"\",\n      \"&lang;\": \"\",\n      \"&rang;\": \"\",\n      \"&loz;\": \"\",\n      \"&spades;\": \"\",\n      \"&clubs;\": \"\",\n      \"&hearts;\": \"\",\n      \"&diams;\": \"\"\n    },\n    characters: {\n      \"'\": \"&apos;\",\n      \"\": \"&nbsp;\",\n      \"\": \"&iexcl;\",\n      \"\": \"&cent;\",\n      \"\": \"&pound;\",\n      \"\": \"&curren;\",\n      \"\": \"&yen;\",\n      \"\": \"&brvbar;\",\n      \"\": \"&sect;\",\n      \"\": \"&uml;\",\n      \"\": \"&copy;\",\n      \"\": \"&ordf;\",\n      \"\": \"&laquo;\",\n      \"\": \"&not;\",\n      \"\": \"&shy;\",\n      \"\": \"&reg;\",\n      \"\": \"&macr;\",\n      \"\": \"&deg;\",\n      \"\": \"&plusmn;\",\n      \"\": \"&sup2;\",\n      \"\": \"&sup3;\",\n      \"\": \"&acute;\",\n      \"\": \"&micro;\",\n      \"\": \"&para;\",\n      \"\": \"&middot;\",\n      \"\": \"&cedil;\",\n      \"\": \"&sup1;\",\n      \"\": \"&ordm;\",\n      \"\": \"&raquo;\",\n      \"\": \"&frac14;\",\n      \"\": \"&frac12;\",\n      \"\": \"&frac34;\",\n      \"\": \"&iquest;\",\n      \"\": \"&Agrave;\",\n      \"\": \"&Aacute;\",\n      \"\": \"&Acirc;\",\n      \"\": \"&Atilde;\",\n      \"\": \"&Auml;\",\n      \"\": \"&Aring;\",\n      \"\": \"&AElig;\",\n      \"\": \"&Ccedil;\",\n      \"\": \"&Egrave;\",\n      \"\": \"&Eacute;\",\n      \"\": \"&Ecirc;\",\n      \"\": \"&Euml;\",\n      \"\": \"&Igrave;\",\n      \"\": \"&Iacute;\",\n      \"\": \"&Icirc;\",\n      \"\": \"&Iuml;\",\n      \"\": \"&ETH;\",\n      \"\": \"&Ntilde;\",\n      \"\": \"&Ograve;\",\n      \"\": \"&Oacute;\",\n      \"\": \"&Ocirc;\",\n      \"\": \"&Otilde;\",\n      \"\": \"&Ouml;\",\n      \"\": \"&times;\",\n      \"\": \"&Oslash;\",\n      \"\": \"&Ugrave;\",\n      \"\": \"&Uacute;\",\n      \"\": \"&Ucirc;\",\n      \"\": \"&Uuml;\",\n      \"\": \"&Yacute;\",\n      \"\": \"&THORN;\",\n      \"\": \"&szlig;\",\n      \"\": \"&agrave;\",\n      \"\": \"&aacute;\",\n      \"\": \"&acirc;\",\n      \"\": \"&atilde;\",\n      \"\": \"&auml;\",\n      \"\": \"&aring;\",\n      \"\": \"&aelig;\",\n      \"\": \"&ccedil;\",\n      \"\": \"&egrave;\",\n      \"\": \"&eacute;\",\n      \"\": \"&ecirc;\",\n      \"\": \"&euml;\",\n      \"\": \"&igrave;\",\n      \"\": \"&iacute;\",\n      \"\": \"&icirc;\",\n      \"\": \"&iuml;\",\n      \"\": \"&eth;\",\n      \"\": \"&ntilde;\",\n      \"\": \"&ograve;\",\n      \"\": \"&oacute;\",\n      \"\": \"&ocirc;\",\n      \"\": \"&otilde;\",\n      \"\": \"&ouml;\",\n      \"\": \"&divide;\",\n      \"\": \"&oslash;\",\n      \"\": \"&ugrave;\",\n      \"\": \"&uacute;\",\n      \"\": \"&ucirc;\",\n      \"\": \"&uuml;\",\n      \"\": \"&yacute;\",\n      \"\": \"&thorn;\",\n      \"\": \"&yuml;\",\n      '\"': \"&quot;\",\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"\": \"&OElig;\",\n      \"\": \"&oelig;\",\n      \"\": \"&Scaron;\",\n      \"\": \"&scaron;\",\n      \"\": \"&Yuml;\",\n      \"\": \"&circ;\",\n      \"\": \"&tilde;\",\n      \"\": \"&ensp;\",\n      \"\": \"&emsp;\",\n      \"\": \"&thinsp;\",\n      \"\": \"&zwnj;\",\n      \"\": \"&zwj;\",\n      \"\": \"&lrm;\",\n      \"\": \"&rlm;\",\n      \"\": \"&ndash;\",\n      \"\": \"&mdash;\",\n      \"\": \"&lsquo;\",\n      \"\": \"&rsquo;\",\n      \"\": \"&sbquo;\",\n      \"\": \"&ldquo;\",\n      \"\": \"&rdquo;\",\n      \"\": \"&bdquo;\",\n      \"\": \"&dagger;\",\n      \"\": \"&Dagger;\",\n      \"\": \"&permil;\",\n      \"\": \"&lsaquo;\",\n      \"\": \"&rsaquo;\",\n      \"\": \"&euro;\",\n      \"\": \"&fnof;\",\n      \"\": \"&Alpha;\",\n      \"\": \"&Beta;\",\n      \"\": \"&Gamma;\",\n      \"\": \"&Delta;\",\n      \"\": \"&Epsilon;\",\n      \"\": \"&Zeta;\",\n      \"\": \"&Eta;\",\n      \"\": \"&Theta;\",\n      \"\": \"&Iota;\",\n      \"\": \"&Kappa;\",\n      \"\": \"&Lambda;\",\n      \"\": \"&Mu;\",\n      \"\": \"&Nu;\",\n      \"\": \"&Xi;\",\n      \"\": \"&Omicron;\",\n      \"\": \"&Pi;\",\n      \"\": \"&Rho;\",\n      \"\": \"&Sigma;\",\n      \"\": \"&Tau;\",\n      \"\": \"&Upsilon;\",\n      \"\": \"&Phi;\",\n      \"\": \"&Chi;\",\n      \"\": \"&Psi;\",\n      \"\": \"&Omega;\",\n      \"\": \"&alpha;\",\n      \"\": \"&beta;\",\n      \"\": \"&gamma;\",\n      \"\": \"&delta;\",\n      \"\": \"&epsilon;\",\n      \"\": \"&zeta;\",\n      \"\": \"&eta;\",\n      \"\": \"&theta;\",\n      \"\": \"&iota;\",\n      \"\": \"&kappa;\",\n      \"\": \"&lambda;\",\n      \"\": \"&mu;\",\n      \"\": \"&nu;\",\n      \"\": \"&xi;\",\n      \"\": \"&omicron;\",\n      \"\": \"&pi;\",\n      \"\": \"&rho;\",\n      \"\": \"&sigmaf;\",\n      \"\": \"&sigma;\",\n      \"\": \"&tau;\",\n      \"\": \"&upsilon;\",\n      \"\": \"&phi;\",\n      \"\": \"&chi;\",\n      \"\": \"&psi;\",\n      \"\": \"&omega;\",\n      \"\": \"&thetasym;\",\n      \"\": \"&upsih;\",\n      \"\": \"&piv;\",\n      \"\": \"&bull;\",\n      \"\": \"&hellip;\",\n      \"\": \"&prime;\",\n      \"\": \"&Prime;\",\n      \"\": \"&oline;\",\n      \"\": \"&frasl;\",\n      \"\": \"&weierp;\",\n      \"\": \"&image;\",\n      \"\": \"&real;\",\n      \"\": \"&trade;\",\n      \"\": \"&alefsym;\",\n      \"\": \"&larr;\",\n      \"\": \"&uarr;\",\n      \"\": \"&rarr;\",\n      \"\": \"&darr;\",\n      \"\": \"&harr;\",\n      \"\": \"&crarr;\",\n      \"\": \"&lArr;\",\n      \"\": \"&uArr;\",\n      \"\": \"&rArr;\",\n      \"\": \"&dArr;\",\n      \"\": \"&hArr;\",\n      \"\": \"&forall;\",\n      \"\": \"&part;\",\n      \"\": \"&exist;\",\n      \"\": \"&empty;\",\n      \"\": \"&nabla;\",\n      \"\": \"&isin;\",\n      \"\": \"&notin;\",\n      \"\": \"&ni;\",\n      \"\": \"&prod;\",\n      \"\": \"&sum;\",\n      \"\": \"&minus;\",\n      \"\": \"&lowast;\",\n      \"\": \"&radic;\",\n      \"\": \"&prop;\",\n      \"\": \"&infin;\",\n      \"\": \"&ang;\",\n      \"\": \"&and;\",\n      \"\": \"&or;\",\n      \"\": \"&cap;\",\n      \"\": \"&cup;\",\n      \"\": \"&int;\",\n      \"\": \"&there4;\",\n      \"\": \"&sim;\",\n      \"\": \"&cong;\",\n      \"\": \"&asymp;\",\n      \"\": \"&ne;\",\n      \"\": \"&equiv;\",\n      \"\": \"&le;\",\n      \"\": \"&ge;\",\n      \"\": \"&sub;\",\n      \"\": \"&sup;\",\n      \"\": \"&nsub;\",\n      \"\": \"&sube;\",\n      \"\": \"&supe;\",\n      \"\": \"&oplus;\",\n      \"\": \"&otimes;\",\n      \"\": \"&perp;\",\n      \"\": \"&sdot;\",\n      \"\": \"&lceil;\",\n      \"\": \"&rceil;\",\n      \"\": \"&lfloor;\",\n      \"\": \"&rfloor;\",\n      \"\": \"&lang;\",\n      \"\": \"&rang;\",\n      \"\": \"&loz;\",\n      \"\": \"&spades;\",\n      \"\": \"&clubs;\",\n      \"\": \"&hearts;\",\n      \"\": \"&diams;\"\n    }\n  },\n  html5: {\n    entities: {\n      \"&AElig\": \"\",\n      \"&AElig;\": \"\",\n      \"&AMP\": \"&\",\n      \"&AMP;\": \"&\",\n      \"&Aacute\": \"\",\n      \"&Aacute;\": \"\",\n      \"&Abreve;\": \"\",\n      \"&Acirc\": \"\",\n      \"&Acirc;\": \"\",\n      \"&Acy;\": \"\",\n      \"&Afr;\": \"\",\n      \"&Agrave\": \"\",\n      \"&Agrave;\": \"\",\n      \"&Alpha;\": \"\",\n      \"&Amacr;\": \"\",\n      \"&And;\": \"\",\n      \"&Aogon;\": \"\",\n      \"&Aopf;\": \"\",\n      \"&ApplyFunction;\": \"\",\n      \"&Aring\": \"\",\n      \"&Aring;\": \"\",\n      \"&Ascr;\": \"\",\n      \"&Assign;\": \"\",\n      \"&Atilde\": \"\",\n      \"&Atilde;\": \"\",\n      \"&Auml\": \"\",\n      \"&Auml;\": \"\",\n      \"&Backslash;\": \"\",\n      \"&Barv;\": \"\",\n      \"&Barwed;\": \"\",\n      \"&Bcy;\": \"\",\n      \"&Because;\": \"\",\n      \"&Bernoullis;\": \"\",\n      \"&Beta;\": \"\",\n      \"&Bfr;\": \"\",\n      \"&Bopf;\": \"\",\n      \"&Breve;\": \"\",\n      \"&Bscr;\": \"\",\n      \"&Bumpeq;\": \"\",\n      \"&CHcy;\": \"\",\n      \"&COPY\": \"\",\n      \"&COPY;\": \"\",\n      \"&Cacute;\": \"\",\n      \"&Cap;\": \"\",\n      \"&CapitalDifferentialD;\": \"\",\n      \"&Cayleys;\": \"\",\n      \"&Ccaron;\": \"\",\n      \"&Ccedil\": \"\",\n      \"&Ccedil;\": \"\",\n      \"&Ccirc;\": \"\",\n      \"&Cconint;\": \"\",\n      \"&Cdot;\": \"\",\n      \"&Cedilla;\": \"\",\n      \"&CenterDot;\": \"\",\n      \"&Cfr;\": \"\",\n      \"&Chi;\": \"\",\n      \"&CircleDot;\": \"\",\n      \"&CircleMinus;\": \"\",\n      \"&CirclePlus;\": \"\",\n      \"&CircleTimes;\": \"\",\n      \"&ClockwiseContourIntegral;\": \"\",\n      \"&CloseCurlyDoubleQuote;\": \"\",\n      \"&CloseCurlyQuote;\": \"\",\n      \"&Colon;\": \"\",\n      \"&Colone;\": \"\",\n      \"&Congruent;\": \"\",\n      \"&Conint;\": \"\",\n      \"&ContourIntegral;\": \"\",\n      \"&Copf;\": \"\",\n      \"&Coproduct;\": \"\",\n      \"&CounterClockwiseContourIntegral;\": \"\",\n      \"&Cross;\": \"\",\n      \"&Cscr;\": \"\",\n      \"&Cup;\": \"\",\n      \"&CupCap;\": \"\",\n      \"&DD;\": \"\",\n      \"&DDotrahd;\": \"\",\n      \"&DJcy;\": \"\",\n      \"&DScy;\": \"\",\n      \"&DZcy;\": \"\",\n      \"&Dagger;\": \"\",\n      \"&Darr;\": \"\",\n      \"&Dashv;\": \"\",\n      \"&Dcaron;\": \"\",\n      \"&Dcy;\": \"\",\n      \"&Del;\": \"\",\n      \"&Delta;\": \"\",\n      \"&Dfr;\": \"\",\n      \"&DiacriticalAcute;\": \"\",\n      \"&DiacriticalDot;\": \"\",\n      \"&DiacriticalDoubleAcute;\": \"\",\n      \"&DiacriticalGrave;\": \"`\",\n      \"&DiacriticalTilde;\": \"\",\n      \"&Diamond;\": \"\",\n      \"&DifferentialD;\": \"\",\n      \"&Dopf;\": \"\",\n      \"&Dot;\": \"\",\n      \"&DotDot;\": \"\",\n      \"&DotEqual;\": \"\",\n      \"&DoubleContourIntegral;\": \"\",\n      \"&DoubleDot;\": \"\",\n      \"&DoubleDownArrow;\": \"\",\n      \"&DoubleLeftArrow;\": \"\",\n      \"&DoubleLeftRightArrow;\": \"\",\n      \"&DoubleLeftTee;\": \"\",\n      \"&DoubleLongLeftArrow;\": \"\",\n      \"&DoubleLongLeftRightArrow;\": \"\",\n      \"&DoubleLongRightArrow;\": \"\",\n      \"&DoubleRightArrow;\": \"\",\n      \"&DoubleRightTee;\": \"\",\n      \"&DoubleUpArrow;\": \"\",\n      \"&DoubleUpDownArrow;\": \"\",\n      \"&DoubleVerticalBar;\": \"\",\n      \"&DownArrow;\": \"\",\n      \"&DownArrowBar;\": \"\",\n      \"&DownArrowUpArrow;\": \"\",\n      \"&DownBreve;\": \"\",\n      \"&DownLeftRightVector;\": \"\",\n      \"&DownLeftTeeVector;\": \"\",\n      \"&DownLeftVector;\": \"\",\n      \"&DownLeftVectorBar;\": \"\",\n      \"&DownRightTeeVector;\": \"\",\n      \"&DownRightVector;\": \"\",\n      \"&DownRightVectorBar;\": \"\",\n      \"&DownTee;\": \"\",\n      \"&DownTeeArrow;\": \"\",\n      \"&Downarrow;\": \"\",\n      \"&Dscr;\": \"\",\n      \"&Dstrok;\": \"\",\n      \"&ENG;\": \"\",\n      \"&ETH\": \"\",\n      \"&ETH;\": \"\",\n      \"&Eacute\": \"\",\n      \"&Eacute;\": \"\",\n      \"&Ecaron;\": \"\",\n      \"&Ecirc\": \"\",\n      \"&Ecirc;\": \"\",\n      \"&Ecy;\": \"\",\n      \"&Edot;\": \"\",\n      \"&Efr;\": \"\",\n      \"&Egrave\": \"\",\n      \"&Egrave;\": \"\",\n      \"&Element;\": \"\",\n      \"&Emacr;\": \"\",\n      \"&EmptySmallSquare;\": \"\",\n      \"&EmptyVerySmallSquare;\": \"\",\n      \"&Eogon;\": \"\",\n      \"&Eopf;\": \"\",\n      \"&Epsilon;\": \"\",\n      \"&Equal;\": \"\",\n      \"&EqualTilde;\": \"\",\n      \"&Equilibrium;\": \"\",\n      \"&Escr;\": \"\",\n      \"&Esim;\": \"\",\n      \"&Eta;\": \"\",\n      \"&Euml\": \"\",\n      \"&Euml;\": \"\",\n      \"&Exists;\": \"\",\n      \"&ExponentialE;\": \"\",\n      \"&Fcy;\": \"\",\n      \"&Ffr;\": \"\",\n      \"&FilledSmallSquare;\": \"\",\n      \"&FilledVerySmallSquare;\": \"\",\n      \"&Fopf;\": \"\",\n      \"&ForAll;\": \"\",\n      \"&Fouriertrf;\": \"\",\n      \"&Fscr;\": \"\",\n      \"&GJcy;\": \"\",\n      \"&GT\": \">\",\n      \"&GT;\": \">\",\n      \"&Gamma;\": \"\",\n      \"&Gammad;\": \"\",\n      \"&Gbreve;\": \"\",\n      \"&Gcedil;\": \"\",\n      \"&Gcirc;\": \"\",\n      \"&Gcy;\": \"\",\n      \"&Gdot;\": \"\",\n      \"&Gfr;\": \"\",\n      \"&Gg;\": \"\",\n      \"&Gopf;\": \"\",\n      \"&GreaterEqual;\": \"\",\n      \"&GreaterEqualLess;\": \"\",\n      \"&GreaterFullEqual;\": \"\",\n      \"&GreaterGreater;\": \"\",\n      \"&GreaterLess;\": \"\",\n      \"&GreaterSlantEqual;\": \"\",\n      \"&GreaterTilde;\": \"\",\n      \"&Gscr;\": \"\",\n      \"&Gt;\": \"\",\n      \"&HARDcy;\": \"\",\n      \"&Hacek;\": \"\",\n      \"&Hat;\": \"^\",\n      \"&Hcirc;\": \"\",\n      \"&Hfr;\": \"\",\n      \"&HilbertSpace;\": \"\",\n      \"&Hopf;\": \"\",\n      \"&HorizontalLine;\": \"\",\n      \"&Hscr;\": \"\",\n      \"&Hstrok;\": \"\",\n      \"&HumpDownHump;\": \"\",\n      \"&HumpEqual;\": \"\",\n      \"&IEcy;\": \"\",\n      \"&IJlig;\": \"\",\n      \"&IOcy;\": \"\",\n      \"&Iacute\": \"\",\n      \"&Iacute;\": \"\",\n      \"&Icirc\": \"\",\n      \"&Icirc;\": \"\",\n      \"&Icy;\": \"\",\n      \"&Idot;\": \"\",\n      \"&Ifr;\": \"\",\n      \"&Igrave\": \"\",\n      \"&Igrave;\": \"\",\n      \"&Im;\": \"\",\n      \"&Imacr;\": \"\",\n      \"&ImaginaryI;\": \"\",\n      \"&Implies;\": \"\",\n      \"&Int;\": \"\",\n      \"&Integral;\": \"\",\n      \"&Intersection;\": \"\",\n      \"&InvisibleComma;\": \"\",\n      \"&InvisibleTimes;\": \"\",\n      \"&Iogon;\": \"\",\n      \"&Iopf;\": \"\",\n      \"&Iota;\": \"\",\n      \"&Iscr;\": \"\",\n      \"&Itilde;\": \"\",\n      \"&Iukcy;\": \"\",\n      \"&Iuml\": \"\",\n      \"&Iuml;\": \"\",\n      \"&Jcirc;\": \"\",\n      \"&Jcy;\": \"\",\n      \"&Jfr;\": \"\",\n      \"&Jopf;\": \"\",\n      \"&Jscr;\": \"\",\n      \"&Jsercy;\": \"\",\n      \"&Jukcy;\": \"\",\n      \"&KHcy;\": \"\",\n      \"&KJcy;\": \"\",\n      \"&Kappa;\": \"\",\n      \"&Kcedil;\": \"\",\n      \"&Kcy;\": \"\",\n      \"&Kfr;\": \"\",\n      \"&Kopf;\": \"\",\n      \"&Kscr;\": \"\",\n      \"&LJcy;\": \"\",\n      \"&LT\": \"<\",\n      \"&LT;\": \"<\",\n      \"&Lacute;\": \"\",\n      \"&Lambda;\": \"\",\n      \"&Lang;\": \"\",\n      \"&Laplacetrf;\": \"\",\n      \"&Larr;\": \"\",\n      \"&Lcaron;\": \"\",\n      \"&Lcedil;\": \"\",\n      \"&Lcy;\": \"\",\n      \"&LeftAngleBracket;\": \"\",\n      \"&LeftArrow;\": \"\",\n      \"&LeftArrowBar;\": \"\",\n      \"&LeftArrowRightArrow;\": \"\",\n      \"&LeftCeiling;\": \"\",\n      \"&LeftDoubleBracket;\": \"\",\n      \"&LeftDownTeeVector;\": \"\",\n      \"&LeftDownVector;\": \"\",\n      \"&LeftDownVectorBar;\": \"\",\n      \"&LeftFloor;\": \"\",\n      \"&LeftRightArrow;\": \"\",\n      \"&LeftRightVector;\": \"\",\n      \"&LeftTee;\": \"\",\n      \"&LeftTeeArrow;\": \"\",\n      \"&LeftTeeVector;\": \"\",\n      \"&LeftTriangle;\": \"\",\n      \"&LeftTriangleBar;\": \"\",\n      \"&LeftTriangleEqual;\": \"\",\n      \"&LeftUpDownVector;\": \"\",\n      \"&LeftUpTeeVector;\": \"\",\n      \"&LeftUpVector;\": \"\",\n      \"&LeftUpVectorBar;\": \"\",\n      \"&LeftVector;\": \"\",\n      \"&LeftVectorBar;\": \"\",\n      \"&Leftarrow;\": \"\",\n      \"&Leftrightarrow;\": \"\",\n      \"&LessEqualGreater;\": \"\",\n      \"&LessFullEqual;\": \"\",\n      \"&LessGreater;\": \"\",\n      \"&LessLess;\": \"\",\n      \"&LessSlantEqual;\": \"\",\n      \"&LessTilde;\": \"\",\n      \"&Lfr;\": \"\",\n      \"&Ll;\": \"\",\n      \"&Lleftarrow;\": \"\",\n      \"&Lmidot;\": \"\",\n      \"&LongLeftArrow;\": \"\",\n      \"&LongLeftRightArrow;\": \"\",\n      \"&LongRightArrow;\": \"\",\n      \"&Longleftarrow;\": \"\",\n      \"&Longleftrightarrow;\": \"\",\n      \"&Longrightarrow;\": \"\",\n      \"&Lopf;\": \"\",\n      \"&LowerLeftArrow;\": \"\",\n      \"&LowerRightArrow;\": \"\",\n      \"&Lscr;\": \"\",\n      \"&Lsh;\": \"\",\n      \"&Lstrok;\": \"\",\n      \"&Lt;\": \"\",\n      \"&Map;\": \"\",\n      \"&Mcy;\": \"\",\n      \"&MediumSpace;\": \"\",\n      \"&Mellintrf;\": \"\",\n      \"&Mfr;\": \"\",\n      \"&MinusPlus;\": \"\",\n      \"&Mopf;\": \"\",\n      \"&Mscr;\": \"\",\n      \"&Mu;\": \"\",\n      \"&NJcy;\": \"\",\n      \"&Nacute;\": \"\",\n      \"&Ncaron;\": \"\",\n      \"&Ncedil;\": \"\",\n      \"&Ncy;\": \"\",\n      \"&NegativeMediumSpace;\": \"\",\n      \"&NegativeThickSpace;\": \"\",\n      \"&NegativeThinSpace;\": \"\",\n      \"&NegativeVeryThinSpace;\": \"\",\n      \"&NestedGreaterGreater;\": \"\",\n      \"&NestedLessLess;\": \"\",\n      \"&NewLine;\": \"\\n\",\n      \"&Nfr;\": \"\",\n      \"&NoBreak;\": \"\",\n      \"&NonBreakingSpace;\": \"\",\n      \"&Nopf;\": \"\",\n      \"&Not;\": \"\",\n      \"&NotCongruent;\": \"\",\n      \"&NotCupCap;\": \"\",\n      \"&NotDoubleVerticalBar;\": \"\",\n      \"&NotElement;\": \"\",\n      \"&NotEqual;\": \"\",\n      \"&NotEqualTilde;\": \"\",\n      \"&NotExists;\": \"\",\n      \"&NotGreater;\": \"\",\n      \"&NotGreaterEqual;\": \"\",\n      \"&NotGreaterFullEqual;\": \"\",\n      \"&NotGreaterGreater;\": \"\",\n      \"&NotGreaterLess;\": \"\",\n      \"&NotGreaterSlantEqual;\": \"\",\n      \"&NotGreaterTilde;\": \"\",\n      \"&NotHumpDownHump;\": \"\",\n      \"&NotHumpEqual;\": \"\",\n      \"&NotLeftTriangle;\": \"\",\n      \"&NotLeftTriangleBar;\": \"\",\n      \"&NotLeftTriangleEqual;\": \"\",\n      \"&NotLess;\": \"\",\n      \"&NotLessEqual;\": \"\",\n      \"&NotLessGreater;\": \"\",\n      \"&NotLessLess;\": \"\",\n      \"&NotLessSlantEqual;\": \"\",\n      \"&NotLessTilde;\": \"\",\n      \"&NotNestedGreaterGreater;\": \"\",\n      \"&NotNestedLessLess;\": \"\",\n      \"&NotPrecedes;\": \"\",\n      \"&NotPrecedesEqual;\": \"\",\n      \"&NotPrecedesSlantEqual;\": \"\",\n      \"&NotReverseElement;\": \"\",\n      \"&NotRightTriangle;\": \"\",\n      \"&NotRightTriangleBar;\": \"\",\n      \"&NotRightTriangleEqual;\": \"\",\n      \"&NotSquareSubset;\": \"\",\n      \"&NotSquareSubsetEqual;\": \"\",\n      \"&NotSquareSuperset;\": \"\",\n      \"&NotSquareSupersetEqual;\": \"\",\n      \"&NotSubset;\": \"\",\n      \"&NotSubsetEqual;\": \"\",\n      \"&NotSucceeds;\": \"\",\n      \"&NotSucceedsEqual;\": \"\",\n      \"&NotSucceedsSlantEqual;\": \"\",\n      \"&NotSucceedsTilde;\": \"\",\n      \"&NotSuperset;\": \"\",\n      \"&NotSupersetEqual;\": \"\",\n      \"&NotTilde;\": \"\",\n      \"&NotTildeEqual;\": \"\",\n      \"&NotTildeFullEqual;\": \"\",\n      \"&NotTildeTilde;\": \"\",\n      \"&NotVerticalBar;\": \"\",\n      \"&Nscr;\": \"\",\n      \"&Ntilde\": \"\",\n      \"&Ntilde;\": \"\",\n      \"&Nu;\": \"\",\n      \"&OElig;\": \"\",\n      \"&Oacute\": \"\",\n      \"&Oacute;\": \"\",\n      \"&Ocirc\": \"\",\n      \"&Ocirc;\": \"\",\n      \"&Ocy;\": \"\",\n      \"&Odblac;\": \"\",\n      \"&Ofr;\": \"\",\n      \"&Ograve\": \"\",\n      \"&Ograve;\": \"\",\n      \"&Omacr;\": \"\",\n      \"&Omega;\": \"\",\n      \"&Omicron;\": \"\",\n      \"&Oopf;\": \"\",\n      \"&OpenCurlyDoubleQuote;\": \"\",\n      \"&OpenCurlyQuote;\": \"\",\n      \"&Or;\": \"\",\n      \"&Oscr;\": \"\",\n      \"&Oslash\": \"\",\n      \"&Oslash;\": \"\",\n      \"&Otilde\": \"\",\n      \"&Otilde;\": \"\",\n      \"&Otimes;\": \"\",\n      \"&Ouml\": \"\",\n      \"&Ouml;\": \"\",\n      \"&OverBar;\": \"\",\n      \"&OverBrace;\": \"\",\n      \"&OverBracket;\": \"\",\n      \"&OverParenthesis;\": \"\",\n      \"&PartialD;\": \"\",\n      \"&Pcy;\": \"\",\n      \"&Pfr;\": \"\",\n      \"&Phi;\": \"\",\n      \"&Pi;\": \"\",\n      \"&PlusMinus;\": \"\",\n      \"&Poincareplane;\": \"\",\n      \"&Popf;\": \"\",\n      \"&Pr;\": \"\",\n      \"&Precedes;\": \"\",\n      \"&PrecedesEqual;\": \"\",\n      \"&PrecedesSlantEqual;\": \"\",\n      \"&PrecedesTilde;\": \"\",\n      \"&Prime;\": \"\",\n      \"&Product;\": \"\",\n      \"&Proportion;\": \"\",\n      \"&Proportional;\": \"\",\n      \"&Pscr;\": \"\",\n      \"&Psi;\": \"\",\n      \"&QUOT\": '\"',\n      \"&QUOT;\": '\"',\n      \"&Qfr;\": \"\",\n      \"&Qopf;\": \"\",\n      \"&Qscr;\": \"\",\n      \"&RBarr;\": \"\",\n      \"&REG\": \"\",\n      \"&REG;\": \"\",\n      \"&Racute;\": \"\",\n      \"&Rang;\": \"\",\n      \"&Rarr;\": \"\",\n      \"&Rarrtl;\": \"\",\n      \"&Rcaron;\": \"\",\n      \"&Rcedil;\": \"\",\n      \"&Rcy;\": \"\",\n      \"&Re;\": \"\",\n      \"&ReverseElement;\": \"\",\n      \"&ReverseEquilibrium;\": \"\",\n      \"&ReverseUpEquilibrium;\": \"\",\n      \"&Rfr;\": \"\",\n      \"&Rho;\": \"\",\n      \"&RightAngleBracket;\": \"\",\n      \"&RightArrow;\": \"\",\n      \"&RightArrowBar;\": \"\",\n      \"&RightArrowLeftArrow;\": \"\",\n      \"&RightCeiling;\": \"\",\n      \"&RightDoubleBracket;\": \"\",\n      \"&RightDownTeeVector;\": \"\",\n      \"&RightDownVector;\": \"\",\n      \"&RightDownVectorBar;\": \"\",\n      \"&RightFloor;\": \"\",\n      \"&RightTee;\": \"\",\n      \"&RightTeeArrow;\": \"\",\n      \"&RightTeeVector;\": \"\",\n      \"&RightTriangle;\": \"\",\n      \"&RightTriangleBar;\": \"\",\n      \"&RightTriangleEqual;\": \"\",\n      \"&RightUpDownVector;\": \"\",\n      \"&RightUpTeeVector;\": \"\",\n      \"&RightUpVector;\": \"\",\n      \"&RightUpVectorBar;\": \"\",\n      \"&RightVector;\": \"\",\n      \"&RightVectorBar;\": \"\",\n      \"&Rightarrow;\": \"\",\n      \"&Ropf;\": \"\",\n      \"&RoundImplies;\": \"\",\n      \"&Rrightarrow;\": \"\",\n      \"&Rscr;\": \"\",\n      \"&Rsh;\": \"\",\n      \"&RuleDelayed;\": \"\",\n      \"&SHCHcy;\": \"\",\n      \"&SHcy;\": \"\",\n      \"&SOFTcy;\": \"\",\n      \"&Sacute;\": \"\",\n      \"&Sc;\": \"\",\n      \"&Scaron;\": \"\",\n      \"&Scedil;\": \"\",\n      \"&Scirc;\": \"\",\n      \"&Scy;\": \"\",\n      \"&Sfr;\": \"\",\n      \"&ShortDownArrow;\": \"\",\n      \"&ShortLeftArrow;\": \"\",\n      \"&ShortRightArrow;\": \"\",\n      \"&ShortUpArrow;\": \"\",\n      \"&Sigma;\": \"\",\n      \"&SmallCircle;\": \"\",\n      \"&Sopf;\": \"\",\n      \"&Sqrt;\": \"\",\n      \"&Square;\": \"\",\n      \"&SquareIntersection;\": \"\",\n      \"&SquareSubset;\": \"\",\n      \"&SquareSubsetEqual;\": \"\",\n      \"&SquareSuperset;\": \"\",\n      \"&SquareSupersetEqual;\": \"\",\n      \"&SquareUnion;\": \"\",\n      \"&Sscr;\": \"\",\n      \"&Star;\": \"\",\n      \"&Sub;\": \"\",\n      \"&Subset;\": \"\",\n      \"&SubsetEqual;\": \"\",\n      \"&Succeeds;\": \"\",\n      \"&SucceedsEqual;\": \"\",\n      \"&SucceedsSlantEqual;\": \"\",\n      \"&SucceedsTilde;\": \"\",\n      \"&SuchThat;\": \"\",\n      \"&Sum;\": \"\",\n      \"&Sup;\": \"\",\n      \"&Superset;\": \"\",\n      \"&SupersetEqual;\": \"\",\n      \"&Supset;\": \"\",\n      \"&THORN\": \"\",\n      \"&THORN;\": \"\",\n      \"&TRADE;\": \"\",\n      \"&TSHcy;\": \"\",\n      \"&TScy;\": \"\",\n      \"&Tab;\": \"\\t\",\n      \"&Tau;\": \"\",\n      \"&Tcaron;\": \"\",\n      \"&Tcedil;\": \"\",\n      \"&Tcy;\": \"\",\n      \"&Tfr;\": \"\",\n      \"&Therefore;\": \"\",\n      \"&Theta;\": \"\",\n      \"&ThickSpace;\": \"\",\n      \"&ThinSpace;\": \"\",\n      \"&Tilde;\": \"\",\n      \"&TildeEqual;\": \"\",\n      \"&TildeFullEqual;\": \"\",\n      \"&TildeTilde;\": \"\",\n      \"&Topf;\": \"\",\n      \"&TripleDot;\": \"\",\n      \"&Tscr;\": \"\",\n      \"&Tstrok;\": \"\",\n      \"&Uacute\": \"\",\n      \"&Uacute;\": \"\",\n      \"&Uarr;\": \"\",\n      \"&Uarrocir;\": \"\",\n      \"&Ubrcy;\": \"\",\n      \"&Ubreve;\": \"\",\n      \"&Ucirc\": \"\",\n      \"&Ucirc;\": \"\",\n      \"&Ucy;\": \"\",\n      \"&Udblac;\": \"\",\n      \"&Ufr;\": \"\",\n      \"&Ugrave\": \"\",\n      \"&Ugrave;\": \"\",\n      \"&Umacr;\": \"\",\n      \"&UnderBar;\": \"_\",\n      \"&UnderBrace;\": \"\",\n      \"&UnderBracket;\": \"\",\n      \"&UnderParenthesis;\": \"\",\n      \"&Union;\": \"\",\n      \"&UnionPlus;\": \"\",\n      \"&Uogon;\": \"\",\n      \"&Uopf;\": \"\",\n      \"&UpArrow;\": \"\",\n      \"&UpArrowBar;\": \"\",\n      \"&UpArrowDownArrow;\": \"\",\n      \"&UpDownArrow;\": \"\",\n      \"&UpEquilibrium;\": \"\",\n      \"&UpTee;\": \"\",\n      \"&UpTeeArrow;\": \"\",\n      \"&Uparrow;\": \"\",\n      \"&Updownarrow;\": \"\",\n      \"&UpperLeftArrow;\": \"\",\n      \"&UpperRightArrow;\": \"\",\n      \"&Upsi;\": \"\",\n      \"&Upsilon;\": \"\",\n      \"&Uring;\": \"\",\n      \"&Uscr;\": \"\",\n      \"&Utilde;\": \"\",\n      \"&Uuml\": \"\",\n      \"&Uuml;\": \"\",\n      \"&VDash;\": \"\",\n      \"&Vbar;\": \"\",\n      \"&Vcy;\": \"\",\n      \"&Vdash;\": \"\",\n      \"&Vdashl;\": \"\",\n      \"&Vee;\": \"\",\n      \"&Verbar;\": \"\",\n      \"&Vert;\": \"\",\n      \"&VerticalBar;\": \"\",\n      \"&VerticalLine;\": \"|\",\n      \"&VerticalSeparator;\": \"\",\n      \"&VerticalTilde;\": \"\",\n      \"&VeryThinSpace;\": \"\",\n      \"&Vfr;\": \"\",\n      \"&Vopf;\": \"\",\n      \"&Vscr;\": \"\",\n      \"&Vvdash;\": \"\",\n      \"&Wcirc;\": \"\",\n      \"&Wedge;\": \"\",\n      \"&Wfr;\": \"\",\n      \"&Wopf;\": \"\",\n      \"&Wscr;\": \"\",\n      \"&Xfr;\": \"\",\n      \"&Xi;\": \"\",\n      \"&Xopf;\": \"\",\n      \"&Xscr;\": \"\",\n      \"&YAcy;\": \"\",\n      \"&YIcy;\": \"\",\n      \"&YUcy;\": \"\",\n      \"&Yacute\": \"\",\n      \"&Yacute;\": \"\",\n      \"&Ycirc;\": \"\",\n      \"&Ycy;\": \"\",\n      \"&Yfr;\": \"\",\n      \"&Yopf;\": \"\",\n      \"&Yscr;\": \"\",\n      \"&Yuml;\": \"\",\n      \"&ZHcy;\": \"\",\n      \"&Zacute;\": \"\",\n      \"&Zcaron;\": \"\",\n      \"&Zcy;\": \"\",\n      \"&Zdot;\": \"\",\n      \"&ZeroWidthSpace;\": \"\",\n      \"&Zeta;\": \"\",\n      \"&Zfr;\": \"\",\n      \"&Zopf;\": \"\",\n      \"&Zscr;\": \"\",\n      \"&aacute\": \"\",\n      \"&aacute;\": \"\",\n      \"&abreve;\": \"\",\n      \"&ac;\": \"\",\n      \"&acE;\": \"\",\n      \"&acd;\": \"\",\n      \"&acirc\": \"\",\n      \"&acirc;\": \"\",\n      \"&acute\": \"\",\n      \"&acute;\": \"\",\n      \"&acy;\": \"\",\n      \"&aelig\": \"\",\n      \"&aelig;\": \"\",\n      \"&af;\": \"\",\n      \"&afr;\": \"\",\n      \"&agrave\": \"\",\n      \"&agrave;\": \"\",\n      \"&alefsym;\": \"\",\n      \"&aleph;\": \"\",\n      \"&alpha;\": \"\",\n      \"&amacr;\": \"\",\n      \"&amalg;\": \"\",\n      \"&amp\": \"&\",\n      \"&amp;\": \"&\",\n      \"&and;\": \"\",\n      \"&andand;\": \"\",\n      \"&andd;\": \"\",\n      \"&andslope;\": \"\",\n      \"&andv;\": \"\",\n      \"&ang;\": \"\",\n      \"&ange;\": \"\",\n      \"&angle;\": \"\",\n      \"&angmsd;\": \"\",\n      \"&angmsdaa;\": \"\",\n      \"&angmsdab;\": \"\",\n      \"&angmsdac;\": \"\",\n      \"&angmsdad;\": \"\",\n      \"&angmsdae;\": \"\",\n      \"&angmsdaf;\": \"\",\n      \"&angmsdag;\": \"\",\n      \"&angmsdah;\": \"\",\n      \"&angrt;\": \"\",\n      \"&angrtvb;\": \"\",\n      \"&angrtvbd;\": \"\",\n      \"&angsph;\": \"\",\n      \"&angst;\": \"\",\n      \"&angzarr;\": \"\",\n      \"&aogon;\": \"\",\n      \"&aopf;\": \"\",\n      \"&ap;\": \"\",\n      \"&apE;\": \"\",\n      \"&apacir;\": \"\",\n      \"&ape;\": \"\",\n      \"&apid;\": \"\",\n      \"&apos;\": \"'\",\n      \"&approx;\": \"\",\n      \"&approxeq;\": \"\",\n      \"&aring\": \"\",\n      \"&aring;\": \"\",\n      \"&ascr;\": \"\",\n      \"&ast;\": \"*\",\n      \"&asymp;\": \"\",\n      \"&asympeq;\": \"\",\n      \"&atilde\": \"\",\n      \"&atilde;\": \"\",\n      \"&auml\": \"\",\n      \"&auml;\": \"\",\n      \"&awconint;\": \"\",\n      \"&awint;\": \"\",\n      \"&bNot;\": \"\",\n      \"&backcong;\": \"\",\n      \"&backepsilon;\": \"\",\n      \"&backprime;\": \"\",\n      \"&backsim;\": \"\",\n      \"&backsimeq;\": \"\",\n      \"&barvee;\": \"\",\n      \"&barwed;\": \"\",\n      \"&barwedge;\": \"\",\n      \"&bbrk;\": \"\",\n      \"&bbrktbrk;\": \"\",\n      \"&bcong;\": \"\",\n      \"&bcy;\": \"\",\n      \"&bdquo;\": \"\",\n      \"&becaus;\": \"\",\n      \"&because;\": \"\",\n      \"&bemptyv;\": \"\",\n      \"&bepsi;\": \"\",\n      \"&bernou;\": \"\",\n      \"&beta;\": \"\",\n      \"&beth;\": \"\",\n      \"&between;\": \"\",\n      \"&bfr;\": \"\",\n      \"&bigcap;\": \"\",\n      \"&bigcirc;\": \"\",\n      \"&bigcup;\": \"\",\n      \"&bigodot;\": \"\",\n      \"&bigoplus;\": \"\",\n      \"&bigotimes;\": \"\",\n      \"&bigsqcup;\": \"\",\n      \"&bigstar;\": \"\",\n      \"&bigtriangledown;\": \"\",\n      \"&bigtriangleup;\": \"\",\n      \"&biguplus;\": \"\",\n      \"&bigvee;\": \"\",\n      \"&bigwedge;\": \"\",\n      \"&bkarow;\": \"\",\n      \"&blacklozenge;\": \"\",\n      \"&blacksquare;\": \"\",\n      \"&blacktriangle;\": \"\",\n      \"&blacktriangledown;\": \"\",\n      \"&blacktriangleleft;\": \"\",\n      \"&blacktriangleright;\": \"\",\n      \"&blank;\": \"\",\n      \"&blk12;\": \"\",\n      \"&blk14;\": \"\",\n      \"&blk34;\": \"\",\n      \"&block;\": \"\",\n      \"&bne;\": \"=\",\n      \"&bnequiv;\": \"\",\n      \"&bnot;\": \"\",\n      \"&bopf;\": \"\",\n      \"&bot;\": \"\",\n      \"&bottom;\": \"\",\n      \"&bowtie;\": \"\",\n      \"&boxDL;\": \"\",\n      \"&boxDR;\": \"\",\n      \"&boxDl;\": \"\",\n      \"&boxDr;\": \"\",\n      \"&boxH;\": \"\",\n      \"&boxHD;\": \"\",\n      \"&boxHU;\": \"\",\n      \"&boxHd;\": \"\",\n      \"&boxHu;\": \"\",\n      \"&boxUL;\": \"\",\n      \"&boxUR;\": \"\",\n      \"&boxUl;\": \"\",\n      \"&boxUr;\": \"\",\n      \"&boxV;\": \"\",\n      \"&boxVH;\": \"\",\n      \"&boxVL;\": \"\",\n      \"&boxVR;\": \"\",\n      \"&boxVh;\": \"\",\n      \"&boxVl;\": \"\",\n      \"&boxVr;\": \"\",\n      \"&boxbox;\": \"\",\n      \"&boxdL;\": \"\",\n      \"&boxdR;\": \"\",\n      \"&boxdl;\": \"\",\n      \"&boxdr;\": \"\",\n      \"&boxh;\": \"\",\n      \"&boxhD;\": \"\",\n      \"&boxhU;\": \"\",\n      \"&boxhd;\": \"\",\n      \"&boxhu;\": \"\",\n      \"&boxminus;\": \"\",\n      \"&boxplus;\": \"\",\n      \"&boxtimes;\": \"\",\n      \"&boxuL;\": \"\",\n      \"&boxuR;\": \"\",\n      \"&boxul;\": \"\",\n      \"&boxur;\": \"\",\n      \"&boxv;\": \"\",\n      \"&boxvH;\": \"\",\n      \"&boxvL;\": \"\",\n      \"&boxvR;\": \"\",\n      \"&boxvh;\": \"\",\n      \"&boxvl;\": \"\",\n      \"&boxvr;\": \"\",\n      \"&bprime;\": \"\",\n      \"&breve;\": \"\",\n      \"&brvbar\": \"\",\n      \"&brvbar;\": \"\",\n      \"&bscr;\": \"\",\n      \"&bsemi;\": \"\",\n      \"&bsim;\": \"\",\n      \"&bsime;\": \"\",\n      \"&bsol;\": \"\\\\\",\n      \"&bsolb;\": \"\",\n      \"&bsolhsub;\": \"\",\n      \"&bull;\": \"\",\n      \"&bullet;\": \"\",\n      \"&bump;\": \"\",\n      \"&bumpE;\": \"\",\n      \"&bumpe;\": \"\",\n      \"&bumpeq;\": \"\",\n      \"&cacute;\": \"\",\n      \"&cap;\": \"\",\n      \"&capand;\": \"\",\n      \"&capbrcup;\": \"\",\n      \"&capcap;\": \"\",\n      \"&capcup;\": \"\",\n      \"&capdot;\": \"\",\n      \"&caps;\": \"\",\n      \"&caret;\": \"\",\n      \"&caron;\": \"\",\n      \"&ccaps;\": \"\",\n      \"&ccaron;\": \"\",\n      \"&ccedil\": \"\",\n      \"&ccedil;\": \"\",\n      \"&ccirc;\": \"\",\n      \"&ccups;\": \"\",\n      \"&ccupssm;\": \"\",\n      \"&cdot;\": \"\",\n      \"&cedil\": \"\",\n      \"&cedil;\": \"\",\n      \"&cemptyv;\": \"\",\n      \"&cent\": \"\",\n      \"&cent;\": \"\",\n      \"&centerdot;\": \"\",\n      \"&cfr;\": \"\",\n      \"&chcy;\": \"\",\n      \"&check;\": \"\",\n      \"&checkmark;\": \"\",\n      \"&chi;\": \"\",\n      \"&cir;\": \"\",\n      \"&cirE;\": \"\",\n      \"&circ;\": \"\",\n      \"&circeq;\": \"\",\n      \"&circlearrowleft;\": \"\",\n      \"&circlearrowright;\": \"\",\n      \"&circledR;\": \"\",\n      \"&circledS;\": \"\",\n      \"&circledast;\": \"\",\n      \"&circledcirc;\": \"\",\n      \"&circleddash;\": \"\",\n      \"&cire;\": \"\",\n      \"&cirfnint;\": \"\",\n      \"&cirmid;\": \"\",\n      \"&cirscir;\": \"\",\n      \"&clubs;\": \"\",\n      \"&clubsuit;\": \"\",\n      \"&colon;\": \":\",\n      \"&colone;\": \"\",\n      \"&coloneq;\": \"\",\n      \"&comma;\": \",\",\n      \"&commat;\": \"@\",\n      \"&comp;\": \"\",\n      \"&compfn;\": \"\",\n      \"&complement;\": \"\",\n      \"&complexes;\": \"\",\n      \"&cong;\": \"\",\n      \"&congdot;\": \"\",\n      \"&conint;\": \"\",\n      \"&copf;\": \"\",\n      \"&coprod;\": \"\",\n      \"&copy\": \"\",\n      \"&copy;\": \"\",\n      \"&copysr;\": \"\",\n      \"&crarr;\": \"\",\n      \"&cross;\": \"\",\n      \"&cscr;\": \"\",\n      \"&csub;\": \"\",\n      \"&csube;\": \"\",\n      \"&csup;\": \"\",\n      \"&csupe;\": \"\",\n      \"&ctdot;\": \"\",\n      \"&cudarrl;\": \"\",\n      \"&cudarrr;\": \"\",\n      \"&cuepr;\": \"\",\n      \"&cuesc;\": \"\",\n      \"&cularr;\": \"\",\n      \"&cularrp;\": \"\",\n      \"&cup;\": \"\",\n      \"&cupbrcap;\": \"\",\n      \"&cupcap;\": \"\",\n      \"&cupcup;\": \"\",\n      \"&cupdot;\": \"\",\n      \"&cupor;\": \"\",\n      \"&cups;\": \"\",\n      \"&curarr;\": \"\",\n      \"&curarrm;\": \"\",\n      \"&curlyeqprec;\": \"\",\n      \"&curlyeqsucc;\": \"\",\n      \"&curlyvee;\": \"\",\n      \"&curlywedge;\": \"\",\n      \"&curren\": \"\",\n      \"&curren;\": \"\",\n      \"&curvearrowleft;\": \"\",\n      \"&curvearrowright;\": \"\",\n      \"&cuvee;\": \"\",\n      \"&cuwed;\": \"\",\n      \"&cwconint;\": \"\",\n      \"&cwint;\": \"\",\n      \"&cylcty;\": \"\",\n      \"&dArr;\": \"\",\n      \"&dHar;\": \"\",\n      \"&dagger;\": \"\",\n      \"&daleth;\": \"\",\n      \"&darr;\": \"\",\n      \"&dash;\": \"\",\n      \"&dashv;\": \"\",\n      \"&dbkarow;\": \"\",\n      \"&dblac;\": \"\",\n      \"&dcaron;\": \"\",\n      \"&dcy;\": \"\",\n      \"&dd;\": \"\",\n      \"&ddagger;\": \"\",\n      \"&ddarr;\": \"\",\n      \"&ddotseq;\": \"\",\n      \"&deg\": \"\",\n      \"&deg;\": \"\",\n      \"&delta;\": \"\",\n      \"&demptyv;\": \"\",\n      \"&dfisht;\": \"\",\n      \"&dfr;\": \"\",\n      \"&dharl;\": \"\",\n      \"&dharr;\": \"\",\n      \"&diam;\": \"\",\n      \"&diamond;\": \"\",\n      \"&diamondsuit;\": \"\",\n      \"&diams;\": \"\",\n      \"&die;\": \"\",\n      \"&digamma;\": \"\",\n      \"&disin;\": \"\",\n      \"&div;\": \"\",\n      \"&divide\": \"\",\n      \"&divide;\": \"\",\n      \"&divideontimes;\": \"\",\n      \"&divonx;\": \"\",\n      \"&djcy;\": \"\",\n      \"&dlcorn;\": \"\",\n      \"&dlcrop;\": \"\",\n      \"&dollar;\": \"$\",\n      \"&dopf;\": \"\",\n      \"&dot;\": \"\",\n      \"&doteq;\": \"\",\n      \"&doteqdot;\": \"\",\n      \"&dotminus;\": \"\",\n      \"&dotplus;\": \"\",\n      \"&dotsquare;\": \"\",\n      \"&doublebarwedge;\": \"\",\n      \"&downarrow;\": \"\",\n      \"&downdownarrows;\": \"\",\n      \"&downharpoonleft;\": \"\",\n      \"&downharpoonright;\": \"\",\n      \"&drbkarow;\": \"\",\n      \"&drcorn;\": \"\",\n      \"&drcrop;\": \"\",\n      \"&dscr;\": \"\",\n      \"&dscy;\": \"\",\n      \"&dsol;\": \"\",\n      \"&dstrok;\": \"\",\n      \"&dtdot;\": \"\",\n      \"&dtri;\": \"\",\n      \"&dtrif;\": \"\",\n      \"&duarr;\": \"\",\n      \"&duhar;\": \"\",\n      \"&dwangle;\": \"\",\n      \"&dzcy;\": \"\",\n      \"&dzigrarr;\": \"\",\n      \"&eDDot;\": \"\",\n      \"&eDot;\": \"\",\n      \"&eacute\": \"\",\n      \"&eacute;\": \"\",\n      \"&easter;\": \"\",\n      \"&ecaron;\": \"\",\n      \"&ecir;\": \"\",\n      \"&ecirc\": \"\",\n      \"&ecirc;\": \"\",\n      \"&ecolon;\": \"\",\n      \"&ecy;\": \"\",\n      \"&edot;\": \"\",\n      \"&ee;\": \"\",\n      \"&efDot;\": \"\",\n      \"&efr;\": \"\",\n      \"&eg;\": \"\",\n      \"&egrave\": \"\",\n      \"&egrave;\": \"\",\n      \"&egs;\": \"\",\n      \"&egsdot;\": \"\",\n      \"&el;\": \"\",\n      \"&elinters;\": \"\",\n      \"&ell;\": \"\",\n      \"&els;\": \"\",\n      \"&elsdot;\": \"\",\n      \"&emacr;\": \"\",\n      \"&empty;\": \"\",\n      \"&emptyset;\": \"\",\n      \"&emptyv;\": \"\",\n      \"&emsp13;\": \"\",\n      \"&emsp14;\": \"\",\n      \"&emsp;\": \"\",\n      \"&eng;\": \"\",\n      \"&ensp;\": \"\",\n      \"&eogon;\": \"\",\n      \"&eopf;\": \"\",\n      \"&epar;\": \"\",\n      \"&eparsl;\": \"\",\n      \"&eplus;\": \"\",\n      \"&epsi;\": \"\",\n      \"&epsilon;\": \"\",\n      \"&epsiv;\": \"\",\n      \"&eqcirc;\": \"\",\n      \"&eqcolon;\": \"\",\n      \"&eqsim;\": \"\",\n      \"&eqslantgtr;\": \"\",\n      \"&eqslantless;\": \"\",\n      \"&equals;\": \"=\",\n      \"&equest;\": \"\",\n      \"&equiv;\": \"\",\n      \"&equivDD;\": \"\",\n      \"&eqvparsl;\": \"\",\n      \"&erDot;\": \"\",\n      \"&erarr;\": \"\",\n      \"&escr;\": \"\",\n      \"&esdot;\": \"\",\n      \"&esim;\": \"\",\n      \"&eta;\": \"\",\n      \"&eth\": \"\",\n      \"&eth;\": \"\",\n      \"&euml\": \"\",\n      \"&euml;\": \"\",\n      \"&euro;\": \"\",\n      \"&excl;\": \"!\",\n      \"&exist;\": \"\",\n      \"&expectation;\": \"\",\n      \"&exponentiale;\": \"\",\n      \"&fallingdotseq;\": \"\",\n      \"&fcy;\": \"\",\n      \"&female;\": \"\",\n      \"&ffilig;\": \"\",\n      \"&fflig;\": \"\",\n      \"&ffllig;\": \"\",\n      \"&ffr;\": \"\",\n      \"&filig;\": \"\",\n      \"&fjlig;\": \"fj\",\n      \"&flat;\": \"\",\n      \"&fllig;\": \"\",\n      \"&fltns;\": \"\",\n      \"&fnof;\": \"\",\n      \"&fopf;\": \"\",\n      \"&forall;\": \"\",\n      \"&fork;\": \"\",\n      \"&forkv;\": \"\",\n      \"&fpartint;\": \"\",\n      \"&frac12\": \"\",\n      \"&frac12;\": \"\",\n      \"&frac13;\": \"\",\n      \"&frac14\": \"\",\n      \"&frac14;\": \"\",\n      \"&frac15;\": \"\",\n      \"&frac16;\": \"\",\n      \"&frac18;\": \"\",\n      \"&frac23;\": \"\",\n      \"&frac25;\": \"\",\n      \"&frac34\": \"\",\n      \"&frac34;\": \"\",\n      \"&frac35;\": \"\",\n      \"&frac38;\": \"\",\n      \"&frac45;\": \"\",\n      \"&frac56;\": \"\",\n      \"&frac58;\": \"\",\n      \"&frac78;\": \"\",\n      \"&frasl;\": \"\",\n      \"&frown;\": \"\",\n      \"&fscr;\": \"\",\n      \"&gE;\": \"\",\n      \"&gEl;\": \"\",\n      \"&gacute;\": \"\",\n      \"&gamma;\": \"\",\n      \"&gammad;\": \"\",\n      \"&gap;\": \"\",\n      \"&gbreve;\": \"\",\n      \"&gcirc;\": \"\",\n      \"&gcy;\": \"\",\n      \"&gdot;\": \"\",\n      \"&ge;\": \"\",\n      \"&gel;\": \"\",\n      \"&geq;\": \"\",\n      \"&geqq;\": \"\",\n      \"&geqslant;\": \"\",\n      \"&ges;\": \"\",\n      \"&gescc;\": \"\",\n      \"&gesdot;\": \"\",\n      \"&gesdoto;\": \"\",\n      \"&gesdotol;\": \"\",\n      \"&gesl;\": \"\",\n      \"&gesles;\": \"\",\n      \"&gfr;\": \"\",\n      \"&gg;\": \"\",\n      \"&ggg;\": \"\",\n      \"&gimel;\": \"\",\n      \"&gjcy;\": \"\",\n      \"&gl;\": \"\",\n      \"&glE;\": \"\",\n      \"&gla;\": \"\",\n      \"&glj;\": \"\",\n      \"&gnE;\": \"\",\n      \"&gnap;\": \"\",\n      \"&gnapprox;\": \"\",\n      \"&gne;\": \"\",\n      \"&gneq;\": \"\",\n      \"&gneqq;\": \"\",\n      \"&gnsim;\": \"\",\n      \"&gopf;\": \"\",\n      \"&grave;\": \"`\",\n      \"&gscr;\": \"\",\n      \"&gsim;\": \"\",\n      \"&gsime;\": \"\",\n      \"&gsiml;\": \"\",\n      \"&gt\": \">\",\n      \"&gt;\": \">\",\n      \"&gtcc;\": \"\",\n      \"&gtcir;\": \"\",\n      \"&gtdot;\": \"\",\n      \"&gtlPar;\": \"\",\n      \"&gtquest;\": \"\",\n      \"&gtrapprox;\": \"\",\n      \"&gtrarr;\": \"\",\n      \"&gtrdot;\": \"\",\n      \"&gtreqless;\": \"\",\n      \"&gtreqqless;\": \"\",\n      \"&gtrless;\": \"\",\n      \"&gtrsim;\": \"\",\n      \"&gvertneqq;\": \"\",\n      \"&gvnE;\": \"\",\n      \"&hArr;\": \"\",\n      \"&hairsp;\": \"\",\n      \"&half;\": \"\",\n      \"&hamilt;\": \"\",\n      \"&hardcy;\": \"\",\n      \"&harr;\": \"\",\n      \"&harrcir;\": \"\",\n      \"&harrw;\": \"\",\n      \"&hbar;\": \"\",\n      \"&hcirc;\": \"\",\n      \"&hearts;\": \"\",\n      \"&heartsuit;\": \"\",\n      \"&hellip;\": \"\",\n      \"&hercon;\": \"\",\n      \"&hfr;\": \"\",\n      \"&hksearow;\": \"\",\n      \"&hkswarow;\": \"\",\n      \"&hoarr;\": \"\",\n      \"&homtht;\": \"\",\n      \"&hookleftarrow;\": \"\",\n      \"&hookrightarrow;\": \"\",\n      \"&hopf;\": \"\",\n      \"&horbar;\": \"\",\n      \"&hscr;\": \"\",\n      \"&hslash;\": \"\",\n      \"&hstrok;\": \"\",\n      \"&hybull;\": \"\",\n      \"&hyphen;\": \"\",\n      \"&iacute\": \"\",\n      \"&iacute;\": \"\",\n      \"&ic;\": \"\",\n      \"&icirc\": \"\",\n      \"&icirc;\": \"\",\n      \"&icy;\": \"\",\n      \"&iecy;\": \"\",\n      \"&iexcl\": \"\",\n      \"&iexcl;\": \"\",\n      \"&iff;\": \"\",\n      \"&ifr;\": \"\",\n      \"&igrave\": \"\",\n      \"&igrave;\": \"\",\n      \"&ii;\": \"\",\n      \"&iiiint;\": \"\",\n      \"&iiint;\": \"\",\n      \"&iinfin;\": \"\",\n      \"&iiota;\": \"\",\n      \"&ijlig;\": \"\",\n      \"&imacr;\": \"\",\n      \"&image;\": \"\",\n      \"&imagline;\": \"\",\n      \"&imagpart;\": \"\",\n      \"&imath;\": \"\",\n      \"&imof;\": \"\",\n      \"&imped;\": \"\",\n      \"&in;\": \"\",\n      \"&incare;\": \"\",\n      \"&infin;\": \"\",\n      \"&infintie;\": \"\",\n      \"&inodot;\": \"\",\n      \"&int;\": \"\",\n      \"&intcal;\": \"\",\n      \"&integers;\": \"\",\n      \"&intercal;\": \"\",\n      \"&intlarhk;\": \"\",\n      \"&intprod;\": \"\",\n      \"&iocy;\": \"\",\n      \"&iogon;\": \"\",\n      \"&iopf;\": \"\",\n      \"&iota;\": \"\",\n      \"&iprod;\": \"\",\n      \"&iquest\": \"\",\n      \"&iquest;\": \"\",\n      \"&iscr;\": \"\",\n      \"&isin;\": \"\",\n      \"&isinE;\": \"\",\n      \"&isindot;\": \"\",\n      \"&isins;\": \"\",\n      \"&isinsv;\": \"\",\n      \"&isinv;\": \"\",\n      \"&it;\": \"\",\n      \"&itilde;\": \"\",\n      \"&iukcy;\": \"\",\n      \"&iuml\": \"\",\n      \"&iuml;\": \"\",\n      \"&jcirc;\": \"\",\n      \"&jcy;\": \"\",\n      \"&jfr;\": \"\",\n      \"&jmath;\": \"\",\n      \"&jopf;\": \"\",\n      \"&jscr;\": \"\",\n      \"&jsercy;\": \"\",\n      \"&jukcy;\": \"\",\n      \"&kappa;\": \"\",\n      \"&kappav;\": \"\",\n      \"&kcedil;\": \"\",\n      \"&kcy;\": \"\",\n      \"&kfr;\": \"\",\n      \"&kgreen;\": \"\",\n      \"&khcy;\": \"\",\n      \"&kjcy;\": \"\",\n      \"&kopf;\": \"\",\n      \"&kscr;\": \"\",\n      \"&lAarr;\": \"\",\n      \"&lArr;\": \"\",\n      \"&lAtail;\": \"\",\n      \"&lBarr;\": \"\",\n      \"&lE;\": \"\",\n      \"&lEg;\": \"\",\n      \"&lHar;\": \"\",\n      \"&lacute;\": \"\",\n      \"&laemptyv;\": \"\",\n      \"&lagran;\": \"\",\n      \"&lambda;\": \"\",\n      \"&lang;\": \"\",\n      \"&langd;\": \"\",\n      \"&langle;\": \"\",\n      \"&lap;\": \"\",\n      \"&laquo\": \"\",\n      \"&laquo;\": \"\",\n      \"&larr;\": \"\",\n      \"&larrb;\": \"\",\n      \"&larrbfs;\": \"\",\n      \"&larrfs;\": \"\",\n      \"&larrhk;\": \"\",\n      \"&larrlp;\": \"\",\n      \"&larrpl;\": \"\",\n      \"&larrsim;\": \"\",\n      \"&larrtl;\": \"\",\n      \"&lat;\": \"\",\n      \"&latail;\": \"\",\n      \"&late;\": \"\",\n      \"&lates;\": \"\",\n      \"&lbarr;\": \"\",\n      \"&lbbrk;\": \"\",\n      \"&lbrace;\": \"{\",\n      \"&lbrack;\": \"[\",\n      \"&lbrke;\": \"\",\n      \"&lbrksld;\": \"\",\n      \"&lbrkslu;\": \"\",\n      \"&lcaron;\": \"\",\n      \"&lcedil;\": \"\",\n      \"&lceil;\": \"\",\n      \"&lcub;\": \"{\",\n      \"&lcy;\": \"\",\n      \"&ldca;\": \"\",\n      \"&ldquo;\": \"\",\n      \"&ldquor;\": \"\",\n      \"&ldrdhar;\": \"\",\n      \"&ldrushar;\": \"\",\n      \"&ldsh;\": \"\",\n      \"&le;\": \"\",\n      \"&leftarrow;\": \"\",\n      \"&leftarrowtail;\": \"\",\n      \"&leftharpoondown;\": \"\",\n      \"&leftharpoonup;\": \"\",\n      \"&leftleftarrows;\": \"\",\n      \"&leftrightarrow;\": \"\",\n      \"&leftrightarrows;\": \"\",\n      \"&leftrightharpoons;\": \"\",\n      \"&leftrightsquigarrow;\": \"\",\n      \"&leftthreetimes;\": \"\",\n      \"&leg;\": \"\",\n      \"&leq;\": \"\",\n      \"&leqq;\": \"\",\n      \"&leqslant;\": \"\",\n      \"&les;\": \"\",\n      \"&lescc;\": \"\",\n      \"&lesdot;\": \"\",\n      \"&lesdoto;\": \"\",\n      \"&lesdotor;\": \"\",\n      \"&lesg;\": \"\",\n      \"&lesges;\": \"\",\n      \"&lessapprox;\": \"\",\n      \"&lessdot;\": \"\",\n      \"&lesseqgtr;\": \"\",\n      \"&lesseqqgtr;\": \"\",\n      \"&lessgtr;\": \"\",\n      \"&lesssim;\": \"\",\n      \"&lfisht;\": \"\",\n      \"&lfloor;\": \"\",\n      \"&lfr;\": \"\",\n      \"&lg;\": \"\",\n      \"&lgE;\": \"\",\n      \"&lhard;\": \"\",\n      \"&lharu;\": \"\",\n      \"&lharul;\": \"\",\n      \"&lhblk;\": \"\",\n      \"&ljcy;\": \"\",\n      \"&ll;\": \"\",\n      \"&llarr;\": \"\",\n      \"&llcorner;\": \"\",\n      \"&llhard;\": \"\",\n      \"&lltri;\": \"\",\n      \"&lmidot;\": \"\",\n      \"&lmoust;\": \"\",\n      \"&lmoustache;\": \"\",\n      \"&lnE;\": \"\",\n      \"&lnap;\": \"\",\n      \"&lnapprox;\": \"\",\n      \"&lne;\": \"\",\n      \"&lneq;\": \"\",\n      \"&lneqq;\": \"\",\n      \"&lnsim;\": \"\",\n      \"&loang;\": \"\",\n      \"&loarr;\": \"\",\n      \"&lobrk;\": \"\",\n      \"&longleftarrow;\": \"\",\n      \"&longleftrightarrow;\": \"\",\n      \"&longmapsto;\": \"\",\n      \"&longrightarrow;\": \"\",\n      \"&looparrowleft;\": \"\",\n      \"&looparrowright;\": \"\",\n      \"&lopar;\": \"\",\n      \"&lopf;\": \"\",\n      \"&loplus;\": \"\",\n      \"&lotimes;\": \"\",\n      \"&lowast;\": \"\",\n      \"&lowbar;\": \"_\",\n      \"&loz;\": \"\",\n      \"&lozenge;\": \"\",\n      \"&lozf;\": \"\",\n      \"&lpar;\": \"(\",\n      \"&lparlt;\": \"\",\n      \"&lrarr;\": \"\",\n      \"&lrcorner;\": \"\",\n      \"&lrhar;\": \"\",\n      \"&lrhard;\": \"\",\n      \"&lrm;\": \"\",\n      \"&lrtri;\": \"\",\n      \"&lsaquo;\": \"\",\n      \"&lscr;\": \"\",\n      \"&lsh;\": \"\",\n      \"&lsim;\": \"\",\n      \"&lsime;\": \"\",\n      \"&lsimg;\": \"\",\n      \"&lsqb;\": \"[\",\n      \"&lsquo;\": \"\",\n      \"&lsquor;\": \"\",\n      \"&lstrok;\": \"\",\n      \"&lt\": \"<\",\n      \"&lt;\": \"<\",\n      \"&ltcc;\": \"\",\n      \"&ltcir;\": \"\",\n      \"&ltdot;\": \"\",\n      \"&lthree;\": \"\",\n      \"&ltimes;\": \"\",\n      \"&ltlarr;\": \"\",\n      \"&ltquest;\": \"\",\n      \"&ltrPar;\": \"\",\n      \"&ltri;\": \"\",\n      \"&ltrie;\": \"\",\n      \"&ltrif;\": \"\",\n      \"&lurdshar;\": \"\",\n      \"&luruhar;\": \"\",\n      \"&lvertneqq;\": \"\",\n      \"&lvnE;\": \"\",\n      \"&mDDot;\": \"\",\n      \"&macr\": \"\",\n      \"&macr;\": \"\",\n      \"&male;\": \"\",\n      \"&malt;\": \"\",\n      \"&maltese;\": \"\",\n      \"&map;\": \"\",\n      \"&mapsto;\": \"\",\n      \"&mapstodown;\": \"\",\n      \"&mapstoleft;\": \"\",\n      \"&mapstoup;\": \"\",\n      \"&marker;\": \"\",\n      \"&mcomma;\": \"\",\n      \"&mcy;\": \"\",\n      \"&mdash;\": \"\",\n      \"&measuredangle;\": \"\",\n      \"&mfr;\": \"\",\n      \"&mho;\": \"\",\n      \"&micro\": \"\",\n      \"&micro;\": \"\",\n      \"&mid;\": \"\",\n      \"&midast;\": \"*\",\n      \"&midcir;\": \"\",\n      \"&middot\": \"\",\n      \"&middot;\": \"\",\n      \"&minus;\": \"\",\n      \"&minusb;\": \"\",\n      \"&minusd;\": \"\",\n      \"&minusdu;\": \"\",\n      \"&mlcp;\": \"\",\n      \"&mldr;\": \"\",\n      \"&mnplus;\": \"\",\n      \"&models;\": \"\",\n      \"&mopf;\": \"\",\n      \"&mp;\": \"\",\n      \"&mscr;\": \"\",\n      \"&mstpos;\": \"\",\n      \"&mu;\": \"\",\n      \"&multimap;\": \"\",\n      \"&mumap;\": \"\",\n      \"&nGg;\": \"\",\n      \"&nGt;\": \"\",\n      \"&nGtv;\": \"\",\n      \"&nLeftarrow;\": \"\",\n      \"&nLeftrightarrow;\": \"\",\n      \"&nLl;\": \"\",\n      \"&nLt;\": \"\",\n      \"&nLtv;\": \"\",\n      \"&nRightarrow;\": \"\",\n      \"&nVDash;\": \"\",\n      \"&nVdash;\": \"\",\n      \"&nabla;\": \"\",\n      \"&nacute;\": \"\",\n      \"&nang;\": \"\",\n      \"&nap;\": \"\",\n      \"&napE;\": \"\",\n      \"&napid;\": \"\",\n      \"&napos;\": \"\",\n      \"&napprox;\": \"\",\n      \"&natur;\": \"\",\n      \"&natural;\": \"\",\n      \"&naturals;\": \"\",\n      \"&nbsp\": \"\",\n      \"&nbsp;\": \"\",\n      \"&nbump;\": \"\",\n      \"&nbumpe;\": \"\",\n      \"&ncap;\": \"\",\n      \"&ncaron;\": \"\",\n      \"&ncedil;\": \"\",\n      \"&ncong;\": \"\",\n      \"&ncongdot;\": \"\",\n      \"&ncup;\": \"\",\n      \"&ncy;\": \"\",\n      \"&ndash;\": \"\",\n      \"&ne;\": \"\",\n      \"&neArr;\": \"\",\n      \"&nearhk;\": \"\",\n      \"&nearr;\": \"\",\n      \"&nearrow;\": \"\",\n      \"&nedot;\": \"\",\n      \"&nequiv;\": \"\",\n      \"&nesear;\": \"\",\n      \"&nesim;\": \"\",\n      \"&nexist;\": \"\",\n      \"&nexists;\": \"\",\n      \"&nfr;\": \"\",\n      \"&ngE;\": \"\",\n      \"&nge;\": \"\",\n      \"&ngeq;\": \"\",\n      \"&ngeqq;\": \"\",\n      \"&ngeqslant;\": \"\",\n      \"&nges;\": \"\",\n      \"&ngsim;\": \"\",\n      \"&ngt;\": \"\",\n      \"&ngtr;\": \"\",\n      \"&nhArr;\": \"\",\n      \"&nharr;\": \"\",\n      \"&nhpar;\": \"\",\n      \"&ni;\": \"\",\n      \"&nis;\": \"\",\n      \"&nisd;\": \"\",\n      \"&niv;\": \"\",\n      \"&njcy;\": \"\",\n      \"&nlArr;\": \"\",\n      \"&nlE;\": \"\",\n      \"&nlarr;\": \"\",\n      \"&nldr;\": \"\",\n      \"&nle;\": \"\",\n      \"&nleftarrow;\": \"\",\n      \"&nleftrightarrow;\": \"\",\n      \"&nleq;\": \"\",\n      \"&nleqq;\": \"\",\n      \"&nleqslant;\": \"\",\n      \"&nles;\": \"\",\n      \"&nless;\": \"\",\n      \"&nlsim;\": \"\",\n      \"&nlt;\": \"\",\n      \"&nltri;\": \"\",\n      \"&nltrie;\": \"\",\n      \"&nmid;\": \"\",\n      \"&nopf;\": \"\",\n      \"&not\": \"\",\n      \"&not;\": \"\",\n      \"&notin;\": \"\",\n      \"&notinE;\": \"\",\n      \"&notindot;\": \"\",\n      \"&notinva;\": \"\",\n      \"&notinvb;\": \"\",\n      \"&notinvc;\": \"\",\n      \"&notni;\": \"\",\n      \"&notniva;\": \"\",\n      \"&notnivb;\": \"\",\n      \"&notnivc;\": \"\",\n      \"&npar;\": \"\",\n      \"&nparallel;\": \"\",\n      \"&nparsl;\": \"\",\n      \"&npart;\": \"\",\n      \"&npolint;\": \"\",\n      \"&npr;\": \"\",\n      \"&nprcue;\": \"\",\n      \"&npre;\": \"\",\n      \"&nprec;\": \"\",\n      \"&npreceq;\": \"\",\n      \"&nrArr;\": \"\",\n      \"&nrarr;\": \"\",\n      \"&nrarrc;\": \"\",\n      \"&nrarrw;\": \"\",\n      \"&nrightarrow;\": \"\",\n      \"&nrtri;\": \"\",\n      \"&nrtrie;\": \"\",\n      \"&nsc;\": \"\",\n      \"&nsccue;\": \"\",\n      \"&nsce;\": \"\",\n      \"&nscr;\": \"\",\n      \"&nshortmid;\": \"\",\n      \"&nshortparallel;\": \"\",\n      \"&nsim;\": \"\",\n      \"&nsime;\": \"\",\n      \"&nsimeq;\": \"\",\n      \"&nsmid;\": \"\",\n      \"&nspar;\": \"\",\n      \"&nsqsube;\": \"\",\n      \"&nsqsupe;\": \"\",\n      \"&nsub;\": \"\",\n      \"&nsubE;\": \"\",\n      \"&nsube;\": \"\",\n      \"&nsubset;\": \"\",\n      \"&nsubseteq;\": \"\",\n      \"&nsubseteqq;\": \"\",\n      \"&nsucc;\": \"\",\n      \"&nsucceq;\": \"\",\n      \"&nsup;\": \"\",\n      \"&nsupE;\": \"\",\n      \"&nsupe;\": \"\",\n      \"&nsupset;\": \"\",\n      \"&nsupseteq;\": \"\",\n      \"&nsupseteqq;\": \"\",\n      \"&ntgl;\": \"\",\n      \"&ntilde\": \"\",\n      \"&ntilde;\": \"\",\n      \"&ntlg;\": \"\",\n      \"&ntriangleleft;\": \"\",\n      \"&ntrianglelefteq;\": \"\",\n      \"&ntriangleright;\": \"\",\n      \"&ntrianglerighteq;\": \"\",\n      \"&nu;\": \"\",\n      \"&num;\": \"#\",\n      \"&numero;\": \"\",\n      \"&numsp;\": \"\",\n      \"&nvDash;\": \"\",\n      \"&nvHarr;\": \"\",\n      \"&nvap;\": \"\",\n      \"&nvdash;\": \"\",\n      \"&nvge;\": \"\",\n      \"&nvgt;\": \">\",\n      \"&nvinfin;\": \"\",\n      \"&nvlArr;\": \"\",\n      \"&nvle;\": \"\",\n      \"&nvlt;\": \"<\",\n      \"&nvltrie;\": \"\",\n      \"&nvrArr;\": \"\",\n      \"&nvrtrie;\": \"\",\n      \"&nvsim;\": \"\",\n      \"&nwArr;\": \"\",\n      \"&nwarhk;\": \"\",\n      \"&nwarr;\": \"\",\n      \"&nwarrow;\": \"\",\n      \"&nwnear;\": \"\",\n      \"&oS;\": \"\",\n      \"&oacute\": \"\",\n      \"&oacute;\": \"\",\n      \"&oast;\": \"\",\n      \"&ocir;\": \"\",\n      \"&ocirc\": \"\",\n      \"&ocirc;\": \"\",\n      \"&ocy;\": \"\",\n      \"&odash;\": \"\",\n      \"&odblac;\": \"\",\n      \"&odiv;\": \"\",\n      \"&odot;\": \"\",\n      \"&odsold;\": \"\",\n      \"&oelig;\": \"\",\n      \"&ofcir;\": \"\",\n      \"&ofr;\": \"\",\n      \"&ogon;\": \"\",\n      \"&ograve\": \"\",\n      \"&ograve;\": \"\",\n      \"&ogt;\": \"\",\n      \"&ohbar;\": \"\",\n      \"&ohm;\": \"\",\n      \"&oint;\": \"\",\n      \"&olarr;\": \"\",\n      \"&olcir;\": \"\",\n      \"&olcross;\": \"\",\n      \"&oline;\": \"\",\n      \"&olt;\": \"\",\n      \"&omacr;\": \"\",\n      \"&omega;\": \"\",\n      \"&omicron;\": \"\",\n      \"&omid;\": \"\",\n      \"&ominus;\": \"\",\n      \"&oopf;\": \"\",\n      \"&opar;\": \"\",\n      \"&operp;\": \"\",\n      \"&oplus;\": \"\",\n      \"&or;\": \"\",\n      \"&orarr;\": \"\",\n      \"&ord;\": \"\",\n      \"&order;\": \"\",\n      \"&orderof;\": \"\",\n      \"&ordf\": \"\",\n      \"&ordf;\": \"\",\n      \"&ordm\": \"\",\n      \"&ordm;\": \"\",\n      \"&origof;\": \"\",\n      \"&oror;\": \"\",\n      \"&orslope;\": \"\",\n      \"&orv;\": \"\",\n      \"&oscr;\": \"\",\n      \"&oslash\": \"\",\n      \"&oslash;\": \"\",\n      \"&osol;\": \"\",\n      \"&otilde\": \"\",\n      \"&otilde;\": \"\",\n      \"&otimes;\": \"\",\n      \"&otimesas;\": \"\",\n      \"&ouml\": \"\",\n      \"&ouml;\": \"\",\n      \"&ovbar;\": \"\",\n      \"&par;\": \"\",\n      \"&para\": \"\",\n      \"&para;\": \"\",\n      \"&parallel;\": \"\",\n      \"&parsim;\": \"\",\n      \"&parsl;\": \"\",\n      \"&part;\": \"\",\n      \"&pcy;\": \"\",\n      \"&percnt;\": \"%\",\n      \"&period;\": \".\",\n      \"&permil;\": \"\",\n      \"&perp;\": \"\",\n      \"&pertenk;\": \"\",\n      \"&pfr;\": \"\",\n      \"&phi;\": \"\",\n      \"&phiv;\": \"\",\n      \"&phmmat;\": \"\",\n      \"&phone;\": \"\",\n      \"&pi;\": \"\",\n      \"&pitchfork;\": \"\",\n      \"&piv;\": \"\",\n      \"&planck;\": \"\",\n      \"&planckh;\": \"\",\n      \"&plankv;\": \"\",\n      \"&plus;\": \"+\",\n      \"&plusacir;\": \"\",\n      \"&plusb;\": \"\",\n      \"&pluscir;\": \"\",\n      \"&plusdo;\": \"\",\n      \"&plusdu;\": \"\",\n      \"&pluse;\": \"\",\n      \"&plusmn\": \"\",\n      \"&plusmn;\": \"\",\n      \"&plussim;\": \"\",\n      \"&plustwo;\": \"\",\n      \"&pm;\": \"\",\n      \"&pointint;\": \"\",\n      \"&popf;\": \"\",\n      \"&pound\": \"\",\n      \"&pound;\": \"\",\n      \"&pr;\": \"\",\n      \"&prE;\": \"\",\n      \"&prap;\": \"\",\n      \"&prcue;\": \"\",\n      \"&pre;\": \"\",\n      \"&prec;\": \"\",\n      \"&precapprox;\": \"\",\n      \"&preccurlyeq;\": \"\",\n      \"&preceq;\": \"\",\n      \"&precnapprox;\": \"\",\n      \"&precneqq;\": \"\",\n      \"&precnsim;\": \"\",\n      \"&precsim;\": \"\",\n      \"&prime;\": \"\",\n      \"&primes;\": \"\",\n      \"&prnE;\": \"\",\n      \"&prnap;\": \"\",\n      \"&prnsim;\": \"\",\n      \"&prod;\": \"\",\n      \"&profalar;\": \"\",\n      \"&profline;\": \"\",\n      \"&profsurf;\": \"\",\n      \"&prop;\": \"\",\n      \"&propto;\": \"\",\n      \"&prsim;\": \"\",\n      \"&prurel;\": \"\",\n      \"&pscr;\": \"\",\n      \"&psi;\": \"\",\n      \"&puncsp;\": \"\",\n      \"&qfr;\": \"\",\n      \"&qint;\": \"\",\n      \"&qopf;\": \"\",\n      \"&qprime;\": \"\",\n      \"&qscr;\": \"\",\n      \"&quaternions;\": \"\",\n      \"&quatint;\": \"\",\n      \"&quest;\": \"?\",\n      \"&questeq;\": \"\",\n      \"&quot\": '\"',\n      \"&quot;\": '\"',\n      \"&rAarr;\": \"\",\n      \"&rArr;\": \"\",\n      \"&rAtail;\": \"\",\n      \"&rBarr;\": \"\",\n      \"&rHar;\": \"\",\n      \"&race;\": \"\",\n      \"&racute;\": \"\",\n      \"&radic;\": \"\",\n      \"&raemptyv;\": \"\",\n      \"&rang;\": \"\",\n      \"&rangd;\": \"\",\n      \"&range;\": \"\",\n      \"&rangle;\": \"\",\n      \"&raquo\": \"\",\n      \"&raquo;\": \"\",\n      \"&rarr;\": \"\",\n      \"&rarrap;\": \"\",\n      \"&rarrb;\": \"\",\n      \"&rarrbfs;\": \"\",\n      \"&rarrc;\": \"\",\n      \"&rarrfs;\": \"\",\n      \"&rarrhk;\": \"\",\n      \"&rarrlp;\": \"\",\n      \"&rarrpl;\": \"\",\n      \"&rarrsim;\": \"\",\n      \"&rarrtl;\": \"\",\n      \"&rarrw;\": \"\",\n      \"&ratail;\": \"\",\n      \"&ratio;\": \"\",\n      \"&rationals;\": \"\",\n      \"&rbarr;\": \"\",\n      \"&rbbrk;\": \"\",\n      \"&rbrace;\": \"}\",\n      \"&rbrack;\": \"]\",\n      \"&rbrke;\": \"\",\n      \"&rbrksld;\": \"\",\n      \"&rbrkslu;\": \"\",\n      \"&rcaron;\": \"\",\n      \"&rcedil;\": \"\",\n      \"&rceil;\": \"\",\n      \"&rcub;\": \"}\",\n      \"&rcy;\": \"\",\n      \"&rdca;\": \"\",\n      \"&rdldhar;\": \"\",\n      \"&rdquo;\": \"\",\n      \"&rdquor;\": \"\",\n      \"&rdsh;\": \"\",\n      \"&real;\": \"\",\n      \"&realine;\": \"\",\n      \"&realpart;\": \"\",\n      \"&reals;\": \"\",\n      \"&rect;\": \"\",\n      \"&reg\": \"\",\n      \"&reg;\": \"\",\n      \"&rfisht;\": \"\",\n      \"&rfloor;\": \"\",\n      \"&rfr;\": \"\",\n      \"&rhard;\": \"\",\n      \"&rharu;\": \"\",\n      \"&rharul;\": \"\",\n      \"&rho;\": \"\",\n      \"&rhov;\": \"\",\n      \"&rightarrow;\": \"\",\n      \"&rightarrowtail;\": \"\",\n      \"&rightharpoondown;\": \"\",\n      \"&rightharpoonup;\": \"\",\n      \"&rightleftarrows;\": \"\",\n      \"&rightleftharpoons;\": \"\",\n      \"&rightrightarrows;\": \"\",\n      \"&rightsquigarrow;\": \"\",\n      \"&rightthreetimes;\": \"\",\n      \"&ring;\": \"\",\n      \"&risingdotseq;\": \"\",\n      \"&rlarr;\": \"\",\n      \"&rlhar;\": \"\",\n      \"&rlm;\": \"\",\n      \"&rmoust;\": \"\",\n      \"&rmoustache;\": \"\",\n      \"&rnmid;\": \"\",\n      \"&roang;\": \"\",\n      \"&roarr;\": \"\",\n      \"&robrk;\": \"\",\n      \"&ropar;\": \"\",\n      \"&ropf;\": \"\",\n      \"&roplus;\": \"\",\n      \"&rotimes;\": \"\",\n      \"&rpar;\": \")\",\n      \"&rpargt;\": \"\",\n      \"&rppolint;\": \"\",\n      \"&rrarr;\": \"\",\n      \"&rsaquo;\": \"\",\n      \"&rscr;\": \"\",\n      \"&rsh;\": \"\",\n      \"&rsqb;\": \"]\",\n      \"&rsquo;\": \"\",\n      \"&rsquor;\": \"\",\n      \"&rthree;\": \"\",\n      \"&rtimes;\": \"\",\n      \"&rtri;\": \"\",\n      \"&rtrie;\": \"\",\n      \"&rtrif;\": \"\",\n      \"&rtriltri;\": \"\",\n      \"&ruluhar;\": \"\",\n      \"&rx;\": \"\",\n      \"&sacute;\": \"\",\n      \"&sbquo;\": \"\",\n      \"&sc;\": \"\",\n      \"&scE;\": \"\",\n      \"&scap;\": \"\",\n      \"&scaron;\": \"\",\n      \"&sccue;\": \"\",\n      \"&sce;\": \"\",\n      \"&scedil;\": \"\",\n      \"&scirc;\": \"\",\n      \"&scnE;\": \"\",\n      \"&scnap;\": \"\",\n      \"&scnsim;\": \"\",\n      \"&scpolint;\": \"\",\n      \"&scsim;\": \"\",\n      \"&scy;\": \"\",\n      \"&sdot;\": \"\",\n      \"&sdotb;\": \"\",\n      \"&sdote;\": \"\",\n      \"&seArr;\": \"\",\n      \"&searhk;\": \"\",\n      \"&searr;\": \"\",\n      \"&searrow;\": \"\",\n      \"&sect\": \"\",\n      \"&sect;\": \"\",\n      \"&semi;\": \";\",\n      \"&seswar;\": \"\",\n      \"&setminus;\": \"\",\n      \"&setmn;\": \"\",\n      \"&sext;\": \"\",\n      \"&sfr;\": \"\",\n      \"&sfrown;\": \"\",\n      \"&sharp;\": \"\",\n      \"&shchcy;\": \"\",\n      \"&shcy;\": \"\",\n      \"&shortmid;\": \"\",\n      \"&shortparallel;\": \"\",\n      \"&shy\": \"\",\n      \"&shy;\": \"\",\n      \"&sigma;\": \"\",\n      \"&sigmaf;\": \"\",\n      \"&sigmav;\": \"\",\n      \"&sim;\": \"\",\n      \"&simdot;\": \"\",\n      \"&sime;\": \"\",\n      \"&simeq;\": \"\",\n      \"&simg;\": \"\",\n      \"&simgE;\": \"\",\n      \"&siml;\": \"\",\n      \"&simlE;\": \"\",\n      \"&simne;\": \"\",\n      \"&simplus;\": \"\",\n      \"&simrarr;\": \"\",\n      \"&slarr;\": \"\",\n      \"&smallsetminus;\": \"\",\n      \"&smashp;\": \"\",\n      \"&smeparsl;\": \"\",\n      \"&smid;\": \"\",\n      \"&smile;\": \"\",\n      \"&smt;\": \"\",\n      \"&smte;\": \"\",\n      \"&smtes;\": \"\",\n      \"&softcy;\": \"\",\n      \"&sol;\": \"/\",\n      \"&solb;\": \"\",\n      \"&solbar;\": \"\",\n      \"&sopf;\": \"\",\n      \"&spades;\": \"\",\n      \"&spadesuit;\": \"\",\n      \"&spar;\": \"\",\n      \"&sqcap;\": \"\",\n      \"&sqcaps;\": \"\",\n      \"&sqcup;\": \"\",\n      \"&sqcups;\": \"\",\n      \"&sqsub;\": \"\",\n      \"&sqsube;\": \"\",\n      \"&sqsubset;\": \"\",\n      \"&sqsubseteq;\": \"\",\n      \"&sqsup;\": \"\",\n      \"&sqsupe;\": \"\",\n      \"&sqsupset;\": \"\",\n      \"&sqsupseteq;\": \"\",\n      \"&squ;\": \"\",\n      \"&square;\": \"\",\n      \"&squarf;\": \"\",\n      \"&squf;\": \"\",\n      \"&srarr;\": \"\",\n      \"&sscr;\": \"\",\n      \"&ssetmn;\": \"\",\n      \"&ssmile;\": \"\",\n      \"&sstarf;\": \"\",\n      \"&star;\": \"\",\n      \"&starf;\": \"\",\n      \"&straightepsilon;\": \"\",\n      \"&straightphi;\": \"\",\n      \"&strns;\": \"\",\n      \"&sub;\": \"\",\n      \"&subE;\": \"\",\n      \"&subdot;\": \"\",\n      \"&sube;\": \"\",\n      \"&subedot;\": \"\",\n      \"&submult;\": \"\",\n      \"&subnE;\": \"\",\n      \"&subne;\": \"\",\n      \"&subplus;\": \"\",\n      \"&subrarr;\": \"\",\n      \"&subset;\": \"\",\n      \"&subseteq;\": \"\",\n      \"&subseteqq;\": \"\",\n      \"&subsetneq;\": \"\",\n      \"&subsetneqq;\": \"\",\n      \"&subsim;\": \"\",\n      \"&subsub;\": \"\",\n      \"&subsup;\": \"\",\n      \"&succ;\": \"\",\n      \"&succapprox;\": \"\",\n      \"&succcurlyeq;\": \"\",\n      \"&succeq;\": \"\",\n      \"&succnapprox;\": \"\",\n      \"&succneqq;\": \"\",\n      \"&succnsim;\": \"\",\n      \"&succsim;\": \"\",\n      \"&sum;\": \"\",\n      \"&sung;\": \"\",\n      \"&sup1\": \"\",\n      \"&sup1;\": \"\",\n      \"&sup2\": \"\",\n      \"&sup2;\": \"\",\n      \"&sup3\": \"\",\n      \"&sup3;\": \"\",\n      \"&sup;\": \"\",\n      \"&supE;\": \"\",\n      \"&supdot;\": \"\",\n      \"&supdsub;\": \"\",\n      \"&supe;\": \"\",\n      \"&supedot;\": \"\",\n      \"&suphsol;\": \"\",\n      \"&suphsub;\": \"\",\n      \"&suplarr;\": \"\",\n      \"&supmult;\": \"\",\n      \"&supnE;\": \"\",\n      \"&supne;\": \"\",\n      \"&supplus;\": \"\",\n      \"&supset;\": \"\",\n      \"&supseteq;\": \"\",\n      \"&supseteqq;\": \"\",\n      \"&supsetneq;\": \"\",\n      \"&supsetneqq;\": \"\",\n      \"&supsim;\": \"\",\n      \"&supsub;\": \"\",\n      \"&supsup;\": \"\",\n      \"&swArr;\": \"\",\n      \"&swarhk;\": \"\",\n      \"&swarr;\": \"\",\n      \"&swarrow;\": \"\",\n      \"&swnwar;\": \"\",\n      \"&szlig\": \"\",\n      \"&szlig;\": \"\",\n      \"&target;\": \"\",\n      \"&tau;\": \"\",\n      \"&tbrk;\": \"\",\n      \"&tcaron;\": \"\",\n      \"&tcedil;\": \"\",\n      \"&tcy;\": \"\",\n      \"&tdot;\": \"\",\n      \"&telrec;\": \"\",\n      \"&tfr;\": \"\",\n      \"&there4;\": \"\",\n      \"&therefore;\": \"\",\n      \"&theta;\": \"\",\n      \"&thetasym;\": \"\",\n      \"&thetav;\": \"\",\n      \"&thickapprox;\": \"\",\n      \"&thicksim;\": \"\",\n      \"&thinsp;\": \"\",\n      \"&thkap;\": \"\",\n      \"&thksim;\": \"\",\n      \"&thorn\": \"\",\n      \"&thorn;\": \"\",\n      \"&tilde;\": \"\",\n      \"&times\": \"\",\n      \"&times;\": \"\",\n      \"&timesb;\": \"\",\n      \"&timesbar;\": \"\",\n      \"&timesd;\": \"\",\n      \"&tint;\": \"\",\n      \"&toea;\": \"\",\n      \"&top;\": \"\",\n      \"&topbot;\": \"\",\n      \"&topcir;\": \"\",\n      \"&topf;\": \"\",\n      \"&topfork;\": \"\",\n      \"&tosa;\": \"\",\n      \"&tprime;\": \"\",\n      \"&trade;\": \"\",\n      \"&triangle;\": \"\",\n      \"&triangledown;\": \"\",\n      \"&triangleleft;\": \"\",\n      \"&trianglelefteq;\": \"\",\n      \"&triangleq;\": \"\",\n      \"&triangleright;\": \"\",\n      \"&trianglerighteq;\": \"\",\n      \"&tridot;\": \"\",\n      \"&trie;\": \"\",\n      \"&triminus;\": \"\",\n      \"&triplus;\": \"\",\n      \"&trisb;\": \"\",\n      \"&tritime;\": \"\",\n      \"&trpezium;\": \"\",\n      \"&tscr;\": \"\",\n      \"&tscy;\": \"\",\n      \"&tshcy;\": \"\",\n      \"&tstrok;\": \"\",\n      \"&twixt;\": \"\",\n      \"&twoheadleftarrow;\": \"\",\n      \"&twoheadrightarrow;\": \"\",\n      \"&uArr;\": \"\",\n      \"&uHar;\": \"\",\n      \"&uacute\": \"\",\n      \"&uacute;\": \"\",\n      \"&uarr;\": \"\",\n      \"&ubrcy;\": \"\",\n      \"&ubreve;\": \"\",\n      \"&ucirc\": \"\",\n      \"&ucirc;\": \"\",\n      \"&ucy;\": \"\",\n      \"&udarr;\": \"\",\n      \"&udblac;\": \"\",\n      \"&udhar;\": \"\",\n      \"&ufisht;\": \"\",\n      \"&ufr;\": \"\",\n      \"&ugrave\": \"\",\n      \"&ugrave;\": \"\",\n      \"&uharl;\": \"\",\n      \"&uharr;\": \"\",\n      \"&uhblk;\": \"\",\n      \"&ulcorn;\": \"\",\n      \"&ulcorner;\": \"\",\n      \"&ulcrop;\": \"\",\n      \"&ultri;\": \"\",\n      \"&umacr;\": \"\",\n      \"&uml\": \"\",\n      \"&uml;\": \"\",\n      \"&uogon;\": \"\",\n      \"&uopf;\": \"\",\n      \"&uparrow;\": \"\",\n      \"&updownarrow;\": \"\",\n      \"&upharpoonleft;\": \"\",\n      \"&upharpoonright;\": \"\",\n      \"&uplus;\": \"\",\n      \"&upsi;\": \"\",\n      \"&upsih;\": \"\",\n      \"&upsilon;\": \"\",\n      \"&upuparrows;\": \"\",\n      \"&urcorn;\": \"\",\n      \"&urcorner;\": \"\",\n      \"&urcrop;\": \"\",\n      \"&uring;\": \"\",\n      \"&urtri;\": \"\",\n      \"&uscr;\": \"\",\n      \"&utdot;\": \"\",\n      \"&utilde;\": \"\",\n      \"&utri;\": \"\",\n      \"&utrif;\": \"\",\n      \"&uuarr;\": \"\",\n      \"&uuml\": \"\",\n      \"&uuml;\": \"\",\n      \"&uwangle;\": \"\",\n      \"&vArr;\": \"\",\n      \"&vBar;\": \"\",\n      \"&vBarv;\": \"\",\n      \"&vDash;\": \"\",\n      \"&vangrt;\": \"\",\n      \"&varepsilon;\": \"\",\n      \"&varkappa;\": \"\",\n      \"&varnothing;\": \"\",\n      \"&varphi;\": \"\",\n      \"&varpi;\": \"\",\n      \"&varpropto;\": \"\",\n      \"&varr;\": \"\",\n      \"&varrho;\": \"\",\n      \"&varsigma;\": \"\",\n      \"&varsubsetneq;\": \"\",\n      \"&varsubsetneqq;\": \"\",\n      \"&varsupsetneq;\": \"\",\n      \"&varsupsetneqq;\": \"\",\n      \"&vartheta;\": \"\",\n      \"&vartriangleleft;\": \"\",\n      \"&vartriangleright;\": \"\",\n      \"&vcy;\": \"\",\n      \"&vdash;\": \"\",\n      \"&vee;\": \"\",\n      \"&veebar;\": \"\",\n      \"&veeeq;\": \"\",\n      \"&vellip;\": \"\",\n      \"&verbar;\": \"|\",\n      \"&vert;\": \"|\",\n      \"&vfr;\": \"\",\n      \"&vltri;\": \"\",\n      \"&vnsub;\": \"\",\n      \"&vnsup;\": \"\",\n      \"&vopf;\": \"\",\n      \"&vprop;\": \"\",\n      \"&vrtri;\": \"\",\n      \"&vscr;\": \"\",\n      \"&vsubnE;\": \"\",\n      \"&vsubne;\": \"\",\n      \"&vsupnE;\": \"\",\n      \"&vsupne;\": \"\",\n      \"&vzigzag;\": \"\",\n      \"&wcirc;\": \"\",\n      \"&wedbar;\": \"\",\n      \"&wedge;\": \"\",\n      \"&wedgeq;\": \"\",\n      \"&weierp;\": \"\",\n      \"&wfr;\": \"\",\n      \"&wopf;\": \"\",\n      \"&wp;\": \"\",\n      \"&wr;\": \"\",\n      \"&wreath;\": \"\",\n      \"&wscr;\": \"\",\n      \"&xcap;\": \"\",\n      \"&xcirc;\": \"\",\n      \"&xcup;\": \"\",\n      \"&xdtri;\": \"\",\n      \"&xfr;\": \"\",\n      \"&xhArr;\": \"\",\n      \"&xharr;\": \"\",\n      \"&xi;\": \"\",\n      \"&xlArr;\": \"\",\n      \"&xlarr;\": \"\",\n      \"&xmap;\": \"\",\n      \"&xnis;\": \"\",\n      \"&xodot;\": \"\",\n      \"&xopf;\": \"\",\n      \"&xoplus;\": \"\",\n      \"&xotime;\": \"\",\n      \"&xrArr;\": \"\",\n      \"&xrarr;\": \"\",\n      \"&xscr;\": \"\",\n      \"&xsqcup;\": \"\",\n      \"&xuplus;\": \"\",\n      \"&xutri;\": \"\",\n      \"&xvee;\": \"\",\n      \"&xwedge;\": \"\",\n      \"&yacute\": \"\",\n      \"&yacute;\": \"\",\n      \"&yacy;\": \"\",\n      \"&ycirc;\": \"\",\n      \"&ycy;\": \"\",\n      \"&yen\": \"\",\n      \"&yen;\": \"\",\n      \"&yfr;\": \"\",\n      \"&yicy;\": \"\",\n      \"&yopf;\": \"\",\n      \"&yscr;\": \"\",\n      \"&yucy;\": \"\",\n      \"&yuml\": \"\",\n      \"&yuml;\": \"\",\n      \"&zacute;\": \"\",\n      \"&zcaron;\": \"\",\n      \"&zcy;\": \"\",\n      \"&zdot;\": \"\",\n      \"&zeetrf;\": \"\",\n      \"&zeta;\": \"\",\n      \"&zfr;\": \"\",\n      \"&zhcy;\": \"\",\n      \"&zigrarr;\": \"\",\n      \"&zopf;\": \"\",\n      \"&zscr;\": \"\",\n      \"&zwj;\": \"\",\n      \"&zwnj;\": \"\"\n    },\n    characters: {\n      \"\": \"&AElig;\",\n      \"&\": \"&amp;\",\n      \"\": \"&Aacute;\",\n      \"\": \"&Abreve;\",\n      \"\": \"&Acirc;\",\n      \"\": \"&Acy;\",\n      \"\": \"&Afr;\",\n      \"\": \"&Agrave;\",\n      \"\": \"&Alpha;\",\n      \"\": \"&Amacr;\",\n      \"\": \"&And;\",\n      \"\": \"&Aogon;\",\n      \"\": \"&Aopf;\",\n      \"\": \"&af;\",\n      \"\": \"&angst;\",\n      \"\": \"&Ascr;\",\n      \"\": \"&coloneq;\",\n      \"\": \"&Atilde;\",\n      \"\": \"&Auml;\",\n      \"\": \"&ssetmn;\",\n      \"\": \"&Barv;\",\n      \"\": \"&doublebarwedge;\",\n      \"\": \"&Bcy;\",\n      \"\": \"&because;\",\n      \"\": \"&bernou;\",\n      \"\": \"&Beta;\",\n      \"\": \"&Bfr;\",\n      \"\": \"&Bopf;\",\n      \"\": \"&breve;\",\n      \"\": \"&bump;\",\n      \"\": \"&CHcy;\",\n      \"\": \"&copy;\",\n      \"\": \"&Cacute;\",\n      \"\": \"&Cap;\",\n      \"\": \"&DD;\",\n      \"\": \"&Cfr;\",\n      \"\": \"&Ccaron;\",\n      \"\": \"&Ccedil;\",\n      \"\": \"&Ccirc;\",\n      \"\": \"&Cconint;\",\n      \"\": \"&Cdot;\",\n      \"\": \"&cedil;\",\n      \"\": \"&middot;\",\n      \"\": \"&Chi;\",\n      \"\": \"&odot;\",\n      \"\": \"&ominus;\",\n      \"\": \"&oplus;\",\n      \"\": \"&otimes;\",\n      \"\": \"&cwconint;\",\n      \"\": \"&rdquor;\",\n      \"\": \"&rsquor;\",\n      \"\": \"&Proportion;\",\n      \"\": \"&Colone;\",\n      \"\": \"&equiv;\",\n      \"\": \"&DoubleContourIntegral;\",\n      \"\": \"&oint;\",\n      \"\": \"&complexes;\",\n      \"\": \"&coprod;\",\n      \"\": \"&awconint;\",\n      \"\": \"&Cross;\",\n      \"\": \"&Cscr;\",\n      \"\": \"&Cup;\",\n      \"\": \"&asympeq;\",\n      \"\": \"&DDotrahd;\",\n      \"\": \"&DJcy;\",\n      \"\": \"&DScy;\",\n      \"\": \"&DZcy;\",\n      \"\": \"&ddagger;\",\n      \"\": \"&Darr;\",\n      \"\": \"&DoubleLeftTee;\",\n      \"\": \"&Dcaron;\",\n      \"\": \"&Dcy;\",\n      \"\": \"&nabla;\",\n      \"\": \"&Delta;\",\n      \"\": \"&Dfr;\",\n      \"\": \"&acute;\",\n      \"\": \"&dot;\",\n      \"\": \"&dblac;\",\n      \"`\": \"&grave;\",\n      \"\": \"&tilde;\",\n      \"\": \"&diamond;\",\n      \"\": \"&dd;\",\n      \"\": \"&Dopf;\",\n      \"\": \"&uml;\",\n      \"\": \"&DotDot;\",\n      \"\": \"&esdot;\",\n      \"\": \"&dArr;\",\n      \"\": \"&lArr;\",\n      \"\": \"&iff;\",\n      \"\": \"&xlArr;\",\n      \"\": \"&xhArr;\",\n      \"\": \"&xrArr;\",\n      \"\": \"&rArr;\",\n      \"\": \"&vDash;\",\n      \"\": \"&uArr;\",\n      \"\": \"&vArr;\",\n      \"\": \"&spar;\",\n      \"\": \"&downarrow;\",\n      \"\": \"&DownArrowBar;\",\n      \"\": \"&duarr;\",\n      \"\": \"&DownBreve;\",\n      \"\": \"&DownLeftRightVector;\",\n      \"\": \"&DownLeftTeeVector;\",\n      \"\": \"&lhard;\",\n      \"\": \"&DownLeftVectorBar;\",\n      \"\": \"&DownRightTeeVector;\",\n      \"\": \"&rightharpoondown;\",\n      \"\": \"&DownRightVectorBar;\",\n      \"\": \"&top;\",\n      \"\": \"&mapstodown;\",\n      \"\": \"&Dscr;\",\n      \"\": \"&Dstrok;\",\n      \"\": \"&ENG;\",\n      \"\": \"&ETH;\",\n      \"\": \"&Eacute;\",\n      \"\": \"&Ecaron;\",\n      \"\": \"&Ecirc;\",\n      \"\": \"&Ecy;\",\n      \"\": \"&Edot;\",\n      \"\": \"&Efr;\",\n      \"\": \"&Egrave;\",\n      \"\": \"&isinv;\",\n      \"\": \"&Emacr;\",\n      \"\": \"&EmptySmallSquare;\",\n      \"\": \"&EmptyVerySmallSquare;\",\n      \"\": \"&Eogon;\",\n      \"\": \"&Eopf;\",\n      \"\": \"&Epsilon;\",\n      \"\": \"&Equal;\",\n      \"\": \"&esim;\",\n      \"\": \"&rlhar;\",\n      \"\": \"&expectation;\",\n      \"\": \"&Esim;\",\n      \"\": \"&Eta;\",\n      \"\": \"&Euml;\",\n      \"\": \"&exist;\",\n      \"\": \"&exponentiale;\",\n      \"\": \"&Fcy;\",\n      \"\": \"&Ffr;\",\n      \"\": \"&FilledSmallSquare;\",\n      \"\": \"&squf;\",\n      \"\": \"&Fopf;\",\n      \"\": \"&forall;\",\n      \"\": \"&Fscr;\",\n      \"\": \"&GJcy;\",\n      \">\": \"&gt;\",\n      \"\": \"&Gamma;\",\n      \"\": \"&Gammad;\",\n      \"\": \"&Gbreve;\",\n      \"\": \"&Gcedil;\",\n      \"\": \"&Gcirc;\",\n      \"\": \"&Gcy;\",\n      \"\": \"&Gdot;\",\n      \"\": \"&Gfr;\",\n      \"\": \"&ggg;\",\n      \"\": \"&Gopf;\",\n      \"\": \"&geq;\",\n      \"\": \"&gtreqless;\",\n      \"\": \"&geqq;\",\n      \"\": \"&GreaterGreater;\",\n      \"\": \"&gtrless;\",\n      \"\": \"&ges;\",\n      \"\": \"&gtrsim;\",\n      \"\": \"&Gscr;\",\n      \"\": \"&gg;\",\n      \"\": \"&HARDcy;\",\n      \"\": \"&caron;\",\n      \"^\": \"&Hat;\",\n      \"\": \"&Hcirc;\",\n      \"\": \"&Poincareplane;\",\n      \"\": \"&hamilt;\",\n      \"\": \"&quaternions;\",\n      \"\": \"&boxh;\",\n      \"\": \"&Hstrok;\",\n      \"\": \"&bumpeq;\",\n      \"\": \"&IEcy;\",\n      \"\": \"&IJlig;\",\n      \"\": \"&IOcy;\",\n      \"\": \"&Iacute;\",\n      \"\": \"&Icirc;\",\n      \"\": \"&Icy;\",\n      \"\": \"&Idot;\",\n      \"\": \"&imagpart;\",\n      \"\": \"&Igrave;\",\n      \"\": \"&Imacr;\",\n      \"\": \"&ii;\",\n      \"\": \"&Int;\",\n      \"\": \"&int;\",\n      \"\": \"&xcap;\",\n      \"\": \"&ic;\",\n      \"\": \"&it;\",\n      \"\": \"&Iogon;\",\n      \"\": \"&Iopf;\",\n      \"\": \"&Iota;\",\n      \"\": \"&imagline;\",\n      \"\": \"&Itilde;\",\n      \"\": \"&Iukcy;\",\n      \"\": \"&Iuml;\",\n      \"\": \"&Jcirc;\",\n      \"\": \"&Jcy;\",\n      \"\": \"&Jfr;\",\n      \"\": \"&Jopf;\",\n      \"\": \"&Jscr;\",\n      \"\": \"&Jsercy;\",\n      \"\": \"&Jukcy;\",\n      \"\": \"&KHcy;\",\n      \"\": \"&KJcy;\",\n      \"\": \"&Kappa;\",\n      \"\": \"&Kcedil;\",\n      \"\": \"&Kcy;\",\n      \"\": \"&Kfr;\",\n      \"\": \"&Kopf;\",\n      \"\": \"&Kscr;\",\n      \"\": \"&LJcy;\",\n      \"<\": \"&lt;\",\n      \"\": \"&Lacute;\",\n      \"\": \"&Lambda;\",\n      \"\": \"&Lang;\",\n      \"\": \"&lagran;\",\n      \"\": \"&twoheadleftarrow;\",\n      \"\": \"&Lcaron;\",\n      \"\": \"&Lcedil;\",\n      \"\": \"&Lcy;\",\n      \"\": \"&langle;\",\n      \"\": \"&slarr;\",\n      \"\": \"&larrb;\",\n      \"\": \"&lrarr;\",\n      \"\": \"&lceil;\",\n      \"\": \"&lobrk;\",\n      \"\": \"&LeftDownTeeVector;\",\n      \"\": \"&downharpoonleft;\",\n      \"\": \"&LeftDownVectorBar;\",\n      \"\": \"&lfloor;\",\n      \"\": \"&leftrightarrow;\",\n      \"\": \"&LeftRightVector;\",\n      \"\": \"&dashv;\",\n      \"\": \"&mapstoleft;\",\n      \"\": \"&LeftTeeVector;\",\n      \"\": \"&vltri;\",\n      \"\": \"&LeftTriangleBar;\",\n      \"\": \"&trianglelefteq;\",\n      \"\": \"&LeftUpDownVector;\",\n      \"\": \"&LeftUpTeeVector;\",\n      \"\": \"&upharpoonleft;\",\n      \"\": \"&LeftUpVectorBar;\",\n      \"\": \"&lharu;\",\n      \"\": \"&LeftVectorBar;\",\n      \"\": \"&lesseqgtr;\",\n      \"\": \"&leqq;\",\n      \"\": \"&lg;\",\n      \"\": \"&LessLess;\",\n      \"\": \"&les;\",\n      \"\": \"&lsim;\",\n      \"\": \"&Lfr;\",\n      \"\": \"&Ll;\",\n      \"\": \"&lAarr;\",\n      \"\": \"&Lmidot;\",\n      \"\": \"&xlarr;\",\n      \"\": \"&xharr;\",\n      \"\": \"&xrarr;\",\n      \"\": \"&Lopf;\",\n      \"\": \"&swarrow;\",\n      \"\": \"&searrow;\",\n      \"\": \"&lsh;\",\n      \"\": \"&Lstrok;\",\n      \"\": \"&ll;\",\n      \"\": \"&Map;\",\n      \"\": \"&Mcy;\",\n      \"\": \"&MediumSpace;\",\n      \"\": \"&phmmat;\",\n      \"\": \"&Mfr;\",\n      \"\": \"&mp;\",\n      \"\": \"&Mopf;\",\n      \"\": \"&Mu;\",\n      \"\": \"&NJcy;\",\n      \"\": \"&Nacute;\",\n      \"\": \"&Ncaron;\",\n      \"\": \"&Ncedil;\",\n      \"\": \"&Ncy;\",\n      \"\": \"&ZeroWidthSpace;\",\n      \"\\n\": \"&NewLine;\",\n      \"\": \"&Nfr;\",\n      \"\": \"&NoBreak;\",\n      \"\": \"&nbsp;\",\n      \"\": \"&naturals;\",\n      \"\": \"&Not;\",\n      \"\": \"&nequiv;\",\n      \"\": \"&NotCupCap;\",\n      \"\": \"&nspar;\",\n      \"\": \"&notinva;\",\n      \"\": \"&ne;\",\n      \"\": \"&nesim;\",\n      \"\": \"&nexists;\",\n      \"\": \"&ngtr;\",\n      \"\": \"&ngeq;\",\n      \"\": \"&ngeqq;\",\n      \"\": \"&nGtv;\",\n      \"\": \"&ntgl;\",\n      \"\": \"&nges;\",\n      \"\": \"&ngsim;\",\n      \"\": \"&nbump;\",\n      \"\": \"&nbumpe;\",\n      \"\": \"&ntriangleleft;\",\n      \"\": \"&NotLeftTriangleBar;\",\n      \"\": \"&ntrianglelefteq;\",\n      \"\": \"&nlt;\",\n      \"\": \"&nleq;\",\n      \"\": \"&ntlg;\",\n      \"\": \"&nLtv;\",\n      \"\": \"&nles;\",\n      \"\": \"&nlsim;\",\n      \"\": \"&NotNestedGreaterGreater;\",\n      \"\": \"&NotNestedLessLess;\",\n      \"\": \"&nprec;\",\n      \"\": \"&npreceq;\",\n      \"\": \"&nprcue;\",\n      \"\": \"&notniva;\",\n      \"\": \"&ntriangleright;\",\n      \"\": \"&NotRightTriangleBar;\",\n      \"\": \"&ntrianglerighteq;\",\n      \"\": \"&NotSquareSubset;\",\n      \"\": \"&nsqsube;\",\n      \"\": \"&NotSquareSuperset;\",\n      \"\": \"&nsqsupe;\",\n      \"\": \"&vnsub;\",\n      \"\": \"&nsubseteq;\",\n      \"\": \"&nsucc;\",\n      \"\": \"&nsucceq;\",\n      \"\": \"&nsccue;\",\n      \"\": \"&NotSucceedsTilde;\",\n      \"\": \"&vnsup;\",\n      \"\": \"&nsupseteq;\",\n      \"\": \"&nsim;\",\n      \"\": \"&nsimeq;\",\n      \"\": \"&ncong;\",\n      \"\": \"&napprox;\",\n      \"\": \"&nsmid;\",\n      \"\": \"&Nscr;\",\n      \"\": \"&Ntilde;\",\n      \"\": \"&Nu;\",\n      \"\": \"&OElig;\",\n      \"\": \"&Oacute;\",\n      \"\": \"&Ocirc;\",\n      \"\": \"&Ocy;\",\n      \"\": \"&Odblac;\",\n      \"\": \"&Ofr;\",\n      \"\": \"&Ograve;\",\n      \"\": \"&Omacr;\",\n      \"\": \"&ohm;\",\n      \"\": \"&Omicron;\",\n      \"\": \"&Oopf;\",\n      \"\": \"&ldquo;\",\n      \"\": \"&lsquo;\",\n      \"\": \"&Or;\",\n      \"\": \"&Oscr;\",\n      \"\": \"&Oslash;\",\n      \"\": \"&Otilde;\",\n      \"\": \"&Otimes;\",\n      \"\": \"&Ouml;\",\n      \"\": \"&oline;\",\n      \"\": \"&OverBrace;\",\n      \"\": \"&tbrk;\",\n      \"\": \"&OverParenthesis;\",\n      \"\": \"&part;\",\n      \"\": \"&Pcy;\",\n      \"\": \"&Pfr;\",\n      \"\": \"&Phi;\",\n      \"\": \"&Pi;\",\n      \"\": \"&pm;\",\n      \"\": \"&primes;\",\n      \"\": \"&Pr;\",\n      \"\": \"&prec;\",\n      \"\": \"&preceq;\",\n      \"\": \"&preccurlyeq;\",\n      \"\": \"&prsim;\",\n      \"\": \"&Prime;\",\n      \"\": \"&prod;\",\n      \"\": \"&vprop;\",\n      \"\": \"&Pscr;\",\n      \"\": \"&Psi;\",\n      '\"': \"&quot;\",\n      \"\": \"&Qfr;\",\n      \"\": \"&rationals;\",\n      \"\": \"&Qscr;\",\n      \"\": \"&drbkarow;\",\n      \"\": \"&reg;\",\n      \"\": \"&Racute;\",\n      \"\": \"&Rang;\",\n      \"\": \"&twoheadrightarrow;\",\n      \"\": \"&Rarrtl;\",\n      \"\": \"&Rcaron;\",\n      \"\": \"&Rcedil;\",\n      \"\": \"&Rcy;\",\n      \"\": \"&realpart;\",\n      \"\": \"&niv;\",\n      \"\": \"&lrhar;\",\n      \"\": \"&duhar;\",\n      \"\": \"&Rho;\",\n      \"\": \"&rangle;\",\n      \"\": \"&srarr;\",\n      \"\": \"&rarrb;\",\n      \"\": \"&rlarr;\",\n      \"\": \"&rceil;\",\n      \"\": \"&robrk;\",\n      \"\": \"&RightDownTeeVector;\",\n      \"\": \"&downharpoonright;\",\n      \"\": \"&RightDownVectorBar;\",\n      \"\": \"&rfloor;\",\n      \"\": \"&vdash;\",\n      \"\": \"&mapsto;\",\n      \"\": \"&RightTeeVector;\",\n      \"\": \"&vrtri;\",\n      \"\": \"&RightTriangleBar;\",\n      \"\": \"&trianglerighteq;\",\n      \"\": \"&RightUpDownVector;\",\n      \"\": \"&RightUpTeeVector;\",\n      \"\": \"&upharpoonright;\",\n      \"\": \"&RightUpVectorBar;\",\n      \"\": \"&rightharpoonup;\",\n      \"\": \"&RightVectorBar;\",\n      \"\": \"&reals;\",\n      \"\": \"&RoundImplies;\",\n      \"\": \"&rAarr;\",\n      \"\": \"&realine;\",\n      \"\": \"&rsh;\",\n      \"\": \"&RuleDelayed;\",\n      \"\": \"&SHCHcy;\",\n      \"\": \"&SHcy;\",\n      \"\": \"&SOFTcy;\",\n      \"\": \"&Sacute;\",\n      \"\": \"&Sc;\",\n      \"\": \"&Scaron;\",\n      \"\": \"&Scedil;\",\n      \"\": \"&Scirc;\",\n      \"\": \"&Scy;\",\n      \"\": \"&Sfr;\",\n      \"\": \"&uparrow;\",\n      \"\": \"&Sigma;\",\n      \"\": \"&compfn;\",\n      \"\": \"&Sopf;\",\n      \"\": \"&radic;\",\n      \"\": \"&square;\",\n      \"\": \"&sqcap;\",\n      \"\": \"&sqsubset;\",\n      \"\": \"&sqsubseteq;\",\n      \"\": \"&sqsupset;\",\n      \"\": \"&sqsupseteq;\",\n      \"\": \"&sqcup;\",\n      \"\": \"&Sscr;\",\n      \"\": \"&sstarf;\",\n      \"\": \"&Subset;\",\n      \"\": \"&subseteq;\",\n      \"\": \"&succ;\",\n      \"\": \"&succeq;\",\n      \"\": \"&succcurlyeq;\",\n      \"\": \"&succsim;\",\n      \"\": \"&sum;\",\n      \"\": \"&Supset;\",\n      \"\": \"&supset;\",\n      \"\": \"&supseteq;\",\n      \"\": \"&THORN;\",\n      \"\": \"&trade;\",\n      \"\": \"&TSHcy;\",\n      \"\": \"&TScy;\",\n      \"\\t\": \"&Tab;\",\n      \"\": \"&Tau;\",\n      \"\": \"&Tcaron;\",\n      \"\": \"&Tcedil;\",\n      \"\": \"&Tcy;\",\n      \"\": \"&Tfr;\",\n      \"\": \"&therefore;\",\n      \"\": \"&Theta;\",\n      \"\": \"&ThickSpace;\",\n      \"\": \"&thinsp;\",\n      \"\": \"&thksim;\",\n      \"\": \"&simeq;\",\n      \"\": \"&cong;\",\n      \"\": \"&thkap;\",\n      \"\": \"&Topf;\",\n      \"\": \"&tdot;\",\n      \"\": \"&Tscr;\",\n      \"\": \"&Tstrok;\",\n      \"\": \"&Uacute;\",\n      \"\": \"&Uarr;\",\n      \"\": \"&Uarrocir;\",\n      \"\": \"&Ubrcy;\",\n      \"\": \"&Ubreve;\",\n      \"\": \"&Ucirc;\",\n      \"\": \"&Ucy;\",\n      \"\": \"&Udblac;\",\n      \"\": \"&Ufr;\",\n      \"\": \"&Ugrave;\",\n      \"\": \"&Umacr;\",\n      _: \"&lowbar;\",\n      \"\": \"&UnderBrace;\",\n      \"\": \"&bbrk;\",\n      \"\": \"&UnderParenthesis;\",\n      \"\": \"&xcup;\",\n      \"\": \"&uplus;\",\n      \"\": \"&Uogon;\",\n      \"\": \"&Uopf;\",\n      \"\": \"&UpArrowBar;\",\n      \"\": \"&udarr;\",\n      \"\": \"&varr;\",\n      \"\": \"&udhar;\",\n      \"\": \"&perp;\",\n      \"\": \"&mapstoup;\",\n      \"\": \"&nwarrow;\",\n      \"\": \"&nearrow;\",\n      \"\": \"&upsih;\",\n      \"\": \"&Upsilon;\",\n      \"\": \"&Uring;\",\n      \"\": \"&Uscr;\",\n      \"\": \"&Utilde;\",\n      \"\": \"&Uuml;\",\n      \"\": \"&VDash;\",\n      \"\": \"&Vbar;\",\n      \"\": \"&Vcy;\",\n      \"\": \"&Vdash;\",\n      \"\": \"&Vdashl;\",\n      \"\": \"&xvee;\",\n      \"\": \"&Vert;\",\n      \"\": \"&smid;\",\n      \"|\": \"&vert;\",\n      \"\": \"&VerticalSeparator;\",\n      \"\": \"&wreath;\",\n      \"\": \"&hairsp;\",\n      \"\": \"&Vfr;\",\n      \"\": \"&Vopf;\",\n      \"\": \"&Vscr;\",\n      \"\": \"&Vvdash;\",\n      \"\": \"&Wcirc;\",\n      \"\": \"&xwedge;\",\n      \"\": \"&Wfr;\",\n      \"\": \"&Wopf;\",\n      \"\": \"&Wscr;\",\n      \"\": \"&Xfr;\",\n      \"\": \"&Xi;\",\n      \"\": \"&Xopf;\",\n      \"\": \"&Xscr;\",\n      \"\": \"&YAcy;\",\n      \"\": \"&YIcy;\",\n      \"\": \"&YUcy;\",\n      \"\": \"&Yacute;\",\n      \"\": \"&Ycirc;\",\n      \"\": \"&Ycy;\",\n      \"\": \"&Yfr;\",\n      \"\": \"&Yopf;\",\n      \"\": \"&Yscr;\",\n      \"\": \"&Yuml;\",\n      \"\": \"&ZHcy;\",\n      \"\": \"&Zacute;\",\n      \"\": \"&Zcaron;\",\n      \"\": \"&Zcy;\",\n      \"\": \"&Zdot;\",\n      \"\": \"&Zeta;\",\n      \"\": \"&zeetrf;\",\n      \"\": \"&integers;\",\n      \"\": \"&Zscr;\",\n      \"\": \"&aacute;\",\n      \"\": \"&abreve;\",\n      \"\": \"&mstpos;\",\n      \"\": \"&acE;\",\n      \"\": \"&acd;\",\n      \"\": \"&acirc;\",\n      \"\": \"&acy;\",\n      \"\": \"&aelig;\",\n      \"\": \"&afr;\",\n      \"\": \"&agrave;\",\n      \"\": \"&aleph;\",\n      \"\": \"&alpha;\",\n      \"\": \"&amacr;\",\n      \"\": \"&amalg;\",\n      \"\": \"&wedge;\",\n      \"\": \"&andand;\",\n      \"\": \"&andd;\",\n      \"\": \"&andslope;\",\n      \"\": \"&andv;\",\n      \"\": \"&angle;\",\n      \"\": \"&ange;\",\n      \"\": \"&measuredangle;\",\n      \"\": \"&angmsdaa;\",\n      \"\": \"&angmsdab;\",\n      \"\": \"&angmsdac;\",\n      \"\": \"&angmsdad;\",\n      \"\": \"&angmsdae;\",\n      \"\": \"&angmsdaf;\",\n      \"\": \"&angmsdag;\",\n      \"\": \"&angmsdah;\",\n      \"\": \"&angrt;\",\n      \"\": \"&angrtvb;\",\n      \"\": \"&angrtvbd;\",\n      \"\": \"&angsph;\",\n      \"\": \"&angzarr;\",\n      \"\": \"&aogon;\",\n      \"\": \"&aopf;\",\n      \"\": \"&apE;\",\n      \"\": \"&apacir;\",\n      \"\": \"&approxeq;\",\n      \"\": \"&apid;\",\n      \"'\": \"&apos;\",\n      \"\": \"&aring;\",\n      \"\": \"&ascr;\",\n      \"*\": \"&midast;\",\n      \"\": \"&atilde;\",\n      \"\": \"&auml;\",\n      \"\": \"&awint;\",\n      \"\": \"&bNot;\",\n      \"\": \"&bcong;\",\n      \"\": \"&bepsi;\",\n      \"\": \"&bprime;\",\n      \"\": \"&bsim;\",\n      \"\": \"&bsime;\",\n      \"\": \"&barvee;\",\n      \"\": \"&barwedge;\",\n      \"\": \"&bbrktbrk;\",\n      \"\": \"&bcy;\",\n      \"\": \"&ldquor;\",\n      \"\": \"&bemptyv;\",\n      \"\": \"&beta;\",\n      \"\": \"&beth;\",\n      \"\": \"&twixt;\",\n      \"\": \"&bfr;\",\n      \"\": \"&xcirc;\",\n      \"\": \"&xodot;\",\n      \"\": \"&xoplus;\",\n      \"\": \"&xotime;\",\n      \"\": \"&xsqcup;\",\n      \"\": \"&starf;\",\n      \"\": \"&xdtri;\",\n      \"\": \"&xutri;\",\n      \"\": \"&xuplus;\",\n      \"\": \"&rbarr;\",\n      \"\": \"&lozf;\",\n      \"\": \"&utrif;\",\n      \"\": \"&dtrif;\",\n      \"\": \"&ltrif;\",\n      \"\": \"&rtrif;\",\n      \"\": \"&blank;\",\n      \"\": \"&blk12;\",\n      \"\": \"&blk14;\",\n      \"\": \"&blk34;\",\n      \"\": \"&block;\",\n      \"=\": \"&bne;\",\n      \"\": \"&bnequiv;\",\n      \"\": \"&bnot;\",\n      \"\": \"&bopf;\",\n      \"\": \"&bowtie;\",\n      \"\": \"&boxDL;\",\n      \"\": \"&boxDR;\",\n      \"\": \"&boxDl;\",\n      \"\": \"&boxDr;\",\n      \"\": \"&boxH;\",\n      \"\": \"&boxHD;\",\n      \"\": \"&boxHU;\",\n      \"\": \"&boxHd;\",\n      \"\": \"&boxHu;\",\n      \"\": \"&boxUL;\",\n      \"\": \"&boxUR;\",\n      \"\": \"&boxUl;\",\n      \"\": \"&boxUr;\",\n      \"\": \"&boxV;\",\n      \"\": \"&boxVH;\",\n      \"\": \"&boxVL;\",\n      \"\": \"&boxVR;\",\n      \"\": \"&boxVh;\",\n      \"\": \"&boxVl;\",\n      \"\": \"&boxVr;\",\n      \"\": \"&boxbox;\",\n      \"\": \"&boxdL;\",\n      \"\": \"&boxdR;\",\n      \"\": \"&boxdl;\",\n      \"\": \"&boxdr;\",\n      \"\": \"&boxhD;\",\n      \"\": \"&boxhU;\",\n      \"\": \"&boxhd;\",\n      \"\": \"&boxhu;\",\n      \"\": \"&minusb;\",\n      \"\": \"&plusb;\",\n      \"\": \"&timesb;\",\n      \"\": \"&boxuL;\",\n      \"\": \"&boxuR;\",\n      \"\": \"&boxul;\",\n      \"\": \"&boxur;\",\n      \"\": \"&boxv;\",\n      \"\": \"&boxvH;\",\n      \"\": \"&boxvL;\",\n      \"\": \"&boxvR;\",\n      \"\": \"&boxvh;\",\n      \"\": \"&boxvl;\",\n      \"\": \"&boxvr;\",\n      \"\": \"&brvbar;\",\n      \"\": \"&bscr;\",\n      \"\": \"&bsemi;\",\n      \"\\\\\": \"&bsol;\",\n      \"\": \"&bsolb;\",\n      \"\": \"&bsolhsub;\",\n      \"\": \"&bullet;\",\n      \"\": \"&bumpE;\",\n      \"\": \"&cacute;\",\n      \"\": \"&cap;\",\n      \"\": \"&capand;\",\n      \"\": \"&capbrcup;\",\n      \"\": \"&capcap;\",\n      \"\": \"&capcup;\",\n      \"\": \"&capdot;\",\n      \"\": \"&caps;\",\n      \"\": \"&caret;\",\n      \"\": \"&ccaps;\",\n      \"\": \"&ccaron;\",\n      \"\": \"&ccedil;\",\n      \"\": \"&ccirc;\",\n      \"\": \"&ccups;\",\n      \"\": \"&ccupssm;\",\n      \"\": \"&cdot;\",\n      \"\": \"&cemptyv;\",\n      \"\": \"&cent;\",\n      \"\": \"&cfr;\",\n      \"\": \"&chcy;\",\n      \"\": \"&checkmark;\",\n      \"\": \"&chi;\",\n      \"\": \"&cir;\",\n      \"\": \"&cirE;\",\n      \"\": \"&circ;\",\n      \"\": \"&cire;\",\n      \"\": \"&olarr;\",\n      \"\": \"&orarr;\",\n      \"\": \"&oS;\",\n      \"\": \"&oast;\",\n      \"\": \"&ocir;\",\n      \"\": \"&odash;\",\n      \"\": \"&cirfnint;\",\n      \"\": \"&cirmid;\",\n      \"\": \"&cirscir;\",\n      \"\": \"&clubsuit;\",\n      \":\": \"&colon;\",\n      \",\": \"&comma;\",\n      \"@\": \"&commat;\",\n      \"\": \"&complement;\",\n      \"\": \"&congdot;\",\n      \"\": \"&copf;\",\n      \"\": \"&copysr;\",\n      \"\": \"&crarr;\",\n      \"\": \"&cross;\",\n      \"\": \"&cscr;\",\n      \"\": \"&csub;\",\n      \"\": \"&csube;\",\n      \"\": \"&csup;\",\n      \"\": \"&csupe;\",\n      \"\": \"&ctdot;\",\n      \"\": \"&cudarrl;\",\n      \"\": \"&cudarrr;\",\n      \"\": \"&curlyeqprec;\",\n      \"\": \"&curlyeqsucc;\",\n      \"\": \"&curvearrowleft;\",\n      \"\": \"&cularrp;\",\n      \"\": \"&cup;\",\n      \"\": \"&cupbrcap;\",\n      \"\": \"&cupcap;\",\n      \"\": \"&cupcup;\",\n      \"\": \"&cupdot;\",\n      \"\": \"&cupor;\",\n      \"\": \"&cups;\",\n      \"\": \"&curvearrowright;\",\n      \"\": \"&curarrm;\",\n      \"\": \"&cuvee;\",\n      \"\": \"&cuwed;\",\n      \"\": \"&curren;\",\n      \"\": \"&cwint;\",\n      \"\": \"&cylcty;\",\n      \"\": \"&dHar;\",\n      \"\": \"&dagger;\",\n      \"\": \"&daleth;\",\n      \"\": \"&hyphen;\",\n      \"\": \"&rBarr;\",\n      \"\": \"&dcaron;\",\n      \"\": \"&dcy;\",\n      \"\": \"&downdownarrows;\",\n      \"\": \"&eDDot;\",\n      \"\": \"&deg;\",\n      \"\": \"&delta;\",\n      \"\": \"&demptyv;\",\n      \"\": \"&dfisht;\",\n      \"\": \"&dfr;\",\n      \"\": \"&diams;\",\n      \"\": \"&gammad;\",\n      \"\": \"&disin;\",\n      \"\": \"&divide;\",\n      \"\": \"&divonx;\",\n      \"\": \"&djcy;\",\n      \"\": \"&llcorner;\",\n      \"\": \"&dlcrop;\",\n      $: \"&dollar;\",\n      \"\": \"&dopf;\",\n      \"\": \"&eDot;\",\n      \"\": \"&minusd;\",\n      \"\": \"&plusdo;\",\n      \"\": \"&sdotb;\",\n      \"\": \"&lrcorner;\",\n      \"\": \"&drcrop;\",\n      \"\": \"&dscr;\",\n      \"\": \"&dscy;\",\n      \"\": \"&dsol;\",\n      \"\": \"&dstrok;\",\n      \"\": \"&dtdot;\",\n      \"\": \"&triangledown;\",\n      \"\": \"&dwangle;\",\n      \"\": \"&dzcy;\",\n      \"\": \"&dzigrarr;\",\n      \"\": \"&eacute;\",\n      \"\": \"&easter;\",\n      \"\": \"&ecaron;\",\n      \"\": \"&eqcirc;\",\n      \"\": \"&ecirc;\",\n      \"\": \"&eqcolon;\",\n      \"\": \"&ecy;\",\n      \"\": \"&edot;\",\n      \"\": \"&fallingdotseq;\",\n      \"\": \"&efr;\",\n      \"\": \"&eg;\",\n      \"\": \"&egrave;\",\n      \"\": \"&eqslantgtr;\",\n      \"\": \"&egsdot;\",\n      \"\": \"&el;\",\n      \"\": \"&elinters;\",\n      \"\": \"&ell;\",\n      \"\": \"&eqslantless;\",\n      \"\": \"&elsdot;\",\n      \"\": \"&emacr;\",\n      \"\": \"&varnothing;\",\n      \"\": \"&emsp13;\",\n      \"\": \"&emsp14;\",\n      \"\": \"&emsp;\",\n      \"\": \"&eng;\",\n      \"\": \"&ensp;\",\n      \"\": \"&eogon;\",\n      \"\": \"&eopf;\",\n      \"\": \"&epar;\",\n      \"\": \"&eparsl;\",\n      \"\": \"&eplus;\",\n      \"\": \"&epsilon;\",\n      \"\": \"&varepsilon;\",\n      \"=\": \"&equals;\",\n      \"\": \"&questeq;\",\n      \"\": \"&equivDD;\",\n      \"\": \"&eqvparsl;\",\n      \"\": \"&risingdotseq;\",\n      \"\": \"&erarr;\",\n      \"\": \"&escr;\",\n      \"\": \"&eta;\",\n      \"\": \"&eth;\",\n      \"\": \"&euml;\",\n      \"\": \"&euro;\",\n      \"!\": \"&excl;\",\n      \"\": \"&fcy;\",\n      \"\": \"&female;\",\n      \"\": \"&ffilig;\",\n      \"\": \"&fflig;\",\n      \"\": \"&ffllig;\",\n      \"\": \"&ffr;\",\n      \"\": \"&filig;\",\n      fj: \"&fjlig;\",\n      \"\": \"&flat;\",\n      \"\": \"&fllig;\",\n      \"\": \"&fltns;\",\n      \"\": \"&fnof;\",\n      \"\": \"&fopf;\",\n      \"\": \"&pitchfork;\",\n      \"\": \"&forkv;\",\n      \"\": \"&fpartint;\",\n      \"\": \"&half;\",\n      \"\": \"&frac13;\",\n      \"\": \"&frac14;\",\n      \"\": \"&frac15;\",\n      \"\": \"&frac16;\",\n      \"\": \"&frac18;\",\n      \"\": \"&frac23;\",\n      \"\": \"&frac25;\",\n      \"\": \"&frac34;\",\n      \"\": \"&frac35;\",\n      \"\": \"&frac38;\",\n      \"\": \"&frac45;\",\n      \"\": \"&frac56;\",\n      \"\": \"&frac58;\",\n      \"\": \"&frac78;\",\n      \"\": \"&frasl;\",\n      \"\": \"&sfrown;\",\n      \"\": \"&fscr;\",\n      \"\": \"&gtreqqless;\",\n      \"\": \"&gacute;\",\n      \"\": \"&gamma;\",\n      \"\": \"&gtrapprox;\",\n      \"\": \"&gbreve;\",\n      \"\": \"&gcirc;\",\n      \"\": \"&gcy;\",\n      \"\": \"&gdot;\",\n      \"\": \"&gescc;\",\n      \"\": \"&gesdot;\",\n      \"\": \"&gesdoto;\",\n      \"\": \"&gesdotol;\",\n      \"\": \"&gesl;\",\n      \"\": \"&gesles;\",\n      \"\": \"&gfr;\",\n      \"\": \"&gimel;\",\n      \"\": \"&gjcy;\",\n      \"\": \"&glE;\",\n      \"\": \"&gla;\",\n      \"\": \"&glj;\",\n      \"\": \"&gneqq;\",\n      \"\": \"&gnapprox;\",\n      \"\": \"&gneq;\",\n      \"\": \"&gnsim;\",\n      \"\": \"&gopf;\",\n      \"\": \"&gscr;\",\n      \"\": \"&gsime;\",\n      \"\": \"&gsiml;\",\n      \"\": \"&gtcc;\",\n      \"\": \"&gtcir;\",\n      \"\": \"&gtrdot;\",\n      \"\": \"&gtlPar;\",\n      \"\": \"&gtquest;\",\n      \"\": \"&gtrarr;\",\n      \"\": \"&gvnE;\",\n      \"\": \"&hardcy;\",\n      \"\": \"&harrcir;\",\n      \"\": \"&leftrightsquigarrow;\",\n      \"\": \"&plankv;\",\n      \"\": \"&hcirc;\",\n      \"\": \"&heartsuit;\",\n      \"\": \"&mldr;\",\n      \"\": \"&hercon;\",\n      \"\": \"&hfr;\",\n      \"\": \"&searhk;\",\n      \"\": \"&swarhk;\",\n      \"\": \"&hoarr;\",\n      \"\": \"&homtht;\",\n      \"\": \"&larrhk;\",\n      \"\": \"&rarrhk;\",\n      \"\": \"&hopf;\",\n      \"\": \"&horbar;\",\n      \"\": \"&hscr;\",\n      \"\": \"&hstrok;\",\n      \"\": \"&hybull;\",\n      \"\": \"&iacute;\",\n      \"\": \"&icirc;\",\n      \"\": \"&icy;\",\n      \"\": \"&iecy;\",\n      \"\": \"&iexcl;\",\n      \"\": \"&ifr;\",\n      \"\": \"&igrave;\",\n      \"\": \"&qint;\",\n      \"\": \"&tint;\",\n      \"\": \"&iinfin;\",\n      \"\": \"&iiota;\",\n      \"\": \"&ijlig;\",\n      \"\": \"&imacr;\",\n      \"\": \"&inodot;\",\n      \"\": \"&imof;\",\n      \"\": \"&imped;\",\n      \"\": \"&incare;\",\n      \"\": \"&infin;\",\n      \"\": \"&infintie;\",\n      \"\": \"&intercal;\",\n      \"\": \"&intlarhk;\",\n      \"\": \"&iprod;\",\n      \"\": \"&iocy;\",\n      \"\": \"&iogon;\",\n      \"\": \"&iopf;\",\n      \"\": \"&iota;\",\n      \"\": \"&iquest;\",\n      \"\": \"&iscr;\",\n      \"\": \"&isinE;\",\n      \"\": \"&isindot;\",\n      \"\": \"&isins;\",\n      \"\": \"&isinsv;\",\n      \"\": \"&itilde;\",\n      \"\": \"&iukcy;\",\n      \"\": \"&iuml;\",\n      \"\": \"&jcirc;\",\n      \"\": \"&jcy;\",\n      \"\": \"&jfr;\",\n      \"\": \"&jmath;\",\n      \"\": \"&jopf;\",\n      \"\": \"&jscr;\",\n      \"\": \"&jsercy;\",\n      \"\": \"&jukcy;\",\n      \"\": \"&kappa;\",\n      \"\": \"&varkappa;\",\n      \"\": \"&kcedil;\",\n      \"\": \"&kcy;\",\n      \"\": \"&kfr;\",\n      \"\": \"&kgreen;\",\n      \"\": \"&khcy;\",\n      \"\": \"&kjcy;\",\n      \"\": \"&kopf;\",\n      \"\": \"&kscr;\",\n      \"\": \"&lAtail;\",\n      \"\": \"&lBarr;\",\n      \"\": \"&lesseqqgtr;\",\n      \"\": \"&lHar;\",\n      \"\": \"&lacute;\",\n      \"\": \"&laemptyv;\",\n      \"\": \"&lambda;\",\n      \"\": \"&langd;\",\n      \"\": \"&lessapprox;\",\n      \"\": \"&laquo;\",\n      \"\": \"&larrbfs;\",\n      \"\": \"&larrfs;\",\n      \"\": \"&looparrowleft;\",\n      \"\": \"&larrpl;\",\n      \"\": \"&larrsim;\",\n      \"\": \"&leftarrowtail;\",\n      \"\": \"&lat;\",\n      \"\": \"&latail;\",\n      \"\": \"&late;\",\n      \"\": \"&lates;\",\n      \"\": \"&lbarr;\",\n      \"\": \"&lbbrk;\",\n      \"{\": \"&lcub;\",\n      \"[\": \"&lsqb;\",\n      \"\": \"&lbrke;\",\n      \"\": \"&lbrksld;\",\n      \"\": \"&lbrkslu;\",\n      \"\": \"&lcaron;\",\n      \"\": \"&lcedil;\",\n      \"\": \"&lcy;\",\n      \"\": \"&ldca;\",\n      \"\": \"&ldrdhar;\",\n      \"\": \"&ldrushar;\",\n      \"\": \"&ldsh;\",\n      \"\": \"&leq;\",\n      \"\": \"&llarr;\",\n      \"\": \"&lthree;\",\n      \"\": \"&lescc;\",\n      \"\": \"&lesdot;\",\n      \"\": \"&lesdoto;\",\n      \"\": \"&lesdotor;\",\n      \"\": \"&lesg;\",\n      \"\": \"&lesges;\",\n      \"\": \"&ltdot;\",\n      \"\": \"&lfisht;\",\n      \"\": \"&lfr;\",\n      \"\": \"&lgE;\",\n      \"\": \"&lharul;\",\n      \"\": \"&lhblk;\",\n      \"\": \"&ljcy;\",\n      \"\": \"&llhard;\",\n      \"\": \"&lltri;\",\n      \"\": \"&lmidot;\",\n      \"\": \"&lmoustache;\",\n      \"\": \"&lneqq;\",\n      \"\": \"&lnapprox;\",\n      \"\": \"&lneq;\",\n      \"\": \"&lnsim;\",\n      \"\": \"&loang;\",\n      \"\": \"&loarr;\",\n      \"\": \"&xmap;\",\n      \"\": \"&rarrlp;\",\n      \"\": \"&lopar;\",\n      \"\": \"&lopf;\",\n      \"\": \"&loplus;\",\n      \"\": \"&lotimes;\",\n      \"\": \"&lowast;\",\n      \"\": \"&lozenge;\",\n      \"(\": \"&lpar;\",\n      \"\": \"&lparlt;\",\n      \"\": \"&lrhard;\",\n      \"\": \"&lrm;\",\n      \"\": \"&lrtri;\",\n      \"\": \"&lsaquo;\",\n      \"\": \"&lscr;\",\n      \"\": \"&lsime;\",\n      \"\": \"&lsimg;\",\n      \"\": \"&sbquo;\",\n      \"\": \"&lstrok;\",\n      \"\": \"&ltcc;\",\n      \"\": \"&ltcir;\",\n      \"\": \"&ltimes;\",\n      \"\": \"&ltlarr;\",\n      \"\": \"&ltquest;\",\n      \"\": \"&ltrPar;\",\n      \"\": \"&triangleleft;\",\n      \"\": \"&lurdshar;\",\n      \"\": \"&luruhar;\",\n      \"\": \"&lvnE;\",\n      \"\": \"&mDDot;\",\n      \"\": \"&strns;\",\n      \"\": \"&male;\",\n      \"\": \"&maltese;\",\n      \"\": \"&marker;\",\n      \"\": \"&mcomma;\",\n      \"\": \"&mcy;\",\n      \"\": \"&mdash;\",\n      \"\": \"&mfr;\",\n      \"\": \"&mho;\",\n      \"\": \"&micro;\",\n      \"\": \"&midcir;\",\n      \"\": \"&minus;\",\n      \"\": \"&minusdu;\",\n      \"\": \"&mlcp;\",\n      \"\": \"&models;\",\n      \"\": \"&mopf;\",\n      \"\": \"&mscr;\",\n      \"\": \"&mu;\",\n      \"\": \"&mumap;\",\n      \"\": \"&nGg;\",\n      \"\": \"&nGt;\",\n      \"\": \"&nlArr;\",\n      \"\": \"&nhArr;\",\n      \"\": \"&nLl;\",\n      \"\": \"&nLt;\",\n      \"\": \"&nrArr;\",\n      \"\": \"&nVDash;\",\n      \"\": \"&nVdash;\",\n      \"\": \"&nacute;\",\n      \"\": \"&nang;\",\n      \"\": \"&napE;\",\n      \"\": \"&napid;\",\n      \"\": \"&napos;\",\n      \"\": \"&natural;\",\n      \"\": \"&ncap;\",\n      \"\": \"&ncaron;\",\n      \"\": \"&ncedil;\",\n      \"\": \"&ncongdot;\",\n      \"\": \"&ncup;\",\n      \"\": \"&ncy;\",\n      \"\": \"&ndash;\",\n      \"\": \"&neArr;\",\n      \"\": \"&nearhk;\",\n      \"\": \"&nedot;\",\n      \"\": \"&toea;\",\n      \"\": \"&nfr;\",\n      \"\": \"&nleftrightarrow;\",\n      \"\": \"&nhpar;\",\n      \"\": \"&nis;\",\n      \"\": \"&nisd;\",\n      \"\": \"&njcy;\",\n      \"\": \"&nleqq;\",\n      \"\": \"&nleftarrow;\",\n      \"\": \"&nldr;\",\n      \"\": \"&nopf;\",\n      \"\": \"&not;\",\n      \"\": \"&notinE;\",\n      \"\": \"&notindot;\",\n      \"\": \"&notinvb;\",\n      \"\": \"&notinvc;\",\n      \"\": \"&notnivb;\",\n      \"\": \"&notnivc;\",\n      \"\": \"&nparsl;\",\n      \"\": \"&npart;\",\n      \"\": \"&npolint;\",\n      \"\": \"&nrightarrow;\",\n      \"\": \"&nrarrc;\",\n      \"\": \"&nrarrw;\",\n      \"\": \"&nscr;\",\n      \"\": \"&nsub;\",\n      \"\": \"&nsubseteqq;\",\n      \"\": \"&nsup;\",\n      \"\": \"&nsupseteqq;\",\n      \"\": \"&ntilde;\",\n      \"\": \"&nu;\",\n      \"#\": \"&num;\",\n      \"\": \"&numero;\",\n      \"\": \"&numsp;\",\n      \"\": \"&nvDash;\",\n      \"\": \"&nvHarr;\",\n      \"\": \"&nvap;\",\n      \"\": \"&nvdash;\",\n      \"\": \"&nvge;\",\n      \">\": \"&nvgt;\",\n      \"\": \"&nvinfin;\",\n      \"\": \"&nvlArr;\",\n      \"\": \"&nvle;\",\n      \"<\": \"&nvlt;\",\n      \"\": \"&nvltrie;\",\n      \"\": \"&nvrArr;\",\n      \"\": \"&nvrtrie;\",\n      \"\": \"&nvsim;\",\n      \"\": \"&nwArr;\",\n      \"\": \"&nwarhk;\",\n      \"\": \"&nwnear;\",\n      \"\": \"&oacute;\",\n      \"\": \"&ocirc;\",\n      \"\": \"&ocy;\",\n      \"\": \"&odblac;\",\n      \"\": \"&odiv;\",\n      \"\": \"&odsold;\",\n      \"\": \"&oelig;\",\n      \"\": \"&ofcir;\",\n      \"\": \"&ofr;\",\n      \"\": \"&ogon;\",\n      \"\": \"&ograve;\",\n      \"\": \"&ogt;\",\n      \"\": \"&ohbar;\",\n      \"\": \"&olcir;\",\n      \"\": \"&olcross;\",\n      \"\": \"&olt;\",\n      \"\": \"&omacr;\",\n      \"\": \"&omega;\",\n      \"\": \"&omicron;\",\n      \"\": \"&omid;\",\n      \"\": \"&oopf;\",\n      \"\": \"&opar;\",\n      \"\": \"&operp;\",\n      \"\": \"&vee;\",\n      \"\": \"&ord;\",\n      \"\": \"&oscr;\",\n      \"\": \"&ordf;\",\n      \"\": \"&ordm;\",\n      \"\": \"&origof;\",\n      \"\": \"&oror;\",\n      \"\": \"&orslope;\",\n      \"\": \"&orv;\",\n      \"\": \"&oslash;\",\n      \"\": \"&osol;\",\n      \"\": \"&otilde;\",\n      \"\": \"&otimesas;\",\n      \"\": \"&ouml;\",\n      \"\": \"&ovbar;\",\n      \"\": \"&para;\",\n      \"\": \"&parsim;\",\n      \"\": \"&parsl;\",\n      \"\": \"&pcy;\",\n      \"%\": \"&percnt;\",\n      \".\": \"&period;\",\n      \"\": \"&permil;\",\n      \"\": \"&pertenk;\",\n      \"\": \"&pfr;\",\n      \"\": \"&phi;\",\n      \"\": \"&varphi;\",\n      \"\": \"&phone;\",\n      \"\": \"&pi;\",\n      \"\": \"&varpi;\",\n      \"\": \"&planckh;\",\n      \"+\": \"&plus;\",\n      \"\": \"&plusacir;\",\n      \"\": \"&pluscir;\",\n      \"\": \"&plusdu;\",\n      \"\": \"&pluse;\",\n      \"\": \"&plussim;\",\n      \"\": \"&plustwo;\",\n      \"\": \"&pointint;\",\n      \"\": \"&popf;\",\n      \"\": \"&pound;\",\n      \"\": \"&prE;\",\n      \"\": \"&precapprox;\",\n      \"\": \"&prnap;\",\n      \"\": \"&prnE;\",\n      \"\": \"&prnsim;\",\n      \"\": \"&prime;\",\n      \"\": \"&profalar;\",\n      \"\": \"&profline;\",\n      \"\": \"&profsurf;\",\n      \"\": \"&prurel;\",\n      \"\": \"&pscr;\",\n      \"\": \"&psi;\",\n      \"\": \"&puncsp;\",\n      \"\": \"&qfr;\",\n      \"\": \"&qopf;\",\n      \"\": \"&qprime;\",\n      \"\": \"&qscr;\",\n      \"\": \"&quatint;\",\n      \"?\": \"&quest;\",\n      \"\": \"&rAtail;\",\n      \"\": \"&rHar;\",\n      \"\": \"&race;\",\n      \"\": \"&racute;\",\n      \"\": \"&raemptyv;\",\n      \"\": \"&rangd;\",\n      \"\": \"&range;\",\n      \"\": \"&raquo;\",\n      \"\": \"&rarrap;\",\n      \"\": \"&rarrbfs;\",\n      \"\": \"&rarrc;\",\n      \"\": \"&rarrfs;\",\n      \"\": \"&rarrpl;\",\n      \"\": \"&rarrsim;\",\n      \"\": \"&rightarrowtail;\",\n      \"\": \"&rightsquigarrow;\",\n      \"\": \"&ratail;\",\n      \"\": \"&ratio;\",\n      \"\": \"&rbbrk;\",\n      \"}\": \"&rcub;\",\n      \"]\": \"&rsqb;\",\n      \"\": \"&rbrke;\",\n      \"\": \"&rbrksld;\",\n      \"\": \"&rbrkslu;\",\n      \"\": \"&rcaron;\",\n      \"\": \"&rcedil;\",\n      \"\": \"&rcy;\",\n      \"\": \"&rdca;\",\n      \"\": \"&rdldhar;\",\n      \"\": \"&rdsh;\",\n      \"\": \"&rect;\",\n      \"\": \"&rfisht;\",\n      \"\": \"&rfr;\",\n      \"\": \"&rharul;\",\n      \"\": \"&rho;\",\n      \"\": \"&varrho;\",\n      \"\": \"&rrarr;\",\n      \"\": \"&rthree;\",\n      \"\": \"&ring;\",\n      \"\": \"&rlm;\",\n      \"\": \"&rmoustache;\",\n      \"\": \"&rnmid;\",\n      \"\": \"&roang;\",\n      \"\": \"&roarr;\",\n      \"\": \"&ropar;\",\n      \"\": \"&ropf;\",\n      \"\": \"&roplus;\",\n      \"\": \"&rotimes;\",\n      \")\": \"&rpar;\",\n      \"\": \"&rpargt;\",\n      \"\": \"&rppolint;\",\n      \"\": \"&rsaquo;\",\n      \"\": \"&rscr;\",\n      \"\": \"&rtimes;\",\n      \"\": \"&triangleright;\",\n      \"\": \"&rtriltri;\",\n      \"\": \"&ruluhar;\",\n      \"\": \"&rx;\",\n      \"\": \"&sacute;\",\n      \"\": \"&scE;\",\n      \"\": \"&succapprox;\",\n      \"\": \"&scaron;\",\n      \"\": \"&scedil;\",\n      \"\": \"&scirc;\",\n      \"\": \"&succneqq;\",\n      \"\": \"&succnapprox;\",\n      \"\": \"&succnsim;\",\n      \"\": \"&scpolint;\",\n      \"\": \"&scy;\",\n      \"\": \"&sdot;\",\n      \"\": \"&sdote;\",\n      \"\": \"&seArr;\",\n      \"\": \"&sect;\",\n      \";\": \"&semi;\",\n      \"\": \"&tosa;\",\n      \"\": \"&sext;\",\n      \"\": \"&sfr;\",\n      \"\": \"&sharp;\",\n      \"\": \"&shchcy;\",\n      \"\": \"&shcy;\",\n      \"\": \"&shy;\",\n      \"\": \"&sigma;\",\n      \"\": \"&varsigma;\",\n      \"\": \"&simdot;\",\n      \"\": \"&simg;\",\n      \"\": \"&simgE;\",\n      \"\": \"&siml;\",\n      \"\": \"&simlE;\",\n      \"\": \"&simne;\",\n      \"\": \"&simplus;\",\n      \"\": \"&simrarr;\",\n      \"\": \"&smashp;\",\n      \"\": \"&smeparsl;\",\n      \"\": \"&ssmile;\",\n      \"\": \"&smt;\",\n      \"\": \"&smte;\",\n      \"\": \"&smtes;\",\n      \"\": \"&softcy;\",\n      \"/\": \"&sol;\",\n      \"\": \"&solb;\",\n      \"\": \"&solbar;\",\n      \"\": \"&sopf;\",\n      \"\": \"&spadesuit;\",\n      \"\": \"&sqcaps;\",\n      \"\": \"&sqcups;\",\n      \"\": \"&sscr;\",\n      \"\": \"&star;\",\n      \"\": \"&subset;\",\n      \"\": \"&subseteqq;\",\n      \"\": \"&subdot;\",\n      \"\": \"&subedot;\",\n      \"\": \"&submult;\",\n      \"\": \"&subsetneqq;\",\n      \"\": \"&subsetneq;\",\n      \"\": \"&subplus;\",\n      \"\": \"&subrarr;\",\n      \"\": \"&subsim;\",\n      \"\": \"&subsub;\",\n      \"\": \"&subsup;\",\n      \"\": \"&sung;\",\n      \"\": \"&sup1;\",\n      \"\": \"&sup2;\",\n      \"\": \"&sup3;\",\n      \"\": \"&supseteqq;\",\n      \"\": \"&supdot;\",\n      \"\": \"&supdsub;\",\n      \"\": \"&supedot;\",\n      \"\": \"&suphsol;\",\n      \"\": \"&suphsub;\",\n      \"\": \"&suplarr;\",\n      \"\": \"&supmult;\",\n      \"\": \"&supsetneqq;\",\n      \"\": \"&supsetneq;\",\n      \"\": \"&supplus;\",\n      \"\": \"&supsim;\",\n      \"\": \"&supsub;\",\n      \"\": \"&supsup;\",\n      \"\": \"&swArr;\",\n      \"\": \"&swnwar;\",\n      \"\": \"&szlig;\",\n      \"\": \"&target;\",\n      \"\": \"&tau;\",\n      \"\": \"&tcaron;\",\n      \"\": \"&tcedil;\",\n      \"\": \"&tcy;\",\n      \"\": \"&telrec;\",\n      \"\": \"&tfr;\",\n      \"\": \"&theta;\",\n      \"\": \"&vartheta;\",\n      \"\": \"&thorn;\",\n      \"\": \"&times;\",\n      \"\": \"&timesbar;\",\n      \"\": \"&timesd;\",\n      \"\": \"&topbot;\",\n      \"\": \"&topcir;\",\n      \"\": \"&topf;\",\n      \"\": \"&topfork;\",\n      \"\": \"&tprime;\",\n      \"\": \"&utri;\",\n      \"\": \"&trie;\",\n      \"\": \"&tridot;\",\n      \"\": \"&triminus;\",\n      \"\": \"&triplus;\",\n      \"\": \"&trisb;\",\n      \"\": \"&tritime;\",\n      \"\": \"&trpezium;\",\n      \"\": \"&tscr;\",\n      \"\": \"&tscy;\",\n      \"\": \"&tshcy;\",\n      \"\": \"&tstrok;\",\n      \"\": \"&uHar;\",\n      \"\": \"&uacute;\",\n      \"\": \"&ubrcy;\",\n      \"\": \"&ubreve;\",\n      \"\": \"&ucirc;\",\n      \"\": \"&ucy;\",\n      \"\": \"&udblac;\",\n      \"\": \"&ufisht;\",\n      \"\": \"&ufr;\",\n      \"\": \"&ugrave;\",\n      \"\": \"&uhblk;\",\n      \"\": \"&ulcorner;\",\n      \"\": \"&ulcrop;\",\n      \"\": \"&ultri;\",\n      \"\": \"&umacr;\",\n      \"\": \"&uogon;\",\n      \"\": \"&uopf;\",\n      \"\": \"&upsilon;\",\n      \"\": \"&uuarr;\",\n      \"\": \"&urcorner;\",\n      \"\": \"&urcrop;\",\n      \"\": \"&uring;\",\n      \"\": \"&urtri;\",\n      \"\": \"&uscr;\",\n      \"\": \"&utdot;\",\n      \"\": \"&utilde;\",\n      \"\": \"&uuml;\",\n      \"\": \"&uwangle;\",\n      \"\": \"&vBar;\",\n      \"\": \"&vBarv;\",\n      \"\": \"&vangrt;\",\n      \"\": \"&vsubne;\",\n      \"\": \"&vsubnE;\",\n      \"\": \"&vsupne;\",\n      \"\": \"&vsupnE;\",\n      \"\": \"&vcy;\",\n      \"\": \"&veebar;\",\n      \"\": \"&veeeq;\",\n      \"\": \"&vellip;\",\n      \"\": \"&vfr;\",\n      \"\": \"&vopf;\",\n      \"\": \"&vscr;\",\n      \"\": \"&vzigzag;\",\n      \"\": \"&wcirc;\",\n      \"\": \"&wedbar;\",\n      \"\": \"&wedgeq;\",\n      \"\": \"&wp;\",\n      \"\": \"&wfr;\",\n      \"\": \"&wopf;\",\n      \"\": \"&wscr;\",\n      \"\": \"&xfr;\",\n      \"\": \"&xi;\",\n      \"\": \"&xnis;\",\n      \"\": \"&xopf;\",\n      \"\": \"&xscr;\",\n      \"\": \"&yacute;\",\n      \"\": \"&yacy;\",\n      \"\": \"&ycirc;\",\n      \"\": \"&ycy;\",\n      \"\": \"&yen;\",\n      \"\": \"&yfr;\",\n      \"\": \"&yicy;\",\n      \"\": \"&yopf;\",\n      \"\": \"&yscr;\",\n      \"\": \"&yucy;\",\n      \"\": \"&yuml;\",\n      \"\": \"&zacute;\",\n      \"\": \"&zcaron;\",\n      \"\": \"&zcy;\",\n      \"\": \"&zdot;\",\n      \"\": \"&zeta;\",\n      \"\": \"&zfr;\",\n      \"\": \"&zhcy;\",\n      \"\": \"&zigrarr;\",\n      \"\": \"&zopf;\",\n      \"\": \"&zscr;\",\n      \"\": \"&zwj;\",\n      \"\": \"&zwnj;\"\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbmFtZWQtcmVmZXJlbmNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUI7QUFDbkIsZ0RBQWdEO0FBQ2hELGlCQUFpQiwybkJBQTJuQjtBQUM1b0IscUJBQXFCLFNBQVMsZ0JBQWdCLE9BQU8sUUFBUSxRQUFRLFNBQVMsVUFBVSxZQUFZLFNBQVMsU0FBUyxZQUFZLGFBQWEsVUFBVSxTQUFTLE9BQU8sUUFBUSxRQUFRLFNBQVMsU0FBUyxTQUFTLFVBQVUsU0FBUyxPQUFPLFFBQVEsUUFBUSxRQUFRLFNBQVMsV0FBVyxVQUFVLFVBQVUsVUFBVSxRQUFRLFVBQVUsVUFBVSxVQUFVLFdBQVcsU0FBUyxXQUFXLFNBQVMsbXBCQUFtcEI7QUFDemhDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBLFlB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YnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL25hbWVkLXJlZmVyZW5jZXMuanM/NGYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYm9keVJlZ0V4cHMgPSB7XG4gIHhtbDogLyYoPzojXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOz8vZyxcbiAgaHRtbDQ6IC8mbm90aW47fCYoPzpuYnNwfGlleGNsfGNlbnR8cG91bmR8Y3VycmVufHllbnxicnZiYXJ8c2VjdHx1bWx8Y29weXxvcmRmfGxhcXVvfG5vdHxzaHl8cmVnfG1hY3J8ZGVnfHBsdXNtbnxzdXAyfHN1cDN8YWN1dGV8bWljcm98cGFyYXxtaWRkb3R8Y2VkaWx8c3VwMXxvcmRtfHJhcXVvfGZyYWMxNHxmcmFjMTJ8ZnJhYzM0fGlxdWVzdHxBZ3JhdmV8QWFjdXRlfEFjaXJjfEF0aWxkZXxBdW1sfEFyaW5nfEFFbGlnfENjZWRpbHxFZ3JhdmV8RWFjdXRlfEVjaXJjfEV1bWx8SWdyYXZlfElhY3V0ZXxJY2lyY3xJdW1sfEVUSHxOdGlsZGV8T2dyYXZlfE9hY3V0ZXxPY2lyY3xPdGlsZGV8T3VtbHx0aW1lc3xPc2xhc2h8VWdyYXZlfFVhY3V0ZXxVY2lyY3xVdW1sfFlhY3V0ZXxUSE9STnxzemxpZ3xhZ3JhdmV8YWFjdXRlfGFjaXJjfGF0aWxkZXxhdW1sfGFyaW5nfGFlbGlnfGNjZWRpbHxlZ3JhdmV8ZWFjdXRlfGVjaXJjfGV1bWx8aWdyYXZlfGlhY3V0ZXxpY2lyY3xpdW1sfGV0aHxudGlsZGV8b2dyYXZlfG9hY3V0ZXxvY2lyY3xvdGlsZGV8b3VtbHxkaXZpZGV8b3NsYXNofHVncmF2ZXx1YWN1dGV8dWNpcmN8dXVtbHx5YWN1dGV8dGhvcm58eXVtbHxxdW90fGFtcHxsdHxndHwjXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOz8vZyxcbiAgaHRtbDU6IC8mY2VudGVyZG90O3wmY29weXNyO3wmZGl2aWRlb250aW1lczt8Jmd0Y2M7fCZndGNpcjt8Jmd0ZG90O3wmZ3RsUGFyO3wmZ3RxdWVzdDt8Jmd0cmFwcHJveDt8Jmd0cmFycjt8Jmd0cmRvdDt8Jmd0cmVxbGVzczt8Jmd0cmVxcWxlc3M7fCZndHJsZXNzO3wmZ3Ryc2ltO3wmbHRjYzt8Jmx0Y2lyO3wmbHRkb3Q7fCZsdGhyZWU7fCZsdGltZXM7fCZsdGxhcnI7fCZsdHF1ZXN0O3wmbHRyUGFyO3wmbHRyaTt8Jmx0cmllO3wmbHRyaWY7fCZub3Rpbjt8Jm5vdGluRTt8Jm5vdGluZG90O3wmbm90aW52YTt8Jm5vdGludmI7fCZub3RpbnZjO3wmbm90bmk7fCZub3RuaXZhO3wmbm90bml2Yjt8Jm5vdG5pdmM7fCZwYXJhbGxlbDt8JnRpbWVzYjt8JnRpbWVzYmFyO3wmdGltZXNkO3wmKD86QUVsaWd8QU1QfEFhY3V0ZXxBY2lyY3xBZ3JhdmV8QXJpbmd8QXRpbGRlfEF1bWx8Q09QWXxDY2VkaWx8RVRIfEVhY3V0ZXxFY2lyY3xFZ3JhdmV8RXVtbHxHVHxJYWN1dGV8SWNpcmN8SWdyYXZlfEl1bWx8TFR8TnRpbGRlfE9hY3V0ZXxPY2lyY3xPZ3JhdmV8T3NsYXNofE90aWxkZXxPdW1sfFFVT1R8UkVHfFRIT1JOfFVhY3V0ZXxVY2lyY3xVZ3JhdmV8VXVtbHxZYWN1dGV8YWFjdXRlfGFjaXJjfGFjdXRlfGFlbGlnfGFncmF2ZXxhbXB8YXJpbmd8YXRpbGRlfGF1bWx8YnJ2YmFyfGNjZWRpbHxjZWRpbHxjZW50fGNvcHl8Y3VycmVufGRlZ3xkaXZpZGV8ZWFjdXRlfGVjaXJjfGVncmF2ZXxldGh8ZXVtbHxmcmFjMTJ8ZnJhYzE0fGZyYWMzNHxndHxpYWN1dGV8aWNpcmN8aWV4Y2x8aWdyYXZlfGlxdWVzdHxpdW1sfGxhcXVvfGx0fG1hY3J8bWljcm98bWlkZG90fG5ic3B8bm90fG50aWxkZXxvYWN1dGV8b2NpcmN8b2dyYXZlfG9yZGZ8b3JkbXxvc2xhc2h8b3RpbGRlfG91bWx8cGFyYXxwbHVzbW58cG91bmR8cXVvdHxyYXF1b3xyZWd8c2VjdHxzaHl8c3VwMXxzdXAyfHN1cDN8c3psaWd8dGhvcm58dGltZXN8dWFjdXRlfHVjaXJjfHVncmF2ZXx1bWx8dXVtbHx5YWN1dGV8eWVufHl1bWx8I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKTs/L2dcbn07XG5leHBvcnRzLm5hbWVkUmVmZXJlbmNlcyA9IHtcbiAgeG1sOiB7XG4gICAgZW50aXRpZXM6IHtcbiAgICAgIFwiJmx0O1wiOiBcIjxcIixcbiAgICAgIFwiJmd0O1wiOiBcIj5cIixcbiAgICAgIFwiJnF1b3Q7XCI6ICdcIicsXG4gICAgICBcIiZhcG9zO1wiOiBcIidcIixcbiAgICAgIFwiJmFtcDtcIjogXCImXCJcbiAgICB9LFxuICAgIGNoYXJhY3RlcnM6IHtcbiAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgICBcIidcIjogXCImYXBvcztcIixcbiAgICAgIFwiJlwiOiBcIiZhbXA7XCJcbiAgICB9XG4gIH0sXG4gIGh0bWw0OiB7XG4gICAgZW50aXRpZXM6IHtcbiAgICAgIFwiJmFwb3M7XCI6IFwiJ1wiLFxuICAgICAgXCImbmJzcFwiOiBcIsKgXCIsXG4gICAgICBcIiZuYnNwO1wiOiBcIsKgXCIsXG4gICAgICBcIiZpZXhjbFwiOiBcIsKhXCIsXG4gICAgICBcIiZpZXhjbDtcIjogXCLCoVwiLFxuICAgICAgXCImY2VudFwiOiBcIsKiXCIsXG4gICAgICBcIiZjZW50O1wiOiBcIsKiXCIsXG4gICAgICBcIiZwb3VuZFwiOiBcIsKjXCIsXG4gICAgICBcIiZwb3VuZDtcIjogXCLCo1wiLFxuICAgICAgXCImY3VycmVuXCI6IFwiwqRcIixcbiAgICAgIFwiJmN1cnJlbjtcIjogXCLCpFwiLFxuICAgICAgXCImeWVuXCI6IFwiwqVcIixcbiAgICAgIFwiJnllbjtcIjogXCLCpVwiLFxuICAgICAgXCImYnJ2YmFyXCI6IFwiwqZcIixcbiAgICAgIFwiJmJydmJhcjtcIjogXCLCplwiLFxuICAgICAgXCImc2VjdFwiOiBcIsKnXCIsXG4gICAgICBcIiZzZWN0O1wiOiBcIsKnXCIsXG4gICAgICBcIiZ1bWxcIjogXCLCqFwiLFxuICAgICAgXCImdW1sO1wiOiBcIsKoXCIsXG4gICAgICBcIiZjb3B5XCI6IFwiwqlcIixcbiAgICAgIFwiJmNvcHk7XCI6IFwiwqlcIixcbiAgICAgIFwiJm9yZGZcIjogXCLCqlwiLFxuICAgICAgXCImb3JkZjtcIjogXCLCqlwiLFxuICAgICAgXCImbGFxdW9cIjogXCLCq1wiLFxuICAgICAgXCImbGFxdW87XCI6IFwiwqtcIixcbiAgICAgIFwiJm5vdFwiOiBcIsKsXCIsXG4gICAgICBcIiZub3Q7XCI6IFwiwqxcIixcbiAgICAgIFwiJnNoeVwiOiBcIsKtXCIsXG4gICAgICBcIiZzaHk7XCI6IFwiwq1cIixcbiAgICAgIFwiJnJlZ1wiOiBcIsKuXCIsXG4gICAgICBcIiZyZWc7XCI6IFwiwq5cIixcbiAgICAgIFwiJm1hY3JcIjogXCLCr1wiLFxuICAgICAgXCImbWFjcjtcIjogXCLCr1wiLFxuICAgICAgXCImZGVnXCI6IFwiwrBcIixcbiAgICAgIFwiJmRlZztcIjogXCLCsFwiLFxuICAgICAgXCImcGx1c21uXCI6IFwiwrFcIixcbiAgICAgIFwiJnBsdXNtbjtcIjogXCLCsVwiLFxuICAgICAgXCImc3VwMlwiOiBcIsKyXCIsXG4gICAgICBcIiZzdXAyO1wiOiBcIsKyXCIsXG4gICAgICBcIiZzdXAzXCI6IFwiwrNcIixcbiAgICAgIFwiJnN1cDM7XCI6IFwiwrNcIixcbiAgICAgIFwiJmFjdXRlXCI6IFwiwrRcIixcbiAgICAgIFwiJmFjdXRlO1wiOiBcIsK0XCIsXG4gICAgICBcIiZtaWNyb1wiOiBcIsK1XCIsXG4gICAgICBcIiZtaWNybztcIjogXCLCtVwiLFxuICAgICAgXCImcGFyYVwiOiBcIsK2XCIsXG4gICAgICBcIiZwYXJhO1wiOiBcIsK2XCIsXG4gICAgICBcIiZtaWRkb3RcIjogXCLCt1wiLFxuICAgICAgXCImbWlkZG90O1wiOiBcIsK3XCIsXG4gICAgICBcIiZjZWRpbFwiOiBcIsK4XCIsXG4gICAgICBcIiZjZWRpbDtcIjogXCLCuFwiLFxuICAgICAgXCImc3VwMVwiOiBcIsK5XCIsXG4gICAgICBcIiZzdXAxO1wiOiBcIsK5XCIsXG4gICAgICBcIiZvcmRtXCI6IFwiwrpcIixcbiAgICAgIFwiJm9yZG07XCI6IFwiwrpcIixcbiAgICAgIFwiJnJhcXVvXCI6IFwiwrtcIixcbiAgICAgIFwiJnJhcXVvO1wiOiBcIsK7XCIsXG4gICAgICBcIiZmcmFjMTRcIjogXCLCvFwiLFxuICAgICAgXCImZnJhYzE0O1wiOiBcIsK8XCIsXG4gICAgICBcIiZmcmFjMTJcIjogXCLCvVwiLFxuICAgICAgXCImZnJhYzEyO1wiOiBcIsK9XCIsXG4gICAgICBcIiZmcmFjMzRcIjogXCLCvlwiLFxuICAgICAgXCImZnJhYzM0O1wiOiBcIsK+XCIsXG4gICAgICBcIiZpcXVlc3RcIjogXCLCv1wiLFxuICAgICAgXCImaXF1ZXN0O1wiOiBcIsK/XCIsXG4gICAgICBcIiZBZ3JhdmVcIjogXCLDgFwiLFxuICAgICAgXCImQWdyYXZlO1wiOiBcIsOAXCIsXG4gICAgICBcIiZBYWN1dGVcIjogXCLDgVwiLFxuICAgICAgXCImQWFjdXRlO1wiOiBcIsOBXCIsXG4gICAgICBcIiZBY2lyY1wiOiBcIsOCXCIsXG4gICAgICBcIiZBY2lyYztcIjogXCLDglwiLFxuICAgICAgXCImQXRpbGRlXCI6IFwiw4NcIixcbiAgICAgIFwiJkF0aWxkZTtcIjogXCLDg1wiLFxuICAgICAgXCImQXVtbFwiOiBcIsOEXCIsXG4gICAgICBcIiZBdW1sO1wiOiBcIsOEXCIsXG4gICAgICBcIiZBcmluZ1wiOiBcIsOFXCIsXG4gICAgICBcIiZBcmluZztcIjogXCLDhVwiLFxuICAgICAgXCImQUVsaWdcIjogXCLDhlwiLFxuICAgICAgXCImQUVsaWc7XCI6IFwiw4ZcIixcbiAgICAgIFwiJkNjZWRpbFwiOiBcIsOHXCIsXG4gICAgICBcIiZDY2VkaWw7XCI6IFwiw4dcIixcbiAgICAgIFwiJkVncmF2ZVwiOiBcIsOIXCIsXG4gICAgICBcIiZFZ3JhdmU7XCI6IFwiw4hcIixcbiAgICAgIFwiJkVhY3V0ZVwiOiBcIsOJXCIsXG4gICAgICBcIiZFYWN1dGU7XCI6IFwiw4lcIixcbiAgICAgIFwiJkVjaXJjXCI6IFwiw4pcIixcbiAgICAgIFwiJkVjaXJjO1wiOiBcIsOKXCIsXG4gICAgICBcIiZFdW1sXCI6IFwiw4tcIixcbiAgICAgIFwiJkV1bWw7XCI6IFwiw4tcIixcbiAgICAgIFwiJklncmF2ZVwiOiBcIsOMXCIsXG4gICAgICBcIiZJZ3JhdmU7XCI6IFwiw4xcIixcbiAgICAgIFwiJklhY3V0ZVwiOiBcIsONXCIsXG4gICAgICBcIiZJYWN1dGU7XCI6IFwiw41cIixcbiAgICAgIFwiJkljaXJjXCI6IFwiw45cIixcbiAgICAgIFwiJkljaXJjO1wiOiBcIsOOXCIsXG4gICAgICBcIiZJdW1sXCI6IFwiw49cIixcbiAgICAgIFwiJkl1bWw7XCI6IFwiw49cIixcbiAgICAgIFwiJkVUSFwiOiBcIsOQXCIsXG4gICAgICBcIiZFVEg7XCI6IFwiw5BcIixcbiAgICAgIFwiJk50aWxkZVwiOiBcIsORXCIsXG4gICAgICBcIiZOdGlsZGU7XCI6IFwiw5FcIixcbiAgICAgIFwiJk9ncmF2ZVwiOiBcIsOSXCIsXG4gICAgICBcIiZPZ3JhdmU7XCI6IFwiw5JcIixcbiAgICAgIFwiJk9hY3V0ZVwiOiBcIsOTXCIsXG4gICAgICBcIiZPYWN1dGU7XCI6IFwiw5NcIixcbiAgICAgIFwiJk9jaXJjXCI6IFwiw5RcIixcbiAgICAgIFwiJk9jaXJjO1wiOiBcIsOUXCIsXG4gICAgICBcIiZPdGlsZGVcIjogXCLDlVwiLFxuICAgICAgXCImT3RpbGRlO1wiOiBcIsOVXCIsXG4gICAgICBcIiZPdW1sXCI6IFwiw5ZcIixcbiAgICAgIFwiJk91bWw7XCI6IFwiw5ZcIixcbiAgICAgIFwiJnRpbWVzXCI6IFwiw5dcIixcbiAgICAgIFwiJnRpbWVzO1wiOiBcIsOXXCIsXG4gICAgICBcIiZPc2xhc2hcIjogXCLDmFwiLFxuICAgICAgXCImT3NsYXNoO1wiOiBcIsOYXCIsXG4gICAgICBcIiZVZ3JhdmVcIjogXCLDmVwiLFxuICAgICAgXCImVWdyYXZlO1wiOiBcIsOZXCIsXG4gICAgICBcIiZVYWN1dGVcIjogXCLDmlwiLFxuICAgICAgXCImVWFjdXRlO1wiOiBcIsOaXCIsXG4gICAgICBcIiZVY2lyY1wiOiBcIsObXCIsXG4gICAgICBcIiZVY2lyYztcIjogXCLDm1wiLFxuICAgICAgXCImVXVtbFwiOiBcIsOcXCIsXG4gICAgICBcIiZVdW1sO1wiOiBcIsOcXCIsXG4gICAgICBcIiZZYWN1dGVcIjogXCLDnVwiLFxuICAgICAgXCImWWFjdXRlO1wiOiBcIsOdXCIsXG4gICAgICBcIiZUSE9STlwiOiBcIsOeXCIsXG4gICAgICBcIiZUSE9STjtcIjogXCLDnlwiLFxuICAgICAgXCImc3psaWdcIjogXCLDn1wiLFxuICAgICAgXCImc3psaWc7XCI6IFwiw59cIixcbiAgICAgIFwiJmFncmF2ZVwiOiBcIsOgXCIsXG4gICAgICBcIiZhZ3JhdmU7XCI6IFwiw6BcIixcbiAgICAgIFwiJmFhY3V0ZVwiOiBcIsOhXCIsXG4gICAgICBcIiZhYWN1dGU7XCI6IFwiw6FcIixcbiAgICAgIFwiJmFjaXJjXCI6IFwiw6JcIixcbiAgICAgIFwiJmFjaXJjO1wiOiBcIsOiXCIsXG4gICAgICBcIiZhdGlsZGVcIjogXCLDo1wiLFxuICAgICAgXCImYXRpbGRlO1wiOiBcIsOjXCIsXG4gICAgICBcIiZhdW1sXCI6IFwiw6RcIixcbiAgICAgIFwiJmF1bWw7XCI6IFwiw6RcIixcbiAgICAgIFwiJmFyaW5nXCI6IFwiw6VcIixcbiAgICAgIFwiJmFyaW5nO1wiOiBcIsOlXCIsXG4gICAgICBcIiZhZWxpZ1wiOiBcIsOmXCIsXG4gICAgICBcIiZhZWxpZztcIjogXCLDplwiLFxuICAgICAgXCImY2NlZGlsXCI6IFwiw6dcIixcbiAgICAgIFwiJmNjZWRpbDtcIjogXCLDp1wiLFxuICAgICAgXCImZWdyYXZlXCI6IFwiw6hcIixcbiAgICAgIFwiJmVncmF2ZTtcIjogXCLDqFwiLFxuICAgICAgXCImZWFjdXRlXCI6IFwiw6lcIixcbiAgICAgIFwiJmVhY3V0ZTtcIjogXCLDqVwiLFxuICAgICAgXCImZWNpcmNcIjogXCLDqlwiLFxuICAgICAgXCImZWNpcmM7XCI6IFwiw6pcIixcbiAgICAgIFwiJmV1bWxcIjogXCLDq1wiLFxuICAgICAgXCImZXVtbDtcIjogXCLDq1wiLFxuICAgICAgXCImaWdyYXZlXCI6IFwiw6xcIixcbiAgICAgIFwiJmlncmF2ZTtcIjogXCLDrFwiLFxuICAgICAgXCImaWFjdXRlXCI6IFwiw61cIixcbiAgICAgIFwiJmlhY3V0ZTtcIjogXCLDrVwiLFxuICAgICAgXCImaWNpcmNcIjogXCLDrlwiLFxuICAgICAgXCImaWNpcmM7XCI6IFwiw65cIixcbiAgICAgIFwiJml1bWxcIjogXCLDr1wiLFxuICAgICAgXCImaXVtbDtcIjogXCLDr1wiLFxuICAgICAgXCImZXRoXCI6IFwiw7BcIixcbiAgICAgIFwiJmV0aDtcIjogXCLDsFwiLFxuICAgICAgXCImbnRpbGRlXCI6IFwiw7FcIixcbiAgICAgIFwiJm50aWxkZTtcIjogXCLDsVwiLFxuICAgICAgXCImb2dyYXZlXCI6IFwiw7JcIixcbiAgICAgIFwiJm9ncmF2ZTtcIjogXCLDslwiLFxuICAgICAgXCImb2FjdXRlXCI6IFwiw7NcIixcbiAgICAgIFwiJm9hY3V0ZTtcIjogXCLDs1wiLFxuICAgICAgXCImb2NpcmNcIjogXCLDtFwiLFxuICAgICAgXCImb2NpcmM7XCI6IFwiw7RcIixcbiAgICAgIFwiJm90aWxkZVwiOiBcIsO1XCIsXG4gICAgICBcIiZvdGlsZGU7XCI6IFwiw7VcIixcbiAgICAgIFwiJm91bWxcIjogXCLDtlwiLFxuICAgICAgXCImb3VtbDtcIjogXCLDtlwiLFxuICAgICAgXCImZGl2aWRlXCI6IFwiw7dcIixcbiAgICAgIFwiJmRpdmlkZTtcIjogXCLDt1wiLFxuICAgICAgXCImb3NsYXNoXCI6IFwiw7hcIixcbiAgICAgIFwiJm9zbGFzaDtcIjogXCLDuFwiLFxuICAgICAgXCImdWdyYXZlXCI6IFwiw7lcIixcbiAgICAgIFwiJnVncmF2ZTtcIjogXCLDuVwiLFxuICAgICAgXCImdWFjdXRlXCI6IFwiw7pcIixcbiAgICAgIFwiJnVhY3V0ZTtcIjogXCLDulwiLFxuICAgICAgXCImdWNpcmNcIjogXCLDu1wiLFxuICAgICAgXCImdWNpcmM7XCI6IFwiw7tcIixcbiAgICAgIFwiJnV1bWxcIjogXCLDvFwiLFxuICAgICAgXCImdXVtbDtcIjogXCLDvFwiLFxuICAgICAgXCImeWFjdXRlXCI6IFwiw71cIixcbiAgICAgIFwiJnlhY3V0ZTtcIjogXCLDvVwiLFxuICAgICAgXCImdGhvcm5cIjogXCLDvlwiLFxuICAgICAgXCImdGhvcm47XCI6IFwiw75cIixcbiAgICAgIFwiJnl1bWxcIjogXCLDv1wiLFxuICAgICAgXCImeXVtbDtcIjogXCLDv1wiLFxuICAgICAgXCImcXVvdFwiOiAnXCInLFxuICAgICAgXCImcXVvdDtcIjogJ1wiJyxcbiAgICAgIFwiJmFtcFwiOiBcIiZcIixcbiAgICAgIFwiJmFtcDtcIjogXCImXCIsXG4gICAgICBcIiZsdFwiOiBcIjxcIixcbiAgICAgIFwiJmx0O1wiOiBcIjxcIixcbiAgICAgIFwiJmd0XCI6IFwiPlwiLFxuICAgICAgXCImZ3Q7XCI6IFwiPlwiLFxuICAgICAgXCImT0VsaWc7XCI6IFwixZJcIixcbiAgICAgIFwiJm9lbGlnO1wiOiBcIsWTXCIsXG4gICAgICBcIiZTY2Fyb247XCI6IFwixaBcIixcbiAgICAgIFwiJnNjYXJvbjtcIjogXCLFoVwiLFxuICAgICAgXCImWXVtbDtcIjogXCLFuFwiLFxuICAgICAgXCImY2lyYztcIjogXCLLhlwiLFxuICAgICAgXCImdGlsZGU7XCI6IFwiy5xcIixcbiAgICAgIFwiJmVuc3A7XCI6IFwi4oCCXCIsXG4gICAgICBcIiZlbXNwO1wiOiBcIuKAg1wiLFxuICAgICAgXCImdGhpbnNwO1wiOiBcIuKAiVwiLFxuICAgICAgXCImenduajtcIjogXCLigIxcIixcbiAgICAgIFwiJnp3ajtcIjogXCLigI1cIixcbiAgICAgIFwiJmxybTtcIjogXCLigI5cIixcbiAgICAgIFwiJnJsbTtcIjogXCLigI9cIixcbiAgICAgIFwiJm5kYXNoO1wiOiBcIuKAk1wiLFxuICAgICAgXCImbWRhc2g7XCI6IFwi4oCUXCIsXG4gICAgICBcIiZsc3F1bztcIjogXCLigJhcIixcbiAgICAgIFwiJnJzcXVvO1wiOiBcIuKAmVwiLFxuICAgICAgXCImc2JxdW87XCI6IFwi4oCaXCIsXG4gICAgICBcIiZsZHF1bztcIjogXCLigJxcIixcbiAgICAgIFwiJnJkcXVvO1wiOiBcIuKAnVwiLFxuICAgICAgXCImYmRxdW87XCI6IFwi4oCeXCIsXG4gICAgICBcIiZkYWdnZXI7XCI6IFwi4oCgXCIsXG4gICAgICBcIiZEYWdnZXI7XCI6IFwi4oChXCIsXG4gICAgICBcIiZwZXJtaWw7XCI6IFwi4oCwXCIsXG4gICAgICBcIiZsc2FxdW87XCI6IFwi4oC5XCIsXG4gICAgICBcIiZyc2FxdW87XCI6IFwi4oC6XCIsXG4gICAgICBcIiZldXJvO1wiOiBcIuKCrFwiLFxuICAgICAgXCImZm5vZjtcIjogXCLGklwiLFxuICAgICAgXCImQWxwaGE7XCI6IFwizpFcIixcbiAgICAgIFwiJkJldGE7XCI6IFwizpJcIixcbiAgICAgIFwiJkdhbW1hO1wiOiBcIs6TXCIsXG4gICAgICBcIiZEZWx0YTtcIjogXCLOlFwiLFxuICAgICAgXCImRXBzaWxvbjtcIjogXCLOlVwiLFxuICAgICAgXCImWmV0YTtcIjogXCLOllwiLFxuICAgICAgXCImRXRhO1wiOiBcIs6XXCIsXG4gICAgICBcIiZUaGV0YTtcIjogXCLOmFwiLFxuICAgICAgXCImSW90YTtcIjogXCLOmVwiLFxuICAgICAgXCImS2FwcGE7XCI6IFwizppcIixcbiAgICAgIFwiJkxhbWJkYTtcIjogXCLOm1wiLFxuICAgICAgXCImTXU7XCI6IFwizpxcIixcbiAgICAgIFwiJk51O1wiOiBcIs6dXCIsXG4gICAgICBcIiZYaTtcIjogXCLOnlwiLFxuICAgICAgXCImT21pY3JvbjtcIjogXCLOn1wiLFxuICAgICAgXCImUGk7XCI6IFwizqBcIixcbiAgICAgIFwiJlJobztcIjogXCLOoVwiLFxuICAgICAgXCImU2lnbWE7XCI6IFwizqNcIixcbiAgICAgIFwiJlRhdTtcIjogXCLOpFwiLFxuICAgICAgXCImVXBzaWxvbjtcIjogXCLOpVwiLFxuICAgICAgXCImUGhpO1wiOiBcIs6mXCIsXG4gICAgICBcIiZDaGk7XCI6IFwizqdcIixcbiAgICAgIFwiJlBzaTtcIjogXCLOqFwiLFxuICAgICAgXCImT21lZ2E7XCI6IFwizqlcIixcbiAgICAgIFwiJmFscGhhO1wiOiBcIs6xXCIsXG4gICAgICBcIiZiZXRhO1wiOiBcIs6yXCIsXG4gICAgICBcIiZnYW1tYTtcIjogXCLOs1wiLFxuICAgICAgXCImZGVsdGE7XCI6IFwizrRcIixcbiAgICAgIFwiJmVwc2lsb247XCI6IFwizrVcIixcbiAgICAgIFwiJnpldGE7XCI6IFwizrZcIixcbiAgICAgIFwiJmV0YTtcIjogXCLOt1wiLFxuICAgICAgXCImdGhldGE7XCI6IFwizrhcIixcbiAgICAgIFwiJmlvdGE7XCI6IFwizrlcIixcbiAgICAgIFwiJmthcHBhO1wiOiBcIs66XCIsXG4gICAgICBcIiZsYW1iZGE7XCI6IFwizrtcIixcbiAgICAgIFwiJm11O1wiOiBcIs68XCIsXG4gICAgICBcIiZudTtcIjogXCLOvVwiLFxuICAgICAgXCImeGk7XCI6IFwizr5cIixcbiAgICAgIFwiJm9taWNyb247XCI6IFwizr9cIixcbiAgICAgIFwiJnBpO1wiOiBcIs+AXCIsXG4gICAgICBcIiZyaG87XCI6IFwiz4FcIixcbiAgICAgIFwiJnNpZ21hZjtcIjogXCLPglwiLFxuICAgICAgXCImc2lnbWE7XCI6IFwiz4NcIixcbiAgICAgIFwiJnRhdTtcIjogXCLPhFwiLFxuICAgICAgXCImdXBzaWxvbjtcIjogXCLPhVwiLFxuICAgICAgXCImcGhpO1wiOiBcIs+GXCIsXG4gICAgICBcIiZjaGk7XCI6IFwiz4dcIixcbiAgICAgIFwiJnBzaTtcIjogXCLPiFwiLFxuICAgICAgXCImb21lZ2E7XCI6IFwiz4lcIixcbiAgICAgIFwiJnRoZXRhc3ltO1wiOiBcIs+RXCIsXG4gICAgICBcIiZ1cHNpaDtcIjogXCLPklwiLFxuICAgICAgXCImcGl2O1wiOiBcIs+WXCIsXG4gICAgICBcIiZidWxsO1wiOiBcIuKAolwiLFxuICAgICAgXCImaGVsbGlwO1wiOiBcIuKAplwiLFxuICAgICAgXCImcHJpbWU7XCI6IFwi4oCyXCIsXG4gICAgICBcIiZQcmltZTtcIjogXCLigLNcIixcbiAgICAgIFwiJm9saW5lO1wiOiBcIuKAvlwiLFxuICAgICAgXCImZnJhc2w7XCI6IFwi4oGEXCIsXG4gICAgICBcIiZ3ZWllcnA7XCI6IFwi4oSYXCIsXG4gICAgICBcIiZpbWFnZTtcIjogXCLihJFcIixcbiAgICAgIFwiJnJlYWw7XCI6IFwi4oScXCIsXG4gICAgICBcIiZ0cmFkZTtcIjogXCLihKJcIixcbiAgICAgIFwiJmFsZWZzeW07XCI6IFwi4oS1XCIsXG4gICAgICBcIiZsYXJyO1wiOiBcIuKGkFwiLFxuICAgICAgXCImdWFycjtcIjogXCLihpFcIixcbiAgICAgIFwiJnJhcnI7XCI6IFwi4oaSXCIsXG4gICAgICBcIiZkYXJyO1wiOiBcIuKGk1wiLFxuICAgICAgXCImaGFycjtcIjogXCLihpRcIixcbiAgICAgIFwiJmNyYXJyO1wiOiBcIuKGtVwiLFxuICAgICAgXCImbEFycjtcIjogXCLih5BcIixcbiAgICAgIFwiJnVBcnI7XCI6IFwi4oeRXCIsXG4gICAgICBcIiZyQXJyO1wiOiBcIuKHklwiLFxuICAgICAgXCImZEFycjtcIjogXCLih5NcIixcbiAgICAgIFwiJmhBcnI7XCI6IFwi4oeUXCIsXG4gICAgICBcIiZmb3JhbGw7XCI6IFwi4oiAXCIsXG4gICAgICBcIiZwYXJ0O1wiOiBcIuKIglwiLFxuICAgICAgXCImZXhpc3Q7XCI6IFwi4oiDXCIsXG4gICAgICBcIiZlbXB0eTtcIjogXCLiiIVcIixcbiAgICAgIFwiJm5hYmxhO1wiOiBcIuKIh1wiLFxuICAgICAgXCImaXNpbjtcIjogXCLiiIhcIixcbiAgICAgIFwiJm5vdGluO1wiOiBcIuKIiVwiLFxuICAgICAgXCImbmk7XCI6IFwi4oiLXCIsXG4gICAgICBcIiZwcm9kO1wiOiBcIuKIj1wiLFxuICAgICAgXCImc3VtO1wiOiBcIuKIkVwiLFxuICAgICAgXCImbWludXM7XCI6IFwi4oiSXCIsXG4gICAgICBcIiZsb3dhc3Q7XCI6IFwi4oiXXCIsXG4gICAgICBcIiZyYWRpYztcIjogXCLiiJpcIixcbiAgICAgIFwiJnByb3A7XCI6IFwi4oidXCIsXG4gICAgICBcIiZpbmZpbjtcIjogXCLiiJ5cIixcbiAgICAgIFwiJmFuZztcIjogXCLiiKBcIixcbiAgICAgIFwiJmFuZDtcIjogXCLiiKdcIixcbiAgICAgIFwiJm9yO1wiOiBcIuKIqFwiLFxuICAgICAgXCImY2FwO1wiOiBcIuKIqVwiLFxuICAgICAgXCImY3VwO1wiOiBcIuKIqlwiLFxuICAgICAgXCImaW50O1wiOiBcIuKIq1wiLFxuICAgICAgXCImdGhlcmU0O1wiOiBcIuKItFwiLFxuICAgICAgXCImc2ltO1wiOiBcIuKIvFwiLFxuICAgICAgXCImY29uZztcIjogXCLiiYVcIixcbiAgICAgIFwiJmFzeW1wO1wiOiBcIuKJiFwiLFxuICAgICAgXCImbmU7XCI6IFwi4omgXCIsXG4gICAgICBcIiZlcXVpdjtcIjogXCLiiaFcIixcbiAgICAgIFwiJmxlO1wiOiBcIuKJpFwiLFxuICAgICAgXCImZ2U7XCI6IFwi4omlXCIsXG4gICAgICBcIiZzdWI7XCI6IFwi4oqCXCIsXG4gICAgICBcIiZzdXA7XCI6IFwi4oqDXCIsXG4gICAgICBcIiZuc3ViO1wiOiBcIuKKhFwiLFxuICAgICAgXCImc3ViZTtcIjogXCLiioZcIixcbiAgICAgIFwiJnN1cGU7XCI6IFwi4oqHXCIsXG4gICAgICBcIiZvcGx1cztcIjogXCLiipVcIixcbiAgICAgIFwiJm90aW1lcztcIjogXCLiipdcIixcbiAgICAgIFwiJnBlcnA7XCI6IFwi4oqlXCIsXG4gICAgICBcIiZzZG90O1wiOiBcIuKLhVwiLFxuICAgICAgXCImbGNlaWw7XCI6IFwi4oyIXCIsXG4gICAgICBcIiZyY2VpbDtcIjogXCLijIlcIixcbiAgICAgIFwiJmxmbG9vcjtcIjogXCLijIpcIixcbiAgICAgIFwiJnJmbG9vcjtcIjogXCLijItcIixcbiAgICAgIFwiJmxhbmc7XCI6IFwi4oypXCIsXG4gICAgICBcIiZyYW5nO1wiOiBcIuKMqlwiLFxuICAgICAgXCImbG96O1wiOiBcIuKXilwiLFxuICAgICAgXCImc3BhZGVzO1wiOiBcIuKZoFwiLFxuICAgICAgXCImY2x1YnM7XCI6IFwi4pmjXCIsXG4gICAgICBcIiZoZWFydHM7XCI6IFwi4pmlXCIsXG4gICAgICBcIiZkaWFtcztcIjogXCLimaZcIlxuICAgIH0sXG4gICAgY2hhcmFjdGVyczoge1xuICAgICAgXCInXCI6IFwiJmFwb3M7XCIsXG4gICAgICBcIsKgXCI6IFwiJm5ic3A7XCIsXG4gICAgICBcIsKhXCI6IFwiJmlleGNsO1wiLFxuICAgICAgXCLColwiOiBcIiZjZW50O1wiLFxuICAgICAgXCLCo1wiOiBcIiZwb3VuZDtcIixcbiAgICAgIFwiwqRcIjogXCImY3VycmVuO1wiLFxuICAgICAgXCLCpVwiOiBcIiZ5ZW47XCIsXG4gICAgICBcIsKmXCI6IFwiJmJydmJhcjtcIixcbiAgICAgIFwiwqdcIjogXCImc2VjdDtcIixcbiAgICAgIFwiwqhcIjogXCImdW1sO1wiLFxuICAgICAgXCLCqVwiOiBcIiZjb3B5O1wiLFxuICAgICAgXCLCqlwiOiBcIiZvcmRmO1wiLFxuICAgICAgXCLCq1wiOiBcIiZsYXF1bztcIixcbiAgICAgIFwiwqxcIjogXCImbm90O1wiLFxuICAgICAgXCLCrVwiOiBcIiZzaHk7XCIsXG4gICAgICBcIsKuXCI6IFwiJnJlZztcIixcbiAgICAgIFwiwq9cIjogXCImbWFjcjtcIixcbiAgICAgIFwiwrBcIjogXCImZGVnO1wiLFxuICAgICAgXCLCsVwiOiBcIiZwbHVzbW47XCIsXG4gICAgICBcIsKyXCI6IFwiJnN1cDI7XCIsXG4gICAgICBcIsKzXCI6IFwiJnN1cDM7XCIsXG4gICAgICBcIsK0XCI6IFwiJmFjdXRlO1wiLFxuICAgICAgXCLCtVwiOiBcIiZtaWNybztcIixcbiAgICAgIFwiwrZcIjogXCImcGFyYTtcIixcbiAgICAgIFwiwrdcIjogXCImbWlkZG90O1wiLFxuICAgICAgXCLCuFwiOiBcIiZjZWRpbDtcIixcbiAgICAgIFwiwrlcIjogXCImc3VwMTtcIixcbiAgICAgIFwiwrpcIjogXCImb3JkbTtcIixcbiAgICAgIFwiwrtcIjogXCImcmFxdW87XCIsXG4gICAgICBcIsK8XCI6IFwiJmZyYWMxNDtcIixcbiAgICAgIFwiwr1cIjogXCImZnJhYzEyO1wiLFxuICAgICAgXCLCvlwiOiBcIiZmcmFjMzQ7XCIsXG4gICAgICBcIsK/XCI6IFwiJmlxdWVzdDtcIixcbiAgICAgIFwiw4BcIjogXCImQWdyYXZlO1wiLFxuICAgICAgXCLDgVwiOiBcIiZBYWN1dGU7XCIsXG4gICAgICBcIsOCXCI6IFwiJkFjaXJjO1wiLFxuICAgICAgXCLDg1wiOiBcIiZBdGlsZGU7XCIsXG4gICAgICBcIsOEXCI6IFwiJkF1bWw7XCIsXG4gICAgICBcIsOFXCI6IFwiJkFyaW5nO1wiLFxuICAgICAgXCLDhlwiOiBcIiZBRWxpZztcIixcbiAgICAgIFwiw4dcIjogXCImQ2NlZGlsO1wiLFxuICAgICAgXCLDiFwiOiBcIiZFZ3JhdmU7XCIsXG4gICAgICBcIsOJXCI6IFwiJkVhY3V0ZTtcIixcbiAgICAgIFwiw4pcIjogXCImRWNpcmM7XCIsXG4gICAgICBcIsOLXCI6IFwiJkV1bWw7XCIsXG4gICAgICBcIsOMXCI6IFwiJklncmF2ZTtcIixcbiAgICAgIFwiw41cIjogXCImSWFjdXRlO1wiLFxuICAgICAgXCLDjlwiOiBcIiZJY2lyYztcIixcbiAgICAgIFwiw49cIjogXCImSXVtbDtcIixcbiAgICAgIFwiw5BcIjogXCImRVRIO1wiLFxuICAgICAgXCLDkVwiOiBcIiZOdGlsZGU7XCIsXG4gICAgICBcIsOSXCI6IFwiJk9ncmF2ZTtcIixcbiAgICAgIFwiw5NcIjogXCImT2FjdXRlO1wiLFxuICAgICAgXCLDlFwiOiBcIiZPY2lyYztcIixcbiAgICAgIFwiw5VcIjogXCImT3RpbGRlO1wiLFxuICAgICAgXCLDllwiOiBcIiZPdW1sO1wiLFxuICAgICAgXCLDl1wiOiBcIiZ0aW1lcztcIixcbiAgICAgIFwiw5hcIjogXCImT3NsYXNoO1wiLFxuICAgICAgXCLDmVwiOiBcIiZVZ3JhdmU7XCIsXG4gICAgICBcIsOaXCI6IFwiJlVhY3V0ZTtcIixcbiAgICAgIFwiw5tcIjogXCImVWNpcmM7XCIsXG4gICAgICBcIsOcXCI6IFwiJlV1bWw7XCIsXG4gICAgICBcIsOdXCI6IFwiJllhY3V0ZTtcIixcbiAgICAgIFwiw55cIjogXCImVEhPUk47XCIsXG4gICAgICBcIsOfXCI6IFwiJnN6bGlnO1wiLFxuICAgICAgXCLDoFwiOiBcIiZhZ3JhdmU7XCIsXG4gICAgICBcIsOhXCI6IFwiJmFhY3V0ZTtcIixcbiAgICAgIFwiw6JcIjogXCImYWNpcmM7XCIsXG4gICAgICBcIsOjXCI6IFwiJmF0aWxkZTtcIixcbiAgICAgIFwiw6RcIjogXCImYXVtbDtcIixcbiAgICAgIFwiw6VcIjogXCImYXJpbmc7XCIsXG4gICAgICBcIsOmXCI6IFwiJmFlbGlnO1wiLFxuICAgICAgXCLDp1wiOiBcIiZjY2VkaWw7XCIsXG4gICAgICBcIsOoXCI6IFwiJmVncmF2ZTtcIixcbiAgICAgIFwiw6lcIjogXCImZWFjdXRlO1wiLFxuICAgICAgXCLDqlwiOiBcIiZlY2lyYztcIixcbiAgICAgIFwiw6tcIjogXCImZXVtbDtcIixcbiAgICAgIFwiw6xcIjogXCImaWdyYXZlO1wiLFxuICAgICAgXCLDrVwiOiBcIiZpYWN1dGU7XCIsXG4gICAgICBcIsOuXCI6IFwiJmljaXJjO1wiLFxuICAgICAgXCLDr1wiOiBcIiZpdW1sO1wiLFxuICAgICAgXCLDsFwiOiBcIiZldGg7XCIsXG4gICAgICBcIsOxXCI6IFwiJm50aWxkZTtcIixcbiAgICAgIFwiw7JcIjogXCImb2dyYXZlO1wiLFxuICAgICAgXCLDs1wiOiBcIiZvYWN1dGU7XCIsXG4gICAgICBcIsO0XCI6IFwiJm9jaXJjO1wiLFxuICAgICAgXCLDtVwiOiBcIiZvdGlsZGU7XCIsXG4gICAgICBcIsO2XCI6IFwiJm91bWw7XCIsXG4gICAgICBcIsO3XCI6IFwiJmRpdmlkZTtcIixcbiAgICAgIFwiw7hcIjogXCImb3NsYXNoO1wiLFxuICAgICAgXCLDuVwiOiBcIiZ1Z3JhdmU7XCIsXG4gICAgICBcIsO6XCI6IFwiJnVhY3V0ZTtcIixcbiAgICAgIFwiw7tcIjogXCImdWNpcmM7XCIsXG4gICAgICBcIsO8XCI6IFwiJnV1bWw7XCIsXG4gICAgICBcIsO9XCI6IFwiJnlhY3V0ZTtcIixcbiAgICAgIFwiw75cIjogXCImdGhvcm47XCIsXG4gICAgICBcIsO/XCI6IFwiJnl1bWw7XCIsXG4gICAgICAnXCInOiBcIiZxdW90O1wiLFxuICAgICAgXCImXCI6IFwiJmFtcDtcIixcbiAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgIFwixZJcIjogXCImT0VsaWc7XCIsXG4gICAgICBcIsWTXCI6IFwiJm9lbGlnO1wiLFxuICAgICAgXCLFoFwiOiBcIiZTY2Fyb247XCIsXG4gICAgICBcIsWhXCI6IFwiJnNjYXJvbjtcIixcbiAgICAgIFwixbhcIjogXCImWXVtbDtcIixcbiAgICAgIFwiy4ZcIjogXCImY2lyYztcIixcbiAgICAgIFwiy5xcIjogXCImdGlsZGU7XCIsXG4gICAgICBcIuKAglwiOiBcIiZlbnNwO1wiLFxuICAgICAgXCLigINcIjogXCImZW1zcDtcIixcbiAgICAgIFwi4oCJXCI6IFwiJnRoaW5zcDtcIixcbiAgICAgIFwi4oCMXCI6IFwiJnp3bmo7XCIsXG4gICAgICBcIuKAjVwiOiBcIiZ6d2o7XCIsXG4gICAgICBcIuKAjlwiOiBcIiZscm07XCIsXG4gICAgICBcIuKAj1wiOiBcIiZybG07XCIsXG4gICAgICBcIuKAk1wiOiBcIiZuZGFzaDtcIixcbiAgICAgIFwi4oCUXCI6IFwiJm1kYXNoO1wiLFxuICAgICAgXCLigJhcIjogXCImbHNxdW87XCIsXG4gICAgICBcIuKAmVwiOiBcIiZyc3F1bztcIixcbiAgICAgIFwi4oCaXCI6IFwiJnNicXVvO1wiLFxuICAgICAgXCLigJxcIjogXCImbGRxdW87XCIsXG4gICAgICBcIuKAnVwiOiBcIiZyZHF1bztcIixcbiAgICAgIFwi4oCeXCI6IFwiJmJkcXVvO1wiLFxuICAgICAgXCLigKBcIjogXCImZGFnZ2VyO1wiLFxuICAgICAgXCLigKFcIjogXCImRGFnZ2VyO1wiLFxuICAgICAgXCLigLBcIjogXCImcGVybWlsO1wiLFxuICAgICAgXCLigLlcIjogXCImbHNhcXVvO1wiLFxuICAgICAgXCLigLpcIjogXCImcnNhcXVvO1wiLFxuICAgICAgXCLigqxcIjogXCImZXVybztcIixcbiAgICAgIFwixpJcIjogXCImZm5vZjtcIixcbiAgICAgIFwizpFcIjogXCImQWxwaGE7XCIsXG4gICAgICBcIs6SXCI6IFwiJkJldGE7XCIsXG4gICAgICBcIs6TXCI6IFwiJkdhbW1hO1wiLFxuICAgICAgXCLOlFwiOiBcIiZEZWx0YTtcIixcbiAgICAgIFwizpVcIjogXCImRXBzaWxvbjtcIixcbiAgICAgIFwizpZcIjogXCImWmV0YTtcIixcbiAgICAgIFwizpdcIjogXCImRXRhO1wiLFxuICAgICAgXCLOmFwiOiBcIiZUaGV0YTtcIixcbiAgICAgIFwizplcIjogXCImSW90YTtcIixcbiAgICAgIFwizppcIjogXCImS2FwcGE7XCIsXG4gICAgICBcIs6bXCI6IFwiJkxhbWJkYTtcIixcbiAgICAgIFwizpxcIjogXCImTXU7XCIsXG4gICAgICBcIs6dXCI6IFwiJk51O1wiLFxuICAgICAgXCLOnlwiOiBcIiZYaTtcIixcbiAgICAgIFwizp9cIjogXCImT21pY3JvbjtcIixcbiAgICAgIFwizqBcIjogXCImUGk7XCIsXG4gICAgICBcIs6hXCI6IFwiJlJobztcIixcbiAgICAgIFwizqNcIjogXCImU2lnbWE7XCIsXG4gICAgICBcIs6kXCI6IFwiJlRhdTtcIixcbiAgICAgIFwizqVcIjogXCImVXBzaWxvbjtcIixcbiAgICAgIFwizqZcIjogXCImUGhpO1wiLFxuICAgICAgXCLOp1wiOiBcIiZDaGk7XCIsXG4gICAgICBcIs6oXCI6IFwiJlBzaTtcIixcbiAgICAgIFwizqlcIjogXCImT21lZ2E7XCIsXG4gICAgICBcIs6xXCI6IFwiJmFscGhhO1wiLFxuICAgICAgXCLOslwiOiBcIiZiZXRhO1wiLFxuICAgICAgXCLOs1wiOiBcIiZnYW1tYTtcIixcbiAgICAgIFwizrRcIjogXCImZGVsdGE7XCIsXG4gICAgICBcIs61XCI6IFwiJmVwc2lsb247XCIsXG4gICAgICBcIs62XCI6IFwiJnpldGE7XCIsXG4gICAgICBcIs63XCI6IFwiJmV0YTtcIixcbiAgICAgIFwizrhcIjogXCImdGhldGE7XCIsXG4gICAgICBcIs65XCI6IFwiJmlvdGE7XCIsXG4gICAgICBcIs66XCI6IFwiJmthcHBhO1wiLFxuICAgICAgXCLOu1wiOiBcIiZsYW1iZGE7XCIsXG4gICAgICBcIs68XCI6IFwiJm11O1wiLFxuICAgICAgXCLOvVwiOiBcIiZudTtcIixcbiAgICAgIFwizr5cIjogXCImeGk7XCIsXG4gICAgICBcIs6/XCI6IFwiJm9taWNyb247XCIsXG4gICAgICBcIs+AXCI6IFwiJnBpO1wiLFxuICAgICAgXCLPgVwiOiBcIiZyaG87XCIsXG4gICAgICBcIs+CXCI6IFwiJnNpZ21hZjtcIixcbiAgICAgIFwiz4NcIjogXCImc2lnbWE7XCIsXG4gICAgICBcIs+EXCI6IFwiJnRhdTtcIixcbiAgICAgIFwiz4VcIjogXCImdXBzaWxvbjtcIixcbiAgICAgIFwiz4ZcIjogXCImcGhpO1wiLFxuICAgICAgXCLPh1wiOiBcIiZjaGk7XCIsXG4gICAgICBcIs+IXCI6IFwiJnBzaTtcIixcbiAgICAgIFwiz4lcIjogXCImb21lZ2E7XCIsXG4gICAgICBcIs+RXCI6IFwiJnRoZXRhc3ltO1wiLFxuICAgICAgXCLPklwiOiBcIiZ1cHNpaDtcIixcbiAgICAgIFwiz5ZcIjogXCImcGl2O1wiLFxuICAgICAgXCLigKJcIjogXCImYnVsbDtcIixcbiAgICAgIFwi4oCmXCI6IFwiJmhlbGxpcDtcIixcbiAgICAgIFwi4oCyXCI6IFwiJnByaW1lO1wiLFxuICAgICAgXCLigLNcIjogXCImUHJpbWU7XCIsXG4gICAgICBcIuKAvlwiOiBcIiZvbGluZTtcIixcbiAgICAgIFwi4oGEXCI6IFwiJmZyYXNsO1wiLFxuICAgICAgXCLihJhcIjogXCImd2VpZXJwO1wiLFxuICAgICAgXCLihJFcIjogXCImaW1hZ2U7XCIsXG4gICAgICBcIuKEnFwiOiBcIiZyZWFsO1wiLFxuICAgICAgXCLihKJcIjogXCImdHJhZGU7XCIsXG4gICAgICBcIuKEtVwiOiBcIiZhbGVmc3ltO1wiLFxuICAgICAgXCLihpBcIjogXCImbGFycjtcIixcbiAgICAgIFwi4oaRXCI6IFwiJnVhcnI7XCIsXG4gICAgICBcIuKGklwiOiBcIiZyYXJyO1wiLFxuICAgICAgXCLihpNcIjogXCImZGFycjtcIixcbiAgICAgIFwi4oaUXCI6IFwiJmhhcnI7XCIsXG4gICAgICBcIuKGtVwiOiBcIiZjcmFycjtcIixcbiAgICAgIFwi4oeQXCI6IFwiJmxBcnI7XCIsXG4gICAgICBcIuKHkVwiOiBcIiZ1QXJyO1wiLFxuICAgICAgXCLih5JcIjogXCImckFycjtcIixcbiAgICAgIFwi4oeTXCI6IFwiJmRBcnI7XCIsXG4gICAgICBcIuKHlFwiOiBcIiZoQXJyO1wiLFxuICAgICAgXCLiiIBcIjogXCImZm9yYWxsO1wiLFxuICAgICAgXCLiiIJcIjogXCImcGFydDtcIixcbiAgICAgIFwi4oiDXCI6IFwiJmV4aXN0O1wiLFxuICAgICAgXCLiiIVcIjogXCImZW1wdHk7XCIsXG4gICAgICBcIuKIh1wiOiBcIiZuYWJsYTtcIixcbiAgICAgIFwi4oiIXCI6IFwiJmlzaW47XCIsXG4gICAgICBcIuKIiVwiOiBcIiZub3RpbjtcIixcbiAgICAgIFwi4oiLXCI6IFwiJm5pO1wiLFxuICAgICAgXCLiiI9cIjogXCImcHJvZDtcIixcbiAgICAgIFwi4oiRXCI6IFwiJnN1bTtcIixcbiAgICAgIFwi4oiSXCI6IFwiJm1pbnVzO1wiLFxuICAgICAgXCLiiJdcIjogXCImbG93YXN0O1wiLFxuICAgICAgXCLiiJpcIjogXCImcmFkaWM7XCIsXG4gICAgICBcIuKInVwiOiBcIiZwcm9wO1wiLFxuICAgICAgXCLiiJ5cIjogXCImaW5maW47XCIsXG4gICAgICBcIuKIoFwiOiBcIiZhbmc7XCIsXG4gICAgICBcIuKIp1wiOiBcIiZhbmQ7XCIsXG4gICAgICBcIuKIqFwiOiBcIiZvcjtcIixcbiAgICAgIFwi4oipXCI6IFwiJmNhcDtcIixcbiAgICAgIFwi4oiqXCI6IFwiJmN1cDtcIixcbiAgICAgIFwi4oirXCI6IFwiJmludDtcIixcbiAgICAgIFwi4oi0XCI6IFwiJnRoZXJlNDtcIixcbiAgICAgIFwi4oi8XCI6IFwiJnNpbTtcIixcbiAgICAgIFwi4omFXCI6IFwiJmNvbmc7XCIsXG4gICAgICBcIuKJiFwiOiBcIiZhc3ltcDtcIixcbiAgICAgIFwi4omgXCI6IFwiJm5lO1wiLFxuICAgICAgXCLiiaFcIjogXCImZXF1aXY7XCIsXG4gICAgICBcIuKJpFwiOiBcIiZsZTtcIixcbiAgICAgIFwi4omlXCI6IFwiJmdlO1wiLFxuICAgICAgXCLiioJcIjogXCImc3ViO1wiLFxuICAgICAgXCLiioNcIjogXCImc3VwO1wiLFxuICAgICAgXCLiioRcIjogXCImbnN1YjtcIixcbiAgICAgIFwi4oqGXCI6IFwiJnN1YmU7XCIsXG4gICAgICBcIuKKh1wiOiBcIiZzdXBlO1wiLFxuICAgICAgXCLiipVcIjogXCImb3BsdXM7XCIsXG4gICAgICBcIuKKl1wiOiBcIiZvdGltZXM7XCIsXG4gICAgICBcIuKKpVwiOiBcIiZwZXJwO1wiLFxuICAgICAgXCLii4VcIjogXCImc2RvdDtcIixcbiAgICAgIFwi4oyIXCI6IFwiJmxjZWlsO1wiLFxuICAgICAgXCLijIlcIjogXCImcmNlaWw7XCIsXG4gICAgICBcIuKMilwiOiBcIiZsZmxvb3I7XCIsXG4gICAgICBcIuKMi1wiOiBcIiZyZmxvb3I7XCIsXG4gICAgICBcIuKMqVwiOiBcIiZsYW5nO1wiLFxuICAgICAgXCLijKpcIjogXCImcmFuZztcIixcbiAgICAgIFwi4peKXCI6IFwiJmxvejtcIixcbiAgICAgIFwi4pmgXCI6IFwiJnNwYWRlcztcIixcbiAgICAgIFwi4pmjXCI6IFwiJmNsdWJzO1wiLFxuICAgICAgXCLimaVcIjogXCImaGVhcnRzO1wiLFxuICAgICAgXCLimaZcIjogXCImZGlhbXM7XCJcbiAgICB9XG4gIH0sXG4gIGh0bWw1OiB7XG4gICAgZW50aXRpZXM6IHtcbiAgICAgIFwiJkFFbGlnXCI6IFwiw4ZcIixcbiAgICAgIFwiJkFFbGlnO1wiOiBcIsOGXCIsXG4gICAgICBcIiZBTVBcIjogXCImXCIsXG4gICAgICBcIiZBTVA7XCI6IFwiJlwiLFxuICAgICAgXCImQWFjdXRlXCI6IFwiw4FcIixcbiAgICAgIFwiJkFhY3V0ZTtcIjogXCLDgVwiLFxuICAgICAgXCImQWJyZXZlO1wiOiBcIsSCXCIsXG4gICAgICBcIiZBY2lyY1wiOiBcIsOCXCIsXG4gICAgICBcIiZBY2lyYztcIjogXCLDglwiLFxuICAgICAgXCImQWN5O1wiOiBcItCQXCIsXG4gICAgICBcIiZBZnI7XCI6IFwi8J2UhFwiLFxuICAgICAgXCImQWdyYXZlXCI6IFwiw4BcIixcbiAgICAgIFwiJkFncmF2ZTtcIjogXCLDgFwiLFxuICAgICAgXCImQWxwaGE7XCI6IFwizpFcIixcbiAgICAgIFwiJkFtYWNyO1wiOiBcIsSAXCIsXG4gICAgICBcIiZBbmQ7XCI6IFwi4qmTXCIsXG4gICAgICBcIiZBb2dvbjtcIjogXCLEhFwiLFxuICAgICAgXCImQW9wZjtcIjogXCLwnZS4XCIsXG4gICAgICBcIiZBcHBseUZ1bmN0aW9uO1wiOiBcIuKBoVwiLFxuICAgICAgXCImQXJpbmdcIjogXCLDhVwiLFxuICAgICAgXCImQXJpbmc7XCI6IFwiw4VcIixcbiAgICAgIFwiJkFzY3I7XCI6IFwi8J2SnFwiLFxuICAgICAgXCImQXNzaWduO1wiOiBcIuKJlFwiLFxuICAgICAgXCImQXRpbGRlXCI6IFwiw4NcIixcbiAgICAgIFwiJkF0aWxkZTtcIjogXCLDg1wiLFxuICAgICAgXCImQXVtbFwiOiBcIsOEXCIsXG4gICAgICBcIiZBdW1sO1wiOiBcIsOEXCIsXG4gICAgICBcIiZCYWNrc2xhc2g7XCI6IFwi4oiWXCIsXG4gICAgICBcIiZCYXJ2O1wiOiBcIuKrp1wiLFxuICAgICAgXCImQmFyd2VkO1wiOiBcIuKMhlwiLFxuICAgICAgXCImQmN5O1wiOiBcItCRXCIsXG4gICAgICBcIiZCZWNhdXNlO1wiOiBcIuKItVwiLFxuICAgICAgXCImQmVybm91bGxpcztcIjogXCLihKxcIixcbiAgICAgIFwiJkJldGE7XCI6IFwizpJcIixcbiAgICAgIFwiJkJmcjtcIjogXCLwnZSFXCIsXG4gICAgICBcIiZCb3BmO1wiOiBcIvCdlLlcIixcbiAgICAgIFwiJkJyZXZlO1wiOiBcIsuYXCIsXG4gICAgICBcIiZCc2NyO1wiOiBcIuKErFwiLFxuICAgICAgXCImQnVtcGVxO1wiOiBcIuKJjlwiLFxuICAgICAgXCImQ0hjeTtcIjogXCLQp1wiLFxuICAgICAgXCImQ09QWVwiOiBcIsKpXCIsXG4gICAgICBcIiZDT1BZO1wiOiBcIsKpXCIsXG4gICAgICBcIiZDYWN1dGU7XCI6IFwixIZcIixcbiAgICAgIFwiJkNhcDtcIjogXCLii5JcIixcbiAgICAgIFwiJkNhcGl0YWxEaWZmZXJlbnRpYWxEO1wiOiBcIuKFhVwiLFxuICAgICAgXCImQ2F5bGV5cztcIjogXCLihK1cIixcbiAgICAgIFwiJkNjYXJvbjtcIjogXCLEjFwiLFxuICAgICAgXCImQ2NlZGlsXCI6IFwiw4dcIixcbiAgICAgIFwiJkNjZWRpbDtcIjogXCLDh1wiLFxuICAgICAgXCImQ2NpcmM7XCI6IFwixIhcIixcbiAgICAgIFwiJkNjb25pbnQ7XCI6IFwi4oiwXCIsXG4gICAgICBcIiZDZG90O1wiOiBcIsSKXCIsXG4gICAgICBcIiZDZWRpbGxhO1wiOiBcIsK4XCIsXG4gICAgICBcIiZDZW50ZXJEb3Q7XCI6IFwiwrdcIixcbiAgICAgIFwiJkNmcjtcIjogXCLihK1cIixcbiAgICAgIFwiJkNoaTtcIjogXCLOp1wiLFxuICAgICAgXCImQ2lyY2xlRG90O1wiOiBcIuKKmVwiLFxuICAgICAgXCImQ2lyY2xlTWludXM7XCI6IFwi4oqWXCIsXG4gICAgICBcIiZDaXJjbGVQbHVzO1wiOiBcIuKKlVwiLFxuICAgICAgXCImQ2lyY2xlVGltZXM7XCI6IFwi4oqXXCIsXG4gICAgICBcIiZDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6IFwi4oiyXCIsXG4gICAgICBcIiZDbG9zZUN1cmx5RG91YmxlUXVvdGU7XCI6IFwi4oCdXCIsXG4gICAgICBcIiZDbG9zZUN1cmx5UXVvdGU7XCI6IFwi4oCZXCIsXG4gICAgICBcIiZDb2xvbjtcIjogXCLiiLdcIixcbiAgICAgIFwiJkNvbG9uZTtcIjogXCLiqbRcIixcbiAgICAgIFwiJkNvbmdydWVudDtcIjogXCLiiaFcIixcbiAgICAgIFwiJkNvbmludDtcIjogXCLiiK9cIixcbiAgICAgIFwiJkNvbnRvdXJJbnRlZ3JhbDtcIjogXCLiiK5cIixcbiAgICAgIFwiJkNvcGY7XCI6IFwi4oSCXCIsXG4gICAgICBcIiZDb3Byb2R1Y3Q7XCI6IFwi4oiQXCIsXG4gICAgICBcIiZDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsO1wiOiBcIuKIs1wiLFxuICAgICAgXCImQ3Jvc3M7XCI6IFwi4qivXCIsXG4gICAgICBcIiZDc2NyO1wiOiBcIvCdkp5cIixcbiAgICAgIFwiJkN1cDtcIjogXCLii5NcIixcbiAgICAgIFwiJkN1cENhcDtcIjogXCLiiY1cIixcbiAgICAgIFwiJkREO1wiOiBcIuKFhVwiLFxuICAgICAgXCImRERvdHJhaGQ7XCI6IFwi4qSRXCIsXG4gICAgICBcIiZESmN5O1wiOiBcItCCXCIsXG4gICAgICBcIiZEU2N5O1wiOiBcItCFXCIsXG4gICAgICBcIiZEWmN5O1wiOiBcItCPXCIsXG4gICAgICBcIiZEYWdnZXI7XCI6IFwi4oChXCIsXG4gICAgICBcIiZEYXJyO1wiOiBcIuKGoVwiLFxuICAgICAgXCImRGFzaHY7XCI6IFwi4qukXCIsXG4gICAgICBcIiZEY2Fyb247XCI6IFwixI5cIixcbiAgICAgIFwiJkRjeTtcIjogXCLQlFwiLFxuICAgICAgXCImRGVsO1wiOiBcIuKIh1wiLFxuICAgICAgXCImRGVsdGE7XCI6IFwizpRcIixcbiAgICAgIFwiJkRmcjtcIjogXCLwnZSHXCIsXG4gICAgICBcIiZEaWFjcml0aWNhbEFjdXRlO1wiOiBcIsK0XCIsXG4gICAgICBcIiZEaWFjcml0aWNhbERvdDtcIjogXCLLmVwiLFxuICAgICAgXCImRGlhY3JpdGljYWxEb3VibGVBY3V0ZTtcIjogXCLLnVwiLFxuICAgICAgXCImRGlhY3JpdGljYWxHcmF2ZTtcIjogXCJgXCIsXG4gICAgICBcIiZEaWFjcml0aWNhbFRpbGRlO1wiOiBcIsucXCIsXG4gICAgICBcIiZEaWFtb25kO1wiOiBcIuKLhFwiLFxuICAgICAgXCImRGlmZmVyZW50aWFsRDtcIjogXCLihYZcIixcbiAgICAgIFwiJkRvcGY7XCI6IFwi8J2Uu1wiLFxuICAgICAgXCImRG90O1wiOiBcIsKoXCIsXG4gICAgICBcIiZEb3REb3Q7XCI6IFwi4oOcXCIsXG4gICAgICBcIiZEb3RFcXVhbDtcIjogXCLiiZBcIixcbiAgICAgIFwiJkRvdWJsZUNvbnRvdXJJbnRlZ3JhbDtcIjogXCLiiK9cIixcbiAgICAgIFwiJkRvdWJsZURvdDtcIjogXCLCqFwiLFxuICAgICAgXCImRG91YmxlRG93bkFycm93O1wiOiBcIuKHk1wiLFxuICAgICAgXCImRG91YmxlTGVmdEFycm93O1wiOiBcIuKHkFwiLFxuICAgICAgXCImRG91YmxlTGVmdFJpZ2h0QXJyb3c7XCI6IFwi4oeUXCIsXG4gICAgICBcIiZEb3VibGVMZWZ0VGVlO1wiOiBcIuKrpFwiLFxuICAgICAgXCImRG91YmxlTG9uZ0xlZnRBcnJvdztcIjogXCLin7hcIixcbiAgICAgIFwiJkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdztcIjogXCLin7pcIixcbiAgICAgIFwiJkRvdWJsZUxvbmdSaWdodEFycm93O1wiOiBcIuKfuVwiLFxuICAgICAgXCImRG91YmxlUmlnaHRBcnJvdztcIjogXCLih5JcIixcbiAgICAgIFwiJkRvdWJsZVJpZ2h0VGVlO1wiOiBcIuKKqFwiLFxuICAgICAgXCImRG91YmxlVXBBcnJvdztcIjogXCLih5FcIixcbiAgICAgIFwiJkRvdWJsZVVwRG93bkFycm93O1wiOiBcIuKHlVwiLFxuICAgICAgXCImRG91YmxlVmVydGljYWxCYXI7XCI6IFwi4oilXCIsXG4gICAgICBcIiZEb3duQXJyb3c7XCI6IFwi4oaTXCIsXG4gICAgICBcIiZEb3duQXJyb3dCYXI7XCI6IFwi4qSTXCIsXG4gICAgICBcIiZEb3duQXJyb3dVcEFycm93O1wiOiBcIuKHtVwiLFxuICAgICAgXCImRG93bkJyZXZlO1wiOiBcIsyRXCIsXG4gICAgICBcIiZEb3duTGVmdFJpZ2h0VmVjdG9yO1wiOiBcIuKlkFwiLFxuICAgICAgXCImRG93bkxlZnRUZWVWZWN0b3I7XCI6IFwi4qWeXCIsXG4gICAgICBcIiZEb3duTGVmdFZlY3RvcjtcIjogXCLihr1cIixcbiAgICAgIFwiJkRvd25MZWZ0VmVjdG9yQmFyO1wiOiBcIuKlllwiLFxuICAgICAgXCImRG93blJpZ2h0VGVlVmVjdG9yO1wiOiBcIuKln1wiLFxuICAgICAgXCImRG93blJpZ2h0VmVjdG9yO1wiOiBcIuKHgVwiLFxuICAgICAgXCImRG93blJpZ2h0VmVjdG9yQmFyO1wiOiBcIuKll1wiLFxuICAgICAgXCImRG93blRlZTtcIjogXCLiiqRcIixcbiAgICAgIFwiJkRvd25UZWVBcnJvdztcIjogXCLihqdcIixcbiAgICAgIFwiJkRvd25hcnJvdztcIjogXCLih5NcIixcbiAgICAgIFwiJkRzY3I7XCI6IFwi8J2Sn1wiLFxuICAgICAgXCImRHN0cm9rO1wiOiBcIsSQXCIsXG4gICAgICBcIiZFTkc7XCI6IFwixYpcIixcbiAgICAgIFwiJkVUSFwiOiBcIsOQXCIsXG4gICAgICBcIiZFVEg7XCI6IFwiw5BcIixcbiAgICAgIFwiJkVhY3V0ZVwiOiBcIsOJXCIsXG4gICAgICBcIiZFYWN1dGU7XCI6IFwiw4lcIixcbiAgICAgIFwiJkVjYXJvbjtcIjogXCLEmlwiLFxuICAgICAgXCImRWNpcmNcIjogXCLDilwiLFxuICAgICAgXCImRWNpcmM7XCI6IFwiw4pcIixcbiAgICAgIFwiJkVjeTtcIjogXCLQrVwiLFxuICAgICAgXCImRWRvdDtcIjogXCLEllwiLFxuICAgICAgXCImRWZyO1wiOiBcIvCdlIhcIixcbiAgICAgIFwiJkVncmF2ZVwiOiBcIsOIXCIsXG4gICAgICBcIiZFZ3JhdmU7XCI6IFwiw4hcIixcbiAgICAgIFwiJkVsZW1lbnQ7XCI6IFwi4oiIXCIsXG4gICAgICBcIiZFbWFjcjtcIjogXCLEklwiLFxuICAgICAgXCImRW1wdHlTbWFsbFNxdWFyZTtcIjogXCLil7tcIixcbiAgICAgIFwiJkVtcHR5VmVyeVNtYWxsU3F1YXJlO1wiOiBcIuKWq1wiLFxuICAgICAgXCImRW9nb247XCI6IFwixJhcIixcbiAgICAgIFwiJkVvcGY7XCI6IFwi8J2UvFwiLFxuICAgICAgXCImRXBzaWxvbjtcIjogXCLOlVwiLFxuICAgICAgXCImRXF1YWw7XCI6IFwi4qm1XCIsXG4gICAgICBcIiZFcXVhbFRpbGRlO1wiOiBcIuKJglwiLFxuICAgICAgXCImRXF1aWxpYnJpdW07XCI6IFwi4oeMXCIsXG4gICAgICBcIiZFc2NyO1wiOiBcIuKEsFwiLFxuICAgICAgXCImRXNpbTtcIjogXCLiqbNcIixcbiAgICAgIFwiJkV0YTtcIjogXCLOl1wiLFxuICAgICAgXCImRXVtbFwiOiBcIsOLXCIsXG4gICAgICBcIiZFdW1sO1wiOiBcIsOLXCIsXG4gICAgICBcIiZFeGlzdHM7XCI6IFwi4oiDXCIsXG4gICAgICBcIiZFeHBvbmVudGlhbEU7XCI6IFwi4oWHXCIsXG4gICAgICBcIiZGY3k7XCI6IFwi0KRcIixcbiAgICAgIFwiJkZmcjtcIjogXCLwnZSJXCIsXG4gICAgICBcIiZGaWxsZWRTbWFsbFNxdWFyZTtcIjogXCLil7xcIixcbiAgICAgIFwiJkZpbGxlZFZlcnlTbWFsbFNxdWFyZTtcIjogXCLilqpcIixcbiAgICAgIFwiJkZvcGY7XCI6IFwi8J2UvVwiLFxuICAgICAgXCImRm9yQWxsO1wiOiBcIuKIgFwiLFxuICAgICAgXCImRm91cmllcnRyZjtcIjogXCLihLFcIixcbiAgICAgIFwiJkZzY3I7XCI6IFwi4oSxXCIsXG4gICAgICBcIiZHSmN5O1wiOiBcItCDXCIsXG4gICAgICBcIiZHVFwiOiBcIj5cIixcbiAgICAgIFwiJkdUO1wiOiBcIj5cIixcbiAgICAgIFwiJkdhbW1hO1wiOiBcIs6TXCIsXG4gICAgICBcIiZHYW1tYWQ7XCI6IFwiz5xcIixcbiAgICAgIFwiJkdicmV2ZTtcIjogXCLEnlwiLFxuICAgICAgXCImR2NlZGlsO1wiOiBcIsSiXCIsXG4gICAgICBcIiZHY2lyYztcIjogXCLEnFwiLFxuICAgICAgXCImR2N5O1wiOiBcItCTXCIsXG4gICAgICBcIiZHZG90O1wiOiBcIsSgXCIsXG4gICAgICBcIiZHZnI7XCI6IFwi8J2UilwiLFxuICAgICAgXCImR2c7XCI6IFwi4ouZXCIsXG4gICAgICBcIiZHb3BmO1wiOiBcIvCdlL5cIixcbiAgICAgIFwiJkdyZWF0ZXJFcXVhbDtcIjogXCLiiaVcIixcbiAgICAgIFwiJkdyZWF0ZXJFcXVhbExlc3M7XCI6IFwi4oubXCIsXG4gICAgICBcIiZHcmVhdGVyRnVsbEVxdWFsO1wiOiBcIuKJp1wiLFxuICAgICAgXCImR3JlYXRlckdyZWF0ZXI7XCI6IFwi4qqiXCIsXG4gICAgICBcIiZHcmVhdGVyTGVzcztcIjogXCLiibdcIixcbiAgICAgIFwiJkdyZWF0ZXJTbGFudEVxdWFsO1wiOiBcIuKpvlwiLFxuICAgICAgXCImR3JlYXRlclRpbGRlO1wiOiBcIuKJs1wiLFxuICAgICAgXCImR3NjcjtcIjogXCLwnZKiXCIsXG4gICAgICBcIiZHdDtcIjogXCLiiatcIixcbiAgICAgIFwiJkhBUkRjeTtcIjogXCLQqlwiLFxuICAgICAgXCImSGFjZWs7XCI6IFwiy4dcIixcbiAgICAgIFwiJkhhdDtcIjogXCJeXCIsXG4gICAgICBcIiZIY2lyYztcIjogXCLEpFwiLFxuICAgICAgXCImSGZyO1wiOiBcIuKEjFwiLFxuICAgICAgXCImSGlsYmVydFNwYWNlO1wiOiBcIuKEi1wiLFxuICAgICAgXCImSG9wZjtcIjogXCLihI1cIixcbiAgICAgIFwiJkhvcml6b250YWxMaW5lO1wiOiBcIuKUgFwiLFxuICAgICAgXCImSHNjcjtcIjogXCLihItcIixcbiAgICAgIFwiJkhzdHJvaztcIjogXCLEplwiLFxuICAgICAgXCImSHVtcERvd25IdW1wO1wiOiBcIuKJjlwiLFxuICAgICAgXCImSHVtcEVxdWFsO1wiOiBcIuKJj1wiLFxuICAgICAgXCImSUVjeTtcIjogXCLQlVwiLFxuICAgICAgXCImSUpsaWc7XCI6IFwixLJcIixcbiAgICAgIFwiJklPY3k7XCI6IFwi0IFcIixcbiAgICAgIFwiJklhY3V0ZVwiOiBcIsONXCIsXG4gICAgICBcIiZJYWN1dGU7XCI6IFwiw41cIixcbiAgICAgIFwiJkljaXJjXCI6IFwiw45cIixcbiAgICAgIFwiJkljaXJjO1wiOiBcIsOOXCIsXG4gICAgICBcIiZJY3k7XCI6IFwi0JhcIixcbiAgICAgIFwiJklkb3Q7XCI6IFwixLBcIixcbiAgICAgIFwiJklmcjtcIjogXCLihJFcIixcbiAgICAgIFwiJklncmF2ZVwiOiBcIsOMXCIsXG4gICAgICBcIiZJZ3JhdmU7XCI6IFwiw4xcIixcbiAgICAgIFwiJkltO1wiOiBcIuKEkVwiLFxuICAgICAgXCImSW1hY3I7XCI6IFwixKpcIixcbiAgICAgIFwiJkltYWdpbmFyeUk7XCI6IFwi4oWIXCIsXG4gICAgICBcIiZJbXBsaWVzO1wiOiBcIuKHklwiLFxuICAgICAgXCImSW50O1wiOiBcIuKIrFwiLFxuICAgICAgXCImSW50ZWdyYWw7XCI6IFwi4oirXCIsXG4gICAgICBcIiZJbnRlcnNlY3Rpb247XCI6IFwi4ouCXCIsXG4gICAgICBcIiZJbnZpc2libGVDb21tYTtcIjogXCLigaNcIixcbiAgICAgIFwiJkludmlzaWJsZVRpbWVzO1wiOiBcIuKBolwiLFxuICAgICAgXCImSW9nb247XCI6IFwixK5cIixcbiAgICAgIFwiJklvcGY7XCI6IFwi8J2VgFwiLFxuICAgICAgXCImSW90YTtcIjogXCLOmVwiLFxuICAgICAgXCImSXNjcjtcIjogXCLihJBcIixcbiAgICAgIFwiJkl0aWxkZTtcIjogXCLEqFwiLFxuICAgICAgXCImSXVrY3k7XCI6IFwi0IZcIixcbiAgICAgIFwiJkl1bWxcIjogXCLDj1wiLFxuICAgICAgXCImSXVtbDtcIjogXCLDj1wiLFxuICAgICAgXCImSmNpcmM7XCI6IFwixLRcIixcbiAgICAgIFwiJkpjeTtcIjogXCLQmVwiLFxuICAgICAgXCImSmZyO1wiOiBcIvCdlI1cIixcbiAgICAgIFwiJkpvcGY7XCI6IFwi8J2VgVwiLFxuICAgICAgXCImSnNjcjtcIjogXCLwnZKlXCIsXG4gICAgICBcIiZKc2VyY3k7XCI6IFwi0IhcIixcbiAgICAgIFwiJkp1a2N5O1wiOiBcItCEXCIsXG4gICAgICBcIiZLSGN5O1wiOiBcItClXCIsXG4gICAgICBcIiZLSmN5O1wiOiBcItCMXCIsXG4gICAgICBcIiZLYXBwYTtcIjogXCLOmlwiLFxuICAgICAgXCImS2NlZGlsO1wiOiBcIsS2XCIsXG4gICAgICBcIiZLY3k7XCI6IFwi0JpcIixcbiAgICAgIFwiJktmcjtcIjogXCLwnZSOXCIsXG4gICAgICBcIiZLb3BmO1wiOiBcIvCdlYJcIixcbiAgICAgIFwiJktzY3I7XCI6IFwi8J2SplwiLFxuICAgICAgXCImTEpjeTtcIjogXCLQiVwiLFxuICAgICAgXCImTFRcIjogXCI8XCIsXG4gICAgICBcIiZMVDtcIjogXCI8XCIsXG4gICAgICBcIiZMYWN1dGU7XCI6IFwixLlcIixcbiAgICAgIFwiJkxhbWJkYTtcIjogXCLOm1wiLFxuICAgICAgXCImTGFuZztcIjogXCLin6pcIixcbiAgICAgIFwiJkxhcGxhY2V0cmY7XCI6IFwi4oSSXCIsXG4gICAgICBcIiZMYXJyO1wiOiBcIuKGnlwiLFxuICAgICAgXCImTGNhcm9uO1wiOiBcIsS9XCIsXG4gICAgICBcIiZMY2VkaWw7XCI6IFwixLtcIixcbiAgICAgIFwiJkxjeTtcIjogXCLQm1wiLFxuICAgICAgXCImTGVmdEFuZ2xlQnJhY2tldDtcIjogXCLin6hcIixcbiAgICAgIFwiJkxlZnRBcnJvdztcIjogXCLihpBcIixcbiAgICAgIFwiJkxlZnRBcnJvd0JhcjtcIjogXCLih6RcIixcbiAgICAgIFwiJkxlZnRBcnJvd1JpZ2h0QXJyb3c7XCI6IFwi4oeGXCIsXG4gICAgICBcIiZMZWZ0Q2VpbGluZztcIjogXCLijIhcIixcbiAgICAgIFwiJkxlZnREb3VibGVCcmFja2V0O1wiOiBcIuKfplwiLFxuICAgICAgXCImTGVmdERvd25UZWVWZWN0b3I7XCI6IFwi4qWhXCIsXG4gICAgICBcIiZMZWZ0RG93blZlY3RvcjtcIjogXCLih4NcIixcbiAgICAgIFwiJkxlZnREb3duVmVjdG9yQmFyO1wiOiBcIuKlmVwiLFxuICAgICAgXCImTGVmdEZsb29yO1wiOiBcIuKMilwiLFxuICAgICAgXCImTGVmdFJpZ2h0QXJyb3c7XCI6IFwi4oaUXCIsXG4gICAgICBcIiZMZWZ0UmlnaHRWZWN0b3I7XCI6IFwi4qWOXCIsXG4gICAgICBcIiZMZWZ0VGVlO1wiOiBcIuKKo1wiLFxuICAgICAgXCImTGVmdFRlZUFycm93O1wiOiBcIuKGpFwiLFxuICAgICAgXCImTGVmdFRlZVZlY3RvcjtcIjogXCLipZpcIixcbiAgICAgIFwiJkxlZnRUcmlhbmdsZTtcIjogXCLiirJcIixcbiAgICAgIFwiJkxlZnRUcmlhbmdsZUJhcjtcIjogXCLip49cIixcbiAgICAgIFwiJkxlZnRUcmlhbmdsZUVxdWFsO1wiOiBcIuKKtFwiLFxuICAgICAgXCImTGVmdFVwRG93blZlY3RvcjtcIjogXCLipZFcIixcbiAgICAgIFwiJkxlZnRVcFRlZVZlY3RvcjtcIjogXCLipaBcIixcbiAgICAgIFwiJkxlZnRVcFZlY3RvcjtcIjogXCLihr9cIixcbiAgICAgIFwiJkxlZnRVcFZlY3RvckJhcjtcIjogXCLipZhcIixcbiAgICAgIFwiJkxlZnRWZWN0b3I7XCI6IFwi4oa8XCIsXG4gICAgICBcIiZMZWZ0VmVjdG9yQmFyO1wiOiBcIuKlklwiLFxuICAgICAgXCImTGVmdGFycm93O1wiOiBcIuKHkFwiLFxuICAgICAgXCImTGVmdHJpZ2h0YXJyb3c7XCI6IFwi4oeUXCIsXG4gICAgICBcIiZMZXNzRXF1YWxHcmVhdGVyO1wiOiBcIuKLmlwiLFxuICAgICAgXCImTGVzc0Z1bGxFcXVhbDtcIjogXCLiiaZcIixcbiAgICAgIFwiJkxlc3NHcmVhdGVyO1wiOiBcIuKJtlwiLFxuICAgICAgXCImTGVzc0xlc3M7XCI6IFwi4qqhXCIsXG4gICAgICBcIiZMZXNzU2xhbnRFcXVhbDtcIjogXCLiqb1cIixcbiAgICAgIFwiJkxlc3NUaWxkZTtcIjogXCLiibJcIixcbiAgICAgIFwiJkxmcjtcIjogXCLwnZSPXCIsXG4gICAgICBcIiZMbDtcIjogXCLii5hcIixcbiAgICAgIFwiJkxsZWZ0YXJyb3c7XCI6IFwi4oeaXCIsXG4gICAgICBcIiZMbWlkb3Q7XCI6IFwixL9cIixcbiAgICAgIFwiJkxvbmdMZWZ0QXJyb3c7XCI6IFwi4p+1XCIsXG4gICAgICBcIiZMb25nTGVmdFJpZ2h0QXJyb3c7XCI6IFwi4p+3XCIsXG4gICAgICBcIiZMb25nUmlnaHRBcnJvdztcIjogXCLin7ZcIixcbiAgICAgIFwiJkxvbmdsZWZ0YXJyb3c7XCI6IFwi4p+4XCIsXG4gICAgICBcIiZMb25nbGVmdHJpZ2h0YXJyb3c7XCI6IFwi4p+6XCIsXG4gICAgICBcIiZMb25ncmlnaHRhcnJvdztcIjogXCLin7lcIixcbiAgICAgIFwiJkxvcGY7XCI6IFwi8J2Vg1wiLFxuICAgICAgXCImTG93ZXJMZWZ0QXJyb3c7XCI6IFwi4oaZXCIsXG4gICAgICBcIiZMb3dlclJpZ2h0QXJyb3c7XCI6IFwi4oaYXCIsXG4gICAgICBcIiZMc2NyO1wiOiBcIuKEklwiLFxuICAgICAgXCImTHNoO1wiOiBcIuKGsFwiLFxuICAgICAgXCImTHN0cm9rO1wiOiBcIsWBXCIsXG4gICAgICBcIiZMdDtcIjogXCLiiapcIixcbiAgICAgIFwiJk1hcDtcIjogXCLipIVcIixcbiAgICAgIFwiJk1jeTtcIjogXCLQnFwiLFxuICAgICAgXCImTWVkaXVtU3BhY2U7XCI6IFwi4oGfXCIsXG4gICAgICBcIiZNZWxsaW50cmY7XCI6IFwi4oSzXCIsXG4gICAgICBcIiZNZnI7XCI6IFwi8J2UkFwiLFxuICAgICAgXCImTWludXNQbHVzO1wiOiBcIuKIk1wiLFxuICAgICAgXCImTW9wZjtcIjogXCLwnZWEXCIsXG4gICAgICBcIiZNc2NyO1wiOiBcIuKEs1wiLFxuICAgICAgXCImTXU7XCI6IFwizpxcIixcbiAgICAgIFwiJk5KY3k7XCI6IFwi0IpcIixcbiAgICAgIFwiJk5hY3V0ZTtcIjogXCLFg1wiLFxuICAgICAgXCImTmNhcm9uO1wiOiBcIsWHXCIsXG4gICAgICBcIiZOY2VkaWw7XCI6IFwixYVcIixcbiAgICAgIFwiJk5jeTtcIjogXCLQnVwiLFxuICAgICAgXCImTmVnYXRpdmVNZWRpdW1TcGFjZTtcIjogXCLigItcIixcbiAgICAgIFwiJk5lZ2F0aXZlVGhpY2tTcGFjZTtcIjogXCLigItcIixcbiAgICAgIFwiJk5lZ2F0aXZlVGhpblNwYWNlO1wiOiBcIuKAi1wiLFxuICAgICAgXCImTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1wiOiBcIuKAi1wiLFxuICAgICAgXCImTmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6IFwi4omrXCIsXG4gICAgICBcIiZOZXN0ZWRMZXNzTGVzcztcIjogXCLiiapcIixcbiAgICAgIFwiJk5ld0xpbmU7XCI6IFwiXFxuXCIsXG4gICAgICBcIiZOZnI7XCI6IFwi8J2UkVwiLFxuICAgICAgXCImTm9CcmVhaztcIjogXCLigaBcIixcbiAgICAgIFwiJk5vbkJyZWFraW5nU3BhY2U7XCI6IFwiwqBcIixcbiAgICAgIFwiJk5vcGY7XCI6IFwi4oSVXCIsXG4gICAgICBcIiZOb3Q7XCI6IFwi4qusXCIsXG4gICAgICBcIiZOb3RDb25ncnVlbnQ7XCI6IFwi4omiXCIsXG4gICAgICBcIiZOb3RDdXBDYXA7XCI6IFwi4omtXCIsXG4gICAgICBcIiZOb3REb3VibGVWZXJ0aWNhbEJhcjtcIjogXCLiiKZcIixcbiAgICAgIFwiJk5vdEVsZW1lbnQ7XCI6IFwi4oiJXCIsXG4gICAgICBcIiZOb3RFcXVhbDtcIjogXCLiiaBcIixcbiAgICAgIFwiJk5vdEVxdWFsVGlsZGU7XCI6IFwi4omCzLhcIixcbiAgICAgIFwiJk5vdEV4aXN0cztcIjogXCLiiIRcIixcbiAgICAgIFwiJk5vdEdyZWF0ZXI7XCI6IFwi4omvXCIsXG4gICAgICBcIiZOb3RHcmVhdGVyRXF1YWw7XCI6IFwi4omxXCIsXG4gICAgICBcIiZOb3RHcmVhdGVyRnVsbEVxdWFsO1wiOiBcIuKJp8y4XCIsXG4gICAgICBcIiZOb3RHcmVhdGVyR3JlYXRlcjtcIjogXCLiiavMuFwiLFxuICAgICAgXCImTm90R3JlYXRlckxlc3M7XCI6IFwi4om5XCIsXG4gICAgICBcIiZOb3RHcmVhdGVyU2xhbnRFcXVhbDtcIjogXCLiqb7MuFwiLFxuICAgICAgXCImTm90R3JlYXRlclRpbGRlO1wiOiBcIuKJtVwiLFxuICAgICAgXCImTm90SHVtcERvd25IdW1wO1wiOiBcIuKJjsy4XCIsXG4gICAgICBcIiZOb3RIdW1wRXF1YWw7XCI6IFwi4omPzLhcIixcbiAgICAgIFwiJk5vdExlZnRUcmlhbmdsZTtcIjogXCLii6pcIixcbiAgICAgIFwiJk5vdExlZnRUcmlhbmdsZUJhcjtcIjogXCLip4/MuFwiLFxuICAgICAgXCImTm90TGVmdFRyaWFuZ2xlRXF1YWw7XCI6IFwi4ousXCIsXG4gICAgICBcIiZOb3RMZXNzO1wiOiBcIuKJrlwiLFxuICAgICAgXCImTm90TGVzc0VxdWFsO1wiOiBcIuKJsFwiLFxuICAgICAgXCImTm90TGVzc0dyZWF0ZXI7XCI6IFwi4om4XCIsXG4gICAgICBcIiZOb3RMZXNzTGVzcztcIjogXCLiiarMuFwiLFxuICAgICAgXCImTm90TGVzc1NsYW50RXF1YWw7XCI6IFwi4qm9zLhcIixcbiAgICAgIFwiJk5vdExlc3NUaWxkZTtcIjogXCLiibRcIixcbiAgICAgIFwiJk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiOiBcIuKqosy4XCIsXG4gICAgICBcIiZOb3ROZXN0ZWRMZXNzTGVzcztcIjogXCLiqqHMuFwiLFxuICAgICAgXCImTm90UHJlY2VkZXM7XCI6IFwi4oqAXCIsXG4gICAgICBcIiZOb3RQcmVjZWRlc0VxdWFsO1wiOiBcIuKqr8y4XCIsXG4gICAgICBcIiZOb3RQcmVjZWRlc1NsYW50RXF1YWw7XCI6IFwi4ougXCIsXG4gICAgICBcIiZOb3RSZXZlcnNlRWxlbWVudDtcIjogXCLiiIxcIixcbiAgICAgIFwiJk5vdFJpZ2h0VHJpYW5nbGU7XCI6IFwi4ourXCIsXG4gICAgICBcIiZOb3RSaWdodFRyaWFuZ2xlQmFyO1wiOiBcIuKnkMy4XCIsXG4gICAgICBcIiZOb3RSaWdodFRyaWFuZ2xlRXF1YWw7XCI6IFwi4outXCIsXG4gICAgICBcIiZOb3RTcXVhcmVTdWJzZXQ7XCI6IFwi4oqPzLhcIixcbiAgICAgIFwiJk5vdFNxdWFyZVN1YnNldEVxdWFsO1wiOiBcIuKLolwiLFxuICAgICAgXCImTm90U3F1YXJlU3VwZXJzZXQ7XCI6IFwi4oqQzLhcIixcbiAgICAgIFwiJk5vdFNxdWFyZVN1cGVyc2V0RXF1YWw7XCI6IFwi4oujXCIsXG4gICAgICBcIiZOb3RTdWJzZXQ7XCI6IFwi4oqC4oOSXCIsXG4gICAgICBcIiZOb3RTdWJzZXRFcXVhbDtcIjogXCLiiohcIixcbiAgICAgIFwiJk5vdFN1Y2NlZWRzO1wiOiBcIuKKgVwiLFxuICAgICAgXCImTm90U3VjY2VlZHNFcXVhbDtcIjogXCLiqrDMuFwiLFxuICAgICAgXCImTm90U3VjY2VlZHNTbGFudEVxdWFsO1wiOiBcIuKLoVwiLFxuICAgICAgXCImTm90U3VjY2VlZHNUaWxkZTtcIjogXCLiib/MuFwiLFxuICAgICAgXCImTm90U3VwZXJzZXQ7XCI6IFwi4oqD4oOSXCIsXG4gICAgICBcIiZOb3RTdXBlcnNldEVxdWFsO1wiOiBcIuKKiVwiLFxuICAgICAgXCImTm90VGlsZGU7XCI6IFwi4omBXCIsXG4gICAgICBcIiZOb3RUaWxkZUVxdWFsO1wiOiBcIuKJhFwiLFxuICAgICAgXCImTm90VGlsZGVGdWxsRXF1YWw7XCI6IFwi4omHXCIsXG4gICAgICBcIiZOb3RUaWxkZVRpbGRlO1wiOiBcIuKJiVwiLFxuICAgICAgXCImTm90VmVydGljYWxCYXI7XCI6IFwi4oikXCIsXG4gICAgICBcIiZOc2NyO1wiOiBcIvCdkqlcIixcbiAgICAgIFwiJk50aWxkZVwiOiBcIsORXCIsXG4gICAgICBcIiZOdGlsZGU7XCI6IFwiw5FcIixcbiAgICAgIFwiJk51O1wiOiBcIs6dXCIsXG4gICAgICBcIiZPRWxpZztcIjogXCLFklwiLFxuICAgICAgXCImT2FjdXRlXCI6IFwiw5NcIixcbiAgICAgIFwiJk9hY3V0ZTtcIjogXCLDk1wiLFxuICAgICAgXCImT2NpcmNcIjogXCLDlFwiLFxuICAgICAgXCImT2NpcmM7XCI6IFwiw5RcIixcbiAgICAgIFwiJk9jeTtcIjogXCLQnlwiLFxuICAgICAgXCImT2RibGFjO1wiOiBcIsWQXCIsXG4gICAgICBcIiZPZnI7XCI6IFwi8J2UklwiLFxuICAgICAgXCImT2dyYXZlXCI6IFwiw5JcIixcbiAgICAgIFwiJk9ncmF2ZTtcIjogXCLDklwiLFxuICAgICAgXCImT21hY3I7XCI6IFwixYxcIixcbiAgICAgIFwiJk9tZWdhO1wiOiBcIs6pXCIsXG4gICAgICBcIiZPbWljcm9uO1wiOiBcIs6fXCIsXG4gICAgICBcIiZPb3BmO1wiOiBcIvCdlYZcIixcbiAgICAgIFwiJk9wZW5DdXJseURvdWJsZVF1b3RlO1wiOiBcIuKAnFwiLFxuICAgICAgXCImT3BlbkN1cmx5UXVvdGU7XCI6IFwi4oCYXCIsXG4gICAgICBcIiZPcjtcIjogXCLiqZRcIixcbiAgICAgIFwiJk9zY3I7XCI6IFwi8J2SqlwiLFxuICAgICAgXCImT3NsYXNoXCI6IFwiw5hcIixcbiAgICAgIFwiJk9zbGFzaDtcIjogXCLDmFwiLFxuICAgICAgXCImT3RpbGRlXCI6IFwiw5VcIixcbiAgICAgIFwiJk90aWxkZTtcIjogXCLDlVwiLFxuICAgICAgXCImT3RpbWVzO1wiOiBcIuKot1wiLFxuICAgICAgXCImT3VtbFwiOiBcIsOWXCIsXG4gICAgICBcIiZPdW1sO1wiOiBcIsOWXCIsXG4gICAgICBcIiZPdmVyQmFyO1wiOiBcIuKAvlwiLFxuICAgICAgXCImT3ZlckJyYWNlO1wiOiBcIuKPnlwiLFxuICAgICAgXCImT3ZlckJyYWNrZXQ7XCI6IFwi4o60XCIsXG4gICAgICBcIiZPdmVyUGFyZW50aGVzaXM7XCI6IFwi4o+cXCIsXG4gICAgICBcIiZQYXJ0aWFsRDtcIjogXCLiiIJcIixcbiAgICAgIFwiJlBjeTtcIjogXCLQn1wiLFxuICAgICAgXCImUGZyO1wiOiBcIvCdlJNcIixcbiAgICAgIFwiJlBoaTtcIjogXCLOplwiLFxuICAgICAgXCImUGk7XCI6IFwizqBcIixcbiAgICAgIFwiJlBsdXNNaW51cztcIjogXCLCsVwiLFxuICAgICAgXCImUG9pbmNhcmVwbGFuZTtcIjogXCLihIxcIixcbiAgICAgIFwiJlBvcGY7XCI6IFwi4oSZXCIsXG4gICAgICBcIiZQcjtcIjogXCLiqrtcIixcbiAgICAgIFwiJlByZWNlZGVzO1wiOiBcIuKJulwiLFxuICAgICAgXCImUHJlY2VkZXNFcXVhbDtcIjogXCLiqq9cIixcbiAgICAgIFwiJlByZWNlZGVzU2xhbnRFcXVhbDtcIjogXCLiibxcIixcbiAgICAgIFwiJlByZWNlZGVzVGlsZGU7XCI6IFwi4om+XCIsXG4gICAgICBcIiZQcmltZTtcIjogXCLigLNcIixcbiAgICAgIFwiJlByb2R1Y3Q7XCI6IFwi4oiPXCIsXG4gICAgICBcIiZQcm9wb3J0aW9uO1wiOiBcIuKIt1wiLFxuICAgICAgXCImUHJvcG9ydGlvbmFsO1wiOiBcIuKInVwiLFxuICAgICAgXCImUHNjcjtcIjogXCLwnZKrXCIsXG4gICAgICBcIiZQc2k7XCI6IFwizqhcIixcbiAgICAgIFwiJlFVT1RcIjogJ1wiJyxcbiAgICAgIFwiJlFVT1Q7XCI6ICdcIicsXG4gICAgICBcIiZRZnI7XCI6IFwi8J2UlFwiLFxuICAgICAgXCImUW9wZjtcIjogXCLihJpcIixcbiAgICAgIFwiJlFzY3I7XCI6IFwi8J2SrFwiLFxuICAgICAgXCImUkJhcnI7XCI6IFwi4qSQXCIsXG4gICAgICBcIiZSRUdcIjogXCLCrlwiLFxuICAgICAgXCImUkVHO1wiOiBcIsKuXCIsXG4gICAgICBcIiZSYWN1dGU7XCI6IFwixZRcIixcbiAgICAgIFwiJlJhbmc7XCI6IFwi4p+rXCIsXG4gICAgICBcIiZSYXJyO1wiOiBcIuKGoFwiLFxuICAgICAgXCImUmFycnRsO1wiOiBcIuKkllwiLFxuICAgICAgXCImUmNhcm9uO1wiOiBcIsWYXCIsXG4gICAgICBcIiZSY2VkaWw7XCI6IFwixZZcIixcbiAgICAgIFwiJlJjeTtcIjogXCLQoFwiLFxuICAgICAgXCImUmU7XCI6IFwi4oScXCIsXG4gICAgICBcIiZSZXZlcnNlRWxlbWVudDtcIjogXCLiiItcIixcbiAgICAgIFwiJlJldmVyc2VFcXVpbGlicml1bTtcIjogXCLih4tcIixcbiAgICAgIFwiJlJldmVyc2VVcEVxdWlsaWJyaXVtO1wiOiBcIuKlr1wiLFxuICAgICAgXCImUmZyO1wiOiBcIuKEnFwiLFxuICAgICAgXCImUmhvO1wiOiBcIs6hXCIsXG4gICAgICBcIiZSaWdodEFuZ2xlQnJhY2tldDtcIjogXCLin6lcIixcbiAgICAgIFwiJlJpZ2h0QXJyb3c7XCI6IFwi4oaSXCIsXG4gICAgICBcIiZSaWdodEFycm93QmFyO1wiOiBcIuKHpVwiLFxuICAgICAgXCImUmlnaHRBcnJvd0xlZnRBcnJvdztcIjogXCLih4RcIixcbiAgICAgIFwiJlJpZ2h0Q2VpbGluZztcIjogXCLijIlcIixcbiAgICAgIFwiJlJpZ2h0RG91YmxlQnJhY2tldDtcIjogXCLin6dcIixcbiAgICAgIFwiJlJpZ2h0RG93blRlZVZlY3RvcjtcIjogXCLipZ1cIixcbiAgICAgIFwiJlJpZ2h0RG93blZlY3RvcjtcIjogXCLih4JcIixcbiAgICAgIFwiJlJpZ2h0RG93blZlY3RvckJhcjtcIjogXCLipZVcIixcbiAgICAgIFwiJlJpZ2h0Rmxvb3I7XCI6IFwi4oyLXCIsXG4gICAgICBcIiZSaWdodFRlZTtcIjogXCLiiqJcIixcbiAgICAgIFwiJlJpZ2h0VGVlQXJyb3c7XCI6IFwi4oamXCIsXG4gICAgICBcIiZSaWdodFRlZVZlY3RvcjtcIjogXCLipZtcIixcbiAgICAgIFwiJlJpZ2h0VHJpYW5nbGU7XCI6IFwi4oqzXCIsXG4gICAgICBcIiZSaWdodFRyaWFuZ2xlQmFyO1wiOiBcIuKnkFwiLFxuICAgICAgXCImUmlnaHRUcmlhbmdsZUVxdWFsO1wiOiBcIuKKtVwiLFxuICAgICAgXCImUmlnaHRVcERvd25WZWN0b3I7XCI6IFwi4qWPXCIsXG4gICAgICBcIiZSaWdodFVwVGVlVmVjdG9yO1wiOiBcIuKlnFwiLFxuICAgICAgXCImUmlnaHRVcFZlY3RvcjtcIjogXCLihr5cIixcbiAgICAgIFwiJlJpZ2h0VXBWZWN0b3JCYXI7XCI6IFwi4qWUXCIsXG4gICAgICBcIiZSaWdodFZlY3RvcjtcIjogXCLih4BcIixcbiAgICAgIFwiJlJpZ2h0VmVjdG9yQmFyO1wiOiBcIuKlk1wiLFxuICAgICAgXCImUmlnaHRhcnJvdztcIjogXCLih5JcIixcbiAgICAgIFwiJlJvcGY7XCI6IFwi4oSdXCIsXG4gICAgICBcIiZSb3VuZEltcGxpZXM7XCI6IFwi4qWwXCIsXG4gICAgICBcIiZScmlnaHRhcnJvdztcIjogXCLih5tcIixcbiAgICAgIFwiJlJzY3I7XCI6IFwi4oSbXCIsXG4gICAgICBcIiZSc2g7XCI6IFwi4oaxXCIsXG4gICAgICBcIiZSdWxlRGVsYXllZDtcIjogXCLip7RcIixcbiAgICAgIFwiJlNIQ0hjeTtcIjogXCLQqVwiLFxuICAgICAgXCImU0hjeTtcIjogXCLQqFwiLFxuICAgICAgXCImU09GVGN5O1wiOiBcItCsXCIsXG4gICAgICBcIiZTYWN1dGU7XCI6IFwixZpcIixcbiAgICAgIFwiJlNjO1wiOiBcIuKqvFwiLFxuICAgICAgXCImU2Nhcm9uO1wiOiBcIsWgXCIsXG4gICAgICBcIiZTY2VkaWw7XCI6IFwixZ5cIixcbiAgICAgIFwiJlNjaXJjO1wiOiBcIsWcXCIsXG4gICAgICBcIiZTY3k7XCI6IFwi0KFcIixcbiAgICAgIFwiJlNmcjtcIjogXCLwnZSWXCIsXG4gICAgICBcIiZTaG9ydERvd25BcnJvdztcIjogXCLihpNcIixcbiAgICAgIFwiJlNob3J0TGVmdEFycm93O1wiOiBcIuKGkFwiLFxuICAgICAgXCImU2hvcnRSaWdodEFycm93O1wiOiBcIuKGklwiLFxuICAgICAgXCImU2hvcnRVcEFycm93O1wiOiBcIuKGkVwiLFxuICAgICAgXCImU2lnbWE7XCI6IFwizqNcIixcbiAgICAgIFwiJlNtYWxsQ2lyY2xlO1wiOiBcIuKImFwiLFxuICAgICAgXCImU29wZjtcIjogXCLwnZWKXCIsXG4gICAgICBcIiZTcXJ0O1wiOiBcIuKImlwiLFxuICAgICAgXCImU3F1YXJlO1wiOiBcIuKWoVwiLFxuICAgICAgXCImU3F1YXJlSW50ZXJzZWN0aW9uO1wiOiBcIuKKk1wiLFxuICAgICAgXCImU3F1YXJlU3Vic2V0O1wiOiBcIuKKj1wiLFxuICAgICAgXCImU3F1YXJlU3Vic2V0RXF1YWw7XCI6IFwi4oqRXCIsXG4gICAgICBcIiZTcXVhcmVTdXBlcnNldDtcIjogXCLiipBcIixcbiAgICAgIFwiJlNxdWFyZVN1cGVyc2V0RXF1YWw7XCI6IFwi4oqSXCIsXG4gICAgICBcIiZTcXVhcmVVbmlvbjtcIjogXCLiipRcIixcbiAgICAgIFwiJlNzY3I7XCI6IFwi8J2SrlwiLFxuICAgICAgXCImU3RhcjtcIjogXCLii4ZcIixcbiAgICAgIFwiJlN1YjtcIjogXCLii5BcIixcbiAgICAgIFwiJlN1YnNldDtcIjogXCLii5BcIixcbiAgICAgIFwiJlN1YnNldEVxdWFsO1wiOiBcIuKKhlwiLFxuICAgICAgXCImU3VjY2VlZHM7XCI6IFwi4om7XCIsXG4gICAgICBcIiZTdWNjZWVkc0VxdWFsO1wiOiBcIuKqsFwiLFxuICAgICAgXCImU3VjY2VlZHNTbGFudEVxdWFsO1wiOiBcIuKJvVwiLFxuICAgICAgXCImU3VjY2VlZHNUaWxkZTtcIjogXCLiib9cIixcbiAgICAgIFwiJlN1Y2hUaGF0O1wiOiBcIuKIi1wiLFxuICAgICAgXCImU3VtO1wiOiBcIuKIkVwiLFxuICAgICAgXCImU3VwO1wiOiBcIuKLkVwiLFxuICAgICAgXCImU3VwZXJzZXQ7XCI6IFwi4oqDXCIsXG4gICAgICBcIiZTdXBlcnNldEVxdWFsO1wiOiBcIuKKh1wiLFxuICAgICAgXCImU3Vwc2V0O1wiOiBcIuKLkVwiLFxuICAgICAgXCImVEhPUk5cIjogXCLDnlwiLFxuICAgICAgXCImVEhPUk47XCI6IFwiw55cIixcbiAgICAgIFwiJlRSQURFO1wiOiBcIuKEolwiLFxuICAgICAgXCImVFNIY3k7XCI6IFwi0ItcIixcbiAgICAgIFwiJlRTY3k7XCI6IFwi0KZcIixcbiAgICAgIFwiJlRhYjtcIjogXCJcXHRcIixcbiAgICAgIFwiJlRhdTtcIjogXCLOpFwiLFxuICAgICAgXCImVGNhcm9uO1wiOiBcIsWkXCIsXG4gICAgICBcIiZUY2VkaWw7XCI6IFwixaJcIixcbiAgICAgIFwiJlRjeTtcIjogXCLQolwiLFxuICAgICAgXCImVGZyO1wiOiBcIvCdlJdcIixcbiAgICAgIFwiJlRoZXJlZm9yZTtcIjogXCLiiLRcIixcbiAgICAgIFwiJlRoZXRhO1wiOiBcIs6YXCIsXG4gICAgICBcIiZUaGlja1NwYWNlO1wiOiBcIuKBn+KAilwiLFxuICAgICAgXCImVGhpblNwYWNlO1wiOiBcIuKAiVwiLFxuICAgICAgXCImVGlsZGU7XCI6IFwi4oi8XCIsXG4gICAgICBcIiZUaWxkZUVxdWFsO1wiOiBcIuKJg1wiLFxuICAgICAgXCImVGlsZGVGdWxsRXF1YWw7XCI6IFwi4omFXCIsXG4gICAgICBcIiZUaWxkZVRpbGRlO1wiOiBcIuKJiFwiLFxuICAgICAgXCImVG9wZjtcIjogXCLwnZWLXCIsXG4gICAgICBcIiZUcmlwbGVEb3Q7XCI6IFwi4oObXCIsXG4gICAgICBcIiZUc2NyO1wiOiBcIvCdkq9cIixcbiAgICAgIFwiJlRzdHJvaztcIjogXCLFplwiLFxuICAgICAgXCImVWFjdXRlXCI6IFwiw5pcIixcbiAgICAgIFwiJlVhY3V0ZTtcIjogXCLDmlwiLFxuICAgICAgXCImVWFycjtcIjogXCLihp9cIixcbiAgICAgIFwiJlVhcnJvY2lyO1wiOiBcIuKliVwiLFxuICAgICAgXCImVWJyY3k7XCI6IFwi0I5cIixcbiAgICAgIFwiJlVicmV2ZTtcIjogXCLFrFwiLFxuICAgICAgXCImVWNpcmNcIjogXCLDm1wiLFxuICAgICAgXCImVWNpcmM7XCI6IFwiw5tcIixcbiAgICAgIFwiJlVjeTtcIjogXCLQo1wiLFxuICAgICAgXCImVWRibGFjO1wiOiBcIsWwXCIsXG4gICAgICBcIiZVZnI7XCI6IFwi8J2UmFwiLFxuICAgICAgXCImVWdyYXZlXCI6IFwiw5lcIixcbiAgICAgIFwiJlVncmF2ZTtcIjogXCLDmVwiLFxuICAgICAgXCImVW1hY3I7XCI6IFwixapcIixcbiAgICAgIFwiJlVuZGVyQmFyO1wiOiBcIl9cIixcbiAgICAgIFwiJlVuZGVyQnJhY2U7XCI6IFwi4o+fXCIsXG4gICAgICBcIiZVbmRlckJyYWNrZXQ7XCI6IFwi4o61XCIsXG4gICAgICBcIiZVbmRlclBhcmVudGhlc2lzO1wiOiBcIuKPnVwiLFxuICAgICAgXCImVW5pb247XCI6IFwi4ouDXCIsXG4gICAgICBcIiZVbmlvblBsdXM7XCI6IFwi4oqOXCIsXG4gICAgICBcIiZVb2dvbjtcIjogXCLFslwiLFxuICAgICAgXCImVW9wZjtcIjogXCLwnZWMXCIsXG4gICAgICBcIiZVcEFycm93O1wiOiBcIuKGkVwiLFxuICAgICAgXCImVXBBcnJvd0JhcjtcIjogXCLipJJcIixcbiAgICAgIFwiJlVwQXJyb3dEb3duQXJyb3c7XCI6IFwi4oeFXCIsXG4gICAgICBcIiZVcERvd25BcnJvdztcIjogXCLihpVcIixcbiAgICAgIFwiJlVwRXF1aWxpYnJpdW07XCI6IFwi4qWuXCIsXG4gICAgICBcIiZVcFRlZTtcIjogXCLiiqVcIixcbiAgICAgIFwiJlVwVGVlQXJyb3c7XCI6IFwi4oalXCIsXG4gICAgICBcIiZVcGFycm93O1wiOiBcIuKHkVwiLFxuICAgICAgXCImVXBkb3duYXJyb3c7XCI6IFwi4oeVXCIsXG4gICAgICBcIiZVcHBlckxlZnRBcnJvdztcIjogXCLihpZcIixcbiAgICAgIFwiJlVwcGVyUmlnaHRBcnJvdztcIjogXCLihpdcIixcbiAgICAgIFwiJlVwc2k7XCI6IFwiz5JcIixcbiAgICAgIFwiJlVwc2lsb247XCI6IFwizqVcIixcbiAgICAgIFwiJlVyaW5nO1wiOiBcIsWuXCIsXG4gICAgICBcIiZVc2NyO1wiOiBcIvCdkrBcIixcbiAgICAgIFwiJlV0aWxkZTtcIjogXCLFqFwiLFxuICAgICAgXCImVXVtbFwiOiBcIsOcXCIsXG4gICAgICBcIiZVdW1sO1wiOiBcIsOcXCIsXG4gICAgICBcIiZWRGFzaDtcIjogXCLiiqtcIixcbiAgICAgIFwiJlZiYXI7XCI6IFwi4qurXCIsXG4gICAgICBcIiZWY3k7XCI6IFwi0JJcIixcbiAgICAgIFwiJlZkYXNoO1wiOiBcIuKKqVwiLFxuICAgICAgXCImVmRhc2hsO1wiOiBcIuKrplwiLFxuICAgICAgXCImVmVlO1wiOiBcIuKLgVwiLFxuICAgICAgXCImVmVyYmFyO1wiOiBcIuKAllwiLFxuICAgICAgXCImVmVydDtcIjogXCLigJZcIixcbiAgICAgIFwiJlZlcnRpY2FsQmFyO1wiOiBcIuKIo1wiLFxuICAgICAgXCImVmVydGljYWxMaW5lO1wiOiBcInxcIixcbiAgICAgIFwiJlZlcnRpY2FsU2VwYXJhdG9yO1wiOiBcIuKdmFwiLFxuICAgICAgXCImVmVydGljYWxUaWxkZTtcIjogXCLiiYBcIixcbiAgICAgIFwiJlZlcnlUaGluU3BhY2U7XCI6IFwi4oCKXCIsXG4gICAgICBcIiZWZnI7XCI6IFwi8J2UmVwiLFxuICAgICAgXCImVm9wZjtcIjogXCLwnZWNXCIsXG4gICAgICBcIiZWc2NyO1wiOiBcIvCdkrFcIixcbiAgICAgIFwiJlZ2ZGFzaDtcIjogXCLiiqpcIixcbiAgICAgIFwiJldjaXJjO1wiOiBcIsW0XCIsXG4gICAgICBcIiZXZWRnZTtcIjogXCLii4BcIixcbiAgICAgIFwiJldmcjtcIjogXCLwnZSaXCIsXG4gICAgICBcIiZXb3BmO1wiOiBcIvCdlY5cIixcbiAgICAgIFwiJldzY3I7XCI6IFwi8J2SslwiLFxuICAgICAgXCImWGZyO1wiOiBcIvCdlJtcIixcbiAgICAgIFwiJlhpO1wiOiBcIs6eXCIsXG4gICAgICBcIiZYb3BmO1wiOiBcIvCdlY9cIixcbiAgICAgIFwiJlhzY3I7XCI6IFwi8J2Ss1wiLFxuICAgICAgXCImWUFjeTtcIjogXCLQr1wiLFxuICAgICAgXCImWUljeTtcIjogXCLQh1wiLFxuICAgICAgXCImWVVjeTtcIjogXCLQrlwiLFxuICAgICAgXCImWWFjdXRlXCI6IFwiw51cIixcbiAgICAgIFwiJllhY3V0ZTtcIjogXCLDnVwiLFxuICAgICAgXCImWWNpcmM7XCI6IFwixbZcIixcbiAgICAgIFwiJlljeTtcIjogXCLQq1wiLFxuICAgICAgXCImWWZyO1wiOiBcIvCdlJxcIixcbiAgICAgIFwiJllvcGY7XCI6IFwi8J2VkFwiLFxuICAgICAgXCImWXNjcjtcIjogXCLwnZK0XCIsXG4gICAgICBcIiZZdW1sO1wiOiBcIsW4XCIsXG4gICAgICBcIiZaSGN5O1wiOiBcItCWXCIsXG4gICAgICBcIiZaYWN1dGU7XCI6IFwixblcIixcbiAgICAgIFwiJlpjYXJvbjtcIjogXCLFvVwiLFxuICAgICAgXCImWmN5O1wiOiBcItCXXCIsXG4gICAgICBcIiZaZG90O1wiOiBcIsW7XCIsXG4gICAgICBcIiZaZXJvV2lkdGhTcGFjZTtcIjogXCLigItcIixcbiAgICAgIFwiJlpldGE7XCI6IFwizpZcIixcbiAgICAgIFwiJlpmcjtcIjogXCLihKhcIixcbiAgICAgIFwiJlpvcGY7XCI6IFwi4oSkXCIsXG4gICAgICBcIiZac2NyO1wiOiBcIvCdkrVcIixcbiAgICAgIFwiJmFhY3V0ZVwiOiBcIsOhXCIsXG4gICAgICBcIiZhYWN1dGU7XCI6IFwiw6FcIixcbiAgICAgIFwiJmFicmV2ZTtcIjogXCLEg1wiLFxuICAgICAgXCImYWM7XCI6IFwi4oi+XCIsXG4gICAgICBcIiZhY0U7XCI6IFwi4oi+zLNcIixcbiAgICAgIFwiJmFjZDtcIjogXCLiiL9cIixcbiAgICAgIFwiJmFjaXJjXCI6IFwiw6JcIixcbiAgICAgIFwiJmFjaXJjO1wiOiBcIsOiXCIsXG4gICAgICBcIiZhY3V0ZVwiOiBcIsK0XCIsXG4gICAgICBcIiZhY3V0ZTtcIjogXCLCtFwiLFxuICAgICAgXCImYWN5O1wiOiBcItCwXCIsXG4gICAgICBcIiZhZWxpZ1wiOiBcIsOmXCIsXG4gICAgICBcIiZhZWxpZztcIjogXCLDplwiLFxuICAgICAgXCImYWY7XCI6IFwi4oGhXCIsXG4gICAgICBcIiZhZnI7XCI6IFwi8J2UnlwiLFxuICAgICAgXCImYWdyYXZlXCI6IFwiw6BcIixcbiAgICAgIFwiJmFncmF2ZTtcIjogXCLDoFwiLFxuICAgICAgXCImYWxlZnN5bTtcIjogXCLihLVcIixcbiAgICAgIFwiJmFsZXBoO1wiOiBcIuKEtVwiLFxuICAgICAgXCImYWxwaGE7XCI6IFwizrFcIixcbiAgICAgIFwiJmFtYWNyO1wiOiBcIsSBXCIsXG4gICAgICBcIiZhbWFsZztcIjogXCLiqL9cIixcbiAgICAgIFwiJmFtcFwiOiBcIiZcIixcbiAgICAgIFwiJmFtcDtcIjogXCImXCIsXG4gICAgICBcIiZhbmQ7XCI6IFwi4oinXCIsXG4gICAgICBcIiZhbmRhbmQ7XCI6IFwi4qmVXCIsXG4gICAgICBcIiZhbmRkO1wiOiBcIuKpnFwiLFxuICAgICAgXCImYW5kc2xvcGU7XCI6IFwi4qmYXCIsXG4gICAgICBcIiZhbmR2O1wiOiBcIuKpmlwiLFxuICAgICAgXCImYW5nO1wiOiBcIuKIoFwiLFxuICAgICAgXCImYW5nZTtcIjogXCLipqRcIixcbiAgICAgIFwiJmFuZ2xlO1wiOiBcIuKIoFwiLFxuICAgICAgXCImYW5nbXNkO1wiOiBcIuKIoVwiLFxuICAgICAgXCImYW5nbXNkYWE7XCI6IFwi4qaoXCIsXG4gICAgICBcIiZhbmdtc2RhYjtcIjogXCLipqlcIixcbiAgICAgIFwiJmFuZ21zZGFjO1wiOiBcIuKmqlwiLFxuICAgICAgXCImYW5nbXNkYWQ7XCI6IFwi4qarXCIsXG4gICAgICBcIiZhbmdtc2RhZTtcIjogXCLipqxcIixcbiAgICAgIFwiJmFuZ21zZGFmO1wiOiBcIuKmrVwiLFxuICAgICAgXCImYW5nbXNkYWc7XCI6IFwi4qauXCIsXG4gICAgICBcIiZhbmdtc2RhaDtcIjogXCLipq9cIixcbiAgICAgIFwiJmFuZ3J0O1wiOiBcIuKIn1wiLFxuICAgICAgXCImYW5ncnR2YjtcIjogXCLiir5cIixcbiAgICAgIFwiJmFuZ3J0dmJkO1wiOiBcIuKmnVwiLFxuICAgICAgXCImYW5nc3BoO1wiOiBcIuKIolwiLFxuICAgICAgXCImYW5nc3Q7XCI6IFwiw4VcIixcbiAgICAgIFwiJmFuZ3phcnI7XCI6IFwi4o28XCIsXG4gICAgICBcIiZhb2dvbjtcIjogXCLEhVwiLFxuICAgICAgXCImYW9wZjtcIjogXCLwnZWSXCIsXG4gICAgICBcIiZhcDtcIjogXCLiiYhcIixcbiAgICAgIFwiJmFwRTtcIjogXCLiqbBcIixcbiAgICAgIFwiJmFwYWNpcjtcIjogXCLiqa9cIixcbiAgICAgIFwiJmFwZTtcIjogXCLiiYpcIixcbiAgICAgIFwiJmFwaWQ7XCI6IFwi4omLXCIsXG4gICAgICBcIiZhcG9zO1wiOiBcIidcIixcbiAgICAgIFwiJmFwcHJveDtcIjogXCLiiYhcIixcbiAgICAgIFwiJmFwcHJveGVxO1wiOiBcIuKJilwiLFxuICAgICAgXCImYXJpbmdcIjogXCLDpVwiLFxuICAgICAgXCImYXJpbmc7XCI6IFwiw6VcIixcbiAgICAgIFwiJmFzY3I7XCI6IFwi8J2StlwiLFxuICAgICAgXCImYXN0O1wiOiBcIipcIixcbiAgICAgIFwiJmFzeW1wO1wiOiBcIuKJiFwiLFxuICAgICAgXCImYXN5bXBlcTtcIjogXCLiiY1cIixcbiAgICAgIFwiJmF0aWxkZVwiOiBcIsOjXCIsXG4gICAgICBcIiZhdGlsZGU7XCI6IFwiw6NcIixcbiAgICAgIFwiJmF1bWxcIjogXCLDpFwiLFxuICAgICAgXCImYXVtbDtcIjogXCLDpFwiLFxuICAgICAgXCImYXdjb25pbnQ7XCI6IFwi4oizXCIsXG4gICAgICBcIiZhd2ludDtcIjogXCLiqJFcIixcbiAgICAgIFwiJmJOb3Q7XCI6IFwi4qutXCIsXG4gICAgICBcIiZiYWNrY29uZztcIjogXCLiiYxcIixcbiAgICAgIFwiJmJhY2tlcHNpbG9uO1wiOiBcIs+2XCIsXG4gICAgICBcIiZiYWNrcHJpbWU7XCI6IFwi4oC1XCIsXG4gICAgICBcIiZiYWNrc2ltO1wiOiBcIuKIvVwiLFxuICAgICAgXCImYmFja3NpbWVxO1wiOiBcIuKLjVwiLFxuICAgICAgXCImYmFydmVlO1wiOiBcIuKKvVwiLFxuICAgICAgXCImYmFyd2VkO1wiOiBcIuKMhVwiLFxuICAgICAgXCImYmFyd2VkZ2U7XCI6IFwi4oyFXCIsXG4gICAgICBcIiZiYnJrO1wiOiBcIuKOtVwiLFxuICAgICAgXCImYmJya3Ricms7XCI6IFwi4o62XCIsXG4gICAgICBcIiZiY29uZztcIjogXCLiiYxcIixcbiAgICAgIFwiJmJjeTtcIjogXCLQsVwiLFxuICAgICAgXCImYmRxdW87XCI6IFwi4oCeXCIsXG4gICAgICBcIiZiZWNhdXM7XCI6IFwi4oi1XCIsXG4gICAgICBcIiZiZWNhdXNlO1wiOiBcIuKItVwiLFxuICAgICAgXCImYmVtcHR5djtcIjogXCLiprBcIixcbiAgICAgIFwiJmJlcHNpO1wiOiBcIs+2XCIsXG4gICAgICBcIiZiZXJub3U7XCI6IFwi4oSsXCIsXG4gICAgICBcIiZiZXRhO1wiOiBcIs6yXCIsXG4gICAgICBcIiZiZXRoO1wiOiBcIuKEtlwiLFxuICAgICAgXCImYmV0d2VlbjtcIjogXCLiiaxcIixcbiAgICAgIFwiJmJmcjtcIjogXCLwnZSfXCIsXG4gICAgICBcIiZiaWdjYXA7XCI6IFwi4ouCXCIsXG4gICAgICBcIiZiaWdjaXJjO1wiOiBcIuKXr1wiLFxuICAgICAgXCImYmlnY3VwO1wiOiBcIuKLg1wiLFxuICAgICAgXCImYmlnb2RvdDtcIjogXCLiqIBcIixcbiAgICAgIFwiJmJpZ29wbHVzO1wiOiBcIuKogVwiLFxuICAgICAgXCImYmlnb3RpbWVzO1wiOiBcIuKoglwiLFxuICAgICAgXCImYmlnc3FjdXA7XCI6IFwi4qiGXCIsXG4gICAgICBcIiZiaWdzdGFyO1wiOiBcIuKYhVwiLFxuICAgICAgXCImYmlndHJpYW5nbGVkb3duO1wiOiBcIuKWvVwiLFxuICAgICAgXCImYmlndHJpYW5nbGV1cDtcIjogXCLilrNcIixcbiAgICAgIFwiJmJpZ3VwbHVzO1wiOiBcIuKohFwiLFxuICAgICAgXCImYmlndmVlO1wiOiBcIuKLgVwiLFxuICAgICAgXCImYmlnd2VkZ2U7XCI6IFwi4ouAXCIsXG4gICAgICBcIiZia2Fyb3c7XCI6IFwi4qSNXCIsXG4gICAgICBcIiZibGFja2xvemVuZ2U7XCI6IFwi4qerXCIsXG4gICAgICBcIiZibGFja3NxdWFyZTtcIjogXCLilqpcIixcbiAgICAgIFwiJmJsYWNrdHJpYW5nbGU7XCI6IFwi4pa0XCIsXG4gICAgICBcIiZibGFja3RyaWFuZ2xlZG93bjtcIjogXCLilr5cIixcbiAgICAgIFwiJmJsYWNrdHJpYW5nbGVsZWZ0O1wiOiBcIuKXglwiLFxuICAgICAgXCImYmxhY2t0cmlhbmdsZXJpZ2h0O1wiOiBcIuKWuFwiLFxuICAgICAgXCImYmxhbms7XCI6IFwi4pCjXCIsXG4gICAgICBcIiZibGsxMjtcIjogXCLilpJcIixcbiAgICAgIFwiJmJsazE0O1wiOiBcIuKWkVwiLFxuICAgICAgXCImYmxrMzQ7XCI6IFwi4paTXCIsXG4gICAgICBcIiZibG9jaztcIjogXCLilohcIixcbiAgICAgIFwiJmJuZTtcIjogXCI94oOlXCIsXG4gICAgICBcIiZibmVxdWl2O1wiOiBcIuKJoeKDpVwiLFxuICAgICAgXCImYm5vdDtcIjogXCLijJBcIixcbiAgICAgIFwiJmJvcGY7XCI6IFwi8J2Vk1wiLFxuICAgICAgXCImYm90O1wiOiBcIuKKpVwiLFxuICAgICAgXCImYm90dG9tO1wiOiBcIuKKpVwiLFxuICAgICAgXCImYm93dGllO1wiOiBcIuKLiFwiLFxuICAgICAgXCImYm94REw7XCI6IFwi4pWXXCIsXG4gICAgICBcIiZib3hEUjtcIjogXCLilZRcIixcbiAgICAgIFwiJmJveERsO1wiOiBcIuKVllwiLFxuICAgICAgXCImYm94RHI7XCI6IFwi4pWTXCIsXG4gICAgICBcIiZib3hIO1wiOiBcIuKVkFwiLFxuICAgICAgXCImYm94SEQ7XCI6IFwi4pWmXCIsXG4gICAgICBcIiZib3hIVTtcIjogXCLilalcIixcbiAgICAgIFwiJmJveEhkO1wiOiBcIuKVpFwiLFxuICAgICAgXCImYm94SHU7XCI6IFwi4pWnXCIsXG4gICAgICBcIiZib3hVTDtcIjogXCLilZ1cIixcbiAgICAgIFwiJmJveFVSO1wiOiBcIuKVmlwiLFxuICAgICAgXCImYm94VWw7XCI6IFwi4pWcXCIsXG4gICAgICBcIiZib3hVcjtcIjogXCLilZlcIixcbiAgICAgIFwiJmJveFY7XCI6IFwi4pWRXCIsXG4gICAgICBcIiZib3hWSDtcIjogXCLilaxcIixcbiAgICAgIFwiJmJveFZMO1wiOiBcIuKVo1wiLFxuICAgICAgXCImYm94VlI7XCI6IFwi4pWgXCIsXG4gICAgICBcIiZib3hWaDtcIjogXCLilatcIixcbiAgICAgIFwiJmJveFZsO1wiOiBcIuKVolwiLFxuICAgICAgXCImYm94VnI7XCI6IFwi4pWfXCIsXG4gICAgICBcIiZib3hib3g7XCI6IFwi4qeJXCIsXG4gICAgICBcIiZib3hkTDtcIjogXCLilZVcIixcbiAgICAgIFwiJmJveGRSO1wiOiBcIuKVklwiLFxuICAgICAgXCImYm94ZGw7XCI6IFwi4pSQXCIsXG4gICAgICBcIiZib3hkcjtcIjogXCLilIxcIixcbiAgICAgIFwiJmJveGg7XCI6IFwi4pSAXCIsXG4gICAgICBcIiZib3hoRDtcIjogXCLilaVcIixcbiAgICAgIFwiJmJveGhVO1wiOiBcIuKVqFwiLFxuICAgICAgXCImYm94aGQ7XCI6IFwi4pSsXCIsXG4gICAgICBcIiZib3hodTtcIjogXCLilLRcIixcbiAgICAgIFwiJmJveG1pbnVzO1wiOiBcIuKKn1wiLFxuICAgICAgXCImYm94cGx1cztcIjogXCLiip5cIixcbiAgICAgIFwiJmJveHRpbWVzO1wiOiBcIuKKoFwiLFxuICAgICAgXCImYm94dUw7XCI6IFwi4pWbXCIsXG4gICAgICBcIiZib3h1UjtcIjogXCLilZhcIixcbiAgICAgIFwiJmJveHVsO1wiOiBcIuKUmFwiLFxuICAgICAgXCImYm94dXI7XCI6IFwi4pSUXCIsXG4gICAgICBcIiZib3h2O1wiOiBcIuKUglwiLFxuICAgICAgXCImYm94dkg7XCI6IFwi4pWqXCIsXG4gICAgICBcIiZib3h2TDtcIjogXCLilaFcIixcbiAgICAgIFwiJmJveHZSO1wiOiBcIuKVnlwiLFxuICAgICAgXCImYm94dmg7XCI6IFwi4pS8XCIsXG4gICAgICBcIiZib3h2bDtcIjogXCLilKRcIixcbiAgICAgIFwiJmJveHZyO1wiOiBcIuKUnFwiLFxuICAgICAgXCImYnByaW1lO1wiOiBcIuKAtVwiLFxuICAgICAgXCImYnJldmU7XCI6IFwiy5hcIixcbiAgICAgIFwiJmJydmJhclwiOiBcIsKmXCIsXG4gICAgICBcIiZicnZiYXI7XCI6IFwiwqZcIixcbiAgICAgIFwiJmJzY3I7XCI6IFwi8J2St1wiLFxuICAgICAgXCImYnNlbWk7XCI6IFwi4oGPXCIsXG4gICAgICBcIiZic2ltO1wiOiBcIuKIvVwiLFxuICAgICAgXCImYnNpbWU7XCI6IFwi4ouNXCIsXG4gICAgICBcIiZic29sO1wiOiBcIlxcXFxcIixcbiAgICAgIFwiJmJzb2xiO1wiOiBcIuKnhVwiLFxuICAgICAgXCImYnNvbGhzdWI7XCI6IFwi4p+IXCIsXG4gICAgICBcIiZidWxsO1wiOiBcIuKAolwiLFxuICAgICAgXCImYnVsbGV0O1wiOiBcIuKAolwiLFxuICAgICAgXCImYnVtcDtcIjogXCLiiY5cIixcbiAgICAgIFwiJmJ1bXBFO1wiOiBcIuKqrlwiLFxuICAgICAgXCImYnVtcGU7XCI6IFwi4omPXCIsXG4gICAgICBcIiZidW1wZXE7XCI6IFwi4omPXCIsXG4gICAgICBcIiZjYWN1dGU7XCI6IFwixIdcIixcbiAgICAgIFwiJmNhcDtcIjogXCLiiKlcIixcbiAgICAgIFwiJmNhcGFuZDtcIjogXCLiqYRcIixcbiAgICAgIFwiJmNhcGJyY3VwO1wiOiBcIuKpiVwiLFxuICAgICAgXCImY2FwY2FwO1wiOiBcIuKpi1wiLFxuICAgICAgXCImY2FwY3VwO1wiOiBcIuKph1wiLFxuICAgICAgXCImY2FwZG90O1wiOiBcIuKpgFwiLFxuICAgICAgXCImY2FwcztcIjogXCLiiKnvuIBcIixcbiAgICAgIFwiJmNhcmV0O1wiOiBcIuKBgVwiLFxuICAgICAgXCImY2Fyb247XCI6IFwiy4dcIixcbiAgICAgIFwiJmNjYXBzO1wiOiBcIuKpjVwiLFxuICAgICAgXCImY2Nhcm9uO1wiOiBcIsSNXCIsXG4gICAgICBcIiZjY2VkaWxcIjogXCLDp1wiLFxuICAgICAgXCImY2NlZGlsO1wiOiBcIsOnXCIsXG4gICAgICBcIiZjY2lyYztcIjogXCLEiVwiLFxuICAgICAgXCImY2N1cHM7XCI6IFwi4qmMXCIsXG4gICAgICBcIiZjY3Vwc3NtO1wiOiBcIuKpkFwiLFxuICAgICAgXCImY2RvdDtcIjogXCLEi1wiLFxuICAgICAgXCImY2VkaWxcIjogXCLCuFwiLFxuICAgICAgXCImY2VkaWw7XCI6IFwiwrhcIixcbiAgICAgIFwiJmNlbXB0eXY7XCI6IFwi4qayXCIsXG4gICAgICBcIiZjZW50XCI6IFwiwqJcIixcbiAgICAgIFwiJmNlbnQ7XCI6IFwiwqJcIixcbiAgICAgIFwiJmNlbnRlcmRvdDtcIjogXCLCt1wiLFxuICAgICAgXCImY2ZyO1wiOiBcIvCdlKBcIixcbiAgICAgIFwiJmNoY3k7XCI6IFwi0YdcIixcbiAgICAgIFwiJmNoZWNrO1wiOiBcIuKck1wiLFxuICAgICAgXCImY2hlY2ttYXJrO1wiOiBcIuKck1wiLFxuICAgICAgXCImY2hpO1wiOiBcIs+HXCIsXG4gICAgICBcIiZjaXI7XCI6IFwi4peLXCIsXG4gICAgICBcIiZjaXJFO1wiOiBcIuKng1wiLFxuICAgICAgXCImY2lyYztcIjogXCLLhlwiLFxuICAgICAgXCImY2lyY2VxO1wiOiBcIuKJl1wiLFxuICAgICAgXCImY2lyY2xlYXJyb3dsZWZ0O1wiOiBcIuKGulwiLFxuICAgICAgXCImY2lyY2xlYXJyb3dyaWdodDtcIjogXCLihrtcIixcbiAgICAgIFwiJmNpcmNsZWRSO1wiOiBcIsKuXCIsXG4gICAgICBcIiZjaXJjbGVkUztcIjogXCLik4hcIixcbiAgICAgIFwiJmNpcmNsZWRhc3Q7XCI6IFwi4oqbXCIsXG4gICAgICBcIiZjaXJjbGVkY2lyYztcIjogXCLiippcIixcbiAgICAgIFwiJmNpcmNsZWRkYXNoO1wiOiBcIuKKnVwiLFxuICAgICAgXCImY2lyZTtcIjogXCLiiZdcIixcbiAgICAgIFwiJmNpcmZuaW50O1wiOiBcIuKokFwiLFxuICAgICAgXCImY2lybWlkO1wiOiBcIuKrr1wiLFxuICAgICAgXCImY2lyc2NpcjtcIjogXCLip4JcIixcbiAgICAgIFwiJmNsdWJzO1wiOiBcIuKZo1wiLFxuICAgICAgXCImY2x1YnN1aXQ7XCI6IFwi4pmjXCIsXG4gICAgICBcIiZjb2xvbjtcIjogXCI6XCIsXG4gICAgICBcIiZjb2xvbmU7XCI6IFwi4omUXCIsXG4gICAgICBcIiZjb2xvbmVxO1wiOiBcIuKJlFwiLFxuICAgICAgXCImY29tbWE7XCI6IFwiLFwiLFxuICAgICAgXCImY29tbWF0O1wiOiBcIkBcIixcbiAgICAgIFwiJmNvbXA7XCI6IFwi4oiBXCIsXG4gICAgICBcIiZjb21wZm47XCI6IFwi4oiYXCIsXG4gICAgICBcIiZjb21wbGVtZW50O1wiOiBcIuKIgVwiLFxuICAgICAgXCImY29tcGxleGVzO1wiOiBcIuKEglwiLFxuICAgICAgXCImY29uZztcIjogXCLiiYVcIixcbiAgICAgIFwiJmNvbmdkb3Q7XCI6IFwi4qmtXCIsXG4gICAgICBcIiZjb25pbnQ7XCI6IFwi4oiuXCIsXG4gICAgICBcIiZjb3BmO1wiOiBcIvCdlZRcIixcbiAgICAgIFwiJmNvcHJvZDtcIjogXCLiiJBcIixcbiAgICAgIFwiJmNvcHlcIjogXCLCqVwiLFxuICAgICAgXCImY29weTtcIjogXCLCqVwiLFxuICAgICAgXCImY29weXNyO1wiOiBcIuKEl1wiLFxuICAgICAgXCImY3JhcnI7XCI6IFwi4oa1XCIsXG4gICAgICBcIiZjcm9zcztcIjogXCLinJdcIixcbiAgICAgIFwiJmNzY3I7XCI6IFwi8J2SuFwiLFxuICAgICAgXCImY3N1YjtcIjogXCLiq49cIixcbiAgICAgIFwiJmNzdWJlO1wiOiBcIuKrkVwiLFxuICAgICAgXCImY3N1cDtcIjogXCLiq5BcIixcbiAgICAgIFwiJmNzdXBlO1wiOiBcIuKrklwiLFxuICAgICAgXCImY3Rkb3Q7XCI6IFwi4ouvXCIsXG4gICAgICBcIiZjdWRhcnJsO1wiOiBcIuKkuFwiLFxuICAgICAgXCImY3VkYXJycjtcIjogXCLipLVcIixcbiAgICAgIFwiJmN1ZXByO1wiOiBcIuKLnlwiLFxuICAgICAgXCImY3Vlc2M7XCI6IFwi4oufXCIsXG4gICAgICBcIiZjdWxhcnI7XCI6IFwi4oa2XCIsXG4gICAgICBcIiZjdWxhcnJwO1wiOiBcIuKkvVwiLFxuICAgICAgXCImY3VwO1wiOiBcIuKIqlwiLFxuICAgICAgXCImY3VwYnJjYXA7XCI6IFwi4qmIXCIsXG4gICAgICBcIiZjdXBjYXA7XCI6IFwi4qmGXCIsXG4gICAgICBcIiZjdXBjdXA7XCI6IFwi4qmKXCIsXG4gICAgICBcIiZjdXBkb3Q7XCI6IFwi4oqNXCIsXG4gICAgICBcIiZjdXBvcjtcIjogXCLiqYVcIixcbiAgICAgIFwiJmN1cHM7XCI6IFwi4oiq77iAXCIsXG4gICAgICBcIiZjdXJhcnI7XCI6IFwi4oa3XCIsXG4gICAgICBcIiZjdXJhcnJtO1wiOiBcIuKkvFwiLFxuICAgICAgXCImY3VybHllcXByZWM7XCI6IFwi4oueXCIsXG4gICAgICBcIiZjdXJseWVxc3VjYztcIjogXCLii59cIixcbiAgICAgIFwiJmN1cmx5dmVlO1wiOiBcIuKLjlwiLFxuICAgICAgXCImY3VybHl3ZWRnZTtcIjogXCLii49cIixcbiAgICAgIFwiJmN1cnJlblwiOiBcIsKkXCIsXG4gICAgICBcIiZjdXJyZW47XCI6IFwiwqRcIixcbiAgICAgIFwiJmN1cnZlYXJyb3dsZWZ0O1wiOiBcIuKGtlwiLFxuICAgICAgXCImY3VydmVhcnJvd3JpZ2h0O1wiOiBcIuKGt1wiLFxuICAgICAgXCImY3V2ZWU7XCI6IFwi4ouOXCIsXG4gICAgICBcIiZjdXdlZDtcIjogXCLii49cIixcbiAgICAgIFwiJmN3Y29uaW50O1wiOiBcIuKIslwiLFxuICAgICAgXCImY3dpbnQ7XCI6IFwi4oixXCIsXG4gICAgICBcIiZjeWxjdHk7XCI6IFwi4oytXCIsXG4gICAgICBcIiZkQXJyO1wiOiBcIuKHk1wiLFxuICAgICAgXCImZEhhcjtcIjogXCLipaVcIixcbiAgICAgIFwiJmRhZ2dlcjtcIjogXCLigKBcIixcbiAgICAgIFwiJmRhbGV0aDtcIjogXCLihLhcIixcbiAgICAgIFwiJmRhcnI7XCI6IFwi4oaTXCIsXG4gICAgICBcIiZkYXNoO1wiOiBcIuKAkFwiLFxuICAgICAgXCImZGFzaHY7XCI6IFwi4oqjXCIsXG4gICAgICBcIiZkYmthcm93O1wiOiBcIuKkj1wiLFxuICAgICAgXCImZGJsYWM7XCI6IFwiy51cIixcbiAgICAgIFwiJmRjYXJvbjtcIjogXCLEj1wiLFxuICAgICAgXCImZGN5O1wiOiBcItC0XCIsXG4gICAgICBcIiZkZDtcIjogXCLihYZcIixcbiAgICAgIFwiJmRkYWdnZXI7XCI6IFwi4oChXCIsXG4gICAgICBcIiZkZGFycjtcIjogXCLih4pcIixcbiAgICAgIFwiJmRkb3RzZXE7XCI6IFwi4qm3XCIsXG4gICAgICBcIiZkZWdcIjogXCLCsFwiLFxuICAgICAgXCImZGVnO1wiOiBcIsKwXCIsXG4gICAgICBcIiZkZWx0YTtcIjogXCLOtFwiLFxuICAgICAgXCImZGVtcHR5djtcIjogXCLiprFcIixcbiAgICAgIFwiJmRmaXNodDtcIjogXCLipb9cIixcbiAgICAgIFwiJmRmcjtcIjogXCLwnZShXCIsXG4gICAgICBcIiZkaGFybDtcIjogXCLih4NcIixcbiAgICAgIFwiJmRoYXJyO1wiOiBcIuKHglwiLFxuICAgICAgXCImZGlhbTtcIjogXCLii4RcIixcbiAgICAgIFwiJmRpYW1vbmQ7XCI6IFwi4ouEXCIsXG4gICAgICBcIiZkaWFtb25kc3VpdDtcIjogXCLimaZcIixcbiAgICAgIFwiJmRpYW1zO1wiOiBcIuKZplwiLFxuICAgICAgXCImZGllO1wiOiBcIsKoXCIsXG4gICAgICBcIiZkaWdhbW1hO1wiOiBcIs+dXCIsXG4gICAgICBcIiZkaXNpbjtcIjogXCLii7JcIixcbiAgICAgIFwiJmRpdjtcIjogXCLDt1wiLFxuICAgICAgXCImZGl2aWRlXCI6IFwiw7dcIixcbiAgICAgIFwiJmRpdmlkZTtcIjogXCLDt1wiLFxuICAgICAgXCImZGl2aWRlb250aW1lcztcIjogXCLii4dcIixcbiAgICAgIFwiJmRpdm9ueDtcIjogXCLii4dcIixcbiAgICAgIFwiJmRqY3k7XCI6IFwi0ZJcIixcbiAgICAgIFwiJmRsY29ybjtcIjogXCLijJ5cIixcbiAgICAgIFwiJmRsY3JvcDtcIjogXCLijI1cIixcbiAgICAgIFwiJmRvbGxhcjtcIjogXCIkXCIsXG4gICAgICBcIiZkb3BmO1wiOiBcIvCdlZVcIixcbiAgICAgIFwiJmRvdDtcIjogXCLLmVwiLFxuICAgICAgXCImZG90ZXE7XCI6IFwi4omQXCIsXG4gICAgICBcIiZkb3RlcWRvdDtcIjogXCLiiZFcIixcbiAgICAgIFwiJmRvdG1pbnVzO1wiOiBcIuKIuFwiLFxuICAgICAgXCImZG90cGx1cztcIjogXCLiiJRcIixcbiAgICAgIFwiJmRvdHNxdWFyZTtcIjogXCLiiqFcIixcbiAgICAgIFwiJmRvdWJsZWJhcndlZGdlO1wiOiBcIuKMhlwiLFxuICAgICAgXCImZG93bmFycm93O1wiOiBcIuKGk1wiLFxuICAgICAgXCImZG93bmRvd25hcnJvd3M7XCI6IFwi4oeKXCIsXG4gICAgICBcIiZkb3duaGFycG9vbmxlZnQ7XCI6IFwi4oeDXCIsXG4gICAgICBcIiZkb3duaGFycG9vbnJpZ2h0O1wiOiBcIuKHglwiLFxuICAgICAgXCImZHJia2Fyb3c7XCI6IFwi4qSQXCIsXG4gICAgICBcIiZkcmNvcm47XCI6IFwi4oyfXCIsXG4gICAgICBcIiZkcmNyb3A7XCI6IFwi4oyMXCIsXG4gICAgICBcIiZkc2NyO1wiOiBcIvCdkrlcIixcbiAgICAgIFwiJmRzY3k7XCI6IFwi0ZVcIixcbiAgICAgIFwiJmRzb2w7XCI6IFwi4qe2XCIsXG4gICAgICBcIiZkc3Ryb2s7XCI6IFwixJFcIixcbiAgICAgIFwiJmR0ZG90O1wiOiBcIuKLsVwiLFxuICAgICAgXCImZHRyaTtcIjogXCLilr9cIixcbiAgICAgIFwiJmR0cmlmO1wiOiBcIuKWvlwiLFxuICAgICAgXCImZHVhcnI7XCI6IFwi4oe1XCIsXG4gICAgICBcIiZkdWhhcjtcIjogXCLipa9cIixcbiAgICAgIFwiJmR3YW5nbGU7XCI6IFwi4qamXCIsXG4gICAgICBcIiZkemN5O1wiOiBcItGfXCIsXG4gICAgICBcIiZkemlncmFycjtcIjogXCLin79cIixcbiAgICAgIFwiJmVERG90O1wiOiBcIuKpt1wiLFxuICAgICAgXCImZURvdDtcIjogXCLiiZFcIixcbiAgICAgIFwiJmVhY3V0ZVwiOiBcIsOpXCIsXG4gICAgICBcIiZlYWN1dGU7XCI6IFwiw6lcIixcbiAgICAgIFwiJmVhc3RlcjtcIjogXCLiqa5cIixcbiAgICAgIFwiJmVjYXJvbjtcIjogXCLEm1wiLFxuICAgICAgXCImZWNpcjtcIjogXCLiiZZcIixcbiAgICAgIFwiJmVjaXJjXCI6IFwiw6pcIixcbiAgICAgIFwiJmVjaXJjO1wiOiBcIsOqXCIsXG4gICAgICBcIiZlY29sb247XCI6IFwi4omVXCIsXG4gICAgICBcIiZlY3k7XCI6IFwi0Y1cIixcbiAgICAgIFwiJmVkb3Q7XCI6IFwixJdcIixcbiAgICAgIFwiJmVlO1wiOiBcIuKFh1wiLFxuICAgICAgXCImZWZEb3Q7XCI6IFwi4omSXCIsXG4gICAgICBcIiZlZnI7XCI6IFwi8J2UolwiLFxuICAgICAgXCImZWc7XCI6IFwi4qqaXCIsXG4gICAgICBcIiZlZ3JhdmVcIjogXCLDqFwiLFxuICAgICAgXCImZWdyYXZlO1wiOiBcIsOoXCIsXG4gICAgICBcIiZlZ3M7XCI6IFwi4qqWXCIsXG4gICAgICBcIiZlZ3Nkb3Q7XCI6IFwi4qqYXCIsXG4gICAgICBcIiZlbDtcIjogXCLiqplcIixcbiAgICAgIFwiJmVsaW50ZXJzO1wiOiBcIuKPp1wiLFxuICAgICAgXCImZWxsO1wiOiBcIuKEk1wiLFxuICAgICAgXCImZWxzO1wiOiBcIuKqlVwiLFxuICAgICAgXCImZWxzZG90O1wiOiBcIuKql1wiLFxuICAgICAgXCImZW1hY3I7XCI6IFwixJNcIixcbiAgICAgIFwiJmVtcHR5O1wiOiBcIuKIhVwiLFxuICAgICAgXCImZW1wdHlzZXQ7XCI6IFwi4oiFXCIsXG4gICAgICBcIiZlbXB0eXY7XCI6IFwi4oiFXCIsXG4gICAgICBcIiZlbXNwMTM7XCI6IFwi4oCEXCIsXG4gICAgICBcIiZlbXNwMTQ7XCI6IFwi4oCFXCIsXG4gICAgICBcIiZlbXNwO1wiOiBcIuKAg1wiLFxuICAgICAgXCImZW5nO1wiOiBcIsWLXCIsXG4gICAgICBcIiZlbnNwO1wiOiBcIuKAglwiLFxuICAgICAgXCImZW9nb247XCI6IFwixJlcIixcbiAgICAgIFwiJmVvcGY7XCI6IFwi8J2VllwiLFxuICAgICAgXCImZXBhcjtcIjogXCLii5VcIixcbiAgICAgIFwiJmVwYXJzbDtcIjogXCLip6NcIixcbiAgICAgIFwiJmVwbHVzO1wiOiBcIuKpsVwiLFxuICAgICAgXCImZXBzaTtcIjogXCLOtVwiLFxuICAgICAgXCImZXBzaWxvbjtcIjogXCLOtVwiLFxuICAgICAgXCImZXBzaXY7XCI6IFwiz7VcIixcbiAgICAgIFwiJmVxY2lyYztcIjogXCLiiZZcIixcbiAgICAgIFwiJmVxY29sb247XCI6IFwi4omVXCIsXG4gICAgICBcIiZlcXNpbTtcIjogXCLiiYJcIixcbiAgICAgIFwiJmVxc2xhbnRndHI7XCI6IFwi4qqWXCIsXG4gICAgICBcIiZlcXNsYW50bGVzcztcIjogXCLiqpVcIixcbiAgICAgIFwiJmVxdWFscztcIjogXCI9XCIsXG4gICAgICBcIiZlcXVlc3Q7XCI6IFwi4omfXCIsXG4gICAgICBcIiZlcXVpdjtcIjogXCLiiaFcIixcbiAgICAgIFwiJmVxdWl2REQ7XCI6IFwi4qm4XCIsXG4gICAgICBcIiZlcXZwYXJzbDtcIjogXCLip6VcIixcbiAgICAgIFwiJmVyRG90O1wiOiBcIuKJk1wiLFxuICAgICAgXCImZXJhcnI7XCI6IFwi4qWxXCIsXG4gICAgICBcIiZlc2NyO1wiOiBcIuKEr1wiLFxuICAgICAgXCImZXNkb3Q7XCI6IFwi4omQXCIsXG4gICAgICBcIiZlc2ltO1wiOiBcIuKJglwiLFxuICAgICAgXCImZXRhO1wiOiBcIs63XCIsXG4gICAgICBcIiZldGhcIjogXCLDsFwiLFxuICAgICAgXCImZXRoO1wiOiBcIsOwXCIsXG4gICAgICBcIiZldW1sXCI6IFwiw6tcIixcbiAgICAgIFwiJmV1bWw7XCI6IFwiw6tcIixcbiAgICAgIFwiJmV1cm87XCI6IFwi4oKsXCIsXG4gICAgICBcIiZleGNsO1wiOiBcIiFcIixcbiAgICAgIFwiJmV4aXN0O1wiOiBcIuKIg1wiLFxuICAgICAgXCImZXhwZWN0YXRpb247XCI6IFwi4oSwXCIsXG4gICAgICBcIiZleHBvbmVudGlhbGU7XCI6IFwi4oWHXCIsXG4gICAgICBcIiZmYWxsaW5nZG90c2VxO1wiOiBcIuKJklwiLFxuICAgICAgXCImZmN5O1wiOiBcItGEXCIsXG4gICAgICBcIiZmZW1hbGU7XCI6IFwi4pmAXCIsXG4gICAgICBcIiZmZmlsaWc7XCI6IFwi76yDXCIsXG4gICAgICBcIiZmZmxpZztcIjogXCLvrIBcIixcbiAgICAgIFwiJmZmbGxpZztcIjogXCLvrIRcIixcbiAgICAgIFwiJmZmcjtcIjogXCLwnZSjXCIsXG4gICAgICBcIiZmaWxpZztcIjogXCLvrIFcIixcbiAgICAgIFwiJmZqbGlnO1wiOiBcImZqXCIsXG4gICAgICBcIiZmbGF0O1wiOiBcIuKZrVwiLFxuICAgICAgXCImZmxsaWc7XCI6IFwi76yCXCIsXG4gICAgICBcIiZmbHRucztcIjogXCLilrFcIixcbiAgICAgIFwiJmZub2Y7XCI6IFwixpJcIixcbiAgICAgIFwiJmZvcGY7XCI6IFwi8J2Vl1wiLFxuICAgICAgXCImZm9yYWxsO1wiOiBcIuKIgFwiLFxuICAgICAgXCImZm9yaztcIjogXCLii5RcIixcbiAgICAgIFwiJmZvcmt2O1wiOiBcIuKrmVwiLFxuICAgICAgXCImZnBhcnRpbnQ7XCI6IFwi4qiNXCIsXG4gICAgICBcIiZmcmFjMTJcIjogXCLCvVwiLFxuICAgICAgXCImZnJhYzEyO1wiOiBcIsK9XCIsXG4gICAgICBcIiZmcmFjMTM7XCI6IFwi4oWTXCIsXG4gICAgICBcIiZmcmFjMTRcIjogXCLCvFwiLFxuICAgICAgXCImZnJhYzE0O1wiOiBcIsK8XCIsXG4gICAgICBcIiZmcmFjMTU7XCI6IFwi4oWVXCIsXG4gICAgICBcIiZmcmFjMTY7XCI6IFwi4oWZXCIsXG4gICAgICBcIiZmcmFjMTg7XCI6IFwi4oWbXCIsXG4gICAgICBcIiZmcmFjMjM7XCI6IFwi4oWUXCIsXG4gICAgICBcIiZmcmFjMjU7XCI6IFwi4oWWXCIsXG4gICAgICBcIiZmcmFjMzRcIjogXCLCvlwiLFxuICAgICAgXCImZnJhYzM0O1wiOiBcIsK+XCIsXG4gICAgICBcIiZmcmFjMzU7XCI6IFwi4oWXXCIsXG4gICAgICBcIiZmcmFjMzg7XCI6IFwi4oWcXCIsXG4gICAgICBcIiZmcmFjNDU7XCI6IFwi4oWYXCIsXG4gICAgICBcIiZmcmFjNTY7XCI6IFwi4oWaXCIsXG4gICAgICBcIiZmcmFjNTg7XCI6IFwi4oWdXCIsXG4gICAgICBcIiZmcmFjNzg7XCI6IFwi4oWeXCIsXG4gICAgICBcIiZmcmFzbDtcIjogXCLigYRcIixcbiAgICAgIFwiJmZyb3duO1wiOiBcIuKMolwiLFxuICAgICAgXCImZnNjcjtcIjogXCLwnZK7XCIsXG4gICAgICBcIiZnRTtcIjogXCLiiadcIixcbiAgICAgIFwiJmdFbDtcIjogXCLiqoxcIixcbiAgICAgIFwiJmdhY3V0ZTtcIjogXCLHtVwiLFxuICAgICAgXCImZ2FtbWE7XCI6IFwizrNcIixcbiAgICAgIFwiJmdhbW1hZDtcIjogXCLPnVwiLFxuICAgICAgXCImZ2FwO1wiOiBcIuKqhlwiLFxuICAgICAgXCImZ2JyZXZlO1wiOiBcIsSfXCIsXG4gICAgICBcIiZnY2lyYztcIjogXCLEnVwiLFxuICAgICAgXCImZ2N5O1wiOiBcItCzXCIsXG4gICAgICBcIiZnZG90O1wiOiBcIsShXCIsXG4gICAgICBcIiZnZTtcIjogXCLiiaVcIixcbiAgICAgIFwiJmdlbDtcIjogXCLii5tcIixcbiAgICAgIFwiJmdlcTtcIjogXCLiiaVcIixcbiAgICAgIFwiJmdlcXE7XCI6IFwi4omnXCIsXG4gICAgICBcIiZnZXFzbGFudDtcIjogXCLiqb5cIixcbiAgICAgIFwiJmdlcztcIjogXCLiqb5cIixcbiAgICAgIFwiJmdlc2NjO1wiOiBcIuKqqVwiLFxuICAgICAgXCImZ2VzZG90O1wiOiBcIuKqgFwiLFxuICAgICAgXCImZ2VzZG90bztcIjogXCLiqoJcIixcbiAgICAgIFwiJmdlc2RvdG9sO1wiOiBcIuKqhFwiLFxuICAgICAgXCImZ2VzbDtcIjogXCLii5vvuIBcIixcbiAgICAgIFwiJmdlc2xlcztcIjogXCLiqpRcIixcbiAgICAgIFwiJmdmcjtcIjogXCLwnZSkXCIsXG4gICAgICBcIiZnZztcIjogXCLiiatcIixcbiAgICAgIFwiJmdnZztcIjogXCLii5lcIixcbiAgICAgIFwiJmdpbWVsO1wiOiBcIuKEt1wiLFxuICAgICAgXCImZ2pjeTtcIjogXCLRk1wiLFxuICAgICAgXCImZ2w7XCI6IFwi4om3XCIsXG4gICAgICBcIiZnbEU7XCI6IFwi4qqSXCIsXG4gICAgICBcIiZnbGE7XCI6IFwi4qqlXCIsXG4gICAgICBcIiZnbGo7XCI6IFwi4qqkXCIsXG4gICAgICBcIiZnbkU7XCI6IFwi4ompXCIsXG4gICAgICBcIiZnbmFwO1wiOiBcIuKqilwiLFxuICAgICAgXCImZ25hcHByb3g7XCI6IFwi4qqKXCIsXG4gICAgICBcIiZnbmU7XCI6IFwi4qqIXCIsXG4gICAgICBcIiZnbmVxO1wiOiBcIuKqiFwiLFxuICAgICAgXCImZ25lcXE7XCI6IFwi4ompXCIsXG4gICAgICBcIiZnbnNpbTtcIjogXCLii6dcIixcbiAgICAgIFwiJmdvcGY7XCI6IFwi8J2VmFwiLFxuICAgICAgXCImZ3JhdmU7XCI6IFwiYFwiLFxuICAgICAgXCImZ3NjcjtcIjogXCLihIpcIixcbiAgICAgIFwiJmdzaW07XCI6IFwi4omzXCIsXG4gICAgICBcIiZnc2ltZTtcIjogXCLiqo5cIixcbiAgICAgIFwiJmdzaW1sO1wiOiBcIuKqkFwiLFxuICAgICAgXCImZ3RcIjogXCI+XCIsXG4gICAgICBcIiZndDtcIjogXCI+XCIsXG4gICAgICBcIiZndGNjO1wiOiBcIuKqp1wiLFxuICAgICAgXCImZ3RjaXI7XCI6IFwi4qm6XCIsXG4gICAgICBcIiZndGRvdDtcIjogXCLii5dcIixcbiAgICAgIFwiJmd0bFBhcjtcIjogXCLippVcIixcbiAgICAgIFwiJmd0cXVlc3Q7XCI6IFwi4qm8XCIsXG4gICAgICBcIiZndHJhcHByb3g7XCI6IFwi4qqGXCIsXG4gICAgICBcIiZndHJhcnI7XCI6IFwi4qW4XCIsXG4gICAgICBcIiZndHJkb3Q7XCI6IFwi4ouXXCIsXG4gICAgICBcIiZndHJlcWxlc3M7XCI6IFwi4oubXCIsXG4gICAgICBcIiZndHJlcXFsZXNzO1wiOiBcIuKqjFwiLFxuICAgICAgXCImZ3RybGVzcztcIjogXCLiibdcIixcbiAgICAgIFwiJmd0cnNpbTtcIjogXCLiibNcIixcbiAgICAgIFwiJmd2ZXJ0bmVxcTtcIjogXCLiianvuIBcIixcbiAgICAgIFwiJmd2bkU7XCI6IFwi4omp77iAXCIsXG4gICAgICBcIiZoQXJyO1wiOiBcIuKHlFwiLFxuICAgICAgXCImaGFpcnNwO1wiOiBcIuKAilwiLFxuICAgICAgXCImaGFsZjtcIjogXCLCvVwiLFxuICAgICAgXCImaGFtaWx0O1wiOiBcIuKEi1wiLFxuICAgICAgXCImaGFyZGN5O1wiOiBcItGKXCIsXG4gICAgICBcIiZoYXJyO1wiOiBcIuKGlFwiLFxuICAgICAgXCImaGFycmNpcjtcIjogXCLipYhcIixcbiAgICAgIFwiJmhhcnJ3O1wiOiBcIuKGrVwiLFxuICAgICAgXCImaGJhcjtcIjogXCLihI9cIixcbiAgICAgIFwiJmhjaXJjO1wiOiBcIsSlXCIsXG4gICAgICBcIiZoZWFydHM7XCI6IFwi4pmlXCIsXG4gICAgICBcIiZoZWFydHN1aXQ7XCI6IFwi4pmlXCIsXG4gICAgICBcIiZoZWxsaXA7XCI6IFwi4oCmXCIsXG4gICAgICBcIiZoZXJjb247XCI6IFwi4oq5XCIsXG4gICAgICBcIiZoZnI7XCI6IFwi8J2UpVwiLFxuICAgICAgXCImaGtzZWFyb3c7XCI6IFwi4qSlXCIsXG4gICAgICBcIiZoa3N3YXJvdztcIjogXCLipKZcIixcbiAgICAgIFwiJmhvYXJyO1wiOiBcIuKHv1wiLFxuICAgICAgXCImaG9tdGh0O1wiOiBcIuKIu1wiLFxuICAgICAgXCImaG9va2xlZnRhcnJvdztcIjogXCLihqlcIixcbiAgICAgIFwiJmhvb2tyaWdodGFycm93O1wiOiBcIuKGqlwiLFxuICAgICAgXCImaG9wZjtcIjogXCLwnZWZXCIsXG4gICAgICBcIiZob3JiYXI7XCI6IFwi4oCVXCIsXG4gICAgICBcIiZoc2NyO1wiOiBcIvCdkr1cIixcbiAgICAgIFwiJmhzbGFzaDtcIjogXCLihI9cIixcbiAgICAgIFwiJmhzdHJvaztcIjogXCLEp1wiLFxuICAgICAgXCImaHlidWxsO1wiOiBcIuKBg1wiLFxuICAgICAgXCImaHlwaGVuO1wiOiBcIuKAkFwiLFxuICAgICAgXCImaWFjdXRlXCI6IFwiw61cIixcbiAgICAgIFwiJmlhY3V0ZTtcIjogXCLDrVwiLFxuICAgICAgXCImaWM7XCI6IFwi4oGjXCIsXG4gICAgICBcIiZpY2lyY1wiOiBcIsOuXCIsXG4gICAgICBcIiZpY2lyYztcIjogXCLDrlwiLFxuICAgICAgXCImaWN5O1wiOiBcItC4XCIsXG4gICAgICBcIiZpZWN5O1wiOiBcItC1XCIsXG4gICAgICBcIiZpZXhjbFwiOiBcIsKhXCIsXG4gICAgICBcIiZpZXhjbDtcIjogXCLCoVwiLFxuICAgICAgXCImaWZmO1wiOiBcIuKHlFwiLFxuICAgICAgXCImaWZyO1wiOiBcIvCdlKZcIixcbiAgICAgIFwiJmlncmF2ZVwiOiBcIsOsXCIsXG4gICAgICBcIiZpZ3JhdmU7XCI6IFwiw6xcIixcbiAgICAgIFwiJmlpO1wiOiBcIuKFiFwiLFxuICAgICAgXCImaWlpaW50O1wiOiBcIuKojFwiLFxuICAgICAgXCImaWlpbnQ7XCI6IFwi4oitXCIsXG4gICAgICBcIiZpaW5maW47XCI6IFwi4qecXCIsXG4gICAgICBcIiZpaW90YTtcIjogXCLihKlcIixcbiAgICAgIFwiJmlqbGlnO1wiOiBcIsSzXCIsXG4gICAgICBcIiZpbWFjcjtcIjogXCLEq1wiLFxuICAgICAgXCImaW1hZ2U7XCI6IFwi4oSRXCIsXG4gICAgICBcIiZpbWFnbGluZTtcIjogXCLihJBcIixcbiAgICAgIFwiJmltYWdwYXJ0O1wiOiBcIuKEkVwiLFxuICAgICAgXCImaW1hdGg7XCI6IFwixLFcIixcbiAgICAgIFwiJmltb2Y7XCI6IFwi4oq3XCIsXG4gICAgICBcIiZpbXBlZDtcIjogXCLGtVwiLFxuICAgICAgXCImaW47XCI6IFwi4oiIXCIsXG4gICAgICBcIiZpbmNhcmU7XCI6IFwi4oSFXCIsXG4gICAgICBcIiZpbmZpbjtcIjogXCLiiJ5cIixcbiAgICAgIFwiJmluZmludGllO1wiOiBcIuKnnVwiLFxuICAgICAgXCImaW5vZG90O1wiOiBcIsSxXCIsXG4gICAgICBcIiZpbnQ7XCI6IFwi4oirXCIsXG4gICAgICBcIiZpbnRjYWw7XCI6IFwi4oq6XCIsXG4gICAgICBcIiZpbnRlZ2VycztcIjogXCLihKRcIixcbiAgICAgIFwiJmludGVyY2FsO1wiOiBcIuKKulwiLFxuICAgICAgXCImaW50bGFyaGs7XCI6IFwi4qiXXCIsXG4gICAgICBcIiZpbnRwcm9kO1wiOiBcIuKovFwiLFxuICAgICAgXCImaW9jeTtcIjogXCLRkVwiLFxuICAgICAgXCImaW9nb247XCI6IFwixK9cIixcbiAgICAgIFwiJmlvcGY7XCI6IFwi8J2VmlwiLFxuICAgICAgXCImaW90YTtcIjogXCLOuVwiLFxuICAgICAgXCImaXByb2Q7XCI6IFwi4qi8XCIsXG4gICAgICBcIiZpcXVlc3RcIjogXCLCv1wiLFxuICAgICAgXCImaXF1ZXN0O1wiOiBcIsK/XCIsXG4gICAgICBcIiZpc2NyO1wiOiBcIvCdkr5cIixcbiAgICAgIFwiJmlzaW47XCI6IFwi4oiIXCIsXG4gICAgICBcIiZpc2luRTtcIjogXCLii7lcIixcbiAgICAgIFwiJmlzaW5kb3Q7XCI6IFwi4ou1XCIsXG4gICAgICBcIiZpc2lucztcIjogXCLii7RcIixcbiAgICAgIFwiJmlzaW5zdjtcIjogXCLii7NcIixcbiAgICAgIFwiJmlzaW52O1wiOiBcIuKIiFwiLFxuICAgICAgXCImaXQ7XCI6IFwi4oGiXCIsXG4gICAgICBcIiZpdGlsZGU7XCI6IFwixKlcIixcbiAgICAgIFwiJml1a2N5O1wiOiBcItGWXCIsXG4gICAgICBcIiZpdW1sXCI6IFwiw69cIixcbiAgICAgIFwiJml1bWw7XCI6IFwiw69cIixcbiAgICAgIFwiJmpjaXJjO1wiOiBcIsS1XCIsXG4gICAgICBcIiZqY3k7XCI6IFwi0LlcIixcbiAgICAgIFwiJmpmcjtcIjogXCLwnZSnXCIsXG4gICAgICBcIiZqbWF0aDtcIjogXCLIt1wiLFxuICAgICAgXCImam9wZjtcIjogXCLwnZWbXCIsXG4gICAgICBcIiZqc2NyO1wiOiBcIvCdkr9cIixcbiAgICAgIFwiJmpzZXJjeTtcIjogXCLRmFwiLFxuICAgICAgXCImanVrY3k7XCI6IFwi0ZRcIixcbiAgICAgIFwiJmthcHBhO1wiOiBcIs66XCIsXG4gICAgICBcIiZrYXBwYXY7XCI6IFwiz7BcIixcbiAgICAgIFwiJmtjZWRpbDtcIjogXCLEt1wiLFxuICAgICAgXCIma2N5O1wiOiBcItC6XCIsXG4gICAgICBcIiZrZnI7XCI6IFwi8J2UqFwiLFxuICAgICAgXCIma2dyZWVuO1wiOiBcIsS4XCIsXG4gICAgICBcIiZraGN5O1wiOiBcItGFXCIsXG4gICAgICBcIiZramN5O1wiOiBcItGcXCIsXG4gICAgICBcIiZrb3BmO1wiOiBcIvCdlZxcIixcbiAgICAgIFwiJmtzY3I7XCI6IFwi8J2TgFwiLFxuICAgICAgXCImbEFhcnI7XCI6IFwi4oeaXCIsXG4gICAgICBcIiZsQXJyO1wiOiBcIuKHkFwiLFxuICAgICAgXCImbEF0YWlsO1wiOiBcIuKkm1wiLFxuICAgICAgXCImbEJhcnI7XCI6IFwi4qSOXCIsXG4gICAgICBcIiZsRTtcIjogXCLiiaZcIixcbiAgICAgIFwiJmxFZztcIjogXCLiqotcIixcbiAgICAgIFwiJmxIYXI7XCI6IFwi4qWiXCIsXG4gICAgICBcIiZsYWN1dGU7XCI6IFwixLpcIixcbiAgICAgIFwiJmxhZW1wdHl2O1wiOiBcIuKmtFwiLFxuICAgICAgXCImbGFncmFuO1wiOiBcIuKEklwiLFxuICAgICAgXCImbGFtYmRhO1wiOiBcIs67XCIsXG4gICAgICBcIiZsYW5nO1wiOiBcIuKfqFwiLFxuICAgICAgXCImbGFuZ2Q7XCI6IFwi4qaRXCIsXG4gICAgICBcIiZsYW5nbGU7XCI6IFwi4p+oXCIsXG4gICAgICBcIiZsYXA7XCI6IFwi4qqFXCIsXG4gICAgICBcIiZsYXF1b1wiOiBcIsKrXCIsXG4gICAgICBcIiZsYXF1bztcIjogXCLCq1wiLFxuICAgICAgXCImbGFycjtcIjogXCLihpBcIixcbiAgICAgIFwiJmxhcnJiO1wiOiBcIuKHpFwiLFxuICAgICAgXCImbGFycmJmcztcIjogXCLipJ9cIixcbiAgICAgIFwiJmxhcnJmcztcIjogXCLipJ1cIixcbiAgICAgIFwiJmxhcnJoaztcIjogXCLihqlcIixcbiAgICAgIFwiJmxhcnJscDtcIjogXCLihqtcIixcbiAgICAgIFwiJmxhcnJwbDtcIjogXCLipLlcIixcbiAgICAgIFwiJmxhcnJzaW07XCI6IFwi4qWzXCIsXG4gICAgICBcIiZsYXJydGw7XCI6IFwi4oaiXCIsXG4gICAgICBcIiZsYXQ7XCI6IFwi4qqrXCIsXG4gICAgICBcIiZsYXRhaWw7XCI6IFwi4qSZXCIsXG4gICAgICBcIiZsYXRlO1wiOiBcIuKqrVwiLFxuICAgICAgXCImbGF0ZXM7XCI6IFwi4qqt77iAXCIsXG4gICAgICBcIiZsYmFycjtcIjogXCLipIxcIixcbiAgICAgIFwiJmxiYnJrO1wiOiBcIuKdslwiLFxuICAgICAgXCImbGJyYWNlO1wiOiBcIntcIixcbiAgICAgIFwiJmxicmFjaztcIjogXCJbXCIsXG4gICAgICBcIiZsYnJrZTtcIjogXCLipotcIixcbiAgICAgIFwiJmxicmtzbGQ7XCI6IFwi4qaPXCIsXG4gICAgICBcIiZsYnJrc2x1O1wiOiBcIuKmjVwiLFxuICAgICAgXCImbGNhcm9uO1wiOiBcIsS+XCIsXG4gICAgICBcIiZsY2VkaWw7XCI6IFwixLxcIixcbiAgICAgIFwiJmxjZWlsO1wiOiBcIuKMiFwiLFxuICAgICAgXCImbGN1YjtcIjogXCJ7XCIsXG4gICAgICBcIiZsY3k7XCI6IFwi0LtcIixcbiAgICAgIFwiJmxkY2E7XCI6IFwi4qS2XCIsXG4gICAgICBcIiZsZHF1bztcIjogXCLigJxcIixcbiAgICAgIFwiJmxkcXVvcjtcIjogXCLigJ5cIixcbiAgICAgIFwiJmxkcmRoYXI7XCI6IFwi4qWnXCIsXG4gICAgICBcIiZsZHJ1c2hhcjtcIjogXCLipYtcIixcbiAgICAgIFwiJmxkc2g7XCI6IFwi4oayXCIsXG4gICAgICBcIiZsZTtcIjogXCLiiaRcIixcbiAgICAgIFwiJmxlZnRhcnJvdztcIjogXCLihpBcIixcbiAgICAgIFwiJmxlZnRhcnJvd3RhaWw7XCI6IFwi4oaiXCIsXG4gICAgICBcIiZsZWZ0aGFycG9vbmRvd247XCI6IFwi4oa9XCIsXG4gICAgICBcIiZsZWZ0aGFycG9vbnVwO1wiOiBcIuKGvFwiLFxuICAgICAgXCImbGVmdGxlZnRhcnJvd3M7XCI6IFwi4oeHXCIsXG4gICAgICBcIiZsZWZ0cmlnaHRhcnJvdztcIjogXCLihpRcIixcbiAgICAgIFwiJmxlZnRyaWdodGFycm93cztcIjogXCLih4ZcIixcbiAgICAgIFwiJmxlZnRyaWdodGhhcnBvb25zO1wiOiBcIuKHi1wiLFxuICAgICAgXCImbGVmdHJpZ2h0c3F1aWdhcnJvdztcIjogXCLihq1cIixcbiAgICAgIFwiJmxlZnR0aHJlZXRpbWVzO1wiOiBcIuKLi1wiLFxuICAgICAgXCImbGVnO1wiOiBcIuKLmlwiLFxuICAgICAgXCImbGVxO1wiOiBcIuKJpFwiLFxuICAgICAgXCImbGVxcTtcIjogXCLiiaZcIixcbiAgICAgIFwiJmxlcXNsYW50O1wiOiBcIuKpvVwiLFxuICAgICAgXCImbGVzO1wiOiBcIuKpvVwiLFxuICAgICAgXCImbGVzY2M7XCI6IFwi4qqoXCIsXG4gICAgICBcIiZsZXNkb3Q7XCI6IFwi4qm/XCIsXG4gICAgICBcIiZsZXNkb3RvO1wiOiBcIuKqgVwiLFxuICAgICAgXCImbGVzZG90b3I7XCI6IFwi4qqDXCIsXG4gICAgICBcIiZsZXNnO1wiOiBcIuKLmu+4gFwiLFxuICAgICAgXCImbGVzZ2VzO1wiOiBcIuKqk1wiLFxuICAgICAgXCImbGVzc2FwcHJveDtcIjogXCLiqoVcIixcbiAgICAgIFwiJmxlc3Nkb3Q7XCI6IFwi4ouWXCIsXG4gICAgICBcIiZsZXNzZXFndHI7XCI6IFwi4ouaXCIsXG4gICAgICBcIiZsZXNzZXFxZ3RyO1wiOiBcIuKqi1wiLFxuICAgICAgXCImbGVzc2d0cjtcIjogXCLiibZcIixcbiAgICAgIFwiJmxlc3NzaW07XCI6IFwi4omyXCIsXG4gICAgICBcIiZsZmlzaHQ7XCI6IFwi4qW8XCIsXG4gICAgICBcIiZsZmxvb3I7XCI6IFwi4oyKXCIsXG4gICAgICBcIiZsZnI7XCI6IFwi8J2UqVwiLFxuICAgICAgXCImbGc7XCI6IFwi4om2XCIsXG4gICAgICBcIiZsZ0U7XCI6IFwi4qqRXCIsXG4gICAgICBcIiZsaGFyZDtcIjogXCLihr1cIixcbiAgICAgIFwiJmxoYXJ1O1wiOiBcIuKGvFwiLFxuICAgICAgXCImbGhhcnVsO1wiOiBcIuKlqlwiLFxuICAgICAgXCImbGhibGs7XCI6IFwi4paEXCIsXG4gICAgICBcIiZsamN5O1wiOiBcItGZXCIsXG4gICAgICBcIiZsbDtcIjogXCLiiapcIixcbiAgICAgIFwiJmxsYXJyO1wiOiBcIuKHh1wiLFxuICAgICAgXCImbGxjb3JuZXI7XCI6IFwi4oyeXCIsXG4gICAgICBcIiZsbGhhcmQ7XCI6IFwi4qWrXCIsXG4gICAgICBcIiZsbHRyaTtcIjogXCLil7pcIixcbiAgICAgIFwiJmxtaWRvdDtcIjogXCLFgFwiLFxuICAgICAgXCImbG1vdXN0O1wiOiBcIuKOsFwiLFxuICAgICAgXCImbG1vdXN0YWNoZTtcIjogXCLijrBcIixcbiAgICAgIFwiJmxuRTtcIjogXCLiiahcIixcbiAgICAgIFwiJmxuYXA7XCI6IFwi4qqJXCIsXG4gICAgICBcIiZsbmFwcHJveDtcIjogXCLiqolcIixcbiAgICAgIFwiJmxuZTtcIjogXCLiqodcIixcbiAgICAgIFwiJmxuZXE7XCI6IFwi4qqHXCIsXG4gICAgICBcIiZsbmVxcTtcIjogXCLiiahcIixcbiAgICAgIFwiJmxuc2ltO1wiOiBcIuKLplwiLFxuICAgICAgXCImbG9hbmc7XCI6IFwi4p+sXCIsXG4gICAgICBcIiZsb2FycjtcIjogXCLih71cIixcbiAgICAgIFwiJmxvYnJrO1wiOiBcIuKfplwiLFxuICAgICAgXCImbG9uZ2xlZnRhcnJvdztcIjogXCLin7VcIixcbiAgICAgIFwiJmxvbmdsZWZ0cmlnaHRhcnJvdztcIjogXCLin7dcIixcbiAgICAgIFwiJmxvbmdtYXBzdG87XCI6IFwi4p+8XCIsXG4gICAgICBcIiZsb25ncmlnaHRhcnJvdztcIjogXCLin7ZcIixcbiAgICAgIFwiJmxvb3BhcnJvd2xlZnQ7XCI6IFwi4oarXCIsXG4gICAgICBcIiZsb29wYXJyb3dyaWdodDtcIjogXCLihqxcIixcbiAgICAgIFwiJmxvcGFyO1wiOiBcIuKmhVwiLFxuICAgICAgXCImbG9wZjtcIjogXCLwnZWdXCIsXG4gICAgICBcIiZsb3BsdXM7XCI6IFwi4qitXCIsXG4gICAgICBcIiZsb3RpbWVzO1wiOiBcIuKotFwiLFxuICAgICAgXCImbG93YXN0O1wiOiBcIuKIl1wiLFxuICAgICAgXCImbG93YmFyO1wiOiBcIl9cIixcbiAgICAgIFwiJmxvejtcIjogXCLil4pcIixcbiAgICAgIFwiJmxvemVuZ2U7XCI6IFwi4peKXCIsXG4gICAgICBcIiZsb3pmO1wiOiBcIuKnq1wiLFxuICAgICAgXCImbHBhcjtcIjogXCIoXCIsXG4gICAgICBcIiZscGFybHQ7XCI6IFwi4qaTXCIsXG4gICAgICBcIiZscmFycjtcIjogXCLih4ZcIixcbiAgICAgIFwiJmxyY29ybmVyO1wiOiBcIuKMn1wiLFxuICAgICAgXCImbHJoYXI7XCI6IFwi4oeLXCIsXG4gICAgICBcIiZscmhhcmQ7XCI6IFwi4qWtXCIsXG4gICAgICBcIiZscm07XCI6IFwi4oCOXCIsXG4gICAgICBcIiZscnRyaTtcIjogXCLiir9cIixcbiAgICAgIFwiJmxzYXF1bztcIjogXCLigLlcIixcbiAgICAgIFwiJmxzY3I7XCI6IFwi8J2TgVwiLFxuICAgICAgXCImbHNoO1wiOiBcIuKGsFwiLFxuICAgICAgXCImbHNpbTtcIjogXCLiibJcIixcbiAgICAgIFwiJmxzaW1lO1wiOiBcIuKqjVwiLFxuICAgICAgXCImbHNpbWc7XCI6IFwi4qqPXCIsXG4gICAgICBcIiZsc3FiO1wiOiBcIltcIixcbiAgICAgIFwiJmxzcXVvO1wiOiBcIuKAmFwiLFxuICAgICAgXCImbHNxdW9yO1wiOiBcIuKAmlwiLFxuICAgICAgXCImbHN0cm9rO1wiOiBcIsWCXCIsXG4gICAgICBcIiZsdFwiOiBcIjxcIixcbiAgICAgIFwiJmx0O1wiOiBcIjxcIixcbiAgICAgIFwiJmx0Y2M7XCI6IFwi4qqmXCIsXG4gICAgICBcIiZsdGNpcjtcIjogXCLiqblcIixcbiAgICAgIFwiJmx0ZG90O1wiOiBcIuKLllwiLFxuICAgICAgXCImbHRocmVlO1wiOiBcIuKLi1wiLFxuICAgICAgXCImbHRpbWVzO1wiOiBcIuKLiVwiLFxuICAgICAgXCImbHRsYXJyO1wiOiBcIuKltlwiLFxuICAgICAgXCImbHRxdWVzdDtcIjogXCLiqbtcIixcbiAgICAgIFwiJmx0clBhcjtcIjogXCLippZcIixcbiAgICAgIFwiJmx0cmk7XCI6IFwi4peDXCIsXG4gICAgICBcIiZsdHJpZTtcIjogXCLiirRcIixcbiAgICAgIFwiJmx0cmlmO1wiOiBcIuKXglwiLFxuICAgICAgXCImbHVyZHNoYXI7XCI6IFwi4qWKXCIsXG4gICAgICBcIiZsdXJ1aGFyO1wiOiBcIuKlplwiLFxuICAgICAgXCImbHZlcnRuZXFxO1wiOiBcIuKJqO+4gFwiLFxuICAgICAgXCImbHZuRTtcIjogXCLiiajvuIBcIixcbiAgICAgIFwiJm1ERG90O1wiOiBcIuKIulwiLFxuICAgICAgXCImbWFjclwiOiBcIsKvXCIsXG4gICAgICBcIiZtYWNyO1wiOiBcIsKvXCIsXG4gICAgICBcIiZtYWxlO1wiOiBcIuKZglwiLFxuICAgICAgXCImbWFsdDtcIjogXCLinKBcIixcbiAgICAgIFwiJm1hbHRlc2U7XCI6IFwi4pygXCIsXG4gICAgICBcIiZtYXA7XCI6IFwi4oamXCIsXG4gICAgICBcIiZtYXBzdG87XCI6IFwi4oamXCIsXG4gICAgICBcIiZtYXBzdG9kb3duO1wiOiBcIuKGp1wiLFxuICAgICAgXCImbWFwc3RvbGVmdDtcIjogXCLihqRcIixcbiAgICAgIFwiJm1hcHN0b3VwO1wiOiBcIuKGpVwiLFxuICAgICAgXCImbWFya2VyO1wiOiBcIuKWrlwiLFxuICAgICAgXCImbWNvbW1hO1wiOiBcIuKoqVwiLFxuICAgICAgXCImbWN5O1wiOiBcItC8XCIsXG4gICAgICBcIiZtZGFzaDtcIjogXCLigJRcIixcbiAgICAgIFwiJm1lYXN1cmVkYW5nbGU7XCI6IFwi4oihXCIsXG4gICAgICBcIiZtZnI7XCI6IFwi8J2UqlwiLFxuICAgICAgXCImbWhvO1wiOiBcIuKEp1wiLFxuICAgICAgXCImbWljcm9cIjogXCLCtVwiLFxuICAgICAgXCImbWljcm87XCI6IFwiwrVcIixcbiAgICAgIFwiJm1pZDtcIjogXCLiiKNcIixcbiAgICAgIFwiJm1pZGFzdDtcIjogXCIqXCIsXG4gICAgICBcIiZtaWRjaXI7XCI6IFwi4quwXCIsXG4gICAgICBcIiZtaWRkb3RcIjogXCLCt1wiLFxuICAgICAgXCImbWlkZG90O1wiOiBcIsK3XCIsXG4gICAgICBcIiZtaW51cztcIjogXCLiiJJcIixcbiAgICAgIFwiJm1pbnVzYjtcIjogXCLiip9cIixcbiAgICAgIFwiJm1pbnVzZDtcIjogXCLiiLhcIixcbiAgICAgIFwiJm1pbnVzZHU7XCI6IFwi4qiqXCIsXG4gICAgICBcIiZtbGNwO1wiOiBcIuKrm1wiLFxuICAgICAgXCImbWxkcjtcIjogXCLigKZcIixcbiAgICAgIFwiJm1ucGx1cztcIjogXCLiiJNcIixcbiAgICAgIFwiJm1vZGVscztcIjogXCLiiqdcIixcbiAgICAgIFwiJm1vcGY7XCI6IFwi8J2VnlwiLFxuICAgICAgXCImbXA7XCI6IFwi4oiTXCIsXG4gICAgICBcIiZtc2NyO1wiOiBcIvCdk4JcIixcbiAgICAgIFwiJm1zdHBvcztcIjogXCLiiL5cIixcbiAgICAgIFwiJm11O1wiOiBcIs68XCIsXG4gICAgICBcIiZtdWx0aW1hcDtcIjogXCLiirhcIixcbiAgICAgIFwiJm11bWFwO1wiOiBcIuKKuFwiLFxuICAgICAgXCImbkdnO1wiOiBcIuKLmcy4XCIsXG4gICAgICBcIiZuR3Q7XCI6IFwi4omr4oOSXCIsXG4gICAgICBcIiZuR3R2O1wiOiBcIuKJq8y4XCIsXG4gICAgICBcIiZuTGVmdGFycm93O1wiOiBcIuKHjVwiLFxuICAgICAgXCImbkxlZnRyaWdodGFycm93O1wiOiBcIuKHjlwiLFxuICAgICAgXCImbkxsO1wiOiBcIuKLmMy4XCIsXG4gICAgICBcIiZuTHQ7XCI6IFwi4omq4oOSXCIsXG4gICAgICBcIiZuTHR2O1wiOiBcIuKJqsy4XCIsXG4gICAgICBcIiZuUmlnaHRhcnJvdztcIjogXCLih49cIixcbiAgICAgIFwiJm5WRGFzaDtcIjogXCLiiq9cIixcbiAgICAgIFwiJm5WZGFzaDtcIjogXCLiiq5cIixcbiAgICAgIFwiJm5hYmxhO1wiOiBcIuKIh1wiLFxuICAgICAgXCImbmFjdXRlO1wiOiBcIsWEXCIsXG4gICAgICBcIiZuYW5nO1wiOiBcIuKIoOKDklwiLFxuICAgICAgXCImbmFwO1wiOiBcIuKJiVwiLFxuICAgICAgXCImbmFwRTtcIjogXCLiqbDMuFwiLFxuICAgICAgXCImbmFwaWQ7XCI6IFwi4omLzLhcIixcbiAgICAgIFwiJm5hcG9zO1wiOiBcIsWJXCIsXG4gICAgICBcIiZuYXBwcm94O1wiOiBcIuKJiVwiLFxuICAgICAgXCImbmF0dXI7XCI6IFwi4pmuXCIsXG4gICAgICBcIiZuYXR1cmFsO1wiOiBcIuKZrlwiLFxuICAgICAgXCImbmF0dXJhbHM7XCI6IFwi4oSVXCIsXG4gICAgICBcIiZuYnNwXCI6IFwiwqBcIixcbiAgICAgIFwiJm5ic3A7XCI6IFwiwqBcIixcbiAgICAgIFwiJm5idW1wO1wiOiBcIuKJjsy4XCIsXG4gICAgICBcIiZuYnVtcGU7XCI6IFwi4omPzLhcIixcbiAgICAgIFwiJm5jYXA7XCI6IFwi4qmDXCIsXG4gICAgICBcIiZuY2Fyb247XCI6IFwixYhcIixcbiAgICAgIFwiJm5jZWRpbDtcIjogXCLFhlwiLFxuICAgICAgXCImbmNvbmc7XCI6IFwi4omHXCIsXG4gICAgICBcIiZuY29uZ2RvdDtcIjogXCLiqa3MuFwiLFxuICAgICAgXCImbmN1cDtcIjogXCLiqYJcIixcbiAgICAgIFwiJm5jeTtcIjogXCLQvVwiLFxuICAgICAgXCImbmRhc2g7XCI6IFwi4oCTXCIsXG4gICAgICBcIiZuZTtcIjogXCLiiaBcIixcbiAgICAgIFwiJm5lQXJyO1wiOiBcIuKHl1wiLFxuICAgICAgXCImbmVhcmhrO1wiOiBcIuKkpFwiLFxuICAgICAgXCImbmVhcnI7XCI6IFwi4oaXXCIsXG4gICAgICBcIiZuZWFycm93O1wiOiBcIuKGl1wiLFxuICAgICAgXCImbmVkb3Q7XCI6IFwi4omQzLhcIixcbiAgICAgIFwiJm5lcXVpdjtcIjogXCLiiaJcIixcbiAgICAgIFwiJm5lc2VhcjtcIjogXCLipKhcIixcbiAgICAgIFwiJm5lc2ltO1wiOiBcIuKJgsy4XCIsXG4gICAgICBcIiZuZXhpc3Q7XCI6IFwi4oiEXCIsXG4gICAgICBcIiZuZXhpc3RzO1wiOiBcIuKIhFwiLFxuICAgICAgXCImbmZyO1wiOiBcIvCdlKtcIixcbiAgICAgIFwiJm5nRTtcIjogXCLiiafMuFwiLFxuICAgICAgXCImbmdlO1wiOiBcIuKJsVwiLFxuICAgICAgXCImbmdlcTtcIjogXCLiibFcIixcbiAgICAgIFwiJm5nZXFxO1wiOiBcIuKJp8y4XCIsXG4gICAgICBcIiZuZ2Vxc2xhbnQ7XCI6IFwi4qm+zLhcIixcbiAgICAgIFwiJm5nZXM7XCI6IFwi4qm+zLhcIixcbiAgICAgIFwiJm5nc2ltO1wiOiBcIuKJtVwiLFxuICAgICAgXCImbmd0O1wiOiBcIuKJr1wiLFxuICAgICAgXCImbmd0cjtcIjogXCLiia9cIixcbiAgICAgIFwiJm5oQXJyO1wiOiBcIuKHjlwiLFxuICAgICAgXCImbmhhcnI7XCI6IFwi4oauXCIsXG4gICAgICBcIiZuaHBhcjtcIjogXCLiq7JcIixcbiAgICAgIFwiJm5pO1wiOiBcIuKIi1wiLFxuICAgICAgXCImbmlzO1wiOiBcIuKLvFwiLFxuICAgICAgXCImbmlzZDtcIjogXCLii7pcIixcbiAgICAgIFwiJm5pdjtcIjogXCLiiItcIixcbiAgICAgIFwiJm5qY3k7XCI6IFwi0ZpcIixcbiAgICAgIFwiJm5sQXJyO1wiOiBcIuKHjVwiLFxuICAgICAgXCImbmxFO1wiOiBcIuKJpsy4XCIsXG4gICAgICBcIiZubGFycjtcIjogXCLihppcIixcbiAgICAgIFwiJm5sZHI7XCI6IFwi4oClXCIsXG4gICAgICBcIiZubGU7XCI6IFwi4omwXCIsXG4gICAgICBcIiZubGVmdGFycm93O1wiOiBcIuKGmlwiLFxuICAgICAgXCImbmxlZnRyaWdodGFycm93O1wiOiBcIuKGrlwiLFxuICAgICAgXCImbmxlcTtcIjogXCLiibBcIixcbiAgICAgIFwiJm5sZXFxO1wiOiBcIuKJpsy4XCIsXG4gICAgICBcIiZubGVxc2xhbnQ7XCI6IFwi4qm9zLhcIixcbiAgICAgIFwiJm5sZXM7XCI6IFwi4qm9zLhcIixcbiAgICAgIFwiJm5sZXNzO1wiOiBcIuKJrlwiLFxuICAgICAgXCImbmxzaW07XCI6IFwi4om0XCIsXG4gICAgICBcIiZubHQ7XCI6IFwi4omuXCIsXG4gICAgICBcIiZubHRyaTtcIjogXCLii6pcIixcbiAgICAgIFwiJm5sdHJpZTtcIjogXCLii6xcIixcbiAgICAgIFwiJm5taWQ7XCI6IFwi4oikXCIsXG4gICAgICBcIiZub3BmO1wiOiBcIvCdlZ9cIixcbiAgICAgIFwiJm5vdFwiOiBcIsKsXCIsXG4gICAgICBcIiZub3Q7XCI6IFwiwqxcIixcbiAgICAgIFwiJm5vdGluO1wiOiBcIuKIiVwiLFxuICAgICAgXCImbm90aW5FO1wiOiBcIuKLucy4XCIsXG4gICAgICBcIiZub3RpbmRvdDtcIjogXCLii7XMuFwiLFxuICAgICAgXCImbm90aW52YTtcIjogXCLiiIlcIixcbiAgICAgIFwiJm5vdGludmI7XCI6IFwi4ou3XCIsXG4gICAgICBcIiZub3RpbnZjO1wiOiBcIuKLtlwiLFxuICAgICAgXCImbm90bmk7XCI6IFwi4oiMXCIsXG4gICAgICBcIiZub3RuaXZhO1wiOiBcIuKIjFwiLFxuICAgICAgXCImbm90bml2YjtcIjogXCLii75cIixcbiAgICAgIFwiJm5vdG5pdmM7XCI6IFwi4ou9XCIsXG4gICAgICBcIiZucGFyO1wiOiBcIuKIplwiLFxuICAgICAgXCImbnBhcmFsbGVsO1wiOiBcIuKIplwiLFxuICAgICAgXCImbnBhcnNsO1wiOiBcIuKrveKDpVwiLFxuICAgICAgXCImbnBhcnQ7XCI6IFwi4oiCzLhcIixcbiAgICAgIFwiJm5wb2xpbnQ7XCI6IFwi4qiUXCIsXG4gICAgICBcIiZucHI7XCI6IFwi4oqAXCIsXG4gICAgICBcIiZucHJjdWU7XCI6IFwi4ougXCIsXG4gICAgICBcIiZucHJlO1wiOiBcIuKqr8y4XCIsXG4gICAgICBcIiZucHJlYztcIjogXCLiioBcIixcbiAgICAgIFwiJm5wcmVjZXE7XCI6IFwi4qqvzLhcIixcbiAgICAgIFwiJm5yQXJyO1wiOiBcIuKHj1wiLFxuICAgICAgXCImbnJhcnI7XCI6IFwi4oabXCIsXG4gICAgICBcIiZucmFycmM7XCI6IFwi4qSzzLhcIixcbiAgICAgIFwiJm5yYXJydztcIjogXCLihp3MuFwiLFxuICAgICAgXCImbnJpZ2h0YXJyb3c7XCI6IFwi4oabXCIsXG4gICAgICBcIiZucnRyaTtcIjogXCLii6tcIixcbiAgICAgIFwiJm5ydHJpZTtcIjogXCLii61cIixcbiAgICAgIFwiJm5zYztcIjogXCLiioFcIixcbiAgICAgIFwiJm5zY2N1ZTtcIjogXCLii6FcIixcbiAgICAgIFwiJm5zY2U7XCI6IFwi4qqwzLhcIixcbiAgICAgIFwiJm5zY3I7XCI6IFwi8J2Tg1wiLFxuICAgICAgXCImbnNob3J0bWlkO1wiOiBcIuKIpFwiLFxuICAgICAgXCImbnNob3J0cGFyYWxsZWw7XCI6IFwi4oimXCIsXG4gICAgICBcIiZuc2ltO1wiOiBcIuKJgVwiLFxuICAgICAgXCImbnNpbWU7XCI6IFwi4omEXCIsXG4gICAgICBcIiZuc2ltZXE7XCI6IFwi4omEXCIsXG4gICAgICBcIiZuc21pZDtcIjogXCLiiKRcIixcbiAgICAgIFwiJm5zcGFyO1wiOiBcIuKIplwiLFxuICAgICAgXCImbnNxc3ViZTtcIjogXCLii6JcIixcbiAgICAgIFwiJm5zcXN1cGU7XCI6IFwi4oujXCIsXG4gICAgICBcIiZuc3ViO1wiOiBcIuKKhFwiLFxuICAgICAgXCImbnN1YkU7XCI6IFwi4quFzLhcIixcbiAgICAgIFwiJm5zdWJlO1wiOiBcIuKKiFwiLFxuICAgICAgXCImbnN1YnNldDtcIjogXCLiioLig5JcIixcbiAgICAgIFwiJm5zdWJzZXRlcTtcIjogXCLiiohcIixcbiAgICAgIFwiJm5zdWJzZXRlcXE7XCI6IFwi4quFzLhcIixcbiAgICAgIFwiJm5zdWNjO1wiOiBcIuKKgVwiLFxuICAgICAgXCImbnN1Y2NlcTtcIjogXCLiqrDMuFwiLFxuICAgICAgXCImbnN1cDtcIjogXCLiioVcIixcbiAgICAgIFwiJm5zdXBFO1wiOiBcIuKrhsy4XCIsXG4gICAgICBcIiZuc3VwZTtcIjogXCLiiolcIixcbiAgICAgIFwiJm5zdXBzZXQ7XCI6IFwi4oqD4oOSXCIsXG4gICAgICBcIiZuc3Vwc2V0ZXE7XCI6IFwi4oqJXCIsXG4gICAgICBcIiZuc3Vwc2V0ZXFxO1wiOiBcIuKrhsy4XCIsXG4gICAgICBcIiZudGdsO1wiOiBcIuKJuVwiLFxuICAgICAgXCImbnRpbGRlXCI6IFwiw7FcIixcbiAgICAgIFwiJm50aWxkZTtcIjogXCLDsVwiLFxuICAgICAgXCImbnRsZztcIjogXCLiibhcIixcbiAgICAgIFwiJm50cmlhbmdsZWxlZnQ7XCI6IFwi4ouqXCIsXG4gICAgICBcIiZudHJpYW5nbGVsZWZ0ZXE7XCI6IFwi4ousXCIsXG4gICAgICBcIiZudHJpYW5nbGVyaWdodDtcIjogXCLii6tcIixcbiAgICAgIFwiJm50cmlhbmdsZXJpZ2h0ZXE7XCI6IFwi4outXCIsXG4gICAgICBcIiZudTtcIjogXCLOvVwiLFxuICAgICAgXCImbnVtO1wiOiBcIiNcIixcbiAgICAgIFwiJm51bWVybztcIjogXCLihJZcIixcbiAgICAgIFwiJm51bXNwO1wiOiBcIuKAh1wiLFxuICAgICAgXCImbnZEYXNoO1wiOiBcIuKKrVwiLFxuICAgICAgXCImbnZIYXJyO1wiOiBcIuKkhFwiLFxuICAgICAgXCImbnZhcDtcIjogXCLiiY3ig5JcIixcbiAgICAgIFwiJm52ZGFzaDtcIjogXCLiiqxcIixcbiAgICAgIFwiJm52Z2U7XCI6IFwi4oml4oOSXCIsXG4gICAgICBcIiZudmd0O1wiOiBcIj7ig5JcIixcbiAgICAgIFwiJm52aW5maW47XCI6IFwi4qeeXCIsXG4gICAgICBcIiZudmxBcnI7XCI6IFwi4qSCXCIsXG4gICAgICBcIiZudmxlO1wiOiBcIuKJpOKDklwiLFxuICAgICAgXCImbnZsdDtcIjogXCI84oOSXCIsXG4gICAgICBcIiZudmx0cmllO1wiOiBcIuKKtOKDklwiLFxuICAgICAgXCImbnZyQXJyO1wiOiBcIuKkg1wiLFxuICAgICAgXCImbnZydHJpZTtcIjogXCLiirXig5JcIixcbiAgICAgIFwiJm52c2ltO1wiOiBcIuKIvOKDklwiLFxuICAgICAgXCImbndBcnI7XCI6IFwi4oeWXCIsXG4gICAgICBcIiZud2FyaGs7XCI6IFwi4qSjXCIsXG4gICAgICBcIiZud2FycjtcIjogXCLihpZcIixcbiAgICAgIFwiJm53YXJyb3c7XCI6IFwi4oaWXCIsXG4gICAgICBcIiZud25lYXI7XCI6IFwi4qSnXCIsXG4gICAgICBcIiZvUztcIjogXCLik4hcIixcbiAgICAgIFwiJm9hY3V0ZVwiOiBcIsOzXCIsXG4gICAgICBcIiZvYWN1dGU7XCI6IFwiw7NcIixcbiAgICAgIFwiJm9hc3Q7XCI6IFwi4oqbXCIsXG4gICAgICBcIiZvY2lyO1wiOiBcIuKKmlwiLFxuICAgICAgXCImb2NpcmNcIjogXCLDtFwiLFxuICAgICAgXCImb2NpcmM7XCI6IFwiw7RcIixcbiAgICAgIFwiJm9jeTtcIjogXCLQvlwiLFxuICAgICAgXCImb2Rhc2g7XCI6IFwi4oqdXCIsXG4gICAgICBcIiZvZGJsYWM7XCI6IFwixZFcIixcbiAgICAgIFwiJm9kaXY7XCI6IFwi4qi4XCIsXG4gICAgICBcIiZvZG90O1wiOiBcIuKKmVwiLFxuICAgICAgXCImb2Rzb2xkO1wiOiBcIuKmvFwiLFxuICAgICAgXCImb2VsaWc7XCI6IFwixZNcIixcbiAgICAgIFwiJm9mY2lyO1wiOiBcIuKmv1wiLFxuICAgICAgXCImb2ZyO1wiOiBcIvCdlKxcIixcbiAgICAgIFwiJm9nb247XCI6IFwiy5tcIixcbiAgICAgIFwiJm9ncmF2ZVwiOiBcIsOyXCIsXG4gICAgICBcIiZvZ3JhdmU7XCI6IFwiw7JcIixcbiAgICAgIFwiJm9ndDtcIjogXCLip4FcIixcbiAgICAgIFwiJm9oYmFyO1wiOiBcIuKmtVwiLFxuICAgICAgXCImb2htO1wiOiBcIs6pXCIsXG4gICAgICBcIiZvaW50O1wiOiBcIuKIrlwiLFxuICAgICAgXCImb2xhcnI7XCI6IFwi4oa6XCIsXG4gICAgICBcIiZvbGNpcjtcIjogXCLipr5cIixcbiAgICAgIFwiJm9sY3Jvc3M7XCI6IFwi4qa7XCIsXG4gICAgICBcIiZvbGluZTtcIjogXCLigL5cIixcbiAgICAgIFwiJm9sdDtcIjogXCLip4BcIixcbiAgICAgIFwiJm9tYWNyO1wiOiBcIsWNXCIsXG4gICAgICBcIiZvbWVnYTtcIjogXCLPiVwiLFxuICAgICAgXCImb21pY3JvbjtcIjogXCLOv1wiLFxuICAgICAgXCImb21pZDtcIjogXCLiprZcIixcbiAgICAgIFwiJm9taW51cztcIjogXCLiipZcIixcbiAgICAgIFwiJm9vcGY7XCI6IFwi8J2VoFwiLFxuICAgICAgXCImb3BhcjtcIjogXCLiprdcIixcbiAgICAgIFwiJm9wZXJwO1wiOiBcIuKmuVwiLFxuICAgICAgXCImb3BsdXM7XCI6IFwi4oqVXCIsXG4gICAgICBcIiZvcjtcIjogXCLiiKhcIixcbiAgICAgIFwiJm9yYXJyO1wiOiBcIuKGu1wiLFxuICAgICAgXCImb3JkO1wiOiBcIuKpnVwiLFxuICAgICAgXCImb3JkZXI7XCI6IFwi4oS0XCIsXG4gICAgICBcIiZvcmRlcm9mO1wiOiBcIuKEtFwiLFxuICAgICAgXCImb3JkZlwiOiBcIsKqXCIsXG4gICAgICBcIiZvcmRmO1wiOiBcIsKqXCIsXG4gICAgICBcIiZvcmRtXCI6IFwiwrpcIixcbiAgICAgIFwiJm9yZG07XCI6IFwiwrpcIixcbiAgICAgIFwiJm9yaWdvZjtcIjogXCLiirZcIixcbiAgICAgIFwiJm9yb3I7XCI6IFwi4qmWXCIsXG4gICAgICBcIiZvcnNsb3BlO1wiOiBcIuKpl1wiLFxuICAgICAgXCImb3J2O1wiOiBcIuKpm1wiLFxuICAgICAgXCImb3NjcjtcIjogXCLihLRcIixcbiAgICAgIFwiJm9zbGFzaFwiOiBcIsO4XCIsXG4gICAgICBcIiZvc2xhc2g7XCI6IFwiw7hcIixcbiAgICAgIFwiJm9zb2w7XCI6IFwi4oqYXCIsXG4gICAgICBcIiZvdGlsZGVcIjogXCLDtVwiLFxuICAgICAgXCImb3RpbGRlO1wiOiBcIsO1XCIsXG4gICAgICBcIiZvdGltZXM7XCI6IFwi4oqXXCIsXG4gICAgICBcIiZvdGltZXNhcztcIjogXCLiqLZcIixcbiAgICAgIFwiJm91bWxcIjogXCLDtlwiLFxuICAgICAgXCImb3VtbDtcIjogXCLDtlwiLFxuICAgICAgXCImb3ZiYXI7XCI6IFwi4oy9XCIsXG4gICAgICBcIiZwYXI7XCI6IFwi4oilXCIsXG4gICAgICBcIiZwYXJhXCI6IFwiwrZcIixcbiAgICAgIFwiJnBhcmE7XCI6IFwiwrZcIixcbiAgICAgIFwiJnBhcmFsbGVsO1wiOiBcIuKIpVwiLFxuICAgICAgXCImcGFyc2ltO1wiOiBcIuKrs1wiLFxuICAgICAgXCImcGFyc2w7XCI6IFwi4qu9XCIsXG4gICAgICBcIiZwYXJ0O1wiOiBcIuKIglwiLFxuICAgICAgXCImcGN5O1wiOiBcItC/XCIsXG4gICAgICBcIiZwZXJjbnQ7XCI6IFwiJVwiLFxuICAgICAgXCImcGVyaW9kO1wiOiBcIi5cIixcbiAgICAgIFwiJnBlcm1pbDtcIjogXCLigLBcIixcbiAgICAgIFwiJnBlcnA7XCI6IFwi4oqlXCIsXG4gICAgICBcIiZwZXJ0ZW5rO1wiOiBcIuKAsVwiLFxuICAgICAgXCImcGZyO1wiOiBcIvCdlK1cIixcbiAgICAgIFwiJnBoaTtcIjogXCLPhlwiLFxuICAgICAgXCImcGhpdjtcIjogXCLPlVwiLFxuICAgICAgXCImcGhtbWF0O1wiOiBcIuKEs1wiLFxuICAgICAgXCImcGhvbmU7XCI6IFwi4piOXCIsXG4gICAgICBcIiZwaTtcIjogXCLPgFwiLFxuICAgICAgXCImcGl0Y2hmb3JrO1wiOiBcIuKLlFwiLFxuICAgICAgXCImcGl2O1wiOiBcIs+WXCIsXG4gICAgICBcIiZwbGFuY2s7XCI6IFwi4oSPXCIsXG4gICAgICBcIiZwbGFuY2toO1wiOiBcIuKEjlwiLFxuICAgICAgXCImcGxhbmt2O1wiOiBcIuKEj1wiLFxuICAgICAgXCImcGx1cztcIjogXCIrXCIsXG4gICAgICBcIiZwbHVzYWNpcjtcIjogXCLiqKNcIixcbiAgICAgIFwiJnBsdXNiO1wiOiBcIuKKnlwiLFxuICAgICAgXCImcGx1c2NpcjtcIjogXCLiqKJcIixcbiAgICAgIFwiJnBsdXNkbztcIjogXCLiiJRcIixcbiAgICAgIFwiJnBsdXNkdTtcIjogXCLiqKVcIixcbiAgICAgIFwiJnBsdXNlO1wiOiBcIuKpslwiLFxuICAgICAgXCImcGx1c21uXCI6IFwiwrFcIixcbiAgICAgIFwiJnBsdXNtbjtcIjogXCLCsVwiLFxuICAgICAgXCImcGx1c3NpbTtcIjogXCLiqKZcIixcbiAgICAgIFwiJnBsdXN0d287XCI6IFwi4qinXCIsXG4gICAgICBcIiZwbTtcIjogXCLCsVwiLFxuICAgICAgXCImcG9pbnRpbnQ7XCI6IFwi4qiVXCIsXG4gICAgICBcIiZwb3BmO1wiOiBcIvCdlaFcIixcbiAgICAgIFwiJnBvdW5kXCI6IFwiwqNcIixcbiAgICAgIFwiJnBvdW5kO1wiOiBcIsKjXCIsXG4gICAgICBcIiZwcjtcIjogXCLiibpcIixcbiAgICAgIFwiJnByRTtcIjogXCLiqrNcIixcbiAgICAgIFwiJnByYXA7XCI6IFwi4qq3XCIsXG4gICAgICBcIiZwcmN1ZTtcIjogXCLiibxcIixcbiAgICAgIFwiJnByZTtcIjogXCLiqq9cIixcbiAgICAgIFwiJnByZWM7XCI6IFwi4om6XCIsXG4gICAgICBcIiZwcmVjYXBwcm94O1wiOiBcIuKqt1wiLFxuICAgICAgXCImcHJlY2N1cmx5ZXE7XCI6IFwi4om8XCIsXG4gICAgICBcIiZwcmVjZXE7XCI6IFwi4qqvXCIsXG4gICAgICBcIiZwcmVjbmFwcHJveDtcIjogXCLiqrlcIixcbiAgICAgIFwiJnByZWNuZXFxO1wiOiBcIuKqtVwiLFxuICAgICAgXCImcHJlY25zaW07XCI6IFwi4ouoXCIsXG4gICAgICBcIiZwcmVjc2ltO1wiOiBcIuKJvlwiLFxuICAgICAgXCImcHJpbWU7XCI6IFwi4oCyXCIsXG4gICAgICBcIiZwcmltZXM7XCI6IFwi4oSZXCIsXG4gICAgICBcIiZwcm5FO1wiOiBcIuKqtVwiLFxuICAgICAgXCImcHJuYXA7XCI6IFwi4qq5XCIsXG4gICAgICBcIiZwcm5zaW07XCI6IFwi4ouoXCIsXG4gICAgICBcIiZwcm9kO1wiOiBcIuKIj1wiLFxuICAgICAgXCImcHJvZmFsYXI7XCI6IFwi4oyuXCIsXG4gICAgICBcIiZwcm9mbGluZTtcIjogXCLijJJcIixcbiAgICAgIFwiJnByb2ZzdXJmO1wiOiBcIuKMk1wiLFxuICAgICAgXCImcHJvcDtcIjogXCLiiJ1cIixcbiAgICAgIFwiJnByb3B0bztcIjogXCLiiJ1cIixcbiAgICAgIFwiJnByc2ltO1wiOiBcIuKJvlwiLFxuICAgICAgXCImcHJ1cmVsO1wiOiBcIuKKsFwiLFxuICAgICAgXCImcHNjcjtcIjogXCLwnZOFXCIsXG4gICAgICBcIiZwc2k7XCI6IFwiz4hcIixcbiAgICAgIFwiJnB1bmNzcDtcIjogXCLigIhcIixcbiAgICAgIFwiJnFmcjtcIjogXCLwnZSuXCIsXG4gICAgICBcIiZxaW50O1wiOiBcIuKojFwiLFxuICAgICAgXCImcW9wZjtcIjogXCLwnZWiXCIsXG4gICAgICBcIiZxcHJpbWU7XCI6IFwi4oGXXCIsXG4gICAgICBcIiZxc2NyO1wiOiBcIvCdk4ZcIixcbiAgICAgIFwiJnF1YXRlcm5pb25zO1wiOiBcIuKEjVwiLFxuICAgICAgXCImcXVhdGludDtcIjogXCLiqJZcIixcbiAgICAgIFwiJnF1ZXN0O1wiOiBcIj9cIixcbiAgICAgIFwiJnF1ZXN0ZXE7XCI6IFwi4omfXCIsXG4gICAgICBcIiZxdW90XCI6ICdcIicsXG4gICAgICBcIiZxdW90O1wiOiAnXCInLFxuICAgICAgXCImckFhcnI7XCI6IFwi4oebXCIsXG4gICAgICBcIiZyQXJyO1wiOiBcIuKHklwiLFxuICAgICAgXCImckF0YWlsO1wiOiBcIuKknFwiLFxuICAgICAgXCImckJhcnI7XCI6IFwi4qSPXCIsXG4gICAgICBcIiZySGFyO1wiOiBcIuKlpFwiLFxuICAgICAgXCImcmFjZTtcIjogXCLiiL3MsVwiLFxuICAgICAgXCImcmFjdXRlO1wiOiBcIsWVXCIsXG4gICAgICBcIiZyYWRpYztcIjogXCLiiJpcIixcbiAgICAgIFwiJnJhZW1wdHl2O1wiOiBcIuKms1wiLFxuICAgICAgXCImcmFuZztcIjogXCLin6lcIixcbiAgICAgIFwiJnJhbmdkO1wiOiBcIuKmklwiLFxuICAgICAgXCImcmFuZ2U7XCI6IFwi4qalXCIsXG4gICAgICBcIiZyYW5nbGU7XCI6IFwi4p+pXCIsXG4gICAgICBcIiZyYXF1b1wiOiBcIsK7XCIsXG4gICAgICBcIiZyYXF1bztcIjogXCLCu1wiLFxuICAgICAgXCImcmFycjtcIjogXCLihpJcIixcbiAgICAgIFwiJnJhcnJhcDtcIjogXCLipbVcIixcbiAgICAgIFwiJnJhcnJiO1wiOiBcIuKHpVwiLFxuICAgICAgXCImcmFycmJmcztcIjogXCLipKBcIixcbiAgICAgIFwiJnJhcnJjO1wiOiBcIuKks1wiLFxuICAgICAgXCImcmFycmZzO1wiOiBcIuKknlwiLFxuICAgICAgXCImcmFycmhrO1wiOiBcIuKGqlwiLFxuICAgICAgXCImcmFycmxwO1wiOiBcIuKGrFwiLFxuICAgICAgXCImcmFycnBsO1wiOiBcIuKlhVwiLFxuICAgICAgXCImcmFycnNpbTtcIjogXCLipbRcIixcbiAgICAgIFwiJnJhcnJ0bDtcIjogXCLihqNcIixcbiAgICAgIFwiJnJhcnJ3O1wiOiBcIuKGnVwiLFxuICAgICAgXCImcmF0YWlsO1wiOiBcIuKkmlwiLFxuICAgICAgXCImcmF0aW87XCI6IFwi4oi2XCIsXG4gICAgICBcIiZyYXRpb25hbHM7XCI6IFwi4oSaXCIsXG4gICAgICBcIiZyYmFycjtcIjogXCLipI1cIixcbiAgICAgIFwiJnJiYnJrO1wiOiBcIuKds1wiLFxuICAgICAgXCImcmJyYWNlO1wiOiBcIn1cIixcbiAgICAgIFwiJnJicmFjaztcIjogXCJdXCIsXG4gICAgICBcIiZyYnJrZTtcIjogXCLipoxcIixcbiAgICAgIFwiJnJicmtzbGQ7XCI6IFwi4qaOXCIsXG4gICAgICBcIiZyYnJrc2x1O1wiOiBcIuKmkFwiLFxuICAgICAgXCImcmNhcm9uO1wiOiBcIsWZXCIsXG4gICAgICBcIiZyY2VkaWw7XCI6IFwixZdcIixcbiAgICAgIFwiJnJjZWlsO1wiOiBcIuKMiVwiLFxuICAgICAgXCImcmN1YjtcIjogXCJ9XCIsXG4gICAgICBcIiZyY3k7XCI6IFwi0YBcIixcbiAgICAgIFwiJnJkY2E7XCI6IFwi4qS3XCIsXG4gICAgICBcIiZyZGxkaGFyO1wiOiBcIuKlqVwiLFxuICAgICAgXCImcmRxdW87XCI6IFwi4oCdXCIsXG4gICAgICBcIiZyZHF1b3I7XCI6IFwi4oCdXCIsXG4gICAgICBcIiZyZHNoO1wiOiBcIuKGs1wiLFxuICAgICAgXCImcmVhbDtcIjogXCLihJxcIixcbiAgICAgIFwiJnJlYWxpbmU7XCI6IFwi4oSbXCIsXG4gICAgICBcIiZyZWFscGFydDtcIjogXCLihJxcIixcbiAgICAgIFwiJnJlYWxzO1wiOiBcIuKEnVwiLFxuICAgICAgXCImcmVjdDtcIjogXCLilq1cIixcbiAgICAgIFwiJnJlZ1wiOiBcIsKuXCIsXG4gICAgICBcIiZyZWc7XCI6IFwiwq5cIixcbiAgICAgIFwiJnJmaXNodDtcIjogXCLipb1cIixcbiAgICAgIFwiJnJmbG9vcjtcIjogXCLijItcIixcbiAgICAgIFwiJnJmcjtcIjogXCLwnZSvXCIsXG4gICAgICBcIiZyaGFyZDtcIjogXCLih4FcIixcbiAgICAgIFwiJnJoYXJ1O1wiOiBcIuKHgFwiLFxuICAgICAgXCImcmhhcnVsO1wiOiBcIuKlrFwiLFxuICAgICAgXCImcmhvO1wiOiBcIs+BXCIsXG4gICAgICBcIiZyaG92O1wiOiBcIs+xXCIsXG4gICAgICBcIiZyaWdodGFycm93O1wiOiBcIuKGklwiLFxuICAgICAgXCImcmlnaHRhcnJvd3RhaWw7XCI6IFwi4oajXCIsXG4gICAgICBcIiZyaWdodGhhcnBvb25kb3duO1wiOiBcIuKHgVwiLFxuICAgICAgXCImcmlnaHRoYXJwb29udXA7XCI6IFwi4oeAXCIsXG4gICAgICBcIiZyaWdodGxlZnRhcnJvd3M7XCI6IFwi4oeEXCIsXG4gICAgICBcIiZyaWdodGxlZnRoYXJwb29ucztcIjogXCLih4xcIixcbiAgICAgIFwiJnJpZ2h0cmlnaHRhcnJvd3M7XCI6IFwi4oeJXCIsXG4gICAgICBcIiZyaWdodHNxdWlnYXJyb3c7XCI6IFwi4oadXCIsXG4gICAgICBcIiZyaWdodHRocmVldGltZXM7XCI6IFwi4ouMXCIsXG4gICAgICBcIiZyaW5nO1wiOiBcIsuaXCIsXG4gICAgICBcIiZyaXNpbmdkb3RzZXE7XCI6IFwi4omTXCIsXG4gICAgICBcIiZybGFycjtcIjogXCLih4RcIixcbiAgICAgIFwiJnJsaGFyO1wiOiBcIuKHjFwiLFxuICAgICAgXCImcmxtO1wiOiBcIuKAj1wiLFxuICAgICAgXCImcm1vdXN0O1wiOiBcIuKOsVwiLFxuICAgICAgXCImcm1vdXN0YWNoZTtcIjogXCLijrFcIixcbiAgICAgIFwiJnJubWlkO1wiOiBcIuKrrlwiLFxuICAgICAgXCImcm9hbmc7XCI6IFwi4p+tXCIsXG4gICAgICBcIiZyb2FycjtcIjogXCLih75cIixcbiAgICAgIFwiJnJvYnJrO1wiOiBcIuKfp1wiLFxuICAgICAgXCImcm9wYXI7XCI6IFwi4qaGXCIsXG4gICAgICBcIiZyb3BmO1wiOiBcIvCdlaNcIixcbiAgICAgIFwiJnJvcGx1cztcIjogXCLiqK5cIixcbiAgICAgIFwiJnJvdGltZXM7XCI6IFwi4qi1XCIsXG4gICAgICBcIiZycGFyO1wiOiBcIilcIixcbiAgICAgIFwiJnJwYXJndDtcIjogXCLippRcIixcbiAgICAgIFwiJnJwcG9saW50O1wiOiBcIuKoklwiLFxuICAgICAgXCImcnJhcnI7XCI6IFwi4oeJXCIsXG4gICAgICBcIiZyc2FxdW87XCI6IFwi4oC6XCIsXG4gICAgICBcIiZyc2NyO1wiOiBcIvCdk4dcIixcbiAgICAgIFwiJnJzaDtcIjogXCLihrFcIixcbiAgICAgIFwiJnJzcWI7XCI6IFwiXVwiLFxuICAgICAgXCImcnNxdW87XCI6IFwi4oCZXCIsXG4gICAgICBcIiZyc3F1b3I7XCI6IFwi4oCZXCIsXG4gICAgICBcIiZydGhyZWU7XCI6IFwi4ouMXCIsXG4gICAgICBcIiZydGltZXM7XCI6IFwi4ouKXCIsXG4gICAgICBcIiZydHJpO1wiOiBcIuKWuVwiLFxuICAgICAgXCImcnRyaWU7XCI6IFwi4oq1XCIsXG4gICAgICBcIiZydHJpZjtcIjogXCLilrhcIixcbiAgICAgIFwiJnJ0cmlsdHJpO1wiOiBcIuKnjlwiLFxuICAgICAgXCImcnVsdWhhcjtcIjogXCLipahcIixcbiAgICAgIFwiJnJ4O1wiOiBcIuKEnlwiLFxuICAgICAgXCImc2FjdXRlO1wiOiBcIsWbXCIsXG4gICAgICBcIiZzYnF1bztcIjogXCLigJpcIixcbiAgICAgIFwiJnNjO1wiOiBcIuKJu1wiLFxuICAgICAgXCImc2NFO1wiOiBcIuKqtFwiLFxuICAgICAgXCImc2NhcDtcIjogXCLiqrhcIixcbiAgICAgIFwiJnNjYXJvbjtcIjogXCLFoVwiLFxuICAgICAgXCImc2NjdWU7XCI6IFwi4om9XCIsXG4gICAgICBcIiZzY2U7XCI6IFwi4qqwXCIsXG4gICAgICBcIiZzY2VkaWw7XCI6IFwixZ9cIixcbiAgICAgIFwiJnNjaXJjO1wiOiBcIsWdXCIsXG4gICAgICBcIiZzY25FO1wiOiBcIuKqtlwiLFxuICAgICAgXCImc2NuYXA7XCI6IFwi4qq6XCIsXG4gICAgICBcIiZzY25zaW07XCI6IFwi4oupXCIsXG4gICAgICBcIiZzY3BvbGludDtcIjogXCLiqJNcIixcbiAgICAgIFwiJnNjc2ltO1wiOiBcIuKJv1wiLFxuICAgICAgXCImc2N5O1wiOiBcItGBXCIsXG4gICAgICBcIiZzZG90O1wiOiBcIuKLhVwiLFxuICAgICAgXCImc2RvdGI7XCI6IFwi4oqhXCIsXG4gICAgICBcIiZzZG90ZTtcIjogXCLiqaZcIixcbiAgICAgIFwiJnNlQXJyO1wiOiBcIuKHmFwiLFxuICAgICAgXCImc2VhcmhrO1wiOiBcIuKkpVwiLFxuICAgICAgXCImc2VhcnI7XCI6IFwi4oaYXCIsXG4gICAgICBcIiZzZWFycm93O1wiOiBcIuKGmFwiLFxuICAgICAgXCImc2VjdFwiOiBcIsKnXCIsXG4gICAgICBcIiZzZWN0O1wiOiBcIsKnXCIsXG4gICAgICBcIiZzZW1pO1wiOiBcIjtcIixcbiAgICAgIFwiJnNlc3dhcjtcIjogXCLipKlcIixcbiAgICAgIFwiJnNldG1pbnVzO1wiOiBcIuKIllwiLFxuICAgICAgXCImc2V0bW47XCI6IFwi4oiWXCIsXG4gICAgICBcIiZzZXh0O1wiOiBcIuKctlwiLFxuICAgICAgXCImc2ZyO1wiOiBcIvCdlLBcIixcbiAgICAgIFwiJnNmcm93bjtcIjogXCLijKJcIixcbiAgICAgIFwiJnNoYXJwO1wiOiBcIuKZr1wiLFxuICAgICAgXCImc2hjaGN5O1wiOiBcItGJXCIsXG4gICAgICBcIiZzaGN5O1wiOiBcItGIXCIsXG4gICAgICBcIiZzaG9ydG1pZDtcIjogXCLiiKNcIixcbiAgICAgIFwiJnNob3J0cGFyYWxsZWw7XCI6IFwi4oilXCIsXG4gICAgICBcIiZzaHlcIjogXCLCrVwiLFxuICAgICAgXCImc2h5O1wiOiBcIsKtXCIsXG4gICAgICBcIiZzaWdtYTtcIjogXCLPg1wiLFxuICAgICAgXCImc2lnbWFmO1wiOiBcIs+CXCIsXG4gICAgICBcIiZzaWdtYXY7XCI6IFwiz4JcIixcbiAgICAgIFwiJnNpbTtcIjogXCLiiLxcIixcbiAgICAgIFwiJnNpbWRvdDtcIjogXCLiqapcIixcbiAgICAgIFwiJnNpbWU7XCI6IFwi4omDXCIsXG4gICAgICBcIiZzaW1lcTtcIjogXCLiiYNcIixcbiAgICAgIFwiJnNpbWc7XCI6IFwi4qqeXCIsXG4gICAgICBcIiZzaW1nRTtcIjogXCLiqqBcIixcbiAgICAgIFwiJnNpbWw7XCI6IFwi4qqdXCIsXG4gICAgICBcIiZzaW1sRTtcIjogXCLiqp9cIixcbiAgICAgIFwiJnNpbW5lO1wiOiBcIuKJhlwiLFxuICAgICAgXCImc2ltcGx1cztcIjogXCLiqKRcIixcbiAgICAgIFwiJnNpbXJhcnI7XCI6IFwi4qWyXCIsXG4gICAgICBcIiZzbGFycjtcIjogXCLihpBcIixcbiAgICAgIFwiJnNtYWxsc2V0bWludXM7XCI6IFwi4oiWXCIsXG4gICAgICBcIiZzbWFzaHA7XCI6IFwi4qizXCIsXG4gICAgICBcIiZzbWVwYXJzbDtcIjogXCLip6RcIixcbiAgICAgIFwiJnNtaWQ7XCI6IFwi4oijXCIsXG4gICAgICBcIiZzbWlsZTtcIjogXCLijKNcIixcbiAgICAgIFwiJnNtdDtcIjogXCLiqqpcIixcbiAgICAgIFwiJnNtdGU7XCI6IFwi4qqsXCIsXG4gICAgICBcIiZzbXRlcztcIjogXCLiqqzvuIBcIixcbiAgICAgIFwiJnNvZnRjeTtcIjogXCLRjFwiLFxuICAgICAgXCImc29sO1wiOiBcIi9cIixcbiAgICAgIFwiJnNvbGI7XCI6IFwi4qeEXCIsXG4gICAgICBcIiZzb2xiYXI7XCI6IFwi4oy/XCIsXG4gICAgICBcIiZzb3BmO1wiOiBcIvCdlaRcIixcbiAgICAgIFwiJnNwYWRlcztcIjogXCLimaBcIixcbiAgICAgIFwiJnNwYWRlc3VpdDtcIjogXCLimaBcIixcbiAgICAgIFwiJnNwYXI7XCI6IFwi4oilXCIsXG4gICAgICBcIiZzcWNhcDtcIjogXCLiipNcIixcbiAgICAgIFwiJnNxY2FwcztcIjogXCLiipPvuIBcIixcbiAgICAgIFwiJnNxY3VwO1wiOiBcIuKKlFwiLFxuICAgICAgXCImc3FjdXBzO1wiOiBcIuKKlO+4gFwiLFxuICAgICAgXCImc3FzdWI7XCI6IFwi4oqPXCIsXG4gICAgICBcIiZzcXN1YmU7XCI6IFwi4oqRXCIsXG4gICAgICBcIiZzcXN1YnNldDtcIjogXCLiio9cIixcbiAgICAgIFwiJnNxc3Vic2V0ZXE7XCI6IFwi4oqRXCIsXG4gICAgICBcIiZzcXN1cDtcIjogXCLiipBcIixcbiAgICAgIFwiJnNxc3VwZTtcIjogXCLiipJcIixcbiAgICAgIFwiJnNxc3Vwc2V0O1wiOiBcIuKKkFwiLFxuICAgICAgXCImc3FzdXBzZXRlcTtcIjogXCLiipJcIixcbiAgICAgIFwiJnNxdTtcIjogXCLilqFcIixcbiAgICAgIFwiJnNxdWFyZTtcIjogXCLilqFcIixcbiAgICAgIFwiJnNxdWFyZjtcIjogXCLilqpcIixcbiAgICAgIFwiJnNxdWY7XCI6IFwi4paqXCIsXG4gICAgICBcIiZzcmFycjtcIjogXCLihpJcIixcbiAgICAgIFwiJnNzY3I7XCI6IFwi8J2TiFwiLFxuICAgICAgXCImc3NldG1uO1wiOiBcIuKIllwiLFxuICAgICAgXCImc3NtaWxlO1wiOiBcIuKMo1wiLFxuICAgICAgXCImc3N0YXJmO1wiOiBcIuKLhlwiLFxuICAgICAgXCImc3RhcjtcIjogXCLimIZcIixcbiAgICAgIFwiJnN0YXJmO1wiOiBcIuKYhVwiLFxuICAgICAgXCImc3RyYWlnaHRlcHNpbG9uO1wiOiBcIs+1XCIsXG4gICAgICBcIiZzdHJhaWdodHBoaTtcIjogXCLPlVwiLFxuICAgICAgXCImc3RybnM7XCI6IFwiwq9cIixcbiAgICAgIFwiJnN1YjtcIjogXCLiioJcIixcbiAgICAgIFwiJnN1YkU7XCI6IFwi4quFXCIsXG4gICAgICBcIiZzdWJkb3Q7XCI6IFwi4qq9XCIsXG4gICAgICBcIiZzdWJlO1wiOiBcIuKKhlwiLFxuICAgICAgXCImc3ViZWRvdDtcIjogXCLiq4NcIixcbiAgICAgIFwiJnN1Ym11bHQ7XCI6IFwi4quBXCIsXG4gICAgICBcIiZzdWJuRTtcIjogXCLiq4tcIixcbiAgICAgIFwiJnN1Ym5lO1wiOiBcIuKKilwiLFxuICAgICAgXCImc3VicGx1cztcIjogXCLiqr9cIixcbiAgICAgIFwiJnN1YnJhcnI7XCI6IFwi4qW5XCIsXG4gICAgICBcIiZzdWJzZXQ7XCI6IFwi4oqCXCIsXG4gICAgICBcIiZzdWJzZXRlcTtcIjogXCLiioZcIixcbiAgICAgIFwiJnN1YnNldGVxcTtcIjogXCLiq4VcIixcbiAgICAgIFwiJnN1YnNldG5lcTtcIjogXCLiiopcIixcbiAgICAgIFwiJnN1YnNldG5lcXE7XCI6IFwi4quLXCIsXG4gICAgICBcIiZzdWJzaW07XCI6IFwi4quHXCIsXG4gICAgICBcIiZzdWJzdWI7XCI6IFwi4quVXCIsXG4gICAgICBcIiZzdWJzdXA7XCI6IFwi4quTXCIsXG4gICAgICBcIiZzdWNjO1wiOiBcIuKJu1wiLFxuICAgICAgXCImc3VjY2FwcHJveDtcIjogXCLiqrhcIixcbiAgICAgIFwiJnN1Y2NjdXJseWVxO1wiOiBcIuKJvVwiLFxuICAgICAgXCImc3VjY2VxO1wiOiBcIuKqsFwiLFxuICAgICAgXCImc3VjY25hcHByb3g7XCI6IFwi4qq6XCIsXG4gICAgICBcIiZzdWNjbmVxcTtcIjogXCLiqrZcIixcbiAgICAgIFwiJnN1Y2Nuc2ltO1wiOiBcIuKLqVwiLFxuICAgICAgXCImc3VjY3NpbTtcIjogXCLiib9cIixcbiAgICAgIFwiJnN1bTtcIjogXCLiiJFcIixcbiAgICAgIFwiJnN1bmc7XCI6IFwi4pmqXCIsXG4gICAgICBcIiZzdXAxXCI6IFwiwrlcIixcbiAgICAgIFwiJnN1cDE7XCI6IFwiwrlcIixcbiAgICAgIFwiJnN1cDJcIjogXCLCslwiLFxuICAgICAgXCImc3VwMjtcIjogXCLCslwiLFxuICAgICAgXCImc3VwM1wiOiBcIsKzXCIsXG4gICAgICBcIiZzdXAzO1wiOiBcIsKzXCIsXG4gICAgICBcIiZzdXA7XCI6IFwi4oqDXCIsXG4gICAgICBcIiZzdXBFO1wiOiBcIuKrhlwiLFxuICAgICAgXCImc3VwZG90O1wiOiBcIuKqvlwiLFxuICAgICAgXCImc3VwZHN1YjtcIjogXCLiq5hcIixcbiAgICAgIFwiJnN1cGU7XCI6IFwi4oqHXCIsXG4gICAgICBcIiZzdXBlZG90O1wiOiBcIuKrhFwiLFxuICAgICAgXCImc3VwaHNvbDtcIjogXCLin4lcIixcbiAgICAgIFwiJnN1cGhzdWI7XCI6IFwi4quXXCIsXG4gICAgICBcIiZzdXBsYXJyO1wiOiBcIuKlu1wiLFxuICAgICAgXCImc3VwbXVsdDtcIjogXCLiq4JcIixcbiAgICAgIFwiJnN1cG5FO1wiOiBcIuKrjFwiLFxuICAgICAgXCImc3VwbmU7XCI6IFwi4oqLXCIsXG4gICAgICBcIiZzdXBwbHVzO1wiOiBcIuKrgFwiLFxuICAgICAgXCImc3Vwc2V0O1wiOiBcIuKKg1wiLFxuICAgICAgXCImc3Vwc2V0ZXE7XCI6IFwi4oqHXCIsXG4gICAgICBcIiZzdXBzZXRlcXE7XCI6IFwi4quGXCIsXG4gICAgICBcIiZzdXBzZXRuZXE7XCI6IFwi4oqLXCIsXG4gICAgICBcIiZzdXBzZXRuZXFxO1wiOiBcIuKrjFwiLFxuICAgICAgXCImc3Vwc2ltO1wiOiBcIuKriFwiLFxuICAgICAgXCImc3Vwc3ViO1wiOiBcIuKrlFwiLFxuICAgICAgXCImc3Vwc3VwO1wiOiBcIuKrllwiLFxuICAgICAgXCImc3dBcnI7XCI6IFwi4oeZXCIsXG4gICAgICBcIiZzd2FyaGs7XCI6IFwi4qSmXCIsXG4gICAgICBcIiZzd2FycjtcIjogXCLihplcIixcbiAgICAgIFwiJnN3YXJyb3c7XCI6IFwi4oaZXCIsXG4gICAgICBcIiZzd253YXI7XCI6IFwi4qSqXCIsXG4gICAgICBcIiZzemxpZ1wiOiBcIsOfXCIsXG4gICAgICBcIiZzemxpZztcIjogXCLDn1wiLFxuICAgICAgXCImdGFyZ2V0O1wiOiBcIuKMllwiLFxuICAgICAgXCImdGF1O1wiOiBcIs+EXCIsXG4gICAgICBcIiZ0YnJrO1wiOiBcIuKOtFwiLFxuICAgICAgXCImdGNhcm9uO1wiOiBcIsWlXCIsXG4gICAgICBcIiZ0Y2VkaWw7XCI6IFwixaNcIixcbiAgICAgIFwiJnRjeTtcIjogXCLRglwiLFxuICAgICAgXCImdGRvdDtcIjogXCLig5tcIixcbiAgICAgIFwiJnRlbHJlYztcIjogXCLijJVcIixcbiAgICAgIFwiJnRmcjtcIjogXCLwnZSxXCIsXG4gICAgICBcIiZ0aGVyZTQ7XCI6IFwi4oi0XCIsXG4gICAgICBcIiZ0aGVyZWZvcmU7XCI6IFwi4oi0XCIsXG4gICAgICBcIiZ0aGV0YTtcIjogXCLOuFwiLFxuICAgICAgXCImdGhldGFzeW07XCI6IFwiz5FcIixcbiAgICAgIFwiJnRoZXRhdjtcIjogXCLPkVwiLFxuICAgICAgXCImdGhpY2thcHByb3g7XCI6IFwi4omIXCIsXG4gICAgICBcIiZ0aGlja3NpbTtcIjogXCLiiLxcIixcbiAgICAgIFwiJnRoaW5zcDtcIjogXCLigIlcIixcbiAgICAgIFwiJnRoa2FwO1wiOiBcIuKJiFwiLFxuICAgICAgXCImdGhrc2ltO1wiOiBcIuKIvFwiLFxuICAgICAgXCImdGhvcm5cIjogXCLDvlwiLFxuICAgICAgXCImdGhvcm47XCI6IFwiw75cIixcbiAgICAgIFwiJnRpbGRlO1wiOiBcIsucXCIsXG4gICAgICBcIiZ0aW1lc1wiOiBcIsOXXCIsXG4gICAgICBcIiZ0aW1lcztcIjogXCLDl1wiLFxuICAgICAgXCImdGltZXNiO1wiOiBcIuKKoFwiLFxuICAgICAgXCImdGltZXNiYXI7XCI6IFwi4qixXCIsXG4gICAgICBcIiZ0aW1lc2Q7XCI6IFwi4qiwXCIsXG4gICAgICBcIiZ0aW50O1wiOiBcIuKIrVwiLFxuICAgICAgXCImdG9lYTtcIjogXCLipKhcIixcbiAgICAgIFwiJnRvcDtcIjogXCLiiqRcIixcbiAgICAgIFwiJnRvcGJvdDtcIjogXCLijLZcIixcbiAgICAgIFwiJnRvcGNpcjtcIjogXCLiq7FcIixcbiAgICAgIFwiJnRvcGY7XCI6IFwi8J2VpVwiLFxuICAgICAgXCImdG9wZm9yaztcIjogXCLiq5pcIixcbiAgICAgIFwiJnRvc2E7XCI6IFwi4qSpXCIsXG4gICAgICBcIiZ0cHJpbWU7XCI6IFwi4oC0XCIsXG4gICAgICBcIiZ0cmFkZTtcIjogXCLihKJcIixcbiAgICAgIFwiJnRyaWFuZ2xlO1wiOiBcIuKWtVwiLFxuICAgICAgXCImdHJpYW5nbGVkb3duO1wiOiBcIuKWv1wiLFxuICAgICAgXCImdHJpYW5nbGVsZWZ0O1wiOiBcIuKXg1wiLFxuICAgICAgXCImdHJpYW5nbGVsZWZ0ZXE7XCI6IFwi4oq0XCIsXG4gICAgICBcIiZ0cmlhbmdsZXE7XCI6IFwi4omcXCIsXG4gICAgICBcIiZ0cmlhbmdsZXJpZ2h0O1wiOiBcIuKWuVwiLFxuICAgICAgXCImdHJpYW5nbGVyaWdodGVxO1wiOiBcIuKKtVwiLFxuICAgICAgXCImdHJpZG90O1wiOiBcIuKXrFwiLFxuICAgICAgXCImdHJpZTtcIjogXCLiiZxcIixcbiAgICAgIFwiJnRyaW1pbnVzO1wiOiBcIuKoulwiLFxuICAgICAgXCImdHJpcGx1cztcIjogXCLiqLlcIixcbiAgICAgIFwiJnRyaXNiO1wiOiBcIuKnjVwiLFxuICAgICAgXCImdHJpdGltZTtcIjogXCLiqLtcIixcbiAgICAgIFwiJnRycGV6aXVtO1wiOiBcIuKPolwiLFxuICAgICAgXCImdHNjcjtcIjogXCLwnZOJXCIsXG4gICAgICBcIiZ0c2N5O1wiOiBcItGGXCIsXG4gICAgICBcIiZ0c2hjeTtcIjogXCLRm1wiLFxuICAgICAgXCImdHN0cm9rO1wiOiBcIsWnXCIsXG4gICAgICBcIiZ0d2l4dDtcIjogXCLiiaxcIixcbiAgICAgIFwiJnR3b2hlYWRsZWZ0YXJyb3c7XCI6IFwi4oaeXCIsXG4gICAgICBcIiZ0d29oZWFkcmlnaHRhcnJvdztcIjogXCLihqBcIixcbiAgICAgIFwiJnVBcnI7XCI6IFwi4oeRXCIsXG4gICAgICBcIiZ1SGFyO1wiOiBcIuKlo1wiLFxuICAgICAgXCImdWFjdXRlXCI6IFwiw7pcIixcbiAgICAgIFwiJnVhY3V0ZTtcIjogXCLDulwiLFxuICAgICAgXCImdWFycjtcIjogXCLihpFcIixcbiAgICAgIFwiJnVicmN5O1wiOiBcItGeXCIsXG4gICAgICBcIiZ1YnJldmU7XCI6IFwixa1cIixcbiAgICAgIFwiJnVjaXJjXCI6IFwiw7tcIixcbiAgICAgIFwiJnVjaXJjO1wiOiBcIsO7XCIsXG4gICAgICBcIiZ1Y3k7XCI6IFwi0YNcIixcbiAgICAgIFwiJnVkYXJyO1wiOiBcIuKHhVwiLFxuICAgICAgXCImdWRibGFjO1wiOiBcIsWxXCIsXG4gICAgICBcIiZ1ZGhhcjtcIjogXCLipa5cIixcbiAgICAgIFwiJnVmaXNodDtcIjogXCLipb5cIixcbiAgICAgIFwiJnVmcjtcIjogXCLwnZSyXCIsXG4gICAgICBcIiZ1Z3JhdmVcIjogXCLDuVwiLFxuICAgICAgXCImdWdyYXZlO1wiOiBcIsO5XCIsXG4gICAgICBcIiZ1aGFybDtcIjogXCLihr9cIixcbiAgICAgIFwiJnVoYXJyO1wiOiBcIuKGvlwiLFxuICAgICAgXCImdWhibGs7XCI6IFwi4paAXCIsXG4gICAgICBcIiZ1bGNvcm47XCI6IFwi4oycXCIsXG4gICAgICBcIiZ1bGNvcm5lcjtcIjogXCLijJxcIixcbiAgICAgIFwiJnVsY3JvcDtcIjogXCLijI9cIixcbiAgICAgIFwiJnVsdHJpO1wiOiBcIuKXuFwiLFxuICAgICAgXCImdW1hY3I7XCI6IFwixatcIixcbiAgICAgIFwiJnVtbFwiOiBcIsKoXCIsXG4gICAgICBcIiZ1bWw7XCI6IFwiwqhcIixcbiAgICAgIFwiJnVvZ29uO1wiOiBcIsWzXCIsXG4gICAgICBcIiZ1b3BmO1wiOiBcIvCdlaZcIixcbiAgICAgIFwiJnVwYXJyb3c7XCI6IFwi4oaRXCIsXG4gICAgICBcIiZ1cGRvd25hcnJvdztcIjogXCLihpVcIixcbiAgICAgIFwiJnVwaGFycG9vbmxlZnQ7XCI6IFwi4oa/XCIsXG4gICAgICBcIiZ1cGhhcnBvb25yaWdodDtcIjogXCLihr5cIixcbiAgICAgIFwiJnVwbHVzO1wiOiBcIuKKjlwiLFxuICAgICAgXCImdXBzaTtcIjogXCLPhVwiLFxuICAgICAgXCImdXBzaWg7XCI6IFwiz5JcIixcbiAgICAgIFwiJnVwc2lsb247XCI6IFwiz4VcIixcbiAgICAgIFwiJnVwdXBhcnJvd3M7XCI6IFwi4oeIXCIsXG4gICAgICBcIiZ1cmNvcm47XCI6IFwi4oydXCIsXG4gICAgICBcIiZ1cmNvcm5lcjtcIjogXCLijJ1cIixcbiAgICAgIFwiJnVyY3JvcDtcIjogXCLijI5cIixcbiAgICAgIFwiJnVyaW5nO1wiOiBcIsWvXCIsXG4gICAgICBcIiZ1cnRyaTtcIjogXCLil7lcIixcbiAgICAgIFwiJnVzY3I7XCI6IFwi8J2TilwiLFxuICAgICAgXCImdXRkb3Q7XCI6IFwi4ouwXCIsXG4gICAgICBcIiZ1dGlsZGU7XCI6IFwixalcIixcbiAgICAgIFwiJnV0cmk7XCI6IFwi4pa1XCIsXG4gICAgICBcIiZ1dHJpZjtcIjogXCLilrRcIixcbiAgICAgIFwiJnV1YXJyO1wiOiBcIuKHiFwiLFxuICAgICAgXCImdXVtbFwiOiBcIsO8XCIsXG4gICAgICBcIiZ1dW1sO1wiOiBcIsO8XCIsXG4gICAgICBcIiZ1d2FuZ2xlO1wiOiBcIuKmp1wiLFxuICAgICAgXCImdkFycjtcIjogXCLih5VcIixcbiAgICAgIFwiJnZCYXI7XCI6IFwi4quoXCIsXG4gICAgICBcIiZ2QmFydjtcIjogXCLiq6lcIixcbiAgICAgIFwiJnZEYXNoO1wiOiBcIuKKqFwiLFxuICAgICAgXCImdmFuZ3J0O1wiOiBcIuKmnFwiLFxuICAgICAgXCImdmFyZXBzaWxvbjtcIjogXCLPtVwiLFxuICAgICAgXCImdmFya2FwcGE7XCI6IFwiz7BcIixcbiAgICAgIFwiJnZhcm5vdGhpbmc7XCI6IFwi4oiFXCIsXG4gICAgICBcIiZ2YXJwaGk7XCI6IFwiz5VcIixcbiAgICAgIFwiJnZhcnBpO1wiOiBcIs+WXCIsXG4gICAgICBcIiZ2YXJwcm9wdG87XCI6IFwi4oidXCIsXG4gICAgICBcIiZ2YXJyO1wiOiBcIuKGlVwiLFxuICAgICAgXCImdmFycmhvO1wiOiBcIs+xXCIsXG4gICAgICBcIiZ2YXJzaWdtYTtcIjogXCLPglwiLFxuICAgICAgXCImdmFyc3Vic2V0bmVxO1wiOiBcIuKKiu+4gFwiLFxuICAgICAgXCImdmFyc3Vic2V0bmVxcTtcIjogXCLiq4vvuIBcIixcbiAgICAgIFwiJnZhcnN1cHNldG5lcTtcIjogXCLiiovvuIBcIixcbiAgICAgIFwiJnZhcnN1cHNldG5lcXE7XCI6IFwi4quM77iAXCIsXG4gICAgICBcIiZ2YXJ0aGV0YTtcIjogXCLPkVwiLFxuICAgICAgXCImdmFydHJpYW5nbGVsZWZ0O1wiOiBcIuKKslwiLFxuICAgICAgXCImdmFydHJpYW5nbGVyaWdodDtcIjogXCLiirNcIixcbiAgICAgIFwiJnZjeTtcIjogXCLQslwiLFxuICAgICAgXCImdmRhc2g7XCI6IFwi4oqiXCIsXG4gICAgICBcIiZ2ZWU7XCI6IFwi4oioXCIsXG4gICAgICBcIiZ2ZWViYXI7XCI6IFwi4oq7XCIsXG4gICAgICBcIiZ2ZWVlcTtcIjogXCLiiZpcIixcbiAgICAgIFwiJnZlbGxpcDtcIjogXCLii65cIixcbiAgICAgIFwiJnZlcmJhcjtcIjogXCJ8XCIsXG4gICAgICBcIiZ2ZXJ0O1wiOiBcInxcIixcbiAgICAgIFwiJnZmcjtcIjogXCLwnZSzXCIsXG4gICAgICBcIiZ2bHRyaTtcIjogXCLiirJcIixcbiAgICAgIFwiJnZuc3ViO1wiOiBcIuKKguKDklwiLFxuICAgICAgXCImdm5zdXA7XCI6IFwi4oqD4oOSXCIsXG4gICAgICBcIiZ2b3BmO1wiOiBcIvCdladcIixcbiAgICAgIFwiJnZwcm9wO1wiOiBcIuKInVwiLFxuICAgICAgXCImdnJ0cmk7XCI6IFwi4oqzXCIsXG4gICAgICBcIiZ2c2NyO1wiOiBcIvCdk4tcIixcbiAgICAgIFwiJnZzdWJuRTtcIjogXCLiq4vvuIBcIixcbiAgICAgIFwiJnZzdWJuZTtcIjogXCLiiorvuIBcIixcbiAgICAgIFwiJnZzdXBuRTtcIjogXCLiq4zvuIBcIixcbiAgICAgIFwiJnZzdXBuZTtcIjogXCLiiovvuIBcIixcbiAgICAgIFwiJnZ6aWd6YWc7XCI6IFwi4qaaXCIsXG4gICAgICBcIiZ3Y2lyYztcIjogXCLFtVwiLFxuICAgICAgXCImd2VkYmFyO1wiOiBcIuKpn1wiLFxuICAgICAgXCImd2VkZ2U7XCI6IFwi4oinXCIsXG4gICAgICBcIiZ3ZWRnZXE7XCI6IFwi4omZXCIsXG4gICAgICBcIiZ3ZWllcnA7XCI6IFwi4oSYXCIsXG4gICAgICBcIiZ3ZnI7XCI6IFwi8J2UtFwiLFxuICAgICAgXCImd29wZjtcIjogXCLwnZWoXCIsXG4gICAgICBcIiZ3cDtcIjogXCLihJhcIixcbiAgICAgIFwiJndyO1wiOiBcIuKJgFwiLFxuICAgICAgXCImd3JlYXRoO1wiOiBcIuKJgFwiLFxuICAgICAgXCImd3NjcjtcIjogXCLwnZOMXCIsXG4gICAgICBcIiZ4Y2FwO1wiOiBcIuKLglwiLFxuICAgICAgXCImeGNpcmM7XCI6IFwi4pevXCIsXG4gICAgICBcIiZ4Y3VwO1wiOiBcIuKLg1wiLFxuICAgICAgXCImeGR0cmk7XCI6IFwi4pa9XCIsXG4gICAgICBcIiZ4ZnI7XCI6IFwi8J2UtVwiLFxuICAgICAgXCImeGhBcnI7XCI6IFwi4p+6XCIsXG4gICAgICBcIiZ4aGFycjtcIjogXCLin7dcIixcbiAgICAgIFwiJnhpO1wiOiBcIs6+XCIsXG4gICAgICBcIiZ4bEFycjtcIjogXCLin7hcIixcbiAgICAgIFwiJnhsYXJyO1wiOiBcIuKftVwiLFxuICAgICAgXCImeG1hcDtcIjogXCLin7xcIixcbiAgICAgIFwiJnhuaXM7XCI6IFwi4ou7XCIsXG4gICAgICBcIiZ4b2RvdDtcIjogXCLiqIBcIixcbiAgICAgIFwiJnhvcGY7XCI6IFwi8J2VqVwiLFxuICAgICAgXCImeG9wbHVzO1wiOiBcIuKogVwiLFxuICAgICAgXCImeG90aW1lO1wiOiBcIuKoglwiLFxuICAgICAgXCImeHJBcnI7XCI6IFwi4p+5XCIsXG4gICAgICBcIiZ4cmFycjtcIjogXCLin7ZcIixcbiAgICAgIFwiJnhzY3I7XCI6IFwi8J2TjVwiLFxuICAgICAgXCImeHNxY3VwO1wiOiBcIuKohlwiLFxuICAgICAgXCImeHVwbHVzO1wiOiBcIuKohFwiLFxuICAgICAgXCImeHV0cmk7XCI6IFwi4pazXCIsXG4gICAgICBcIiZ4dmVlO1wiOiBcIuKLgVwiLFxuICAgICAgXCImeHdlZGdlO1wiOiBcIuKLgFwiLFxuICAgICAgXCImeWFjdXRlXCI6IFwiw71cIixcbiAgICAgIFwiJnlhY3V0ZTtcIjogXCLDvVwiLFxuICAgICAgXCImeWFjeTtcIjogXCLRj1wiLFxuICAgICAgXCImeWNpcmM7XCI6IFwixbdcIixcbiAgICAgIFwiJnljeTtcIjogXCLRi1wiLFxuICAgICAgXCImeWVuXCI6IFwiwqVcIixcbiAgICAgIFwiJnllbjtcIjogXCLCpVwiLFxuICAgICAgXCImeWZyO1wiOiBcIvCdlLZcIixcbiAgICAgIFwiJnlpY3k7XCI6IFwi0ZdcIixcbiAgICAgIFwiJnlvcGY7XCI6IFwi8J2VqlwiLFxuICAgICAgXCImeXNjcjtcIjogXCLwnZOOXCIsXG4gICAgICBcIiZ5dWN5O1wiOiBcItGOXCIsXG4gICAgICBcIiZ5dW1sXCI6IFwiw79cIixcbiAgICAgIFwiJnl1bWw7XCI6IFwiw79cIixcbiAgICAgIFwiJnphY3V0ZTtcIjogXCLFulwiLFxuICAgICAgXCImemNhcm9uO1wiOiBcIsW+XCIsXG4gICAgICBcIiZ6Y3k7XCI6IFwi0LdcIixcbiAgICAgIFwiJnpkb3Q7XCI6IFwixbxcIixcbiAgICAgIFwiJnplZXRyZjtcIjogXCLihKhcIixcbiAgICAgIFwiJnpldGE7XCI6IFwizrZcIixcbiAgICAgIFwiJnpmcjtcIjogXCLwnZS3XCIsXG4gICAgICBcIiZ6aGN5O1wiOiBcItC2XCIsXG4gICAgICBcIiZ6aWdyYXJyO1wiOiBcIuKHnVwiLFxuICAgICAgXCImem9wZjtcIjogXCLwnZWrXCIsXG4gICAgICBcIiZ6c2NyO1wiOiBcIvCdk49cIixcbiAgICAgIFwiJnp3ajtcIjogXCLigI1cIixcbiAgICAgIFwiJnp3bmo7XCI6IFwi4oCMXCJcbiAgICB9LFxuICAgIGNoYXJhY3RlcnM6IHtcbiAgICAgIFwiw4ZcIjogXCImQUVsaWc7XCIsXG4gICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgXCLDgVwiOiBcIiZBYWN1dGU7XCIsXG4gICAgICBcIsSCXCI6IFwiJkFicmV2ZTtcIixcbiAgICAgIFwiw4JcIjogXCImQWNpcmM7XCIsXG4gICAgICBcItCQXCI6IFwiJkFjeTtcIixcbiAgICAgIFwi8J2UhFwiOiBcIiZBZnI7XCIsXG4gICAgICBcIsOAXCI6IFwiJkFncmF2ZTtcIixcbiAgICAgIFwizpFcIjogXCImQWxwaGE7XCIsXG4gICAgICBcIsSAXCI6IFwiJkFtYWNyO1wiLFxuICAgICAgXCLiqZNcIjogXCImQW5kO1wiLFxuICAgICAgXCLEhFwiOiBcIiZBb2dvbjtcIixcbiAgICAgIFwi8J2UuFwiOiBcIiZBb3BmO1wiLFxuICAgICAgXCLigaFcIjogXCImYWY7XCIsXG4gICAgICBcIsOFXCI6IFwiJmFuZ3N0O1wiLFxuICAgICAgXCLwnZKcXCI6IFwiJkFzY3I7XCIsXG4gICAgICBcIuKJlFwiOiBcIiZjb2xvbmVxO1wiLFxuICAgICAgXCLDg1wiOiBcIiZBdGlsZGU7XCIsXG4gICAgICBcIsOEXCI6IFwiJkF1bWw7XCIsXG4gICAgICBcIuKIllwiOiBcIiZzc2V0bW47XCIsXG4gICAgICBcIuKrp1wiOiBcIiZCYXJ2O1wiLFxuICAgICAgXCLijIZcIjogXCImZG91YmxlYmFyd2VkZ2U7XCIsXG4gICAgICBcItCRXCI6IFwiJkJjeTtcIixcbiAgICAgIFwi4oi1XCI6IFwiJmJlY2F1c2U7XCIsXG4gICAgICBcIuKErFwiOiBcIiZiZXJub3U7XCIsXG4gICAgICBcIs6SXCI6IFwiJkJldGE7XCIsXG4gICAgICBcIvCdlIVcIjogXCImQmZyO1wiLFxuICAgICAgXCLwnZS5XCI6IFwiJkJvcGY7XCIsXG4gICAgICBcIsuYXCI6IFwiJmJyZXZlO1wiLFxuICAgICAgXCLiiY5cIjogXCImYnVtcDtcIixcbiAgICAgIFwi0KdcIjogXCImQ0hjeTtcIixcbiAgICAgIFwiwqlcIjogXCImY29weTtcIixcbiAgICAgIFwixIZcIjogXCImQ2FjdXRlO1wiLFxuICAgICAgXCLii5JcIjogXCImQ2FwO1wiLFxuICAgICAgXCLihYVcIjogXCImREQ7XCIsXG4gICAgICBcIuKErVwiOiBcIiZDZnI7XCIsXG4gICAgICBcIsSMXCI6IFwiJkNjYXJvbjtcIixcbiAgICAgIFwiw4dcIjogXCImQ2NlZGlsO1wiLFxuICAgICAgXCLEiFwiOiBcIiZDY2lyYztcIixcbiAgICAgIFwi4oiwXCI6IFwiJkNjb25pbnQ7XCIsXG4gICAgICBcIsSKXCI6IFwiJkNkb3Q7XCIsXG4gICAgICBcIsK4XCI6IFwiJmNlZGlsO1wiLFxuICAgICAgXCLCt1wiOiBcIiZtaWRkb3Q7XCIsXG4gICAgICBcIs6nXCI6IFwiJkNoaTtcIixcbiAgICAgIFwi4oqZXCI6IFwiJm9kb3Q7XCIsXG4gICAgICBcIuKKllwiOiBcIiZvbWludXM7XCIsXG4gICAgICBcIuKKlVwiOiBcIiZvcGx1cztcIixcbiAgICAgIFwi4oqXXCI6IFwiJm90aW1lcztcIixcbiAgICAgIFwi4oiyXCI6IFwiJmN3Y29uaW50O1wiLFxuICAgICAgXCLigJ1cIjogXCImcmRxdW9yO1wiLFxuICAgICAgXCLigJlcIjogXCImcnNxdW9yO1wiLFxuICAgICAgXCLiiLdcIjogXCImUHJvcG9ydGlvbjtcIixcbiAgICAgIFwi4qm0XCI6IFwiJkNvbG9uZTtcIixcbiAgICAgIFwi4omhXCI6IFwiJmVxdWl2O1wiLFxuICAgICAgXCLiiK9cIjogXCImRG91YmxlQ29udG91ckludGVncmFsO1wiLFxuICAgICAgXCLiiK5cIjogXCImb2ludDtcIixcbiAgICAgIFwi4oSCXCI6IFwiJmNvbXBsZXhlcztcIixcbiAgICAgIFwi4oiQXCI6IFwiJmNvcHJvZDtcIixcbiAgICAgIFwi4oizXCI6IFwiJmF3Y29uaW50O1wiLFxuICAgICAgXCLiqK9cIjogXCImQ3Jvc3M7XCIsXG4gICAgICBcIvCdkp5cIjogXCImQ3NjcjtcIixcbiAgICAgIFwi4ouTXCI6IFwiJkN1cDtcIixcbiAgICAgIFwi4omNXCI6IFwiJmFzeW1wZXE7XCIsXG4gICAgICBcIuKkkVwiOiBcIiZERG90cmFoZDtcIixcbiAgICAgIFwi0IJcIjogXCImREpjeTtcIixcbiAgICAgIFwi0IVcIjogXCImRFNjeTtcIixcbiAgICAgIFwi0I9cIjogXCImRFpjeTtcIixcbiAgICAgIFwi4oChXCI6IFwiJmRkYWdnZXI7XCIsXG4gICAgICBcIuKGoVwiOiBcIiZEYXJyO1wiLFxuICAgICAgXCLiq6RcIjogXCImRG91YmxlTGVmdFRlZTtcIixcbiAgICAgIFwixI5cIjogXCImRGNhcm9uO1wiLFxuICAgICAgXCLQlFwiOiBcIiZEY3k7XCIsXG4gICAgICBcIuKIh1wiOiBcIiZuYWJsYTtcIixcbiAgICAgIFwizpRcIjogXCImRGVsdGE7XCIsXG4gICAgICBcIvCdlIdcIjogXCImRGZyO1wiLFxuICAgICAgXCLCtFwiOiBcIiZhY3V0ZTtcIixcbiAgICAgIFwiy5lcIjogXCImZG90O1wiLFxuICAgICAgXCLLnVwiOiBcIiZkYmxhYztcIixcbiAgICAgIFwiYFwiOiBcIiZncmF2ZTtcIixcbiAgICAgIFwiy5xcIjogXCImdGlsZGU7XCIsXG4gICAgICBcIuKLhFwiOiBcIiZkaWFtb25kO1wiLFxuICAgICAgXCLihYZcIjogXCImZGQ7XCIsXG4gICAgICBcIvCdlLtcIjogXCImRG9wZjtcIixcbiAgICAgIFwiwqhcIjogXCImdW1sO1wiLFxuICAgICAgXCLig5xcIjogXCImRG90RG90O1wiLFxuICAgICAgXCLiiZBcIjogXCImZXNkb3Q7XCIsXG4gICAgICBcIuKHk1wiOiBcIiZkQXJyO1wiLFxuICAgICAgXCLih5BcIjogXCImbEFycjtcIixcbiAgICAgIFwi4oeUXCI6IFwiJmlmZjtcIixcbiAgICAgIFwi4p+4XCI6IFwiJnhsQXJyO1wiLFxuICAgICAgXCLin7pcIjogXCImeGhBcnI7XCIsXG4gICAgICBcIuKfuVwiOiBcIiZ4ckFycjtcIixcbiAgICAgIFwi4oeSXCI6IFwiJnJBcnI7XCIsXG4gICAgICBcIuKKqFwiOiBcIiZ2RGFzaDtcIixcbiAgICAgIFwi4oeRXCI6IFwiJnVBcnI7XCIsXG4gICAgICBcIuKHlVwiOiBcIiZ2QXJyO1wiLFxuICAgICAgXCLiiKVcIjogXCImc3BhcjtcIixcbiAgICAgIFwi4oaTXCI6IFwiJmRvd25hcnJvdztcIixcbiAgICAgIFwi4qSTXCI6IFwiJkRvd25BcnJvd0JhcjtcIixcbiAgICAgIFwi4oe1XCI6IFwiJmR1YXJyO1wiLFxuICAgICAgXCLMkVwiOiBcIiZEb3duQnJldmU7XCIsXG4gICAgICBcIuKlkFwiOiBcIiZEb3duTGVmdFJpZ2h0VmVjdG9yO1wiLFxuICAgICAgXCLipZ5cIjogXCImRG93bkxlZnRUZWVWZWN0b3I7XCIsXG4gICAgICBcIuKGvVwiOiBcIiZsaGFyZDtcIixcbiAgICAgIFwi4qWWXCI6IFwiJkRvd25MZWZ0VmVjdG9yQmFyO1wiLFxuICAgICAgXCLipZ9cIjogXCImRG93blJpZ2h0VGVlVmVjdG9yO1wiLFxuICAgICAgXCLih4FcIjogXCImcmlnaHRoYXJwb29uZG93bjtcIixcbiAgICAgIFwi4qWXXCI6IFwiJkRvd25SaWdodFZlY3RvckJhcjtcIixcbiAgICAgIFwi4oqkXCI6IFwiJnRvcDtcIixcbiAgICAgIFwi4oanXCI6IFwiJm1hcHN0b2Rvd247XCIsXG4gICAgICBcIvCdkp9cIjogXCImRHNjcjtcIixcbiAgICAgIFwixJBcIjogXCImRHN0cm9rO1wiLFxuICAgICAgXCLFilwiOiBcIiZFTkc7XCIsXG4gICAgICBcIsOQXCI6IFwiJkVUSDtcIixcbiAgICAgIFwiw4lcIjogXCImRWFjdXRlO1wiLFxuICAgICAgXCLEmlwiOiBcIiZFY2Fyb247XCIsXG4gICAgICBcIsOKXCI6IFwiJkVjaXJjO1wiLFxuICAgICAgXCLQrVwiOiBcIiZFY3k7XCIsXG4gICAgICBcIsSWXCI6IFwiJkVkb3Q7XCIsXG4gICAgICBcIvCdlIhcIjogXCImRWZyO1wiLFxuICAgICAgXCLDiFwiOiBcIiZFZ3JhdmU7XCIsXG4gICAgICBcIuKIiFwiOiBcIiZpc2ludjtcIixcbiAgICAgIFwixJJcIjogXCImRW1hY3I7XCIsXG4gICAgICBcIuKXu1wiOiBcIiZFbXB0eVNtYWxsU3F1YXJlO1wiLFxuICAgICAgXCLilqtcIjogXCImRW1wdHlWZXJ5U21hbGxTcXVhcmU7XCIsXG4gICAgICBcIsSYXCI6IFwiJkVvZ29uO1wiLFxuICAgICAgXCLwnZS8XCI6IFwiJkVvcGY7XCIsXG4gICAgICBcIs6VXCI6IFwiJkVwc2lsb247XCIsXG4gICAgICBcIuKptVwiOiBcIiZFcXVhbDtcIixcbiAgICAgIFwi4omCXCI6IFwiJmVzaW07XCIsXG4gICAgICBcIuKHjFwiOiBcIiZybGhhcjtcIixcbiAgICAgIFwi4oSwXCI6IFwiJmV4cGVjdGF0aW9uO1wiLFxuICAgICAgXCLiqbNcIjogXCImRXNpbTtcIixcbiAgICAgIFwizpdcIjogXCImRXRhO1wiLFxuICAgICAgXCLDi1wiOiBcIiZFdW1sO1wiLFxuICAgICAgXCLiiINcIjogXCImZXhpc3Q7XCIsXG4gICAgICBcIuKFh1wiOiBcIiZleHBvbmVudGlhbGU7XCIsXG4gICAgICBcItCkXCI6IFwiJkZjeTtcIixcbiAgICAgIFwi8J2UiVwiOiBcIiZGZnI7XCIsXG4gICAgICBcIuKXvFwiOiBcIiZGaWxsZWRTbWFsbFNxdWFyZTtcIixcbiAgICAgIFwi4paqXCI6IFwiJnNxdWY7XCIsXG4gICAgICBcIvCdlL1cIjogXCImRm9wZjtcIixcbiAgICAgIFwi4oiAXCI6IFwiJmZvcmFsbDtcIixcbiAgICAgIFwi4oSxXCI6IFwiJkZzY3I7XCIsXG4gICAgICBcItCDXCI6IFwiJkdKY3k7XCIsXG4gICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICBcIs6TXCI6IFwiJkdhbW1hO1wiLFxuICAgICAgXCLPnFwiOiBcIiZHYW1tYWQ7XCIsXG4gICAgICBcIsSeXCI6IFwiJkdicmV2ZTtcIixcbiAgICAgIFwixKJcIjogXCImR2NlZGlsO1wiLFxuICAgICAgXCLEnFwiOiBcIiZHY2lyYztcIixcbiAgICAgIFwi0JNcIjogXCImR2N5O1wiLFxuICAgICAgXCLEoFwiOiBcIiZHZG90O1wiLFxuICAgICAgXCLwnZSKXCI6IFwiJkdmcjtcIixcbiAgICAgIFwi4ouZXCI6IFwiJmdnZztcIixcbiAgICAgIFwi8J2UvlwiOiBcIiZHb3BmO1wiLFxuICAgICAgXCLiiaVcIjogXCImZ2VxO1wiLFxuICAgICAgXCLii5tcIjogXCImZ3RyZXFsZXNzO1wiLFxuICAgICAgXCLiiadcIjogXCImZ2VxcTtcIixcbiAgICAgIFwi4qqiXCI6IFwiJkdyZWF0ZXJHcmVhdGVyO1wiLFxuICAgICAgXCLiibdcIjogXCImZ3RybGVzcztcIixcbiAgICAgIFwi4qm+XCI6IFwiJmdlcztcIixcbiAgICAgIFwi4omzXCI6IFwiJmd0cnNpbTtcIixcbiAgICAgIFwi8J2SolwiOiBcIiZHc2NyO1wiLFxuICAgICAgXCLiiatcIjogXCImZ2c7XCIsXG4gICAgICBcItCqXCI6IFwiJkhBUkRjeTtcIixcbiAgICAgIFwiy4dcIjogXCImY2Fyb247XCIsXG4gICAgICBcIl5cIjogXCImSGF0O1wiLFxuICAgICAgXCLEpFwiOiBcIiZIY2lyYztcIixcbiAgICAgIFwi4oSMXCI6IFwiJlBvaW5jYXJlcGxhbmU7XCIsXG4gICAgICBcIuKEi1wiOiBcIiZoYW1pbHQ7XCIsXG4gICAgICBcIuKEjVwiOiBcIiZxdWF0ZXJuaW9ucztcIixcbiAgICAgIFwi4pSAXCI6IFwiJmJveGg7XCIsXG4gICAgICBcIsSmXCI6IFwiJkhzdHJvaztcIixcbiAgICAgIFwi4omPXCI6IFwiJmJ1bXBlcTtcIixcbiAgICAgIFwi0JVcIjogXCImSUVjeTtcIixcbiAgICAgIFwixLJcIjogXCImSUpsaWc7XCIsXG4gICAgICBcItCBXCI6IFwiJklPY3k7XCIsXG4gICAgICBcIsONXCI6IFwiJklhY3V0ZTtcIixcbiAgICAgIFwiw45cIjogXCImSWNpcmM7XCIsXG4gICAgICBcItCYXCI6IFwiJkljeTtcIixcbiAgICAgIFwixLBcIjogXCImSWRvdDtcIixcbiAgICAgIFwi4oSRXCI6IFwiJmltYWdwYXJ0O1wiLFxuICAgICAgXCLDjFwiOiBcIiZJZ3JhdmU7XCIsXG4gICAgICBcIsSqXCI6IFwiJkltYWNyO1wiLFxuICAgICAgXCLihYhcIjogXCImaWk7XCIsXG4gICAgICBcIuKIrFwiOiBcIiZJbnQ7XCIsXG4gICAgICBcIuKIq1wiOiBcIiZpbnQ7XCIsXG4gICAgICBcIuKLglwiOiBcIiZ4Y2FwO1wiLFxuICAgICAgXCLigaNcIjogXCImaWM7XCIsXG4gICAgICBcIuKBolwiOiBcIiZpdDtcIixcbiAgICAgIFwixK5cIjogXCImSW9nb247XCIsXG4gICAgICBcIvCdlYBcIjogXCImSW9wZjtcIixcbiAgICAgIFwizplcIjogXCImSW90YTtcIixcbiAgICAgIFwi4oSQXCI6IFwiJmltYWdsaW5lO1wiLFxuICAgICAgXCLEqFwiOiBcIiZJdGlsZGU7XCIsXG4gICAgICBcItCGXCI6IFwiJkl1a2N5O1wiLFxuICAgICAgXCLDj1wiOiBcIiZJdW1sO1wiLFxuICAgICAgXCLEtFwiOiBcIiZKY2lyYztcIixcbiAgICAgIFwi0JlcIjogXCImSmN5O1wiLFxuICAgICAgXCLwnZSNXCI6IFwiJkpmcjtcIixcbiAgICAgIFwi8J2VgVwiOiBcIiZKb3BmO1wiLFxuICAgICAgXCLwnZKlXCI6IFwiJkpzY3I7XCIsXG4gICAgICBcItCIXCI6IFwiJkpzZXJjeTtcIixcbiAgICAgIFwi0IRcIjogXCImSnVrY3k7XCIsXG4gICAgICBcItClXCI6IFwiJktIY3k7XCIsXG4gICAgICBcItCMXCI6IFwiJktKY3k7XCIsXG4gICAgICBcIs6aXCI6IFwiJkthcHBhO1wiLFxuICAgICAgXCLEtlwiOiBcIiZLY2VkaWw7XCIsXG4gICAgICBcItCaXCI6IFwiJktjeTtcIixcbiAgICAgIFwi8J2UjlwiOiBcIiZLZnI7XCIsXG4gICAgICBcIvCdlYJcIjogXCImS29wZjtcIixcbiAgICAgIFwi8J2SplwiOiBcIiZLc2NyO1wiLFxuICAgICAgXCLQiVwiOiBcIiZMSmN5O1wiLFxuICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgXCLEuVwiOiBcIiZMYWN1dGU7XCIsXG4gICAgICBcIs6bXCI6IFwiJkxhbWJkYTtcIixcbiAgICAgIFwi4p+qXCI6IFwiJkxhbmc7XCIsXG4gICAgICBcIuKEklwiOiBcIiZsYWdyYW47XCIsXG4gICAgICBcIuKGnlwiOiBcIiZ0d29oZWFkbGVmdGFycm93O1wiLFxuICAgICAgXCLEvVwiOiBcIiZMY2Fyb247XCIsXG4gICAgICBcIsS7XCI6IFwiJkxjZWRpbDtcIixcbiAgICAgIFwi0JtcIjogXCImTGN5O1wiLFxuICAgICAgXCLin6hcIjogXCImbGFuZ2xlO1wiLFxuICAgICAgXCLihpBcIjogXCImc2xhcnI7XCIsXG4gICAgICBcIuKHpFwiOiBcIiZsYXJyYjtcIixcbiAgICAgIFwi4oeGXCI6IFwiJmxyYXJyO1wiLFxuICAgICAgXCLijIhcIjogXCImbGNlaWw7XCIsXG4gICAgICBcIuKfplwiOiBcIiZsb2JyaztcIixcbiAgICAgIFwi4qWhXCI6IFwiJkxlZnREb3duVGVlVmVjdG9yO1wiLFxuICAgICAgXCLih4NcIjogXCImZG93bmhhcnBvb25sZWZ0O1wiLFxuICAgICAgXCLipZlcIjogXCImTGVmdERvd25WZWN0b3JCYXI7XCIsXG4gICAgICBcIuKMilwiOiBcIiZsZmxvb3I7XCIsXG4gICAgICBcIuKGlFwiOiBcIiZsZWZ0cmlnaHRhcnJvdztcIixcbiAgICAgIFwi4qWOXCI6IFwiJkxlZnRSaWdodFZlY3RvcjtcIixcbiAgICAgIFwi4oqjXCI6IFwiJmRhc2h2O1wiLFxuICAgICAgXCLihqRcIjogXCImbWFwc3RvbGVmdDtcIixcbiAgICAgIFwi4qWaXCI6IFwiJkxlZnRUZWVWZWN0b3I7XCIsXG4gICAgICBcIuKKslwiOiBcIiZ2bHRyaTtcIixcbiAgICAgIFwi4qePXCI6IFwiJkxlZnRUcmlhbmdsZUJhcjtcIixcbiAgICAgIFwi4oq0XCI6IFwiJnRyaWFuZ2xlbGVmdGVxO1wiLFxuICAgICAgXCLipZFcIjogXCImTGVmdFVwRG93blZlY3RvcjtcIixcbiAgICAgIFwi4qWgXCI6IFwiJkxlZnRVcFRlZVZlY3RvcjtcIixcbiAgICAgIFwi4oa/XCI6IFwiJnVwaGFycG9vbmxlZnQ7XCIsXG4gICAgICBcIuKlmFwiOiBcIiZMZWZ0VXBWZWN0b3JCYXI7XCIsXG4gICAgICBcIuKGvFwiOiBcIiZsaGFydTtcIixcbiAgICAgIFwi4qWSXCI6IFwiJkxlZnRWZWN0b3JCYXI7XCIsXG4gICAgICBcIuKLmlwiOiBcIiZsZXNzZXFndHI7XCIsXG4gICAgICBcIuKJplwiOiBcIiZsZXFxO1wiLFxuICAgICAgXCLiibZcIjogXCImbGc7XCIsXG4gICAgICBcIuKqoVwiOiBcIiZMZXNzTGVzcztcIixcbiAgICAgIFwi4qm9XCI6IFwiJmxlcztcIixcbiAgICAgIFwi4omyXCI6IFwiJmxzaW07XCIsXG4gICAgICBcIvCdlI9cIjogXCImTGZyO1wiLFxuICAgICAgXCLii5hcIjogXCImTGw7XCIsXG4gICAgICBcIuKHmlwiOiBcIiZsQWFycjtcIixcbiAgICAgIFwixL9cIjogXCImTG1pZG90O1wiLFxuICAgICAgXCLin7VcIjogXCImeGxhcnI7XCIsXG4gICAgICBcIuKft1wiOiBcIiZ4aGFycjtcIixcbiAgICAgIFwi4p+2XCI6IFwiJnhyYXJyO1wiLFxuICAgICAgXCLwnZWDXCI6IFwiJkxvcGY7XCIsXG4gICAgICBcIuKGmVwiOiBcIiZzd2Fycm93O1wiLFxuICAgICAgXCLihphcIjogXCImc2VhcnJvdztcIixcbiAgICAgIFwi4oawXCI6IFwiJmxzaDtcIixcbiAgICAgIFwixYFcIjogXCImTHN0cm9rO1wiLFxuICAgICAgXCLiiapcIjogXCImbGw7XCIsXG4gICAgICBcIuKkhVwiOiBcIiZNYXA7XCIsXG4gICAgICBcItCcXCI6IFwiJk1jeTtcIixcbiAgICAgIFwi4oGfXCI6IFwiJk1lZGl1bVNwYWNlO1wiLFxuICAgICAgXCLihLNcIjogXCImcGhtbWF0O1wiLFxuICAgICAgXCLwnZSQXCI6IFwiJk1mcjtcIixcbiAgICAgIFwi4oiTXCI6IFwiJm1wO1wiLFxuICAgICAgXCLwnZWEXCI6IFwiJk1vcGY7XCIsXG4gICAgICBcIs6cXCI6IFwiJk11O1wiLFxuICAgICAgXCLQilwiOiBcIiZOSmN5O1wiLFxuICAgICAgXCLFg1wiOiBcIiZOYWN1dGU7XCIsXG4gICAgICBcIsWHXCI6IFwiJk5jYXJvbjtcIixcbiAgICAgIFwixYVcIjogXCImTmNlZGlsO1wiLFxuICAgICAgXCLQnVwiOiBcIiZOY3k7XCIsXG4gICAgICBcIuKAi1wiOiBcIiZaZXJvV2lkdGhTcGFjZTtcIixcbiAgICAgIFwiXFxuXCI6IFwiJk5ld0xpbmU7XCIsXG4gICAgICBcIvCdlJFcIjogXCImTmZyO1wiLFxuICAgICAgXCLigaBcIjogXCImTm9CcmVhaztcIixcbiAgICAgIFwiwqBcIjogXCImbmJzcDtcIixcbiAgICAgIFwi4oSVXCI6IFwiJm5hdHVyYWxzO1wiLFxuICAgICAgXCLiq6xcIjogXCImTm90O1wiLFxuICAgICAgXCLiiaJcIjogXCImbmVxdWl2O1wiLFxuICAgICAgXCLiia1cIjogXCImTm90Q3VwQ2FwO1wiLFxuICAgICAgXCLiiKZcIjogXCImbnNwYXI7XCIsXG4gICAgICBcIuKIiVwiOiBcIiZub3RpbnZhO1wiLFxuICAgICAgXCLiiaBcIjogXCImbmU7XCIsXG4gICAgICBcIuKJgsy4XCI6IFwiJm5lc2ltO1wiLFxuICAgICAgXCLiiIRcIjogXCImbmV4aXN0cztcIixcbiAgICAgIFwi4omvXCI6IFwiJm5ndHI7XCIsXG4gICAgICBcIuKJsVwiOiBcIiZuZ2VxO1wiLFxuICAgICAgXCLiiafMuFwiOiBcIiZuZ2VxcTtcIixcbiAgICAgIFwi4omrzLhcIjogXCImbkd0djtcIixcbiAgICAgIFwi4om5XCI6IFwiJm50Z2w7XCIsXG4gICAgICBcIuKpvsy4XCI6IFwiJm5nZXM7XCIsXG4gICAgICBcIuKJtVwiOiBcIiZuZ3NpbTtcIixcbiAgICAgIFwi4omOzLhcIjogXCImbmJ1bXA7XCIsXG4gICAgICBcIuKJj8y4XCI6IFwiJm5idW1wZTtcIixcbiAgICAgIFwi4ouqXCI6IFwiJm50cmlhbmdsZWxlZnQ7XCIsXG4gICAgICBcIuKnj8y4XCI6IFwiJk5vdExlZnRUcmlhbmdsZUJhcjtcIixcbiAgICAgIFwi4ousXCI6IFwiJm50cmlhbmdsZWxlZnRlcTtcIixcbiAgICAgIFwi4omuXCI6IFwiJm5sdDtcIixcbiAgICAgIFwi4omwXCI6IFwiJm5sZXE7XCIsXG4gICAgICBcIuKJuFwiOiBcIiZudGxnO1wiLFxuICAgICAgXCLiiarMuFwiOiBcIiZuTHR2O1wiLFxuICAgICAgXCLiqb3MuFwiOiBcIiZubGVzO1wiLFxuICAgICAgXCLiibRcIjogXCImbmxzaW07XCIsXG4gICAgICBcIuKqosy4XCI6IFwiJk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiLFxuICAgICAgXCLiqqHMuFwiOiBcIiZOb3ROZXN0ZWRMZXNzTGVzcztcIixcbiAgICAgIFwi4oqAXCI6IFwiJm5wcmVjO1wiLFxuICAgICAgXCLiqq/MuFwiOiBcIiZucHJlY2VxO1wiLFxuICAgICAgXCLii6BcIjogXCImbnByY3VlO1wiLFxuICAgICAgXCLiiIxcIjogXCImbm90bml2YTtcIixcbiAgICAgIFwi4ourXCI6IFwiJm50cmlhbmdsZXJpZ2h0O1wiLFxuICAgICAgXCLip5DMuFwiOiBcIiZOb3RSaWdodFRyaWFuZ2xlQmFyO1wiLFxuICAgICAgXCLii61cIjogXCImbnRyaWFuZ2xlcmlnaHRlcTtcIixcbiAgICAgIFwi4oqPzLhcIjogXCImTm90U3F1YXJlU3Vic2V0O1wiLFxuICAgICAgXCLii6JcIjogXCImbnNxc3ViZTtcIixcbiAgICAgIFwi4oqQzLhcIjogXCImTm90U3F1YXJlU3VwZXJzZXQ7XCIsXG4gICAgICBcIuKLo1wiOiBcIiZuc3FzdXBlO1wiLFxuICAgICAgXCLiioLig5JcIjogXCImdm5zdWI7XCIsXG4gICAgICBcIuKKiFwiOiBcIiZuc3Vic2V0ZXE7XCIsXG4gICAgICBcIuKKgVwiOiBcIiZuc3VjYztcIixcbiAgICAgIFwi4qqwzLhcIjogXCImbnN1Y2NlcTtcIixcbiAgICAgIFwi4ouhXCI6IFwiJm5zY2N1ZTtcIixcbiAgICAgIFwi4om/zLhcIjogXCImTm90U3VjY2VlZHNUaWxkZTtcIixcbiAgICAgIFwi4oqD4oOSXCI6IFwiJnZuc3VwO1wiLFxuICAgICAgXCLiiolcIjogXCImbnN1cHNldGVxO1wiLFxuICAgICAgXCLiiYFcIjogXCImbnNpbTtcIixcbiAgICAgIFwi4omEXCI6IFwiJm5zaW1lcTtcIixcbiAgICAgIFwi4omHXCI6IFwiJm5jb25nO1wiLFxuICAgICAgXCLiiYlcIjogXCImbmFwcHJveDtcIixcbiAgICAgIFwi4oikXCI6IFwiJm5zbWlkO1wiLFxuICAgICAgXCLwnZKpXCI6IFwiJk5zY3I7XCIsXG4gICAgICBcIsORXCI6IFwiJk50aWxkZTtcIixcbiAgICAgIFwizp1cIjogXCImTnU7XCIsXG4gICAgICBcIsWSXCI6IFwiJk9FbGlnO1wiLFxuICAgICAgXCLDk1wiOiBcIiZPYWN1dGU7XCIsXG4gICAgICBcIsOUXCI6IFwiJk9jaXJjO1wiLFxuICAgICAgXCLQnlwiOiBcIiZPY3k7XCIsXG4gICAgICBcIsWQXCI6IFwiJk9kYmxhYztcIixcbiAgICAgIFwi8J2UklwiOiBcIiZPZnI7XCIsXG4gICAgICBcIsOSXCI6IFwiJk9ncmF2ZTtcIixcbiAgICAgIFwixYxcIjogXCImT21hY3I7XCIsXG4gICAgICBcIs6pXCI6IFwiJm9obTtcIixcbiAgICAgIFwizp9cIjogXCImT21pY3JvbjtcIixcbiAgICAgIFwi8J2VhlwiOiBcIiZPb3BmO1wiLFxuICAgICAgXCLigJxcIjogXCImbGRxdW87XCIsXG4gICAgICBcIuKAmFwiOiBcIiZsc3F1bztcIixcbiAgICAgIFwi4qmUXCI6IFwiJk9yO1wiLFxuICAgICAgXCLwnZKqXCI6IFwiJk9zY3I7XCIsXG4gICAgICBcIsOYXCI6IFwiJk9zbGFzaDtcIixcbiAgICAgIFwiw5VcIjogXCImT3RpbGRlO1wiLFxuICAgICAgXCLiqLdcIjogXCImT3RpbWVzO1wiLFxuICAgICAgXCLDllwiOiBcIiZPdW1sO1wiLFxuICAgICAgXCLigL5cIjogXCImb2xpbmU7XCIsXG4gICAgICBcIuKPnlwiOiBcIiZPdmVyQnJhY2U7XCIsXG4gICAgICBcIuKOtFwiOiBcIiZ0YnJrO1wiLFxuICAgICAgXCLij5xcIjogXCImT3ZlclBhcmVudGhlc2lzO1wiLFxuICAgICAgXCLiiIJcIjogXCImcGFydDtcIixcbiAgICAgIFwi0J9cIjogXCImUGN5O1wiLFxuICAgICAgXCLwnZSTXCI6IFwiJlBmcjtcIixcbiAgICAgIFwizqZcIjogXCImUGhpO1wiLFxuICAgICAgXCLOoFwiOiBcIiZQaTtcIixcbiAgICAgIFwiwrFcIjogXCImcG07XCIsXG4gICAgICBcIuKEmVwiOiBcIiZwcmltZXM7XCIsXG4gICAgICBcIuKqu1wiOiBcIiZQcjtcIixcbiAgICAgIFwi4om6XCI6IFwiJnByZWM7XCIsXG4gICAgICBcIuKqr1wiOiBcIiZwcmVjZXE7XCIsXG4gICAgICBcIuKJvFwiOiBcIiZwcmVjY3VybHllcTtcIixcbiAgICAgIFwi4om+XCI6IFwiJnByc2ltO1wiLFxuICAgICAgXCLigLNcIjogXCImUHJpbWU7XCIsXG4gICAgICBcIuKIj1wiOiBcIiZwcm9kO1wiLFxuICAgICAgXCLiiJ1cIjogXCImdnByb3A7XCIsXG4gICAgICBcIvCdkqtcIjogXCImUHNjcjtcIixcbiAgICAgIFwizqhcIjogXCImUHNpO1wiLFxuICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgIFwi8J2UlFwiOiBcIiZRZnI7XCIsXG4gICAgICBcIuKEmlwiOiBcIiZyYXRpb25hbHM7XCIsXG4gICAgICBcIvCdkqxcIjogXCImUXNjcjtcIixcbiAgICAgIFwi4qSQXCI6IFwiJmRyYmthcm93O1wiLFxuICAgICAgXCLCrlwiOiBcIiZyZWc7XCIsXG4gICAgICBcIsWUXCI6IFwiJlJhY3V0ZTtcIixcbiAgICAgIFwi4p+rXCI6IFwiJlJhbmc7XCIsXG4gICAgICBcIuKGoFwiOiBcIiZ0d29oZWFkcmlnaHRhcnJvdztcIixcbiAgICAgIFwi4qSWXCI6IFwiJlJhcnJ0bDtcIixcbiAgICAgIFwixZhcIjogXCImUmNhcm9uO1wiLFxuICAgICAgXCLFllwiOiBcIiZSY2VkaWw7XCIsXG4gICAgICBcItCgXCI6IFwiJlJjeTtcIixcbiAgICAgIFwi4oScXCI6IFwiJnJlYWxwYXJ0O1wiLFxuICAgICAgXCLiiItcIjogXCImbml2O1wiLFxuICAgICAgXCLih4tcIjogXCImbHJoYXI7XCIsXG4gICAgICBcIuKlr1wiOiBcIiZkdWhhcjtcIixcbiAgICAgIFwizqFcIjogXCImUmhvO1wiLFxuICAgICAgXCLin6lcIjogXCImcmFuZ2xlO1wiLFxuICAgICAgXCLihpJcIjogXCImc3JhcnI7XCIsXG4gICAgICBcIuKHpVwiOiBcIiZyYXJyYjtcIixcbiAgICAgIFwi4oeEXCI6IFwiJnJsYXJyO1wiLFxuICAgICAgXCLijIlcIjogXCImcmNlaWw7XCIsXG4gICAgICBcIuKfp1wiOiBcIiZyb2JyaztcIixcbiAgICAgIFwi4qWdXCI6IFwiJlJpZ2h0RG93blRlZVZlY3RvcjtcIixcbiAgICAgIFwi4oeCXCI6IFwiJmRvd25oYXJwb29ucmlnaHQ7XCIsXG4gICAgICBcIuKllVwiOiBcIiZSaWdodERvd25WZWN0b3JCYXI7XCIsXG4gICAgICBcIuKMi1wiOiBcIiZyZmxvb3I7XCIsXG4gICAgICBcIuKKolwiOiBcIiZ2ZGFzaDtcIixcbiAgICAgIFwi4oamXCI6IFwiJm1hcHN0bztcIixcbiAgICAgIFwi4qWbXCI6IFwiJlJpZ2h0VGVlVmVjdG9yO1wiLFxuICAgICAgXCLiirNcIjogXCImdnJ0cmk7XCIsXG4gICAgICBcIuKnkFwiOiBcIiZSaWdodFRyaWFuZ2xlQmFyO1wiLFxuICAgICAgXCLiirVcIjogXCImdHJpYW5nbGVyaWdodGVxO1wiLFxuICAgICAgXCLipY9cIjogXCImUmlnaHRVcERvd25WZWN0b3I7XCIsXG4gICAgICBcIuKlnFwiOiBcIiZSaWdodFVwVGVlVmVjdG9yO1wiLFxuICAgICAgXCLihr5cIjogXCImdXBoYXJwb29ucmlnaHQ7XCIsXG4gICAgICBcIuKllFwiOiBcIiZSaWdodFVwVmVjdG9yQmFyO1wiLFxuICAgICAgXCLih4BcIjogXCImcmlnaHRoYXJwb29udXA7XCIsXG4gICAgICBcIuKlk1wiOiBcIiZSaWdodFZlY3RvckJhcjtcIixcbiAgICAgIFwi4oSdXCI6IFwiJnJlYWxzO1wiLFxuICAgICAgXCLipbBcIjogXCImUm91bmRJbXBsaWVzO1wiLFxuICAgICAgXCLih5tcIjogXCImckFhcnI7XCIsXG4gICAgICBcIuKEm1wiOiBcIiZyZWFsaW5lO1wiLFxuICAgICAgXCLihrFcIjogXCImcnNoO1wiLFxuICAgICAgXCLip7RcIjogXCImUnVsZURlbGF5ZWQ7XCIsXG4gICAgICBcItCpXCI6IFwiJlNIQ0hjeTtcIixcbiAgICAgIFwi0KhcIjogXCImU0hjeTtcIixcbiAgICAgIFwi0KxcIjogXCImU09GVGN5O1wiLFxuICAgICAgXCLFmlwiOiBcIiZTYWN1dGU7XCIsXG4gICAgICBcIuKqvFwiOiBcIiZTYztcIixcbiAgICAgIFwixaBcIjogXCImU2Nhcm9uO1wiLFxuICAgICAgXCLFnlwiOiBcIiZTY2VkaWw7XCIsXG4gICAgICBcIsWcXCI6IFwiJlNjaXJjO1wiLFxuICAgICAgXCLQoVwiOiBcIiZTY3k7XCIsXG4gICAgICBcIvCdlJZcIjogXCImU2ZyO1wiLFxuICAgICAgXCLihpFcIjogXCImdXBhcnJvdztcIixcbiAgICAgIFwizqNcIjogXCImU2lnbWE7XCIsXG4gICAgICBcIuKImFwiOiBcIiZjb21wZm47XCIsXG4gICAgICBcIvCdlYpcIjogXCImU29wZjtcIixcbiAgICAgIFwi4oiaXCI6IFwiJnJhZGljO1wiLFxuICAgICAgXCLilqFcIjogXCImc3F1YXJlO1wiLFxuICAgICAgXCLiipNcIjogXCImc3FjYXA7XCIsXG4gICAgICBcIuKKj1wiOiBcIiZzcXN1YnNldDtcIixcbiAgICAgIFwi4oqRXCI6IFwiJnNxc3Vic2V0ZXE7XCIsXG4gICAgICBcIuKKkFwiOiBcIiZzcXN1cHNldDtcIixcbiAgICAgIFwi4oqSXCI6IFwiJnNxc3Vwc2V0ZXE7XCIsXG4gICAgICBcIuKKlFwiOiBcIiZzcWN1cDtcIixcbiAgICAgIFwi8J2SrlwiOiBcIiZTc2NyO1wiLFxuICAgICAgXCLii4ZcIjogXCImc3N0YXJmO1wiLFxuICAgICAgXCLii5BcIjogXCImU3Vic2V0O1wiLFxuICAgICAgXCLiioZcIjogXCImc3Vic2V0ZXE7XCIsXG4gICAgICBcIuKJu1wiOiBcIiZzdWNjO1wiLFxuICAgICAgXCLiqrBcIjogXCImc3VjY2VxO1wiLFxuICAgICAgXCLiib1cIjogXCImc3VjY2N1cmx5ZXE7XCIsXG4gICAgICBcIuKJv1wiOiBcIiZzdWNjc2ltO1wiLFxuICAgICAgXCLiiJFcIjogXCImc3VtO1wiLFxuICAgICAgXCLii5FcIjogXCImU3Vwc2V0O1wiLFxuICAgICAgXCLiioNcIjogXCImc3Vwc2V0O1wiLFxuICAgICAgXCLiiodcIjogXCImc3Vwc2V0ZXE7XCIsXG4gICAgICBcIsOeXCI6IFwiJlRIT1JOO1wiLFxuICAgICAgXCLihKJcIjogXCImdHJhZGU7XCIsXG4gICAgICBcItCLXCI6IFwiJlRTSGN5O1wiLFxuICAgICAgXCLQplwiOiBcIiZUU2N5O1wiLFxuICAgICAgXCJcXHRcIjogXCImVGFiO1wiLFxuICAgICAgXCLOpFwiOiBcIiZUYXU7XCIsXG4gICAgICBcIsWkXCI6IFwiJlRjYXJvbjtcIixcbiAgICAgIFwixaJcIjogXCImVGNlZGlsO1wiLFxuICAgICAgXCLQolwiOiBcIiZUY3k7XCIsXG4gICAgICBcIvCdlJdcIjogXCImVGZyO1wiLFxuICAgICAgXCLiiLRcIjogXCImdGhlcmVmb3JlO1wiLFxuICAgICAgXCLOmFwiOiBcIiZUaGV0YTtcIixcbiAgICAgIFwi4oGf4oCKXCI6IFwiJlRoaWNrU3BhY2U7XCIsXG4gICAgICBcIuKAiVwiOiBcIiZ0aGluc3A7XCIsXG4gICAgICBcIuKIvFwiOiBcIiZ0aGtzaW07XCIsXG4gICAgICBcIuKJg1wiOiBcIiZzaW1lcTtcIixcbiAgICAgIFwi4omFXCI6IFwiJmNvbmc7XCIsXG4gICAgICBcIuKJiFwiOiBcIiZ0aGthcDtcIixcbiAgICAgIFwi8J2Vi1wiOiBcIiZUb3BmO1wiLFxuICAgICAgXCLig5tcIjogXCImdGRvdDtcIixcbiAgICAgIFwi8J2Sr1wiOiBcIiZUc2NyO1wiLFxuICAgICAgXCLFplwiOiBcIiZUc3Ryb2s7XCIsXG4gICAgICBcIsOaXCI6IFwiJlVhY3V0ZTtcIixcbiAgICAgIFwi4oafXCI6IFwiJlVhcnI7XCIsXG4gICAgICBcIuKliVwiOiBcIiZVYXJyb2NpcjtcIixcbiAgICAgIFwi0I5cIjogXCImVWJyY3k7XCIsXG4gICAgICBcIsWsXCI6IFwiJlVicmV2ZTtcIixcbiAgICAgIFwiw5tcIjogXCImVWNpcmM7XCIsXG4gICAgICBcItCjXCI6IFwiJlVjeTtcIixcbiAgICAgIFwixbBcIjogXCImVWRibGFjO1wiLFxuICAgICAgXCLwnZSYXCI6IFwiJlVmcjtcIixcbiAgICAgIFwiw5lcIjogXCImVWdyYXZlO1wiLFxuICAgICAgXCLFqlwiOiBcIiZVbWFjcjtcIixcbiAgICAgIF86IFwiJmxvd2JhcjtcIixcbiAgICAgIFwi4o+fXCI6IFwiJlVuZGVyQnJhY2U7XCIsXG4gICAgICBcIuKOtVwiOiBcIiZiYnJrO1wiLFxuICAgICAgXCLij51cIjogXCImVW5kZXJQYXJlbnRoZXNpcztcIixcbiAgICAgIFwi4ouDXCI6IFwiJnhjdXA7XCIsXG4gICAgICBcIuKKjlwiOiBcIiZ1cGx1cztcIixcbiAgICAgIFwixbJcIjogXCImVW9nb247XCIsXG4gICAgICBcIvCdlYxcIjogXCImVW9wZjtcIixcbiAgICAgIFwi4qSSXCI6IFwiJlVwQXJyb3dCYXI7XCIsXG4gICAgICBcIuKHhVwiOiBcIiZ1ZGFycjtcIixcbiAgICAgIFwi4oaVXCI6IFwiJnZhcnI7XCIsXG4gICAgICBcIuKlrlwiOiBcIiZ1ZGhhcjtcIixcbiAgICAgIFwi4oqlXCI6IFwiJnBlcnA7XCIsXG4gICAgICBcIuKGpVwiOiBcIiZtYXBzdG91cDtcIixcbiAgICAgIFwi4oaWXCI6IFwiJm53YXJyb3c7XCIsXG4gICAgICBcIuKGl1wiOiBcIiZuZWFycm93O1wiLFxuICAgICAgXCLPklwiOiBcIiZ1cHNpaDtcIixcbiAgICAgIFwizqVcIjogXCImVXBzaWxvbjtcIixcbiAgICAgIFwixa5cIjogXCImVXJpbmc7XCIsXG4gICAgICBcIvCdkrBcIjogXCImVXNjcjtcIixcbiAgICAgIFwixahcIjogXCImVXRpbGRlO1wiLFxuICAgICAgXCLDnFwiOiBcIiZVdW1sO1wiLFxuICAgICAgXCLiiqtcIjogXCImVkRhc2g7XCIsXG4gICAgICBcIuKrq1wiOiBcIiZWYmFyO1wiLFxuICAgICAgXCLQklwiOiBcIiZWY3k7XCIsXG4gICAgICBcIuKKqVwiOiBcIiZWZGFzaDtcIixcbiAgICAgIFwi4qumXCI6IFwiJlZkYXNobDtcIixcbiAgICAgIFwi4ouBXCI6IFwiJnh2ZWU7XCIsXG4gICAgICBcIuKAllwiOiBcIiZWZXJ0O1wiLFxuICAgICAgXCLiiKNcIjogXCImc21pZDtcIixcbiAgICAgIFwifFwiOiBcIiZ2ZXJ0O1wiLFxuICAgICAgXCLinZhcIjogXCImVmVydGljYWxTZXBhcmF0b3I7XCIsXG4gICAgICBcIuKJgFwiOiBcIiZ3cmVhdGg7XCIsXG4gICAgICBcIuKAilwiOiBcIiZoYWlyc3A7XCIsXG4gICAgICBcIvCdlJlcIjogXCImVmZyO1wiLFxuICAgICAgXCLwnZWNXCI6IFwiJlZvcGY7XCIsXG4gICAgICBcIvCdkrFcIjogXCImVnNjcjtcIixcbiAgICAgIFwi4oqqXCI6IFwiJlZ2ZGFzaDtcIixcbiAgICAgIFwixbRcIjogXCImV2NpcmM7XCIsXG4gICAgICBcIuKLgFwiOiBcIiZ4d2VkZ2U7XCIsXG4gICAgICBcIvCdlJpcIjogXCImV2ZyO1wiLFxuICAgICAgXCLwnZWOXCI6IFwiJldvcGY7XCIsXG4gICAgICBcIvCdkrJcIjogXCImV3NjcjtcIixcbiAgICAgIFwi8J2Um1wiOiBcIiZYZnI7XCIsXG4gICAgICBcIs6eXCI6IFwiJlhpO1wiLFxuICAgICAgXCLwnZWPXCI6IFwiJlhvcGY7XCIsXG4gICAgICBcIvCdkrNcIjogXCImWHNjcjtcIixcbiAgICAgIFwi0K9cIjogXCImWUFjeTtcIixcbiAgICAgIFwi0IdcIjogXCImWUljeTtcIixcbiAgICAgIFwi0K5cIjogXCImWVVjeTtcIixcbiAgICAgIFwiw51cIjogXCImWWFjdXRlO1wiLFxuICAgICAgXCLFtlwiOiBcIiZZY2lyYztcIixcbiAgICAgIFwi0KtcIjogXCImWWN5O1wiLFxuICAgICAgXCLwnZScXCI6IFwiJllmcjtcIixcbiAgICAgIFwi8J2VkFwiOiBcIiZZb3BmO1wiLFxuICAgICAgXCLwnZK0XCI6IFwiJllzY3I7XCIsXG4gICAgICBcIsW4XCI6IFwiJll1bWw7XCIsXG4gICAgICBcItCWXCI6IFwiJlpIY3k7XCIsXG4gICAgICBcIsW5XCI6IFwiJlphY3V0ZTtcIixcbiAgICAgIFwixb1cIjogXCImWmNhcm9uO1wiLFxuICAgICAgXCLQl1wiOiBcIiZaY3k7XCIsXG4gICAgICBcIsW7XCI6IFwiJlpkb3Q7XCIsXG4gICAgICBcIs6WXCI6IFwiJlpldGE7XCIsXG4gICAgICBcIuKEqFwiOiBcIiZ6ZWV0cmY7XCIsXG4gICAgICBcIuKEpFwiOiBcIiZpbnRlZ2VycztcIixcbiAgICAgIFwi8J2StVwiOiBcIiZac2NyO1wiLFxuICAgICAgXCLDoVwiOiBcIiZhYWN1dGU7XCIsXG4gICAgICBcIsSDXCI6IFwiJmFicmV2ZTtcIixcbiAgICAgIFwi4oi+XCI6IFwiJm1zdHBvcztcIixcbiAgICAgIFwi4oi+zLNcIjogXCImYWNFO1wiLFxuICAgICAgXCLiiL9cIjogXCImYWNkO1wiLFxuICAgICAgXCLDolwiOiBcIiZhY2lyYztcIixcbiAgICAgIFwi0LBcIjogXCImYWN5O1wiLFxuICAgICAgXCLDplwiOiBcIiZhZWxpZztcIixcbiAgICAgIFwi8J2UnlwiOiBcIiZhZnI7XCIsXG4gICAgICBcIsOgXCI6IFwiJmFncmF2ZTtcIixcbiAgICAgIFwi4oS1XCI6IFwiJmFsZXBoO1wiLFxuICAgICAgXCLOsVwiOiBcIiZhbHBoYTtcIixcbiAgICAgIFwixIFcIjogXCImYW1hY3I7XCIsXG4gICAgICBcIuKov1wiOiBcIiZhbWFsZztcIixcbiAgICAgIFwi4oinXCI6IFwiJndlZGdlO1wiLFxuICAgICAgXCLiqZVcIjogXCImYW5kYW5kO1wiLFxuICAgICAgXCLiqZxcIjogXCImYW5kZDtcIixcbiAgICAgIFwi4qmYXCI6IFwiJmFuZHNsb3BlO1wiLFxuICAgICAgXCLiqZpcIjogXCImYW5kdjtcIixcbiAgICAgIFwi4oigXCI6IFwiJmFuZ2xlO1wiLFxuICAgICAgXCLipqRcIjogXCImYW5nZTtcIixcbiAgICAgIFwi4oihXCI6IFwiJm1lYXN1cmVkYW5nbGU7XCIsXG4gICAgICBcIuKmqFwiOiBcIiZhbmdtc2RhYTtcIixcbiAgICAgIFwi4qapXCI6IFwiJmFuZ21zZGFiO1wiLFxuICAgICAgXCLipqpcIjogXCImYW5nbXNkYWM7XCIsXG4gICAgICBcIuKmq1wiOiBcIiZhbmdtc2RhZDtcIixcbiAgICAgIFwi4qasXCI6IFwiJmFuZ21zZGFlO1wiLFxuICAgICAgXCLipq1cIjogXCImYW5nbXNkYWY7XCIsXG4gICAgICBcIuKmrlwiOiBcIiZhbmdtc2RhZztcIixcbiAgICAgIFwi4qavXCI6IFwiJmFuZ21zZGFoO1wiLFxuICAgICAgXCLiiJ9cIjogXCImYW5ncnQ7XCIsXG4gICAgICBcIuKKvlwiOiBcIiZhbmdydHZiO1wiLFxuICAgICAgXCLipp1cIjogXCImYW5ncnR2YmQ7XCIsXG4gICAgICBcIuKIolwiOiBcIiZhbmdzcGg7XCIsXG4gICAgICBcIuKNvFwiOiBcIiZhbmd6YXJyO1wiLFxuICAgICAgXCLEhVwiOiBcIiZhb2dvbjtcIixcbiAgICAgIFwi8J2VklwiOiBcIiZhb3BmO1wiLFxuICAgICAgXCLiqbBcIjogXCImYXBFO1wiLFxuICAgICAgXCLiqa9cIjogXCImYXBhY2lyO1wiLFxuICAgICAgXCLiiYpcIjogXCImYXBwcm94ZXE7XCIsXG4gICAgICBcIuKJi1wiOiBcIiZhcGlkO1wiLFxuICAgICAgXCInXCI6IFwiJmFwb3M7XCIsXG4gICAgICBcIsOlXCI6IFwiJmFyaW5nO1wiLFxuICAgICAgXCLwnZK2XCI6IFwiJmFzY3I7XCIsXG4gICAgICBcIipcIjogXCImbWlkYXN0O1wiLFxuICAgICAgXCLDo1wiOiBcIiZhdGlsZGU7XCIsXG4gICAgICBcIsOkXCI6IFwiJmF1bWw7XCIsXG4gICAgICBcIuKokVwiOiBcIiZhd2ludDtcIixcbiAgICAgIFwi4qutXCI6IFwiJmJOb3Q7XCIsXG4gICAgICBcIuKJjFwiOiBcIiZiY29uZztcIixcbiAgICAgIFwiz7ZcIjogXCImYmVwc2k7XCIsXG4gICAgICBcIuKAtVwiOiBcIiZicHJpbWU7XCIsXG4gICAgICBcIuKIvVwiOiBcIiZic2ltO1wiLFxuICAgICAgXCLii41cIjogXCImYnNpbWU7XCIsXG4gICAgICBcIuKKvVwiOiBcIiZiYXJ2ZWU7XCIsXG4gICAgICBcIuKMhVwiOiBcIiZiYXJ3ZWRnZTtcIixcbiAgICAgIFwi4o62XCI6IFwiJmJicmt0YnJrO1wiLFxuICAgICAgXCLQsVwiOiBcIiZiY3k7XCIsXG4gICAgICBcIuKAnlwiOiBcIiZsZHF1b3I7XCIsXG4gICAgICBcIuKmsFwiOiBcIiZiZW1wdHl2O1wiLFxuICAgICAgXCLOslwiOiBcIiZiZXRhO1wiLFxuICAgICAgXCLihLZcIjogXCImYmV0aDtcIixcbiAgICAgIFwi4omsXCI6IFwiJnR3aXh0O1wiLFxuICAgICAgXCLwnZSfXCI6IFwiJmJmcjtcIixcbiAgICAgIFwi4pevXCI6IFwiJnhjaXJjO1wiLFxuICAgICAgXCLiqIBcIjogXCImeG9kb3Q7XCIsXG4gICAgICBcIuKogVwiOiBcIiZ4b3BsdXM7XCIsXG4gICAgICBcIuKoglwiOiBcIiZ4b3RpbWU7XCIsXG4gICAgICBcIuKohlwiOiBcIiZ4c3FjdXA7XCIsXG4gICAgICBcIuKYhVwiOiBcIiZzdGFyZjtcIixcbiAgICAgIFwi4pa9XCI6IFwiJnhkdHJpO1wiLFxuICAgICAgXCLilrNcIjogXCImeHV0cmk7XCIsXG4gICAgICBcIuKohFwiOiBcIiZ4dXBsdXM7XCIsXG4gICAgICBcIuKkjVwiOiBcIiZyYmFycjtcIixcbiAgICAgIFwi4qerXCI6IFwiJmxvemY7XCIsXG4gICAgICBcIuKWtFwiOiBcIiZ1dHJpZjtcIixcbiAgICAgIFwi4pa+XCI6IFwiJmR0cmlmO1wiLFxuICAgICAgXCLil4JcIjogXCImbHRyaWY7XCIsXG4gICAgICBcIuKWuFwiOiBcIiZydHJpZjtcIixcbiAgICAgIFwi4pCjXCI6IFwiJmJsYW5rO1wiLFxuICAgICAgXCLilpJcIjogXCImYmxrMTI7XCIsXG4gICAgICBcIuKWkVwiOiBcIiZibGsxNDtcIixcbiAgICAgIFwi4paTXCI6IFwiJmJsazM0O1wiLFxuICAgICAgXCLilohcIjogXCImYmxvY2s7XCIsXG4gICAgICBcIj3ig6VcIjogXCImYm5lO1wiLFxuICAgICAgXCLiiaHig6VcIjogXCImYm5lcXVpdjtcIixcbiAgICAgIFwi4oyQXCI6IFwiJmJub3Q7XCIsXG4gICAgICBcIvCdlZNcIjogXCImYm9wZjtcIixcbiAgICAgIFwi4ouIXCI6IFwiJmJvd3RpZTtcIixcbiAgICAgIFwi4pWXXCI6IFwiJmJveERMO1wiLFxuICAgICAgXCLilZRcIjogXCImYm94RFI7XCIsXG4gICAgICBcIuKVllwiOiBcIiZib3hEbDtcIixcbiAgICAgIFwi4pWTXCI6IFwiJmJveERyO1wiLFxuICAgICAgXCLilZBcIjogXCImYm94SDtcIixcbiAgICAgIFwi4pWmXCI6IFwiJmJveEhEO1wiLFxuICAgICAgXCLilalcIjogXCImYm94SFU7XCIsXG4gICAgICBcIuKVpFwiOiBcIiZib3hIZDtcIixcbiAgICAgIFwi4pWnXCI6IFwiJmJveEh1O1wiLFxuICAgICAgXCLilZ1cIjogXCImYm94VUw7XCIsXG4gICAgICBcIuKVmlwiOiBcIiZib3hVUjtcIixcbiAgICAgIFwi4pWcXCI6IFwiJmJveFVsO1wiLFxuICAgICAgXCLilZlcIjogXCImYm94VXI7XCIsXG4gICAgICBcIuKVkVwiOiBcIiZib3hWO1wiLFxuICAgICAgXCLilaxcIjogXCImYm94Vkg7XCIsXG4gICAgICBcIuKVo1wiOiBcIiZib3hWTDtcIixcbiAgICAgIFwi4pWgXCI6IFwiJmJveFZSO1wiLFxuICAgICAgXCLilatcIjogXCImYm94Vmg7XCIsXG4gICAgICBcIuKVolwiOiBcIiZib3hWbDtcIixcbiAgICAgIFwi4pWfXCI6IFwiJmJveFZyO1wiLFxuICAgICAgXCLip4lcIjogXCImYm94Ym94O1wiLFxuICAgICAgXCLilZVcIjogXCImYm94ZEw7XCIsXG4gICAgICBcIuKVklwiOiBcIiZib3hkUjtcIixcbiAgICAgIFwi4pSQXCI6IFwiJmJveGRsO1wiLFxuICAgICAgXCLilIxcIjogXCImYm94ZHI7XCIsXG4gICAgICBcIuKVpVwiOiBcIiZib3hoRDtcIixcbiAgICAgIFwi4pWoXCI6IFwiJmJveGhVO1wiLFxuICAgICAgXCLilKxcIjogXCImYm94aGQ7XCIsXG4gICAgICBcIuKUtFwiOiBcIiZib3hodTtcIixcbiAgICAgIFwi4oqfXCI6IFwiJm1pbnVzYjtcIixcbiAgICAgIFwi4oqeXCI6IFwiJnBsdXNiO1wiLFxuICAgICAgXCLiiqBcIjogXCImdGltZXNiO1wiLFxuICAgICAgXCLilZtcIjogXCImYm94dUw7XCIsXG4gICAgICBcIuKVmFwiOiBcIiZib3h1UjtcIixcbiAgICAgIFwi4pSYXCI6IFwiJmJveHVsO1wiLFxuICAgICAgXCLilJRcIjogXCImYm94dXI7XCIsXG4gICAgICBcIuKUglwiOiBcIiZib3h2O1wiLFxuICAgICAgXCLilapcIjogXCImYm94dkg7XCIsXG4gICAgICBcIuKVoVwiOiBcIiZib3h2TDtcIixcbiAgICAgIFwi4pWeXCI6IFwiJmJveHZSO1wiLFxuICAgICAgXCLilLxcIjogXCImYm94dmg7XCIsXG4gICAgICBcIuKUpFwiOiBcIiZib3h2bDtcIixcbiAgICAgIFwi4pScXCI6IFwiJmJveHZyO1wiLFxuICAgICAgXCLCplwiOiBcIiZicnZiYXI7XCIsXG4gICAgICBcIvCdkrdcIjogXCImYnNjcjtcIixcbiAgICAgIFwi4oGPXCI6IFwiJmJzZW1pO1wiLFxuICAgICAgXCJcXFxcXCI6IFwiJmJzb2w7XCIsXG4gICAgICBcIuKnhVwiOiBcIiZic29sYjtcIixcbiAgICAgIFwi4p+IXCI6IFwiJmJzb2xoc3ViO1wiLFxuICAgICAgXCLigKJcIjogXCImYnVsbGV0O1wiLFxuICAgICAgXCLiqq5cIjogXCImYnVtcEU7XCIsXG4gICAgICBcIsSHXCI6IFwiJmNhY3V0ZTtcIixcbiAgICAgIFwi4oipXCI6IFwiJmNhcDtcIixcbiAgICAgIFwi4qmEXCI6IFwiJmNhcGFuZDtcIixcbiAgICAgIFwi4qmJXCI6IFwiJmNhcGJyY3VwO1wiLFxuICAgICAgXCLiqYtcIjogXCImY2FwY2FwO1wiLFxuICAgICAgXCLiqYdcIjogXCImY2FwY3VwO1wiLFxuICAgICAgXCLiqYBcIjogXCImY2FwZG90O1wiLFxuICAgICAgXCLiiKnvuIBcIjogXCImY2FwcztcIixcbiAgICAgIFwi4oGBXCI6IFwiJmNhcmV0O1wiLFxuICAgICAgXCLiqY1cIjogXCImY2NhcHM7XCIsXG4gICAgICBcIsSNXCI6IFwiJmNjYXJvbjtcIixcbiAgICAgIFwiw6dcIjogXCImY2NlZGlsO1wiLFxuICAgICAgXCLEiVwiOiBcIiZjY2lyYztcIixcbiAgICAgIFwi4qmMXCI6IFwiJmNjdXBzO1wiLFxuICAgICAgXCLiqZBcIjogXCImY2N1cHNzbTtcIixcbiAgICAgIFwixItcIjogXCImY2RvdDtcIixcbiAgICAgIFwi4qayXCI6IFwiJmNlbXB0eXY7XCIsXG4gICAgICBcIsKiXCI6IFwiJmNlbnQ7XCIsXG4gICAgICBcIvCdlKBcIjogXCImY2ZyO1wiLFxuICAgICAgXCLRh1wiOiBcIiZjaGN5O1wiLFxuICAgICAgXCLinJNcIjogXCImY2hlY2ttYXJrO1wiLFxuICAgICAgXCLPh1wiOiBcIiZjaGk7XCIsXG4gICAgICBcIuKXi1wiOiBcIiZjaXI7XCIsXG4gICAgICBcIuKng1wiOiBcIiZjaXJFO1wiLFxuICAgICAgXCLLhlwiOiBcIiZjaXJjO1wiLFxuICAgICAgXCLiiZdcIjogXCImY2lyZTtcIixcbiAgICAgIFwi4oa6XCI6IFwiJm9sYXJyO1wiLFxuICAgICAgXCLihrtcIjogXCImb3JhcnI7XCIsXG4gICAgICBcIuKTiFwiOiBcIiZvUztcIixcbiAgICAgIFwi4oqbXCI6IFwiJm9hc3Q7XCIsXG4gICAgICBcIuKKmlwiOiBcIiZvY2lyO1wiLFxuICAgICAgXCLiip1cIjogXCImb2Rhc2g7XCIsXG4gICAgICBcIuKokFwiOiBcIiZjaXJmbmludDtcIixcbiAgICAgIFwi4quvXCI6IFwiJmNpcm1pZDtcIixcbiAgICAgIFwi4qeCXCI6IFwiJmNpcnNjaXI7XCIsXG4gICAgICBcIuKZo1wiOiBcIiZjbHVic3VpdDtcIixcbiAgICAgIFwiOlwiOiBcIiZjb2xvbjtcIixcbiAgICAgIFwiLFwiOiBcIiZjb21tYTtcIixcbiAgICAgIFwiQFwiOiBcIiZjb21tYXQ7XCIsXG4gICAgICBcIuKIgVwiOiBcIiZjb21wbGVtZW50O1wiLFxuICAgICAgXCLiqa1cIjogXCImY29uZ2RvdDtcIixcbiAgICAgIFwi8J2VlFwiOiBcIiZjb3BmO1wiLFxuICAgICAgXCLihJdcIjogXCImY29weXNyO1wiLFxuICAgICAgXCLihrVcIjogXCImY3JhcnI7XCIsXG4gICAgICBcIuKcl1wiOiBcIiZjcm9zcztcIixcbiAgICAgIFwi8J2SuFwiOiBcIiZjc2NyO1wiLFxuICAgICAgXCLiq49cIjogXCImY3N1YjtcIixcbiAgICAgIFwi4quRXCI6IFwiJmNzdWJlO1wiLFxuICAgICAgXCLiq5BcIjogXCImY3N1cDtcIixcbiAgICAgIFwi4quSXCI6IFwiJmNzdXBlO1wiLFxuICAgICAgXCLii69cIjogXCImY3Rkb3Q7XCIsXG4gICAgICBcIuKkuFwiOiBcIiZjdWRhcnJsO1wiLFxuICAgICAgXCLipLVcIjogXCImY3VkYXJycjtcIixcbiAgICAgIFwi4oueXCI6IFwiJmN1cmx5ZXFwcmVjO1wiLFxuICAgICAgXCLii59cIjogXCImY3VybHllcXN1Y2M7XCIsXG4gICAgICBcIuKGtlwiOiBcIiZjdXJ2ZWFycm93bGVmdDtcIixcbiAgICAgIFwi4qS9XCI6IFwiJmN1bGFycnA7XCIsXG4gICAgICBcIuKIqlwiOiBcIiZjdXA7XCIsXG4gICAgICBcIuKpiFwiOiBcIiZjdXBicmNhcDtcIixcbiAgICAgIFwi4qmGXCI6IFwiJmN1cGNhcDtcIixcbiAgICAgIFwi4qmKXCI6IFwiJmN1cGN1cDtcIixcbiAgICAgIFwi4oqNXCI6IFwiJmN1cGRvdDtcIixcbiAgICAgIFwi4qmFXCI6IFwiJmN1cG9yO1wiLFxuICAgICAgXCLiiKrvuIBcIjogXCImY3VwcztcIixcbiAgICAgIFwi4oa3XCI6IFwiJmN1cnZlYXJyb3dyaWdodDtcIixcbiAgICAgIFwi4qS8XCI6IFwiJmN1cmFycm07XCIsXG4gICAgICBcIuKLjlwiOiBcIiZjdXZlZTtcIixcbiAgICAgIFwi4ouPXCI6IFwiJmN1d2VkO1wiLFxuICAgICAgXCLCpFwiOiBcIiZjdXJyZW47XCIsXG4gICAgICBcIuKIsVwiOiBcIiZjd2ludDtcIixcbiAgICAgIFwi4oytXCI6IFwiJmN5bGN0eTtcIixcbiAgICAgIFwi4qWlXCI6IFwiJmRIYXI7XCIsXG4gICAgICBcIuKAoFwiOiBcIiZkYWdnZXI7XCIsXG4gICAgICBcIuKEuFwiOiBcIiZkYWxldGg7XCIsXG4gICAgICBcIuKAkFwiOiBcIiZoeXBoZW47XCIsXG4gICAgICBcIuKkj1wiOiBcIiZyQmFycjtcIixcbiAgICAgIFwixI9cIjogXCImZGNhcm9uO1wiLFxuICAgICAgXCLQtFwiOiBcIiZkY3k7XCIsXG4gICAgICBcIuKHilwiOiBcIiZkb3duZG93bmFycm93cztcIixcbiAgICAgIFwi4qm3XCI6IFwiJmVERG90O1wiLFxuICAgICAgXCLCsFwiOiBcIiZkZWc7XCIsXG4gICAgICBcIs60XCI6IFwiJmRlbHRhO1wiLFxuICAgICAgXCLiprFcIjogXCImZGVtcHR5djtcIixcbiAgICAgIFwi4qW/XCI6IFwiJmRmaXNodDtcIixcbiAgICAgIFwi8J2UoVwiOiBcIiZkZnI7XCIsXG4gICAgICBcIuKZplwiOiBcIiZkaWFtcztcIixcbiAgICAgIFwiz51cIjogXCImZ2FtbWFkO1wiLFxuICAgICAgXCLii7JcIjogXCImZGlzaW47XCIsXG4gICAgICBcIsO3XCI6IFwiJmRpdmlkZTtcIixcbiAgICAgIFwi4ouHXCI6IFwiJmRpdm9ueDtcIixcbiAgICAgIFwi0ZJcIjogXCImZGpjeTtcIixcbiAgICAgIFwi4oyeXCI6IFwiJmxsY29ybmVyO1wiLFxuICAgICAgXCLijI1cIjogXCImZGxjcm9wO1wiLFxuICAgICAgJDogXCImZG9sbGFyO1wiLFxuICAgICAgXCLwnZWVXCI6IFwiJmRvcGY7XCIsXG4gICAgICBcIuKJkVwiOiBcIiZlRG90O1wiLFxuICAgICAgXCLiiLhcIjogXCImbWludXNkO1wiLFxuICAgICAgXCLiiJRcIjogXCImcGx1c2RvO1wiLFxuICAgICAgXCLiiqFcIjogXCImc2RvdGI7XCIsXG4gICAgICBcIuKMn1wiOiBcIiZscmNvcm5lcjtcIixcbiAgICAgIFwi4oyMXCI6IFwiJmRyY3JvcDtcIixcbiAgICAgIFwi8J2SuVwiOiBcIiZkc2NyO1wiLFxuICAgICAgXCLRlVwiOiBcIiZkc2N5O1wiLFxuICAgICAgXCLip7ZcIjogXCImZHNvbDtcIixcbiAgICAgIFwixJFcIjogXCImZHN0cm9rO1wiLFxuICAgICAgXCLii7FcIjogXCImZHRkb3Q7XCIsXG4gICAgICBcIuKWv1wiOiBcIiZ0cmlhbmdsZWRvd247XCIsXG4gICAgICBcIuKmplwiOiBcIiZkd2FuZ2xlO1wiLFxuICAgICAgXCLRn1wiOiBcIiZkemN5O1wiLFxuICAgICAgXCLin79cIjogXCImZHppZ3JhcnI7XCIsXG4gICAgICBcIsOpXCI6IFwiJmVhY3V0ZTtcIixcbiAgICAgIFwi4qmuXCI6IFwiJmVhc3RlcjtcIixcbiAgICAgIFwixJtcIjogXCImZWNhcm9uO1wiLFxuICAgICAgXCLiiZZcIjogXCImZXFjaXJjO1wiLFxuICAgICAgXCLDqlwiOiBcIiZlY2lyYztcIixcbiAgICAgIFwi4omVXCI6IFwiJmVxY29sb247XCIsXG4gICAgICBcItGNXCI6IFwiJmVjeTtcIixcbiAgICAgIFwixJdcIjogXCImZWRvdDtcIixcbiAgICAgIFwi4omSXCI6IFwiJmZhbGxpbmdkb3RzZXE7XCIsXG4gICAgICBcIvCdlKJcIjogXCImZWZyO1wiLFxuICAgICAgXCLiqppcIjogXCImZWc7XCIsXG4gICAgICBcIsOoXCI6IFwiJmVncmF2ZTtcIixcbiAgICAgIFwi4qqWXCI6IFwiJmVxc2xhbnRndHI7XCIsXG4gICAgICBcIuKqmFwiOiBcIiZlZ3Nkb3Q7XCIsXG4gICAgICBcIuKqmVwiOiBcIiZlbDtcIixcbiAgICAgIFwi4o+nXCI6IFwiJmVsaW50ZXJzO1wiLFxuICAgICAgXCLihJNcIjogXCImZWxsO1wiLFxuICAgICAgXCLiqpVcIjogXCImZXFzbGFudGxlc3M7XCIsXG4gICAgICBcIuKql1wiOiBcIiZlbHNkb3Q7XCIsXG4gICAgICBcIsSTXCI6IFwiJmVtYWNyO1wiLFxuICAgICAgXCLiiIVcIjogXCImdmFybm90aGluZztcIixcbiAgICAgIFwi4oCEXCI6IFwiJmVtc3AxMztcIixcbiAgICAgIFwi4oCFXCI6IFwiJmVtc3AxNDtcIixcbiAgICAgIFwi4oCDXCI6IFwiJmVtc3A7XCIsXG4gICAgICBcIsWLXCI6IFwiJmVuZztcIixcbiAgICAgIFwi4oCCXCI6IFwiJmVuc3A7XCIsXG4gICAgICBcIsSZXCI6IFwiJmVvZ29uO1wiLFxuICAgICAgXCLwnZWWXCI6IFwiJmVvcGY7XCIsXG4gICAgICBcIuKLlVwiOiBcIiZlcGFyO1wiLFxuICAgICAgXCLip6NcIjogXCImZXBhcnNsO1wiLFxuICAgICAgXCLiqbFcIjogXCImZXBsdXM7XCIsXG4gICAgICBcIs61XCI6IFwiJmVwc2lsb247XCIsXG4gICAgICBcIs+1XCI6IFwiJnZhcmVwc2lsb247XCIsXG4gICAgICBcIj1cIjogXCImZXF1YWxzO1wiLFxuICAgICAgXCLiiZ9cIjogXCImcXVlc3RlcTtcIixcbiAgICAgIFwi4qm4XCI6IFwiJmVxdWl2REQ7XCIsXG4gICAgICBcIuKnpVwiOiBcIiZlcXZwYXJzbDtcIixcbiAgICAgIFwi4omTXCI6IFwiJnJpc2luZ2RvdHNlcTtcIixcbiAgICAgIFwi4qWxXCI6IFwiJmVyYXJyO1wiLFxuICAgICAgXCLihK9cIjogXCImZXNjcjtcIixcbiAgICAgIFwizrdcIjogXCImZXRhO1wiLFxuICAgICAgXCLDsFwiOiBcIiZldGg7XCIsXG4gICAgICBcIsOrXCI6IFwiJmV1bWw7XCIsXG4gICAgICBcIuKCrFwiOiBcIiZldXJvO1wiLFxuICAgICAgXCIhXCI6IFwiJmV4Y2w7XCIsXG4gICAgICBcItGEXCI6IFwiJmZjeTtcIixcbiAgICAgIFwi4pmAXCI6IFwiJmZlbWFsZTtcIixcbiAgICAgIFwi76yDXCI6IFwiJmZmaWxpZztcIixcbiAgICAgIFwi76yAXCI6IFwiJmZmbGlnO1wiLFxuICAgICAgXCLvrIRcIjogXCImZmZsbGlnO1wiLFxuICAgICAgXCLwnZSjXCI6IFwiJmZmcjtcIixcbiAgICAgIFwi76yBXCI6IFwiJmZpbGlnO1wiLFxuICAgICAgZmo6IFwiJmZqbGlnO1wiLFxuICAgICAgXCLima1cIjogXCImZmxhdDtcIixcbiAgICAgIFwi76yCXCI6IFwiJmZsbGlnO1wiLFxuICAgICAgXCLilrFcIjogXCImZmx0bnM7XCIsXG4gICAgICBcIsaSXCI6IFwiJmZub2Y7XCIsXG4gICAgICBcIvCdlZdcIjogXCImZm9wZjtcIixcbiAgICAgIFwi4ouUXCI6IFwiJnBpdGNoZm9yaztcIixcbiAgICAgIFwi4quZXCI6IFwiJmZvcmt2O1wiLFxuICAgICAgXCLiqI1cIjogXCImZnBhcnRpbnQ7XCIsXG4gICAgICBcIsK9XCI6IFwiJmhhbGY7XCIsXG4gICAgICBcIuKFk1wiOiBcIiZmcmFjMTM7XCIsXG4gICAgICBcIsK8XCI6IFwiJmZyYWMxNDtcIixcbiAgICAgIFwi4oWVXCI6IFwiJmZyYWMxNTtcIixcbiAgICAgIFwi4oWZXCI6IFwiJmZyYWMxNjtcIixcbiAgICAgIFwi4oWbXCI6IFwiJmZyYWMxODtcIixcbiAgICAgIFwi4oWUXCI6IFwiJmZyYWMyMztcIixcbiAgICAgIFwi4oWWXCI6IFwiJmZyYWMyNTtcIixcbiAgICAgIFwiwr5cIjogXCImZnJhYzM0O1wiLFxuICAgICAgXCLihZdcIjogXCImZnJhYzM1O1wiLFxuICAgICAgXCLihZxcIjogXCImZnJhYzM4O1wiLFxuICAgICAgXCLihZhcIjogXCImZnJhYzQ1O1wiLFxuICAgICAgXCLihZpcIjogXCImZnJhYzU2O1wiLFxuICAgICAgXCLihZ1cIjogXCImZnJhYzU4O1wiLFxuICAgICAgXCLihZ5cIjogXCImZnJhYzc4O1wiLFxuICAgICAgXCLigYRcIjogXCImZnJhc2w7XCIsXG4gICAgICBcIuKMolwiOiBcIiZzZnJvd247XCIsXG4gICAgICBcIvCdkrtcIjogXCImZnNjcjtcIixcbiAgICAgIFwi4qqMXCI6IFwiJmd0cmVxcWxlc3M7XCIsXG4gICAgICBcIse1XCI6IFwiJmdhY3V0ZTtcIixcbiAgICAgIFwizrNcIjogXCImZ2FtbWE7XCIsXG4gICAgICBcIuKqhlwiOiBcIiZndHJhcHByb3g7XCIsXG4gICAgICBcIsSfXCI6IFwiJmdicmV2ZTtcIixcbiAgICAgIFwixJ1cIjogXCImZ2NpcmM7XCIsXG4gICAgICBcItCzXCI6IFwiJmdjeTtcIixcbiAgICAgIFwixKFcIjogXCImZ2RvdDtcIixcbiAgICAgIFwi4qqpXCI6IFwiJmdlc2NjO1wiLFxuICAgICAgXCLiqoBcIjogXCImZ2VzZG90O1wiLFxuICAgICAgXCLiqoJcIjogXCImZ2VzZG90bztcIixcbiAgICAgIFwi4qqEXCI6IFwiJmdlc2RvdG9sO1wiLFxuICAgICAgXCLii5vvuIBcIjogXCImZ2VzbDtcIixcbiAgICAgIFwi4qqUXCI6IFwiJmdlc2xlcztcIixcbiAgICAgIFwi8J2UpFwiOiBcIiZnZnI7XCIsXG4gICAgICBcIuKEt1wiOiBcIiZnaW1lbDtcIixcbiAgICAgIFwi0ZNcIjogXCImZ2pjeTtcIixcbiAgICAgIFwi4qqSXCI6IFwiJmdsRTtcIixcbiAgICAgIFwi4qqlXCI6IFwiJmdsYTtcIixcbiAgICAgIFwi4qqkXCI6IFwiJmdsajtcIixcbiAgICAgIFwi4ompXCI6IFwiJmduZXFxO1wiLFxuICAgICAgXCLiqopcIjogXCImZ25hcHByb3g7XCIsXG4gICAgICBcIuKqiFwiOiBcIiZnbmVxO1wiLFxuICAgICAgXCLii6dcIjogXCImZ25zaW07XCIsXG4gICAgICBcIvCdlZhcIjogXCImZ29wZjtcIixcbiAgICAgIFwi4oSKXCI6IFwiJmdzY3I7XCIsXG4gICAgICBcIuKqjlwiOiBcIiZnc2ltZTtcIixcbiAgICAgIFwi4qqQXCI6IFwiJmdzaW1sO1wiLFxuICAgICAgXCLiqqdcIjogXCImZ3RjYztcIixcbiAgICAgIFwi4qm6XCI6IFwiJmd0Y2lyO1wiLFxuICAgICAgXCLii5dcIjogXCImZ3RyZG90O1wiLFxuICAgICAgXCLippVcIjogXCImZ3RsUGFyO1wiLFxuICAgICAgXCLiqbxcIjogXCImZ3RxdWVzdDtcIixcbiAgICAgIFwi4qW4XCI6IFwiJmd0cmFycjtcIixcbiAgICAgIFwi4omp77iAXCI6IFwiJmd2bkU7XCIsXG4gICAgICBcItGKXCI6IFwiJmhhcmRjeTtcIixcbiAgICAgIFwi4qWIXCI6IFwiJmhhcnJjaXI7XCIsXG4gICAgICBcIuKGrVwiOiBcIiZsZWZ0cmlnaHRzcXVpZ2Fycm93O1wiLFxuICAgICAgXCLihI9cIjogXCImcGxhbmt2O1wiLFxuICAgICAgXCLEpVwiOiBcIiZoY2lyYztcIixcbiAgICAgIFwi4pmlXCI6IFwiJmhlYXJ0c3VpdDtcIixcbiAgICAgIFwi4oCmXCI6IFwiJm1sZHI7XCIsXG4gICAgICBcIuKKuVwiOiBcIiZoZXJjb247XCIsXG4gICAgICBcIvCdlKVcIjogXCImaGZyO1wiLFxuICAgICAgXCLipKVcIjogXCImc2VhcmhrO1wiLFxuICAgICAgXCLipKZcIjogXCImc3dhcmhrO1wiLFxuICAgICAgXCLih79cIjogXCImaG9hcnI7XCIsXG4gICAgICBcIuKIu1wiOiBcIiZob210aHQ7XCIsXG4gICAgICBcIuKGqVwiOiBcIiZsYXJyaGs7XCIsXG4gICAgICBcIuKGqlwiOiBcIiZyYXJyaGs7XCIsXG4gICAgICBcIvCdlZlcIjogXCImaG9wZjtcIixcbiAgICAgIFwi4oCVXCI6IFwiJmhvcmJhcjtcIixcbiAgICAgIFwi8J2SvVwiOiBcIiZoc2NyO1wiLFxuICAgICAgXCLEp1wiOiBcIiZoc3Ryb2s7XCIsXG4gICAgICBcIuKBg1wiOiBcIiZoeWJ1bGw7XCIsXG4gICAgICBcIsOtXCI6IFwiJmlhY3V0ZTtcIixcbiAgICAgIFwiw65cIjogXCImaWNpcmM7XCIsXG4gICAgICBcItC4XCI6IFwiJmljeTtcIixcbiAgICAgIFwi0LVcIjogXCImaWVjeTtcIixcbiAgICAgIFwiwqFcIjogXCImaWV4Y2w7XCIsXG4gICAgICBcIvCdlKZcIjogXCImaWZyO1wiLFxuICAgICAgXCLDrFwiOiBcIiZpZ3JhdmU7XCIsXG4gICAgICBcIuKojFwiOiBcIiZxaW50O1wiLFxuICAgICAgXCLiiK1cIjogXCImdGludDtcIixcbiAgICAgIFwi4qecXCI6IFwiJmlpbmZpbjtcIixcbiAgICAgIFwi4oSpXCI6IFwiJmlpb3RhO1wiLFxuICAgICAgXCLEs1wiOiBcIiZpamxpZztcIixcbiAgICAgIFwixKtcIjogXCImaW1hY3I7XCIsXG4gICAgICBcIsSxXCI6IFwiJmlub2RvdDtcIixcbiAgICAgIFwi4oq3XCI6IFwiJmltb2Y7XCIsXG4gICAgICBcIsa1XCI6IFwiJmltcGVkO1wiLFxuICAgICAgXCLihIVcIjogXCImaW5jYXJlO1wiLFxuICAgICAgXCLiiJ5cIjogXCImaW5maW47XCIsXG4gICAgICBcIuKnnVwiOiBcIiZpbmZpbnRpZTtcIixcbiAgICAgIFwi4oq6XCI6IFwiJmludGVyY2FsO1wiLFxuICAgICAgXCLiqJdcIjogXCImaW50bGFyaGs7XCIsXG4gICAgICBcIuKovFwiOiBcIiZpcHJvZDtcIixcbiAgICAgIFwi0ZFcIjogXCImaW9jeTtcIixcbiAgICAgIFwixK9cIjogXCImaW9nb247XCIsXG4gICAgICBcIvCdlZpcIjogXCImaW9wZjtcIixcbiAgICAgIFwizrlcIjogXCImaW90YTtcIixcbiAgICAgIFwiwr9cIjogXCImaXF1ZXN0O1wiLFxuICAgICAgXCLwnZK+XCI6IFwiJmlzY3I7XCIsXG4gICAgICBcIuKLuVwiOiBcIiZpc2luRTtcIixcbiAgICAgIFwi4ou1XCI6IFwiJmlzaW5kb3Q7XCIsXG4gICAgICBcIuKLtFwiOiBcIiZpc2lucztcIixcbiAgICAgIFwi4ouzXCI6IFwiJmlzaW5zdjtcIixcbiAgICAgIFwixKlcIjogXCImaXRpbGRlO1wiLFxuICAgICAgXCLRllwiOiBcIiZpdWtjeTtcIixcbiAgICAgIFwiw69cIjogXCImaXVtbDtcIixcbiAgICAgIFwixLVcIjogXCImamNpcmM7XCIsXG4gICAgICBcItC5XCI6IFwiJmpjeTtcIixcbiAgICAgIFwi8J2Up1wiOiBcIiZqZnI7XCIsXG4gICAgICBcIsi3XCI6IFwiJmptYXRoO1wiLFxuICAgICAgXCLwnZWbXCI6IFwiJmpvcGY7XCIsXG4gICAgICBcIvCdkr9cIjogXCImanNjcjtcIixcbiAgICAgIFwi0ZhcIjogXCImanNlcmN5O1wiLFxuICAgICAgXCLRlFwiOiBcIiZqdWtjeTtcIixcbiAgICAgIFwizrpcIjogXCIma2FwcGE7XCIsXG4gICAgICBcIs+wXCI6IFwiJnZhcmthcHBhO1wiLFxuICAgICAgXCLEt1wiOiBcIiZrY2VkaWw7XCIsXG4gICAgICBcItC6XCI6IFwiJmtjeTtcIixcbiAgICAgIFwi8J2UqFwiOiBcIiZrZnI7XCIsXG4gICAgICBcIsS4XCI6IFwiJmtncmVlbjtcIixcbiAgICAgIFwi0YVcIjogXCIma2hjeTtcIixcbiAgICAgIFwi0ZxcIjogXCIma2pjeTtcIixcbiAgICAgIFwi8J2VnFwiOiBcIiZrb3BmO1wiLFxuICAgICAgXCLwnZOAXCI6IFwiJmtzY3I7XCIsXG4gICAgICBcIuKkm1wiOiBcIiZsQXRhaWw7XCIsXG4gICAgICBcIuKkjlwiOiBcIiZsQmFycjtcIixcbiAgICAgIFwi4qqLXCI6IFwiJmxlc3NlcXFndHI7XCIsXG4gICAgICBcIuKlolwiOiBcIiZsSGFyO1wiLFxuICAgICAgXCLEulwiOiBcIiZsYWN1dGU7XCIsXG4gICAgICBcIuKmtFwiOiBcIiZsYWVtcHR5djtcIixcbiAgICAgIFwizrtcIjogXCImbGFtYmRhO1wiLFxuICAgICAgXCLippFcIjogXCImbGFuZ2Q7XCIsXG4gICAgICBcIuKqhVwiOiBcIiZsZXNzYXBwcm94O1wiLFxuICAgICAgXCLCq1wiOiBcIiZsYXF1bztcIixcbiAgICAgIFwi4qSfXCI6IFwiJmxhcnJiZnM7XCIsXG4gICAgICBcIuKknVwiOiBcIiZsYXJyZnM7XCIsXG4gICAgICBcIuKGq1wiOiBcIiZsb29wYXJyb3dsZWZ0O1wiLFxuICAgICAgXCLipLlcIjogXCImbGFycnBsO1wiLFxuICAgICAgXCLipbNcIjogXCImbGFycnNpbTtcIixcbiAgICAgIFwi4oaiXCI6IFwiJmxlZnRhcnJvd3RhaWw7XCIsXG4gICAgICBcIuKqq1wiOiBcIiZsYXQ7XCIsXG4gICAgICBcIuKkmVwiOiBcIiZsYXRhaWw7XCIsXG4gICAgICBcIuKqrVwiOiBcIiZsYXRlO1wiLFxuICAgICAgXCLiqq3vuIBcIjogXCImbGF0ZXM7XCIsXG4gICAgICBcIuKkjFwiOiBcIiZsYmFycjtcIixcbiAgICAgIFwi4p2yXCI6IFwiJmxiYnJrO1wiLFxuICAgICAgXCJ7XCI6IFwiJmxjdWI7XCIsXG4gICAgICBcIltcIjogXCImbHNxYjtcIixcbiAgICAgIFwi4qaLXCI6IFwiJmxicmtlO1wiLFxuICAgICAgXCLipo9cIjogXCImbGJya3NsZDtcIixcbiAgICAgIFwi4qaNXCI6IFwiJmxicmtzbHU7XCIsXG4gICAgICBcIsS+XCI6IFwiJmxjYXJvbjtcIixcbiAgICAgIFwixLxcIjogXCImbGNlZGlsO1wiLFxuICAgICAgXCLQu1wiOiBcIiZsY3k7XCIsXG4gICAgICBcIuKktlwiOiBcIiZsZGNhO1wiLFxuICAgICAgXCLipadcIjogXCImbGRyZGhhcjtcIixcbiAgICAgIFwi4qWLXCI6IFwiJmxkcnVzaGFyO1wiLFxuICAgICAgXCLihrJcIjogXCImbGRzaDtcIixcbiAgICAgIFwi4omkXCI6IFwiJmxlcTtcIixcbiAgICAgIFwi4oeHXCI6IFwiJmxsYXJyO1wiLFxuICAgICAgXCLii4tcIjogXCImbHRocmVlO1wiLFxuICAgICAgXCLiqqhcIjogXCImbGVzY2M7XCIsXG4gICAgICBcIuKpv1wiOiBcIiZsZXNkb3Q7XCIsXG4gICAgICBcIuKqgVwiOiBcIiZsZXNkb3RvO1wiLFxuICAgICAgXCLiqoNcIjogXCImbGVzZG90b3I7XCIsXG4gICAgICBcIuKLmu+4gFwiOiBcIiZsZXNnO1wiLFxuICAgICAgXCLiqpNcIjogXCImbGVzZ2VzO1wiLFxuICAgICAgXCLii5ZcIjogXCImbHRkb3Q7XCIsXG4gICAgICBcIuKlvFwiOiBcIiZsZmlzaHQ7XCIsXG4gICAgICBcIvCdlKlcIjogXCImbGZyO1wiLFxuICAgICAgXCLiqpFcIjogXCImbGdFO1wiLFxuICAgICAgXCLipapcIjogXCImbGhhcnVsO1wiLFxuICAgICAgXCLiloRcIjogXCImbGhibGs7XCIsXG4gICAgICBcItGZXCI6IFwiJmxqY3k7XCIsXG4gICAgICBcIuKlq1wiOiBcIiZsbGhhcmQ7XCIsXG4gICAgICBcIuKXulwiOiBcIiZsbHRyaTtcIixcbiAgICAgIFwixYBcIjogXCImbG1pZG90O1wiLFxuICAgICAgXCLijrBcIjogXCImbG1vdXN0YWNoZTtcIixcbiAgICAgIFwi4omoXCI6IFwiJmxuZXFxO1wiLFxuICAgICAgXCLiqolcIjogXCImbG5hcHByb3g7XCIsXG4gICAgICBcIuKqh1wiOiBcIiZsbmVxO1wiLFxuICAgICAgXCLii6ZcIjogXCImbG5zaW07XCIsXG4gICAgICBcIuKfrFwiOiBcIiZsb2FuZztcIixcbiAgICAgIFwi4oe9XCI6IFwiJmxvYXJyO1wiLFxuICAgICAgXCLin7xcIjogXCImeG1hcDtcIixcbiAgICAgIFwi4oasXCI6IFwiJnJhcnJscDtcIixcbiAgICAgIFwi4qaFXCI6IFwiJmxvcGFyO1wiLFxuICAgICAgXCLwnZWdXCI6IFwiJmxvcGY7XCIsXG4gICAgICBcIuKorVwiOiBcIiZsb3BsdXM7XCIsXG4gICAgICBcIuKotFwiOiBcIiZsb3RpbWVzO1wiLFxuICAgICAgXCLiiJdcIjogXCImbG93YXN0O1wiLFxuICAgICAgXCLil4pcIjogXCImbG96ZW5nZTtcIixcbiAgICAgIFwiKFwiOiBcIiZscGFyO1wiLFxuICAgICAgXCLippNcIjogXCImbHBhcmx0O1wiLFxuICAgICAgXCLipa1cIjogXCImbHJoYXJkO1wiLFxuICAgICAgXCLigI5cIjogXCImbHJtO1wiLFxuICAgICAgXCLiir9cIjogXCImbHJ0cmk7XCIsXG4gICAgICBcIuKAuVwiOiBcIiZsc2FxdW87XCIsXG4gICAgICBcIvCdk4FcIjogXCImbHNjcjtcIixcbiAgICAgIFwi4qqNXCI6IFwiJmxzaW1lO1wiLFxuICAgICAgXCLiqo9cIjogXCImbHNpbWc7XCIsXG4gICAgICBcIuKAmlwiOiBcIiZzYnF1bztcIixcbiAgICAgIFwixYJcIjogXCImbHN0cm9rO1wiLFxuICAgICAgXCLiqqZcIjogXCImbHRjYztcIixcbiAgICAgIFwi4qm5XCI6IFwiJmx0Y2lyO1wiLFxuICAgICAgXCLii4lcIjogXCImbHRpbWVzO1wiLFxuICAgICAgXCLipbZcIjogXCImbHRsYXJyO1wiLFxuICAgICAgXCLiqbtcIjogXCImbHRxdWVzdDtcIixcbiAgICAgIFwi4qaWXCI6IFwiJmx0clBhcjtcIixcbiAgICAgIFwi4peDXCI6IFwiJnRyaWFuZ2xlbGVmdDtcIixcbiAgICAgIFwi4qWKXCI6IFwiJmx1cmRzaGFyO1wiLFxuICAgICAgXCLipaZcIjogXCImbHVydWhhcjtcIixcbiAgICAgIFwi4omo77iAXCI6IFwiJmx2bkU7XCIsXG4gICAgICBcIuKIulwiOiBcIiZtRERvdDtcIixcbiAgICAgIFwiwq9cIjogXCImc3RybnM7XCIsXG4gICAgICBcIuKZglwiOiBcIiZtYWxlO1wiLFxuICAgICAgXCLinKBcIjogXCImbWFsdGVzZTtcIixcbiAgICAgIFwi4pauXCI6IFwiJm1hcmtlcjtcIixcbiAgICAgIFwi4qipXCI6IFwiJm1jb21tYTtcIixcbiAgICAgIFwi0LxcIjogXCImbWN5O1wiLFxuICAgICAgXCLigJRcIjogXCImbWRhc2g7XCIsXG4gICAgICBcIvCdlKpcIjogXCImbWZyO1wiLFxuICAgICAgXCLihKdcIjogXCImbWhvO1wiLFxuICAgICAgXCLCtVwiOiBcIiZtaWNybztcIixcbiAgICAgIFwi4quwXCI6IFwiJm1pZGNpcjtcIixcbiAgICAgIFwi4oiSXCI6IFwiJm1pbnVzO1wiLFxuICAgICAgXCLiqKpcIjogXCImbWludXNkdTtcIixcbiAgICAgIFwi4qubXCI6IFwiJm1sY3A7XCIsXG4gICAgICBcIuKKp1wiOiBcIiZtb2RlbHM7XCIsXG4gICAgICBcIvCdlZ5cIjogXCImbW9wZjtcIixcbiAgICAgIFwi8J2TglwiOiBcIiZtc2NyO1wiLFxuICAgICAgXCLOvFwiOiBcIiZtdTtcIixcbiAgICAgIFwi4oq4XCI6IFwiJm11bWFwO1wiLFxuICAgICAgXCLii5nMuFwiOiBcIiZuR2c7XCIsXG4gICAgICBcIuKJq+KDklwiOiBcIiZuR3Q7XCIsXG4gICAgICBcIuKHjVwiOiBcIiZubEFycjtcIixcbiAgICAgIFwi4oeOXCI6IFwiJm5oQXJyO1wiLFxuICAgICAgXCLii5jMuFwiOiBcIiZuTGw7XCIsXG4gICAgICBcIuKJquKDklwiOiBcIiZuTHQ7XCIsXG4gICAgICBcIuKHj1wiOiBcIiZuckFycjtcIixcbiAgICAgIFwi4oqvXCI6IFwiJm5WRGFzaDtcIixcbiAgICAgIFwi4oquXCI6IFwiJm5WZGFzaDtcIixcbiAgICAgIFwixYRcIjogXCImbmFjdXRlO1wiLFxuICAgICAgXCLiiKDig5JcIjogXCImbmFuZztcIixcbiAgICAgIFwi4qmwzLhcIjogXCImbmFwRTtcIixcbiAgICAgIFwi4omLzLhcIjogXCImbmFwaWQ7XCIsXG4gICAgICBcIsWJXCI6IFwiJm5hcG9zO1wiLFxuICAgICAgXCLima5cIjogXCImbmF0dXJhbDtcIixcbiAgICAgIFwi4qmDXCI6IFwiJm5jYXA7XCIsXG4gICAgICBcIsWIXCI6IFwiJm5jYXJvbjtcIixcbiAgICAgIFwixYZcIjogXCImbmNlZGlsO1wiLFxuICAgICAgXCLiqa3MuFwiOiBcIiZuY29uZ2RvdDtcIixcbiAgICAgIFwi4qmCXCI6IFwiJm5jdXA7XCIsXG4gICAgICBcItC9XCI6IFwiJm5jeTtcIixcbiAgICAgIFwi4oCTXCI6IFwiJm5kYXNoO1wiLFxuICAgICAgXCLih5dcIjogXCImbmVBcnI7XCIsXG4gICAgICBcIuKkpFwiOiBcIiZuZWFyaGs7XCIsXG4gICAgICBcIuKJkMy4XCI6IFwiJm5lZG90O1wiLFxuICAgICAgXCLipKhcIjogXCImdG9lYTtcIixcbiAgICAgIFwi8J2Uq1wiOiBcIiZuZnI7XCIsXG4gICAgICBcIuKGrlwiOiBcIiZubGVmdHJpZ2h0YXJyb3c7XCIsXG4gICAgICBcIuKrslwiOiBcIiZuaHBhcjtcIixcbiAgICAgIFwi4ou8XCI6IFwiJm5pcztcIixcbiAgICAgIFwi4ou6XCI6IFwiJm5pc2Q7XCIsXG4gICAgICBcItGaXCI6IFwiJm5qY3k7XCIsXG4gICAgICBcIuKJpsy4XCI6IFwiJm5sZXFxO1wiLFxuICAgICAgXCLihppcIjogXCImbmxlZnRhcnJvdztcIixcbiAgICAgIFwi4oClXCI6IFwiJm5sZHI7XCIsXG4gICAgICBcIvCdlZ9cIjogXCImbm9wZjtcIixcbiAgICAgIFwiwqxcIjogXCImbm90O1wiLFxuICAgICAgXCLii7nMuFwiOiBcIiZub3RpbkU7XCIsXG4gICAgICBcIuKLtcy4XCI6IFwiJm5vdGluZG90O1wiLFxuICAgICAgXCLii7dcIjogXCImbm90aW52YjtcIixcbiAgICAgIFwi4ou2XCI6IFwiJm5vdGludmM7XCIsXG4gICAgICBcIuKLvlwiOiBcIiZub3RuaXZiO1wiLFxuICAgICAgXCLii71cIjogXCImbm90bml2YztcIixcbiAgICAgIFwi4qu94oOlXCI6IFwiJm5wYXJzbDtcIixcbiAgICAgIFwi4oiCzLhcIjogXCImbnBhcnQ7XCIsXG4gICAgICBcIuKolFwiOiBcIiZucG9saW50O1wiLFxuICAgICAgXCLihptcIjogXCImbnJpZ2h0YXJyb3c7XCIsXG4gICAgICBcIuKks8y4XCI6IFwiJm5yYXJyYztcIixcbiAgICAgIFwi4oadzLhcIjogXCImbnJhcnJ3O1wiLFxuICAgICAgXCLwnZODXCI6IFwiJm5zY3I7XCIsXG4gICAgICBcIuKKhFwiOiBcIiZuc3ViO1wiLFxuICAgICAgXCLiq4XMuFwiOiBcIiZuc3Vic2V0ZXFxO1wiLFxuICAgICAgXCLiioVcIjogXCImbnN1cDtcIixcbiAgICAgIFwi4quGzLhcIjogXCImbnN1cHNldGVxcTtcIixcbiAgICAgIFwiw7FcIjogXCImbnRpbGRlO1wiLFxuICAgICAgXCLOvVwiOiBcIiZudTtcIixcbiAgICAgIFwiI1wiOiBcIiZudW07XCIsXG4gICAgICBcIuKEllwiOiBcIiZudW1lcm87XCIsXG4gICAgICBcIuKAh1wiOiBcIiZudW1zcDtcIixcbiAgICAgIFwi4oqtXCI6IFwiJm52RGFzaDtcIixcbiAgICAgIFwi4qSEXCI6IFwiJm52SGFycjtcIixcbiAgICAgIFwi4omN4oOSXCI6IFwiJm52YXA7XCIsXG4gICAgICBcIuKKrFwiOiBcIiZudmRhc2g7XCIsXG4gICAgICBcIuKJpeKDklwiOiBcIiZudmdlO1wiLFxuICAgICAgXCI+4oOSXCI6IFwiJm52Z3Q7XCIsXG4gICAgICBcIuKnnlwiOiBcIiZudmluZmluO1wiLFxuICAgICAgXCLipIJcIjogXCImbnZsQXJyO1wiLFxuICAgICAgXCLiiaTig5JcIjogXCImbnZsZTtcIixcbiAgICAgIFwiPOKDklwiOiBcIiZudmx0O1wiLFxuICAgICAgXCLiirTig5JcIjogXCImbnZsdHJpZTtcIixcbiAgICAgIFwi4qSDXCI6IFwiJm52ckFycjtcIixcbiAgICAgIFwi4oq14oOSXCI6IFwiJm52cnRyaWU7XCIsXG4gICAgICBcIuKIvOKDklwiOiBcIiZudnNpbTtcIixcbiAgICAgIFwi4oeWXCI6IFwiJm53QXJyO1wiLFxuICAgICAgXCLipKNcIjogXCImbndhcmhrO1wiLFxuICAgICAgXCLipKdcIjogXCImbnduZWFyO1wiLFxuICAgICAgXCLDs1wiOiBcIiZvYWN1dGU7XCIsXG4gICAgICBcIsO0XCI6IFwiJm9jaXJjO1wiLFxuICAgICAgXCLQvlwiOiBcIiZvY3k7XCIsXG4gICAgICBcIsWRXCI6IFwiJm9kYmxhYztcIixcbiAgICAgIFwi4qi4XCI6IFwiJm9kaXY7XCIsXG4gICAgICBcIuKmvFwiOiBcIiZvZHNvbGQ7XCIsXG4gICAgICBcIsWTXCI6IFwiJm9lbGlnO1wiLFxuICAgICAgXCLipr9cIjogXCImb2ZjaXI7XCIsXG4gICAgICBcIvCdlKxcIjogXCImb2ZyO1wiLFxuICAgICAgXCLLm1wiOiBcIiZvZ29uO1wiLFxuICAgICAgXCLDslwiOiBcIiZvZ3JhdmU7XCIsXG4gICAgICBcIuKngVwiOiBcIiZvZ3Q7XCIsXG4gICAgICBcIuKmtVwiOiBcIiZvaGJhcjtcIixcbiAgICAgIFwi4qa+XCI6IFwiJm9sY2lyO1wiLFxuICAgICAgXCLiprtcIjogXCImb2xjcm9zcztcIixcbiAgICAgIFwi4qeAXCI6IFwiJm9sdDtcIixcbiAgICAgIFwixY1cIjogXCImb21hY3I7XCIsXG4gICAgICBcIs+JXCI6IFwiJm9tZWdhO1wiLFxuICAgICAgXCLOv1wiOiBcIiZvbWljcm9uO1wiLFxuICAgICAgXCLiprZcIjogXCImb21pZDtcIixcbiAgICAgIFwi8J2VoFwiOiBcIiZvb3BmO1wiLFxuICAgICAgXCLiprdcIjogXCImb3BhcjtcIixcbiAgICAgIFwi4qa5XCI6IFwiJm9wZXJwO1wiLFxuICAgICAgXCLiiKhcIjogXCImdmVlO1wiLFxuICAgICAgXCLiqZ1cIjogXCImb3JkO1wiLFxuICAgICAgXCLihLRcIjogXCImb3NjcjtcIixcbiAgICAgIFwiwqpcIjogXCImb3JkZjtcIixcbiAgICAgIFwiwrpcIjogXCImb3JkbTtcIixcbiAgICAgIFwi4oq2XCI6IFwiJm9yaWdvZjtcIixcbiAgICAgIFwi4qmWXCI6IFwiJm9yb3I7XCIsXG4gICAgICBcIuKpl1wiOiBcIiZvcnNsb3BlO1wiLFxuICAgICAgXCLiqZtcIjogXCImb3J2O1wiLFxuICAgICAgXCLDuFwiOiBcIiZvc2xhc2g7XCIsXG4gICAgICBcIuKKmFwiOiBcIiZvc29sO1wiLFxuICAgICAgXCLDtVwiOiBcIiZvdGlsZGU7XCIsXG4gICAgICBcIuKotlwiOiBcIiZvdGltZXNhcztcIixcbiAgICAgIFwiw7ZcIjogXCImb3VtbDtcIixcbiAgICAgIFwi4oy9XCI6IFwiJm92YmFyO1wiLFxuICAgICAgXCLCtlwiOiBcIiZwYXJhO1wiLFxuICAgICAgXCLiq7NcIjogXCImcGFyc2ltO1wiLFxuICAgICAgXCLiq71cIjogXCImcGFyc2w7XCIsXG4gICAgICBcItC/XCI6IFwiJnBjeTtcIixcbiAgICAgIFwiJVwiOiBcIiZwZXJjbnQ7XCIsXG4gICAgICBcIi5cIjogXCImcGVyaW9kO1wiLFxuICAgICAgXCLigLBcIjogXCImcGVybWlsO1wiLFxuICAgICAgXCLigLFcIjogXCImcGVydGVuaztcIixcbiAgICAgIFwi8J2UrVwiOiBcIiZwZnI7XCIsXG4gICAgICBcIs+GXCI6IFwiJnBoaTtcIixcbiAgICAgIFwiz5VcIjogXCImdmFycGhpO1wiLFxuICAgICAgXCLimI5cIjogXCImcGhvbmU7XCIsXG4gICAgICBcIs+AXCI6IFwiJnBpO1wiLFxuICAgICAgXCLPllwiOiBcIiZ2YXJwaTtcIixcbiAgICAgIFwi4oSOXCI6IFwiJnBsYW5ja2g7XCIsXG4gICAgICBcIitcIjogXCImcGx1cztcIixcbiAgICAgIFwi4qijXCI6IFwiJnBsdXNhY2lyO1wiLFxuICAgICAgXCLiqKJcIjogXCImcGx1c2NpcjtcIixcbiAgICAgIFwi4qilXCI6IFwiJnBsdXNkdTtcIixcbiAgICAgIFwi4qmyXCI6IFwiJnBsdXNlO1wiLFxuICAgICAgXCLiqKZcIjogXCImcGx1c3NpbTtcIixcbiAgICAgIFwi4qinXCI6IFwiJnBsdXN0d287XCIsXG4gICAgICBcIuKolVwiOiBcIiZwb2ludGludDtcIixcbiAgICAgIFwi8J2VoVwiOiBcIiZwb3BmO1wiLFxuICAgICAgXCLCo1wiOiBcIiZwb3VuZDtcIixcbiAgICAgIFwi4qqzXCI6IFwiJnByRTtcIixcbiAgICAgIFwi4qq3XCI6IFwiJnByZWNhcHByb3g7XCIsXG4gICAgICBcIuKquVwiOiBcIiZwcm5hcDtcIixcbiAgICAgIFwi4qq1XCI6IFwiJnBybkU7XCIsXG4gICAgICBcIuKLqFwiOiBcIiZwcm5zaW07XCIsXG4gICAgICBcIuKAslwiOiBcIiZwcmltZTtcIixcbiAgICAgIFwi4oyuXCI6IFwiJnByb2ZhbGFyO1wiLFxuICAgICAgXCLijJJcIjogXCImcHJvZmxpbmU7XCIsXG4gICAgICBcIuKMk1wiOiBcIiZwcm9mc3VyZjtcIixcbiAgICAgIFwi4oqwXCI6IFwiJnBydXJlbDtcIixcbiAgICAgIFwi8J2ThVwiOiBcIiZwc2NyO1wiLFxuICAgICAgXCLPiFwiOiBcIiZwc2k7XCIsXG4gICAgICBcIuKAiFwiOiBcIiZwdW5jc3A7XCIsXG4gICAgICBcIvCdlK5cIjogXCImcWZyO1wiLFxuICAgICAgXCLwnZWiXCI6IFwiJnFvcGY7XCIsXG4gICAgICBcIuKBl1wiOiBcIiZxcHJpbWU7XCIsXG4gICAgICBcIvCdk4ZcIjogXCImcXNjcjtcIixcbiAgICAgIFwi4qiWXCI6IFwiJnF1YXRpbnQ7XCIsXG4gICAgICBcIj9cIjogXCImcXVlc3Q7XCIsXG4gICAgICBcIuKknFwiOiBcIiZyQXRhaWw7XCIsXG4gICAgICBcIuKlpFwiOiBcIiZySGFyO1wiLFxuICAgICAgXCLiiL3MsVwiOiBcIiZyYWNlO1wiLFxuICAgICAgXCLFlVwiOiBcIiZyYWN1dGU7XCIsXG4gICAgICBcIuKms1wiOiBcIiZyYWVtcHR5djtcIixcbiAgICAgIFwi4qaSXCI6IFwiJnJhbmdkO1wiLFxuICAgICAgXCLipqVcIjogXCImcmFuZ2U7XCIsXG4gICAgICBcIsK7XCI6IFwiJnJhcXVvO1wiLFxuICAgICAgXCLipbVcIjogXCImcmFycmFwO1wiLFxuICAgICAgXCLipKBcIjogXCImcmFycmJmcztcIixcbiAgICAgIFwi4qSzXCI6IFwiJnJhcnJjO1wiLFxuICAgICAgXCLipJ5cIjogXCImcmFycmZzO1wiLFxuICAgICAgXCLipYVcIjogXCImcmFycnBsO1wiLFxuICAgICAgXCLipbRcIjogXCImcmFycnNpbTtcIixcbiAgICAgIFwi4oajXCI6IFwiJnJpZ2h0YXJyb3d0YWlsO1wiLFxuICAgICAgXCLihp1cIjogXCImcmlnaHRzcXVpZ2Fycm93O1wiLFxuICAgICAgXCLipJpcIjogXCImcmF0YWlsO1wiLFxuICAgICAgXCLiiLZcIjogXCImcmF0aW87XCIsXG4gICAgICBcIuKds1wiOiBcIiZyYmJyaztcIixcbiAgICAgIFwifVwiOiBcIiZyY3ViO1wiLFxuICAgICAgXCJdXCI6IFwiJnJzcWI7XCIsXG4gICAgICBcIuKmjFwiOiBcIiZyYnJrZTtcIixcbiAgICAgIFwi4qaOXCI6IFwiJnJicmtzbGQ7XCIsXG4gICAgICBcIuKmkFwiOiBcIiZyYnJrc2x1O1wiLFxuICAgICAgXCLFmVwiOiBcIiZyY2Fyb247XCIsXG4gICAgICBcIsWXXCI6IFwiJnJjZWRpbDtcIixcbiAgICAgIFwi0YBcIjogXCImcmN5O1wiLFxuICAgICAgXCLipLdcIjogXCImcmRjYTtcIixcbiAgICAgIFwi4qWpXCI6IFwiJnJkbGRoYXI7XCIsXG4gICAgICBcIuKGs1wiOiBcIiZyZHNoO1wiLFxuICAgICAgXCLilq1cIjogXCImcmVjdDtcIixcbiAgICAgIFwi4qW9XCI6IFwiJnJmaXNodDtcIixcbiAgICAgIFwi8J2Ur1wiOiBcIiZyZnI7XCIsXG4gICAgICBcIuKlrFwiOiBcIiZyaGFydWw7XCIsXG4gICAgICBcIs+BXCI6IFwiJnJobztcIixcbiAgICAgIFwiz7FcIjogXCImdmFycmhvO1wiLFxuICAgICAgXCLih4lcIjogXCImcnJhcnI7XCIsXG4gICAgICBcIuKLjFwiOiBcIiZydGhyZWU7XCIsXG4gICAgICBcIsuaXCI6IFwiJnJpbmc7XCIsXG4gICAgICBcIuKAj1wiOiBcIiZybG07XCIsXG4gICAgICBcIuKOsVwiOiBcIiZybW91c3RhY2hlO1wiLFxuICAgICAgXCLiq65cIjogXCImcm5taWQ7XCIsXG4gICAgICBcIuKfrVwiOiBcIiZyb2FuZztcIixcbiAgICAgIFwi4oe+XCI6IFwiJnJvYXJyO1wiLFxuICAgICAgXCLipoZcIjogXCImcm9wYXI7XCIsXG4gICAgICBcIvCdlaNcIjogXCImcm9wZjtcIixcbiAgICAgIFwi4qiuXCI6IFwiJnJvcGx1cztcIixcbiAgICAgIFwi4qi1XCI6IFwiJnJvdGltZXM7XCIsXG4gICAgICBcIilcIjogXCImcnBhcjtcIixcbiAgICAgIFwi4qaUXCI6IFwiJnJwYXJndDtcIixcbiAgICAgIFwi4qiSXCI6IFwiJnJwcG9saW50O1wiLFxuICAgICAgXCLigLpcIjogXCImcnNhcXVvO1wiLFxuICAgICAgXCLwnZOHXCI6IFwiJnJzY3I7XCIsXG4gICAgICBcIuKLilwiOiBcIiZydGltZXM7XCIsXG4gICAgICBcIuKWuVwiOiBcIiZ0cmlhbmdsZXJpZ2h0O1wiLFxuICAgICAgXCLip45cIjogXCImcnRyaWx0cmk7XCIsXG4gICAgICBcIuKlqFwiOiBcIiZydWx1aGFyO1wiLFxuICAgICAgXCLihJ5cIjogXCImcng7XCIsXG4gICAgICBcIsWbXCI6IFwiJnNhY3V0ZTtcIixcbiAgICAgIFwi4qq0XCI6IFwiJnNjRTtcIixcbiAgICAgIFwi4qq4XCI6IFwiJnN1Y2NhcHByb3g7XCIsXG4gICAgICBcIsWhXCI6IFwiJnNjYXJvbjtcIixcbiAgICAgIFwixZ9cIjogXCImc2NlZGlsO1wiLFxuICAgICAgXCLFnVwiOiBcIiZzY2lyYztcIixcbiAgICAgIFwi4qq2XCI6IFwiJnN1Y2NuZXFxO1wiLFxuICAgICAgXCLiqrpcIjogXCImc3VjY25hcHByb3g7XCIsXG4gICAgICBcIuKLqVwiOiBcIiZzdWNjbnNpbTtcIixcbiAgICAgIFwi4qiTXCI6IFwiJnNjcG9saW50O1wiLFxuICAgICAgXCLRgVwiOiBcIiZzY3k7XCIsXG4gICAgICBcIuKLhVwiOiBcIiZzZG90O1wiLFxuICAgICAgXCLiqaZcIjogXCImc2RvdGU7XCIsXG4gICAgICBcIuKHmFwiOiBcIiZzZUFycjtcIixcbiAgICAgIFwiwqdcIjogXCImc2VjdDtcIixcbiAgICAgIFwiO1wiOiBcIiZzZW1pO1wiLFxuICAgICAgXCLipKlcIjogXCImdG9zYTtcIixcbiAgICAgIFwi4py2XCI6IFwiJnNleHQ7XCIsXG4gICAgICBcIvCdlLBcIjogXCImc2ZyO1wiLFxuICAgICAgXCLima9cIjogXCImc2hhcnA7XCIsXG4gICAgICBcItGJXCI6IFwiJnNoY2hjeTtcIixcbiAgICAgIFwi0YhcIjogXCImc2hjeTtcIixcbiAgICAgIFwiwq1cIjogXCImc2h5O1wiLFxuICAgICAgXCLPg1wiOiBcIiZzaWdtYTtcIixcbiAgICAgIFwiz4JcIjogXCImdmFyc2lnbWE7XCIsXG4gICAgICBcIuKpqlwiOiBcIiZzaW1kb3Q7XCIsXG4gICAgICBcIuKqnlwiOiBcIiZzaW1nO1wiLFxuICAgICAgXCLiqqBcIjogXCImc2ltZ0U7XCIsXG4gICAgICBcIuKqnVwiOiBcIiZzaW1sO1wiLFxuICAgICAgXCLiqp9cIjogXCImc2ltbEU7XCIsXG4gICAgICBcIuKJhlwiOiBcIiZzaW1uZTtcIixcbiAgICAgIFwi4qikXCI6IFwiJnNpbXBsdXM7XCIsXG4gICAgICBcIuKlslwiOiBcIiZzaW1yYXJyO1wiLFxuICAgICAgXCLiqLNcIjogXCImc21hc2hwO1wiLFxuICAgICAgXCLip6RcIjogXCImc21lcGFyc2w7XCIsXG4gICAgICBcIuKMo1wiOiBcIiZzc21pbGU7XCIsXG4gICAgICBcIuKqqlwiOiBcIiZzbXQ7XCIsXG4gICAgICBcIuKqrFwiOiBcIiZzbXRlO1wiLFxuICAgICAgXCLiqqzvuIBcIjogXCImc210ZXM7XCIsXG4gICAgICBcItGMXCI6IFwiJnNvZnRjeTtcIixcbiAgICAgIFwiL1wiOiBcIiZzb2w7XCIsXG4gICAgICBcIuKnhFwiOiBcIiZzb2xiO1wiLFxuICAgICAgXCLijL9cIjogXCImc29sYmFyO1wiLFxuICAgICAgXCLwnZWkXCI6IFwiJnNvcGY7XCIsXG4gICAgICBcIuKZoFwiOiBcIiZzcGFkZXN1aXQ7XCIsXG4gICAgICBcIuKKk++4gFwiOiBcIiZzcWNhcHM7XCIsXG4gICAgICBcIuKKlO+4gFwiOiBcIiZzcWN1cHM7XCIsXG4gICAgICBcIvCdk4hcIjogXCImc3NjcjtcIixcbiAgICAgIFwi4piGXCI6IFwiJnN0YXI7XCIsXG4gICAgICBcIuKKglwiOiBcIiZzdWJzZXQ7XCIsXG4gICAgICBcIuKrhVwiOiBcIiZzdWJzZXRlcXE7XCIsXG4gICAgICBcIuKqvVwiOiBcIiZzdWJkb3Q7XCIsXG4gICAgICBcIuKrg1wiOiBcIiZzdWJlZG90O1wiLFxuICAgICAgXCLiq4FcIjogXCImc3VibXVsdDtcIixcbiAgICAgIFwi4quLXCI6IFwiJnN1YnNldG5lcXE7XCIsXG4gICAgICBcIuKKilwiOiBcIiZzdWJzZXRuZXE7XCIsXG4gICAgICBcIuKqv1wiOiBcIiZzdWJwbHVzO1wiLFxuICAgICAgXCLipblcIjogXCImc3VicmFycjtcIixcbiAgICAgIFwi4quHXCI6IFwiJnN1YnNpbTtcIixcbiAgICAgIFwi4quVXCI6IFwiJnN1YnN1YjtcIixcbiAgICAgIFwi4quTXCI6IFwiJnN1YnN1cDtcIixcbiAgICAgIFwi4pmqXCI6IFwiJnN1bmc7XCIsXG4gICAgICBcIsK5XCI6IFwiJnN1cDE7XCIsXG4gICAgICBcIsKyXCI6IFwiJnN1cDI7XCIsXG4gICAgICBcIsKzXCI6IFwiJnN1cDM7XCIsXG4gICAgICBcIuKrhlwiOiBcIiZzdXBzZXRlcXE7XCIsXG4gICAgICBcIuKqvlwiOiBcIiZzdXBkb3Q7XCIsXG4gICAgICBcIuKrmFwiOiBcIiZzdXBkc3ViO1wiLFxuICAgICAgXCLiq4RcIjogXCImc3VwZWRvdDtcIixcbiAgICAgIFwi4p+JXCI6IFwiJnN1cGhzb2w7XCIsXG4gICAgICBcIuKrl1wiOiBcIiZzdXBoc3ViO1wiLFxuICAgICAgXCLipbtcIjogXCImc3VwbGFycjtcIixcbiAgICAgIFwi4quCXCI6IFwiJnN1cG11bHQ7XCIsXG4gICAgICBcIuKrjFwiOiBcIiZzdXBzZXRuZXFxO1wiLFxuICAgICAgXCLiiotcIjogXCImc3Vwc2V0bmVxO1wiLFxuICAgICAgXCLiq4BcIjogXCImc3VwcGx1cztcIixcbiAgICAgIFwi4quIXCI6IFwiJnN1cHNpbTtcIixcbiAgICAgIFwi4quUXCI6IFwiJnN1cHN1YjtcIixcbiAgICAgIFwi4quWXCI6IFwiJnN1cHN1cDtcIixcbiAgICAgIFwi4oeZXCI6IFwiJnN3QXJyO1wiLFxuICAgICAgXCLipKpcIjogXCImc3dud2FyO1wiLFxuICAgICAgXCLDn1wiOiBcIiZzemxpZztcIixcbiAgICAgIFwi4oyWXCI6IFwiJnRhcmdldDtcIixcbiAgICAgIFwiz4RcIjogXCImdGF1O1wiLFxuICAgICAgXCLFpVwiOiBcIiZ0Y2Fyb247XCIsXG4gICAgICBcIsWjXCI6IFwiJnRjZWRpbDtcIixcbiAgICAgIFwi0YJcIjogXCImdGN5O1wiLFxuICAgICAgXCLijJVcIjogXCImdGVscmVjO1wiLFxuICAgICAgXCLwnZSxXCI6IFwiJnRmcjtcIixcbiAgICAgIFwizrhcIjogXCImdGhldGE7XCIsXG4gICAgICBcIs+RXCI6IFwiJnZhcnRoZXRhO1wiLFxuICAgICAgXCLDvlwiOiBcIiZ0aG9ybjtcIixcbiAgICAgIFwiw5dcIjogXCImdGltZXM7XCIsXG4gICAgICBcIuKosVwiOiBcIiZ0aW1lc2JhcjtcIixcbiAgICAgIFwi4qiwXCI6IFwiJnRpbWVzZDtcIixcbiAgICAgIFwi4oy2XCI6IFwiJnRvcGJvdDtcIixcbiAgICAgIFwi4quxXCI6IFwiJnRvcGNpcjtcIixcbiAgICAgIFwi8J2VpVwiOiBcIiZ0b3BmO1wiLFxuICAgICAgXCLiq5pcIjogXCImdG9wZm9yaztcIixcbiAgICAgIFwi4oC0XCI6IFwiJnRwcmltZTtcIixcbiAgICAgIFwi4pa1XCI6IFwiJnV0cmk7XCIsXG4gICAgICBcIuKJnFwiOiBcIiZ0cmllO1wiLFxuICAgICAgXCLil6xcIjogXCImdHJpZG90O1wiLFxuICAgICAgXCLiqLpcIjogXCImdHJpbWludXM7XCIsXG4gICAgICBcIuKouVwiOiBcIiZ0cmlwbHVzO1wiLFxuICAgICAgXCLip41cIjogXCImdHJpc2I7XCIsXG4gICAgICBcIuKou1wiOiBcIiZ0cml0aW1lO1wiLFxuICAgICAgXCLij6JcIjogXCImdHJwZXppdW07XCIsXG4gICAgICBcIvCdk4lcIjogXCImdHNjcjtcIixcbiAgICAgIFwi0YZcIjogXCImdHNjeTtcIixcbiAgICAgIFwi0ZtcIjogXCImdHNoY3k7XCIsXG4gICAgICBcIsWnXCI6IFwiJnRzdHJvaztcIixcbiAgICAgIFwi4qWjXCI6IFwiJnVIYXI7XCIsXG4gICAgICBcIsO6XCI6IFwiJnVhY3V0ZTtcIixcbiAgICAgIFwi0Z5cIjogXCImdWJyY3k7XCIsXG4gICAgICBcIsWtXCI6IFwiJnVicmV2ZTtcIixcbiAgICAgIFwiw7tcIjogXCImdWNpcmM7XCIsXG4gICAgICBcItGDXCI6IFwiJnVjeTtcIixcbiAgICAgIFwixbFcIjogXCImdWRibGFjO1wiLFxuICAgICAgXCLipb5cIjogXCImdWZpc2h0O1wiLFxuICAgICAgXCLwnZSyXCI6IFwiJnVmcjtcIixcbiAgICAgIFwiw7lcIjogXCImdWdyYXZlO1wiLFxuICAgICAgXCLiloBcIjogXCImdWhibGs7XCIsXG4gICAgICBcIuKMnFwiOiBcIiZ1bGNvcm5lcjtcIixcbiAgICAgIFwi4oyPXCI6IFwiJnVsY3JvcDtcIixcbiAgICAgIFwi4pe4XCI6IFwiJnVsdHJpO1wiLFxuICAgICAgXCLFq1wiOiBcIiZ1bWFjcjtcIixcbiAgICAgIFwixbNcIjogXCImdW9nb247XCIsXG4gICAgICBcIvCdlaZcIjogXCImdW9wZjtcIixcbiAgICAgIFwiz4VcIjogXCImdXBzaWxvbjtcIixcbiAgICAgIFwi4oeIXCI6IFwiJnV1YXJyO1wiLFxuICAgICAgXCLijJ1cIjogXCImdXJjb3JuZXI7XCIsXG4gICAgICBcIuKMjlwiOiBcIiZ1cmNyb3A7XCIsXG4gICAgICBcIsWvXCI6IFwiJnVyaW5nO1wiLFxuICAgICAgXCLil7lcIjogXCImdXJ0cmk7XCIsXG4gICAgICBcIvCdk4pcIjogXCImdXNjcjtcIixcbiAgICAgIFwi4ouwXCI6IFwiJnV0ZG90O1wiLFxuICAgICAgXCLFqVwiOiBcIiZ1dGlsZGU7XCIsXG4gICAgICBcIsO8XCI6IFwiJnV1bWw7XCIsXG4gICAgICBcIuKmp1wiOiBcIiZ1d2FuZ2xlO1wiLFxuICAgICAgXCLiq6hcIjogXCImdkJhcjtcIixcbiAgICAgIFwi4qupXCI6IFwiJnZCYXJ2O1wiLFxuICAgICAgXCLippxcIjogXCImdmFuZ3J0O1wiLFxuICAgICAgXCLiiorvuIBcIjogXCImdnN1Ym5lO1wiLFxuICAgICAgXCLiq4vvuIBcIjogXCImdnN1Ym5FO1wiLFxuICAgICAgXCLiiovvuIBcIjogXCImdnN1cG5lO1wiLFxuICAgICAgXCLiq4zvuIBcIjogXCImdnN1cG5FO1wiLFxuICAgICAgXCLQslwiOiBcIiZ2Y3k7XCIsXG4gICAgICBcIuKKu1wiOiBcIiZ2ZWViYXI7XCIsXG4gICAgICBcIuKJmlwiOiBcIiZ2ZWVlcTtcIixcbiAgICAgIFwi4ouuXCI6IFwiJnZlbGxpcDtcIixcbiAgICAgIFwi8J2Us1wiOiBcIiZ2ZnI7XCIsXG4gICAgICBcIvCdladcIjogXCImdm9wZjtcIixcbiAgICAgIFwi8J2Ti1wiOiBcIiZ2c2NyO1wiLFxuICAgICAgXCLipppcIjogXCImdnppZ3phZztcIixcbiAgICAgIFwixbVcIjogXCImd2NpcmM7XCIsXG4gICAgICBcIuKpn1wiOiBcIiZ3ZWRiYXI7XCIsXG4gICAgICBcIuKJmVwiOiBcIiZ3ZWRnZXE7XCIsXG4gICAgICBcIuKEmFwiOiBcIiZ3cDtcIixcbiAgICAgIFwi8J2UtFwiOiBcIiZ3ZnI7XCIsXG4gICAgICBcIvCdlahcIjogXCImd29wZjtcIixcbiAgICAgIFwi8J2TjFwiOiBcIiZ3c2NyO1wiLFxuICAgICAgXCLwnZS1XCI6IFwiJnhmcjtcIixcbiAgICAgIFwizr5cIjogXCImeGk7XCIsXG4gICAgICBcIuKLu1wiOiBcIiZ4bmlzO1wiLFxuICAgICAgXCLwnZWpXCI6IFwiJnhvcGY7XCIsXG4gICAgICBcIvCdk41cIjogXCImeHNjcjtcIixcbiAgICAgIFwiw71cIjogXCImeWFjdXRlO1wiLFxuICAgICAgXCLRj1wiOiBcIiZ5YWN5O1wiLFxuICAgICAgXCLFt1wiOiBcIiZ5Y2lyYztcIixcbiAgICAgIFwi0YtcIjogXCImeWN5O1wiLFxuICAgICAgXCLCpVwiOiBcIiZ5ZW47XCIsXG4gICAgICBcIvCdlLZcIjogXCImeWZyO1wiLFxuICAgICAgXCLRl1wiOiBcIiZ5aWN5O1wiLFxuICAgICAgXCLwnZWqXCI6IFwiJnlvcGY7XCIsXG4gICAgICBcIvCdk45cIjogXCImeXNjcjtcIixcbiAgICAgIFwi0Y5cIjogXCImeXVjeTtcIixcbiAgICAgIFwiw79cIjogXCImeXVtbDtcIixcbiAgICAgIFwixbpcIjogXCImemFjdXRlO1wiLFxuICAgICAgXCLFvlwiOiBcIiZ6Y2Fyb247XCIsXG4gICAgICBcItC3XCI6IFwiJnpjeTtcIixcbiAgICAgIFwixbxcIjogXCImemRvdDtcIixcbiAgICAgIFwizrZcIjogXCImemV0YTtcIixcbiAgICAgIFwi8J2Ut1wiOiBcIiZ6ZnI7XCIsXG4gICAgICBcItC2XCI6IFwiJnpoY3k7XCIsXG4gICAgICBcIuKHnVwiOiBcIiZ6aWdyYXJyO1wiLFxuICAgICAgXCLwnZWrXCI6IFwiJnpvcGY7XCIsXG4gICAgICBcIvCdk49cIjogXCImenNjcjtcIixcbiAgICAgIFwi4oCNXCI6IFwiJnp3ajtcIixcbiAgICAgIFwi4oCMXCI6IFwiJnp3bmo7XCJcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/named-references.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/numeric-unicode-map.js":
/*!***************************************************************!*\
  !*** ./node_modules/html-entities/lib/numeric-unicode-map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.numericUnicodeMap = {\n  0: 65533,\n  128: 8364,\n  130: 8218,\n  131: 402,\n  132: 8222,\n  133: 8230,\n  134: 8224,\n  135: 8225,\n  136: 710,\n  137: 8240,\n  138: 352,\n  139: 8249,\n  140: 338,\n  142: 381,\n  145: 8216,\n  146: 8217,\n  147: 8220,\n  148: 8221,\n  149: 8226,\n  150: 8211,\n  151: 8212,\n  152: 732,\n  153: 8482,\n  154: 353,\n  155: 8250,\n  156: 339,\n  158: 382,\n  159: 376\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbnVtZXJpYy11bmljb2RlLW1hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbnVtZXJpYy11bmljb2RlLW1hcC5qcz9kMDRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5udW1lcmljVW5pY29kZU1hcCA9IHtcbiAgMDogNjU1MzMsXG4gIDEyODogODM2NCxcbiAgMTMwOiA4MjE4LFxuICAxMzE6IDQwMixcbiAgMTMyOiA4MjIyLFxuICAxMzM6IDgyMzAsXG4gIDEzNDogODIyNCxcbiAgMTM1OiA4MjI1LFxuICAxMzY6IDcxMCxcbiAgMTM3OiA4MjQwLFxuICAxMzg6IDM1MixcbiAgMTM5OiA4MjQ5LFxuICAxNDA6IDMzOCxcbiAgMTQyOiAzODEsXG4gIDE0NTogODIxNixcbiAgMTQ2OiA4MjE3LFxuICAxNDc6IDgyMjAsXG4gIDE0ODogODIyMSxcbiAgMTQ5OiA4MjI2LFxuICAxNTA6IDgyMTEsXG4gIDE1MTogODIxMixcbiAgMTUyOiA3MzIsXG4gIDE1MzogODQ4MixcbiAgMTU0OiAzNTMsXG4gIDE1NTogODI1MCxcbiAgMTU2OiAzMzksXG4gIDE1ODogMzgyLFxuICAxNTk6IDM3NlxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/numeric-unicode-map.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {\n  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);\n};\nexports.getCodePoint = String.prototype.codePointAt ? function (input, position) {\n  return input.codePointAt(position);\n} : function (input, position) {\n  return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;\n};\nexports.highSurrogateFrom = 55296;\nexports.highSurrogateTo = 56319;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9zdXJyb2dhdGUtcGFpcnMuanM/OWVhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50IHx8IGZ1bmN0aW9uIChhc3RyYWxDb2RlUG9pbnQpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5mbG9vcigoYXN0cmFsQ29kZVBvaW50IC0gNjU1MzYpIC8gMTAyNCkgKyA1NTI5NiwgKGFzdHJhbENvZGVQb2ludCAtIDY1NTM2KSAlIDEwMjQgKyA1NjMyMCk7XG59O1xuZXhwb3J0cy5nZXRDb2RlUG9pbnQgPSBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID8gZnVuY3Rpb24gKGlucHV0LCBwb3NpdGlvbikge1xuICByZXR1cm4gaW5wdXQuY29kZVBvaW50QXQocG9zaXRpb24pO1xufSA6IGZ1bmN0aW9uIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIChpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKSAtIDU1Mjk2KSAqIDEwMjQgKyBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkgLSA1NjMyMCArIDY1NTM2O1xufTtcbmV4cG9ydHMuaGlnaFN1cnJvZ2F0ZUZyb20gPSA1NTI5NjtcbmV4cG9ydHMuaGlnaFN1cnJvZ2F0ZVRvID0gNTYzMTk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/surrogate-pairs.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=true;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_SCOPE_TYPE=Symbol.for('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol.for('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol.for('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol.for('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if(typeof Reflect==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(typeof type==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp */ /**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n */ /**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(typeof props.dangerouslySetInnerHTML!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&typeof props.style!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+typeof listener+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.\nvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */ // Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */ /**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance.return;}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return{message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n// const nextSibling = instance.nextSibling;\n// if (nextSibling) {\n//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n//   value.message = dataset.msg;\n//   value.hash = dataset.hash;\n//   if (true) {\n//     value.stack = dataset.stack;\n//   }\n// }\n// return value;\n}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+typeof typeSpecs[typeSpecName]+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,typeof error$1);setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId  it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress.return;if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment.return=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child,returnFiber){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(typeof child._store!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function isReactClass(type){return type.prototype&&type.prototype.isReactComponent;}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)&&// Will already throw with \"Function components cannot have string refs\"\n!(element._owner&&element._owner.tag!==ClassComponent)&&// Will already warn with \"Function components cannot be given refs\"\n!(typeof element.type==='function'&&!isReactClass(element.type))&&// Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\nelement._owner){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('Component \"%s\" contains the string ref \"%s\". Support for string refs '+'will be removed in a future major release. We recommend using '+'useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',componentName,mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=resolvedInst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\ntypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted  the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\ntypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing.return=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node.return;}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber.return;if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber.return=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else{concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n// queue so we can process it immediately during the current render.\nvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n// this fiber. This is for backwards compatibility in the case where you\n// update a different component during render phase than the one that is\n// currently renderings (a pattern that is accompanied by a warning).\nreturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else{return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps);}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\nhook.memoizedState=value;return value;}else{// This is a rerender during an update.\nvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n// previous value and spawn a deferred render to update it later.\nif(!objectIs(value,prevValue)){// Schedule a deferred render\nvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n// from the latest value. The name \"baseState\" doesn't really match how we\n// use it because we're reusing a state hook field instead of creating a\n// new one.\nhook.baseState=true;}// Reuse the previous value\nreturn prevValue;}else{// This is not an urgent update, so we can use the latest value regardless\n// of what it is. No need to defer it.\n// However, if we're currently inside a spawned render, then we need to mark\n// this as an update to prevent the fiber from bailing out.\n//\n// `baseState` is true when the current value is different from the rendered\n// value. The name doesn't really match how we use it because we're reusing\n// a state hook field instead of creating a new one.\nif(hook.baseState){// Flip this back to false.\nhook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\n// TODO: Do we still need to entangle transitions in this case?\nenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber.return;}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber.return;}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var fakeInternalInstance={};var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;var didWarnAboutLegacyContext$1;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();didWarnAboutLegacyContext$1=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(ctor.childContextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy childContextTypes API which is no longer '+'supported and will be removed in the next major release. Use '+'React.createContext() instead\\n\\n.'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(ctor.contextTypes&&!didWarnAboutLegacyContext$1.has(ctor)&&// Strict Mode has its own warning for legacy context, so we can skip\n// this one.\n(workInProgress.mode&StrictLegacyMode)===NoMode){didWarnAboutLegacyContext$1.add(ctor);error('%s uses the legacy contextTypes API which is no longer supported '+'and will be removed in the next major release. Use '+'React.createContext() with static contextType instead.\\n\\n'+'Learn more about this warning here: https://reactjs.org/link/legacy-context',name);}if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&typeof ctor.childContextTypes!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs={};initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return{value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node.return;}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;var didWarnAboutDefaultPropsOnFunctionComponent;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};didWarnAboutDefaultPropsOnFunctionComponent={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(type)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from memo components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n// would during a normal fiber bailout.\n//\n// We don't have strong guarantees that the props object is referentially\n// equal during updates where we can't bail out anyway  like if the props\n// are shallowly equal, but there's a local state or context update in the\n// same batch.\n//\n// However, as a principle, we should aim to make the behavior consistent\n// across different ways of memoizing a component. For example, React.memo\n// has a different internal Fiber layout if you pass a normal function\n// component (SimpleMemoComponent) versus if you pass a different type\n// like forwardRef (MemoComponent). But this is an implementation detail.\n// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n// affect whether the props object is reused during a bailout.\nworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n// TODO: Consider how Offscreen should work with transitions in the future\nvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\nfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\ntypeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(Component.defaultProps!==undefined){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutDefaultPropsOnFunctionComponent[componentName]){error('%s: Support for defaultProps will be removed from function components '+'in a future major release. Use JavaScript default parameters instead.',componentName);didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true;}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// Special path for hydration\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\nvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// Special path for hydration\nvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else{var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required  every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(message);}else{error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else{// This is the second render pass. We already attempted to hydrated, but\n// something either suspended or errored.\nif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\nappendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(current,workInProgress){// Noop\n};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child.return=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3.return=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else{// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\nreturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n// to its own fiber type so that we can add other kinds of hydration\n// boundaries that aren't associated with a Suspense tree. In anticipation\n// of such a refactor, all the hydration logic is contained in\n// this branch.\nif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n// this as a mismatch. Revert to client rendering.\nreturn workInProgress;}else{// Did not finish hydrating, either because this is the initial\n// render or because something suspended.\nreturn null;}}// Continue with the normal Suspense path.\n}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\nif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding  it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber.return;}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber.return;}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node.return);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node.return);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node.return,instance);}safelyAttachRef(node,node.return);break;}case HostComponent:{safelyAttachRef(node,node.return);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node.return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate.return=null;}fiber.return=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical  it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\n// Recursively delete all host nodes from the parent, detach refs, clean\n// up mounted layout effects, and call componentWillUnmount.\n// We only need to remove the topmost host child in each branch. But then we\n// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n// could split this into two separate traversals functions, where the second\n// one doesn't include any removeChild logic. This is maybe the same\n// function as \"disappearLayoutEffects\" (or whatever that turns into after\n// the layout phase is refactored to use recursion).\n// Before starting, find the nearest host parent on the stack so we know\n// which instance/container to remove the children from.\n// TODO: Instead of searching up the fiber return path on every deletion, we\n// can track the nearest host component on the JS stack as we traverse the\n// tree during the commit phase. This would make insertions faster, too.\nvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent.return;}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\nvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n// into their subtree. There are simpler cases in the inner switch\n// that don't modify the stack.\nswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n}// eslint-disable-next-line-no-fallthrough\ncase HostText:{// We only need to remove the nearest host child. Set the host parent\n// to `null` on the stack to indicate that nested children don't\n// need to be removed.\n{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n// node from the tree.\nif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\nvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\ndeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n// deleting the children, track that it's already unmounted so that we\n// don't attempt to unmount the effects again.\n// TODO: If the tree is hidden, in most cases we should be able to skip\n// over the nested children entirely. An exception is we haven't yet found\n// the topmost host node to delete, which we already track on the stack.\n// But the other case is portals, which need to be detached no matter how\n// deeply they are nested. We should use a subtree flag to track whether a\n// subtree includes a nested portal.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n// before the children effects hae fired.\nvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n// because the fiber tag is more specific. An exception is any flag related\n// to reconcilation, because those can be set on all fiber types.\nswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}{// TODO: ContentReset gets cleared by the children during the commit\n// phase. This is a refactor hazard because it means we must read\n// flags the flags after `commitReconciliationEffects` has already run;\n// the order matters. We should refactor so that ContentReset does not\n// rely on mutating the flag during commit. Like by setting a flag\n// during the render phase instead.\nif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n// read it during an event\noffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\nfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n// offscreen subtree was already hidden, so that we don't unmount the\n// effects again.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n// read it during an event\n_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n// type. They needs to happen after the children effects have fired, but\n// before the effects on this fiber have fired.\nvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber.return);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber.return);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber.return);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild.return=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber.return;{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling.return=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\"  a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\nreturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n// decided not to enable it.\n(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n// if this happens outside render or commit phase (e.g. in an event).\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return true;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&typeof thrownValue==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork.return;workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n// We need to pass this through as an argument to commitRoot\n// because workInProgressTransitions might have changed between\n// the previous render and commit if we throttle the commit\n// with setTimeout\npendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed  that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\nvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber.return;}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current.return;}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&typeof originalError==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n// Don't replay errors if we are hydrating and have already suspended or handled an error\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(typeof replayError==='object'&&replayError!==null&&replayError._suppressLogging&&typeof originalError==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=typeof nextType==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:typeof type)+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.3.1';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(typeof options==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}var didWarnAboutFindDOMNode=false;function findDOMNode(componentOrElement){{if(!didWarnAboutFindDOMNode){didWarnAboutFindDOMNode=true;error('findDOMNode is deprecated and will be removed in the next major '+'release. Instead, add a ref directly to the element you want '+'to reference. Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node');}var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}var didWarnAboutUnmountComponentAtNode=false;function unmountComponentAtNode(container){{if(!didWarnAboutUnmountComponentAtNode){didWarnAboutUnmountComponentAtNode=true;error('unmountComponentAtNode is deprecated and will be removed in the '+'next major release. Switch to the createRoot API. Learn '+'more: https://reactjs.org/link/switch-to-createroot');}}if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQWdCLEdBQUcsSUFBbUMsRUFBRSxZQUFZLGFBQWEsbUxBQW1MLHlFQUF5RSxVQUFVLG1CQUFPLENBQUMsNENBQU8sRUFBRSxjQUFjLG1CQUFPLENBQUMsb0RBQVcsRUFBRSxrRkFBa0YsMEJBQTBCLGlEQUFpRCxxQ0FBcUM7QUFDN2tCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQixxRUFBcUUsVUFBVSxRQUFRLDhCQUE4QixvQ0FBb0Msd0JBQXdCLHFCQUFxQix5RUFBeUUsWUFBWSxTQUFTLGdDQUFnQyxxQ0FBcUMseUNBQXlDO0FBQzliO0FBQ0EsQ0FBQyx1RUFBdUUsb0RBQW9ELGVBQWUsYUFBYSwyQkFBMkI7QUFDbkwsMkNBQTJDLHFCQUFxQixFQUFFO0FBQ2xFLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QixxQkFBcUIsNkJBQTZCO0FBQ2pKLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsb0JBQW9CLGVBQWUsZUFBZSxXQUFXLHNCQUFzQix1QkFBdUIsa0JBQWtCLGdCQUFnQix5QkFBeUIscUJBQXFCLDJCQUEyQixxQkFBcUIsZ0NBQWdDLDBCQUEwQiw2QkFBNkIsc0JBQXNCLDBCQUEwQiw2QkFBNkIsc0JBQXNCLDhCQUE4QjtBQUNsYyxrREFBa0Q7QUFDbEQ7QUFDQSw4QkFBOEI7QUFDOUIsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3QiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25D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RkFBZ0YsOEZBQThGLDJSQUEyUiwyQ0FBMkMsMkRBQTJELGlEQUFpRCxvRUFBb0UsK0ZBQStGLDZDQUE2Qyw0Q0FBNEMsd0NBQXdDLHdDQUF3Qyw2TEFBNkwsdUNBQXVDLHlGQUF5RiwrRkFBK0YsaUJBQWlCLHNNQUFzTSxtQ0FBbUMscURBQXFELGtFQUFrRSw2QkFBNkIscUhBQXFIO0FBQ3JrRixxQkFBcUIsc0VBQXNFO0FBQzNGLG1DQUFtQyxrQ0FBa0MsR0FBRyxFQUFFO0FBQzFFO0FBQ0EsYUFBYSxNQUFNLHNEQUFzRCxtRUFBbUU7QUFDNUkscUpBQXFKLHlCQUF5Qiw0VkFBNFYsZUFBZSw4REFBOEQsNERBQTRELDBFQUEwRSxzREFBc0QsZ0RBQWdEO0FBQ24wQjtBQUNBLHlHQUF5RywwSkFBMEosbURBQW1ELHNFQUFzRSw0Q0FBNEMsdUVBQXVFLGlDQUFpQywyREFBMkQ7QUFDM2tCO0FBQ0Esa0RBQWtELG9GQUFvRiw0RkFBNEYsZUFBZTtBQUNqUDtBQUNBLHlJQUF5SSwwQ0FBMEMsNkNBQTZDLDBJQUEwSSxzQ0FBc0MsMkRBQTJELDZDQUE2QywySUFBMkksdURBQXVEO0FBQzFyQjtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5Qix1TEFBdUwsc0JBQXNCLHNDQUFzQyxxSEFBcUgsR0FBRyx3REFBd0Q7QUFDdGQsa0lBQWtJLHNDQUFzQztBQUN4SyxzQ0FBc0M7QUFDdEMsbVNBQW1TLDBEQUEwRCxXQUFXLG9CQUFvQixnQkFBZ0Isa0JBQWtCLGNBQWMsbUJBQW1CLGFBQWEsaUJBQWlCLGFBQWEsZUFBZSxTQUFTLG1CQUFtQixlQUFlLGNBQWMsUUFBUSw4QkFBOEIsd0JBQXdCLCtCQUErQixrQkFBa0IsMkNBQTJDLDRCQUE0QixlQUFlLGNBQWMsa0xBQWtMLHlFQUF5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/YTg5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqLyd1c2Ugc3RyaWN0JztpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PVwicHJvZHVjdGlvblwiKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7LyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL2lmKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18hPT0ndW5kZWZpbmVkJyYmdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQ9PT0nZnVuY3Rpb24nKXtfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTt9dmFyIFJlYWN0PXJlcXVpcmUoJ3JlYWN0Jyk7dmFyIFNjaGVkdWxlcj1yZXF1aXJlKCdzY2hlZHVsZXInKTt2YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHM9UmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7dmFyIHN1cHByZXNzV2FybmluZz1mYWxzZTtmdW5jdGlvbiBzZXRTdXBwcmVzc1dhcm5pbmcobmV3U3VwcHJlc3NXYXJuaW5nKXt7c3VwcHJlc3NXYXJuaW5nPW5ld1N1cHByZXNzV2FybmluZzt9fS8vIEluIERFViwgY2FsbHMgdG8gY29uc29sZS53YXJuIGFuZCBjb25zb2xlLmVycm9yIGdldCByZXBsYWNlZFxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuZnVuY3Rpb24gd2Fybihmb3JtYXQpe3tpZighc3VwcHJlc3NXYXJuaW5nKXtmb3IodmFyIF9sZW49YXJndW1lbnRzLmxlbmd0aCxhcmdzPW5ldyBBcnJheShfbGVuPjE/X2xlbi0xOjApLF9rZXk9MTtfa2V5PF9sZW47X2tleSsrKXthcmdzW19rZXktMV09YXJndW1lbnRzW19rZXldO31wcmludFdhcm5pbmcoJ3dhcm4nLGZvcm1hdCxhcmdzKTt9fX1mdW5jdGlvbiBlcnJvcihmb3JtYXQpe3tpZighc3VwcHJlc3NXYXJuaW5nKXtmb3IodmFyIF9sZW4yPWFyZ3VtZW50cy5sZW5ndGgsYXJncz1uZXcgQXJyYXkoX2xlbjI+MT9fbGVuMi0xOjApLF9rZXkyPTE7X2tleTI8X2xlbjI7X2tleTIrKyl7YXJnc1tfa2V5Mi0xXT1hcmd1bWVudHNbX2tleTJdO31wcmludFdhcm5pbmcoJ2Vycm9yJyxmb3JtYXQsYXJncyk7fX19ZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLGZvcm1hdCxhcmdzKXsvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbi8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxue3ZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7dmFyIHN0YWNrPVJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO2lmKHN0YWNrIT09Jycpe2Zvcm1hdCs9JyVzJzthcmdzPWFyZ3MuY29uY2F0KFtzdGFja10pO30vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnZhciBhcmdzV2l0aEZvcm1hdD1hcmdzLm1hcChmdW5jdGlvbihpdGVtKXtyZXR1cm4gU3RyaW5nKGl0ZW0pO30pOy8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5hcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnK2Zvcm1hdCk7Ly8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbi8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLGNvbnNvbGUsYXJnc1dpdGhGb3JtYXQpO319dmFyIEZ1bmN0aW9uQ29tcG9uZW50PTA7dmFyIENsYXNzQ29tcG9uZW50PTE7dmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ9MjsvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG52YXIgSG9zdFJvb3Q9MzsvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsPTQ7Ly8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50PTU7dmFyIEhvc3RUZXh0PTY7dmFyIEZyYWdtZW50PTc7dmFyIE1vZGU9ODt2YXIgQ29udGV4dENvbnN1bWVyPTk7dmFyIENvbnRleHRQcm92aWRlcj0xMDt2YXIgRm9yd2FyZFJlZj0xMTt2YXIgUHJvZmlsZXI9MTI7dmFyIFN1c3BlbnNlQ29tcG9uZW50PTEzO3ZhciBNZW1vQ29tcG9uZW50PTE0O3ZhciBTaW1wbGVNZW1vQ29tcG9uZW50PTE1O3ZhciBMYXp5Q29tcG9uZW50PTE2O3ZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ9MTc7dmFyIERlaHlkcmF0ZWRGcmFnbWVudD0xODt2YXIgU3VzcGVuc2VMaXN0Q29tcG9uZW50PTE5O3ZhciBTY29wZUNvbXBvbmVudD0yMTt2YXIgT2Zmc2NyZWVuQ29tcG9uZW50PTIyO3ZhciBMZWdhY3lIaWRkZW5Db21wb25lbnQ9MjM7dmFyIENhY2hlQ29tcG9uZW50PTI0O3ZhciBUcmFjaW5nTWFya2VyQ29tcG9uZW50PTI1Oy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgZW5hYmxlQ2xpZW50UmVuZGVyRmFsbGJhY2tPblRleHRNaXNtYXRjaD10cnVlOy8vIFRPRE86IE5lZWQgdG8gcmV2aWV3IHRoaXMgY29kZSBvbmUgbW9yZSB0aW1lIGJlZm9yZSBsYW5kaW5nXG4vLyB0aGUgcmVhY3QtcmVjb25jaWxlciBwYWNrYWdlLlxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXI9ZmFsc2U7Ly8gU3VwcG9ydCBsZWdhY3kgUHJpbWVyIHN1cHBvcnQgb24gaW50ZXJuYWwgRkIgd3d3XG52YXIgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbj1mYWxzZTsvLyBGQi1vbmx5IHVzYWdlLiBUaGUgbmV3IEFQSSBoYXMgZGlmZmVyZW50IHNlbWFudGljcy5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW49ZmFsc2U7Ly8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjaz1mYWxzZTsvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRml6elxuLy8gUmVhY3QgRE9NIENob3BwaW5nIEJsb2NrXG4vL1xuLy8gU2ltaWxhciB0byBtYWluIENob3BwaW5nIEJsb2NrIGJ1dCBvbmx5IGZsYWdzIHJlbGF0ZWQgdG8gUmVhY3QgRE9NLiBUaGVzZSBhcmVcbi8vIGdyb3VwZWQgYmVjYXVzZSB3ZSB3aWxsIGxpa2VseSBiYXRjaCBhbGwgb2YgdGhlbSBpbnRvIGEgc2luZ2xlIG1ham9yIHJlbGVhc2UuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGlzYWJsZSBzdXBwb3J0IGZvciBjb21tZW50IG5vZGVzIGFzIFJlYWN0IERPTSBjb250YWluZXJzLiBBbHJlYWR5IGRpc2FibGVkXG4vLyBpbiBvcGVuIHNvdXJjZSwgYnV0IHd3dyBjb2RlYmFzZSBzdGlsbCByZWxpZXMgb24gaXQuIE5lZWQgdG8gcmVtb3ZlLlxudmFyIGRpc2FibGVDb21tZW50c0FzRE9NQ29udGFpbmVycz10cnVlOy8vIERpc2FibGUgamF2YXNjcmlwdDogVVJMIHN0cmluZ3MgaW4gaHJlZiBmb3IgWFNTIHByb3RlY3Rpb24uXG4vLyBhbmQgY2xpZW50IHJlbmRlcmluZywgbW9zdGx5IHRvIGFsbG93IEpTWCBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBjdXN0b21cbi8vIGVsZW1lbnQncyBvYmplY3QgcHJvcGVydGllcyBpbnN0ZWFkIG9mIG9ubHkgSFRNTCBhdHRyaWJ1dGVzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTM0N1xudmFyIGVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQ9ZmFsc2U7Ly8gRGlzYWJsZXMgY2hpbGRyZW4gZm9yIDx0ZXh0YXJlYT4gZWxlbWVudHNcbnZhciB3YXJuQWJvdXRTdHJpbmdSZWZzPXRydWU7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxudmFyIGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcj10cnVlOy8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiByZW5kZXItcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZVxudmFyIGVuYWJsZVByb2ZpbGVyVGltZXI9dHJ1ZTsvLyBSZWNvcmQgZHVyYXRpb25zIGZvciBjb21taXQgYW5kIHBhc3NpdmUgZWZmZWN0cyBwaGFzZXMuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcz10cnVlOy8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG52YXIgYWxsTmF0aXZlRXZlbnRzPW5ldyBTZXQoKTsvKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi92YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcz17fTsvKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL3ZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzPXt9Oy8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSxkZXBlbmRlbmNpZXMpe3JlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSxkZXBlbmRlbmNpZXMpO3JlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSsnQ2FwdHVyZScsZGVwZW5kZW5jaWVzKTt9ZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLGRlcGVuZGVuY2llcyl7e2lmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0pe2Vycm9yKCdFdmVudFJlZ2lzdHJ5OiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnKydyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLHJlZ2lzdHJhdGlvbk5hbWUpO319cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXT1kZXBlbmRlbmNpZXM7e3ZhciBsb3dlckNhc2VkTmFtZT1yZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7cG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV09cmVnaXN0cmF0aW9uTmFtZTtpZihyZWdpc3RyYXRpb25OYW1lPT09J29uRG91YmxlQ2xpY2snKXtwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2s9cmVnaXN0cmF0aW9uTmFtZTt9fWZvcih2YXIgaT0wO2k8ZGVwZW5kZW5jaWVzLmxlbmd0aDtpKyspe2FsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW2ldKTt9fXZhciBjYW5Vc2VET009ISEodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnJiZ0eXBlb2Ygd2luZG93LmRvY3VtZW50IT09J3VuZGVmaW5lZCcmJnR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCE9PSd1bmRlZmluZWQnKTt2YXIgaGFzT3duUHJvcGVydHk9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsvKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqLyAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpe3svLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG52YXIgaGFzVG9TdHJpbmdUYWc9dHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbicmJlN5bWJvbC50b1N0cmluZ1RhZzt2YXIgdHlwZT1oYXNUb1N0cmluZ1RhZyYmdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXXx8dmFsdWUuY29uc3RydWN0b3IubmFtZXx8J09iamVjdCc7cmV0dXJuIHR5cGU7fX0vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpe3t0cnl7dGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtyZXR1cm4gZmFsc2U7fWNhdGNoKGUpe3JldHVybiB0cnVlO319fWZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSl7Ly8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4vLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4vL1xuLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4vLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4vLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbi8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbi8vXG4vLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4vLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4vL1xuLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbi8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbi8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbi8vXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnJldHVybicnK3ZhbHVlO31mdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLGF0dHJpYnV0ZU5hbWUpe3tpZih3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpe2Vycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsYXR0cmlidXRlTmFtZSx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja1Byb3BTdHJpbmdDb2VyY2lvbih2YWx1ZSxwcm9wTmFtZSl7e2lmKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSl7ZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nKycgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicscHJvcE5hbWUsdHlwZU5hbWUodmFsdWUpKTtyZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxufX19ZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLHByb3BOYW1lKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgQ1NTIHByb3BlcnR5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJysnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLHByb3BOYW1lLHR5cGVOYW1lKHZhbHVlKSk7cmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7Ly8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbn19fWZ1bmN0aW9uIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHZhbHVlKXt7aWYod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKXtlcnJvcignVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX1mdW5jdGlvbiBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpe3tpZih3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpe2Vycm9yKCdGb3JtIGZpZWxkIHZhbHVlcyAodmFsdWUsIGNoZWNrZWQsIGRlZmF1bHRWYWx1ZSwgb3IgZGVmYXVsdENoZWNrZWQgcHJvcHMpJysnIG11c3QgYmUgc3RyaW5ncywgbm90ICVzLicrJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJyx0eXBlTmFtZSh2YWx1ZSkpO3JldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOy8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG59fX0vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRD0wOy8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxudmFyIFNUUklORz0xOy8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxudmFyIEJPT0xFQU5JU0hfU1RSSU5HPTI7Ly8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG52YXIgQk9PTEVBTj0zOy8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxudmFyIE9WRVJMT0FERURfQk9PTEVBTj00Oy8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBOVU1FUklDPTU7Ly8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxudmFyIFBPU0lUSVZFX05VTUVSSUM9NjsvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovdmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI9XCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovdmFyIEFUVFJJQlVURV9OQU1FX0NIQVI9QVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUitcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7dmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYPW5ldyBSZWdFeHAoJ15bJytBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSKyddWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7dmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGU9e307dmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZT17fTtmdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpe2lmKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLGF0dHJpYnV0ZU5hbWUpKXtyZXR1cm4gdHJ1ZTt9aWYoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLGF0dHJpYnV0ZU5hbWUpKXtyZXR1cm4gZmFsc2U7fWlmKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpe3ZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXT10cnVlO3JldHVybiB0cnVlO31pbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdPXRydWU7e2Vycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJyxhdHRyaWJ1dGVOYW1lKTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpe2lmKHByb3BlcnR5SW5mbyE9PW51bGwpe3JldHVybiBwcm9wZXJ0eUluZm8udHlwZT09PVJFU0VSVkVEO31pZihpc0N1c3RvbUNvbXBvbmVudFRhZyl7cmV0dXJuIGZhbHNlO31pZihuYW1lLmxlbmd0aD4yJiYobmFtZVswXT09PSdvJ3x8bmFtZVswXT09PSdPJykmJihuYW1lWzFdPT09J24nfHxuYW1lWzFdPT09J04nKSl7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpe2lmKHByb3BlcnR5SW5mbyE9PW51bGwmJnByb3BlcnR5SW5mby50eXBlPT09UkVTRVJWRUQpe3JldHVybiBmYWxzZTt9c3dpdGNoKHR5cGVvZiB2YWx1ZSl7Y2FzZSdmdW5jdGlvbic6Ly8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcbmNhc2Unc3ltYm9sJzovLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5yZXR1cm4gdHJ1ZTtjYXNlJ2Jvb2xlYW4nOntpZihpc0N1c3RvbUNvbXBvbmVudFRhZyl7cmV0dXJuIGZhbHNlO31pZihwcm9wZXJ0eUluZm8hPT1udWxsKXtyZXR1cm4hcHJvcGVydHlJbmZvLmFjY2VwdHNCb29sZWFuczt9ZWxzZXt2YXIgcHJlZml4PW5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpO3JldHVybiBwcmVmaXghPT0nZGF0YS0nJiZwcmVmaXghPT0nYXJpYS0nO319ZGVmYXVsdDpyZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSx2YWx1ZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpe2lmKHZhbHVlPT09bnVsbHx8dHlwZW9mIHZhbHVlPT09J3VuZGVmaW5lZCcpe3JldHVybiB0cnVlO31pZihzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLHZhbHVlLHByb3BlcnR5SW5mbyxpc0N1c3RvbUNvbXBvbmVudFRhZykpe3JldHVybiB0cnVlO31pZihpc0N1c3RvbUNvbXBvbmVudFRhZyl7cmV0dXJuIGZhbHNlO31pZihwcm9wZXJ0eUluZm8hPT1udWxsKXtzd2l0Y2gocHJvcGVydHlJbmZvLnR5cGUpe2Nhc2UgQk9PTEVBTjpyZXR1cm4hdmFsdWU7Y2FzZSBPVkVSTE9BREVEX0JPT0xFQU46cmV0dXJuIHZhbHVlPT09ZmFsc2U7Y2FzZSBOVU1FUklDOnJldHVybiBpc05hTih2YWx1ZSk7Y2FzZSBQT1NJVElWRV9OVU1FUklDOnJldHVybiBpc05hTih2YWx1ZSl8fHZhbHVlPDE7fX1yZXR1cm4gZmFsc2U7fWZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKXtyZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKT9wcm9wZXJ0aWVzW25hbWVdOm51bGw7fWZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLHR5cGUsbXVzdFVzZVByb3BlcnR5LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlTmFtZXNwYWNlLHNhbml0aXplVVJMLHJlbW92ZUVtcHR5U3RyaW5nKXt0aGlzLmFjY2VwdHNCb29sZWFucz10eXBlPT09Qk9PTEVBTklTSF9TVFJJTkd8fHR5cGU9PT1CT09MRUFOfHx0eXBlPT09T1ZFUkxPQURFRF9CT09MRUFOO3RoaXMuYXR0cmlidXRlTmFtZT1hdHRyaWJ1dGVOYW1lO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWF0dHJpYnV0ZU5hbWVzcGFjZTt0aGlzLm11c3RVc2VQcm9wZXJ0eT1tdXN0VXNlUHJvcGVydHk7dGhpcy5wcm9wZXJ0eU5hbWU9bmFtZTt0aGlzLnR5cGU9dHlwZTt0aGlzLnNhbml0aXplVVJMPXNhbml0aXplVVJMO3RoaXMucmVtb3ZlRW1wdHlTdHJpbmc9cmVtb3ZlRW1wdHlTdHJpbmc7fS8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxudmFyIHByb3BlcnRpZXM9e307Ly8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgcmVzZXJ2ZWRQcm9wcz1bJ2NoaWxkcmVuJywnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsJ2RlZmF1bHRDaGVja2VkJywnaW5uZXJIVE1MJywnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywnc3R5bGUnXTtyZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsUkVTRVJWRUQsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuW1snYWNjZXB0Q2hhcnNldCcsJ2FjY2VwdC1jaGFyc2V0J10sWydjbGFzc05hbWUnLCdjbGFzcyddLFsnaHRtbEZvcicsJ2ZvciddLFsnaHR0cEVxdWl2JywnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uKF9yZWYpe3ZhciBuYW1lPV9yZWZbMF0sYXR0cmlidXRlTmFtZT1fcmVmWzFdO3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUsLy8gYXR0cmlidXRlTmFtZVxubnVsbCwvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbmZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblsnY29udGVudEVkaXRhYmxlJywnZHJhZ2dhYmxlJywnc3BlbGxDaGVjaycsJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOSVNIX1NUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5bJ2F1dG9SZXZlcnNlJywnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsJ2ZvY3VzYWJsZScsJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLEJPT0xFQU5JU0hfU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5bJ2FsbG93RnVsbFNjcmVlbicsJ2FzeW5jJywvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywnYXV0b1BsYXknLCdjb250cm9scycsJ2RlZmF1bHQnLCdkZWZlcicsJ2Rpc2FibGVkJywnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLCdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCdmb3JtTm9WYWxpZGF0ZScsJ2hpZGRlbicsJ2xvb3AnLCdub01vZHVsZScsJ25vVmFsaWRhdGUnLCdvcGVuJywncGxheXNJbmxpbmUnLCdyZWFkT25seScsJ3JlcXVpcmVkJywncmV2ZXJzZWQnLCdzY29wZWQnLCdzZWFtbGVzcycsLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZS50b0xvd2VyQ2FzZSgpLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuWydjaGVja2VkJywvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywnbXV0ZWQnLCdzZWxlY3RlZCcvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxCT09MRUFOLHRydWUsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuWydjYXB0dXJlJywnZG93bmxvYWQnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsT1ZFUkxPQURFRF9CT09MRUFOLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxubmFtZSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuWydjb2xzJywncm93cycsJ3NpemUnLCdzcGFuJy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFBPU0lUSVZFX05VTUVSSUMsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5uYW1lLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5bJ3Jvd1NwYW4nLCdzdGFydCddLmZvckVhY2goZnVuY3Rpb24obmFtZSl7cHJvcGVydGllc1tuYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsTlVNRVJJQyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbm5hbWUudG9Mb3dlckNhc2UoKSwvLyBhdHRyaWJ1dGVOYW1lXG5udWxsLC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTt2YXIgQ0FNRUxJWkU9L1tcXC1cXDpdKFthLXpdKS9nO3ZhciBjYXBpdGFsaXplPWZ1bmN0aW9uKHRva2VuKXtyZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTt9Oy8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5bJ2FjY2VudC1oZWlnaHQnLCdhbGlnbm1lbnQtYmFzZWxpbmUnLCdhcmFiaWMtZm9ybScsJ2Jhc2VsaW5lLXNoaWZ0JywnY2FwLWhlaWdodCcsJ2NsaXAtcGF0aCcsJ2NsaXAtcnVsZScsJ2NvbG9yLWludGVycG9sYXRpb24nLCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCdjb2xvci1wcm9maWxlJywnY29sb3ItcmVuZGVyaW5nJywnZG9taW5hbnQtYmFzZWxpbmUnLCdlbmFibGUtYmFja2dyb3VuZCcsJ2ZpbGwtb3BhY2l0eScsJ2ZpbGwtcnVsZScsJ2Zsb29kLWNvbG9yJywnZmxvb2Qtb3BhY2l0eScsJ2ZvbnQtZmFtaWx5JywnZm9udC1zaXplJywnZm9udC1zaXplLWFkanVzdCcsJ2ZvbnQtc3RyZXRjaCcsJ2ZvbnQtc3R5bGUnLCdmb250LXZhcmlhbnQnLCdmb250LXdlaWdodCcsJ2dseXBoLW5hbWUnLCdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCdob3Jpei1hZHYteCcsJ2hvcml6LW9yaWdpbi14JywnaW1hZ2UtcmVuZGVyaW5nJywnbGV0dGVyLXNwYWNpbmcnLCdsaWdodGluZy1jb2xvcicsJ21hcmtlci1lbmQnLCdtYXJrZXItbWlkJywnbWFya2VyLXN0YXJ0Jywnb3ZlcmxpbmUtcG9zaXRpb24nLCdvdmVybGluZS10aGlja25lc3MnLCdwYWludC1vcmRlcicsJ3Bhbm9zZS0xJywncG9pbnRlci1ldmVudHMnLCdyZW5kZXJpbmctaW50ZW50Jywnc2hhcGUtcmVuZGVyaW5nJywnc3RvcC1jb2xvcicsJ3N0b3Atb3BhY2l0eScsJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsJ3N0cm9rZS1kYXNoYXJyYXknLCdzdHJva2UtZGFzaG9mZnNldCcsJ3N0cm9rZS1saW5lY2FwJywnc3Ryb2tlLWxpbmVqb2luJywnc3Ryb2tlLW1pdGVybGltaXQnLCdzdHJva2Utb3BhY2l0eScsJ3N0cm9rZS13aWR0aCcsJ3RleHQtYW5jaG9yJywndGV4dC1kZWNvcmF0aW9uJywndGV4dC1yZW5kZXJpbmcnLCd1bmRlcmxpbmUtcG9zaXRpb24nLCd1bmRlcmxpbmUtdGhpY2tuZXNzJywndW5pY29kZS1iaWRpJywndW5pY29kZS1yYW5nZScsJ3VuaXRzLXBlci1lbScsJ3YtYWxwaGFiZXRpYycsJ3YtaGFuZ2luZycsJ3YtaWRlb2dyYXBoaWMnLCd2LW1hdGhlbWF0aWNhbCcsJ3ZlY3Rvci1lZmZlY3QnLCd2ZXJ0LWFkdi15JywndmVydC1vcmlnaW4teCcsJ3ZlcnQtb3JpZ2luLXknLCd3b3JkLXNwYWNpbmcnLCd3cml0aW5nLW1vZGUnLCd4bWxuczp4bGluaycsJ3gtaGVpZ2h0Jy8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpe3ZhciBuYW1lPWF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSxjYXBpdGFsaXplKTtwcm9wZXJ0aWVzW25hbWVdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSxTVFJJTkcsZmFsc2UsLy8gbXVzdFVzZVByb3BlcnR5XG5hdHRyaWJ1dGVOYW1lLG51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5bJ3hsaW5rOmFjdHVhdGUnLCd4bGluazphcmNyb2xlJywneGxpbms6cm9sZScsJ3hsaW5rOnNob3cnLCd4bGluazp0aXRsZScsJ3hsaW5rOnR5cGUnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7dmFyIG5hbWU9YXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLGNhcGl0YWxpemUpO3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUsJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLGZhbHNlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7fSk7Ly8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5bJ3htbDpiYXNlJywneG1sOmxhbmcnLCd4bWw6c3BhY2UnLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7dmFyIG5hbWU9YXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLGNhcGl0YWxpemUpO3Byb3BlcnRpZXNbbmFtZV09bmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLFNUUklORyxmYWxzZSwvLyBtdXN0VXNlUHJvcGVydHlcbmF0dHJpYnV0ZU5hbWUsJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsZmFsc2UsLy8gc2FuaXRpemVVUkxcbmZhbHNlKTt9KTsvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblsndGFiSW5kZXgnLCdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7cHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG5mYWxzZSwvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO30pOy8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cbnZhciB4bGlua0hyZWY9J3hsaW5rSHJlZic7cHJvcGVydGllc1t4bGlua0hyZWZdPW5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyx0cnVlLC8vIHNhbml0aXplVVJMXG5mYWxzZSk7WydzcmMnLCdocmVmJywnYWN0aW9uJywnZm9ybUFjdGlvbiddLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSl7cHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXT1uZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsU1RSSU5HLGZhbHNlLC8vIG11c3RVc2VQcm9wZXJ0eVxuYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwsLy8gYXR0cmlidXRlTmFtZXNwYWNlXG50cnVlLC8vIHNhbml0aXplVVJMXG50cnVlKTt9KTsvLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2Vcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi92YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2w9L15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO3ZhciBkaWRXYXJuPWZhbHNlO2Z1bmN0aW9uIHNhbml0aXplVVJMKHVybCl7e2lmKCFkaWRXYXJuJiZpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpe2RpZFdhcm49dHJ1ZTtlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnKydVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJysndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLEpTT04uc3RyaW5naWZ5KHVybCkpO319fS8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLG5hbWUsZXhwZWN0ZWQscHJvcGVydHlJbmZvKXt7aWYocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSl7dmFyIHByb3BlcnR5TmFtZT1wcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO3JldHVybiBub2RlW3Byb3BlcnR5TmFtZV07fWVsc2V7Ly8gVGhpcyBjaGVjayBwcm90ZWN0cyBtdWx0aXBsZSB1c2VzIG9mIGBleHBlY3RlZGAsIHdoaWNoIGlzIHdoeSB0aGVcbi8vIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uIHJ1bGUgaXMgZGlzYWJsZWQgaW4gc2V2ZXJhbCBzcG90c1xuLy8gYmVsb3cuXG57Y2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihleHBlY3RlZCxuYW1lKTt9aWYocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKXsvLyBJZiB3ZSBoYXZlbid0IGZ1bGx5IGRpc2FibGVkIGphdmFzY3JpcHQ6IFVSTHMsIGFuZCBpZlxuLy8gdGhlIGh5ZHJhdGlvbiBpcyBzdWNjZXNzZnVsIG9mIGEgamF2YXNjcmlwdDogVVJMLCB3ZVxuLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnNhbml0aXplVVJMKCcnK2V4cGVjdGVkKTt9dmFyIGF0dHJpYnV0ZU5hbWU9cHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7dmFyIHN0cmluZ1ZhbHVlPW51bGw7aWYocHJvcGVydHlJbmZvLnR5cGU9PT1PVkVSTE9BREVEX0JPT0xFQU4pe2lmKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKXt2YXIgdmFsdWU9bm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7aWYodmFsdWU9PT0nJyl7cmV0dXJuIHRydWU7fWlmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLGV4cGVjdGVkLHByb3BlcnR5SW5mbyxmYWxzZSkpe3JldHVybiB2YWx1ZTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5pZih2YWx1ZT09PScnK2V4cGVjdGVkKXtyZXR1cm4gZXhwZWN0ZWQ7fXJldHVybiB2YWx1ZTt9fWVsc2UgaWYobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpe2lmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLGV4cGVjdGVkLHByb3BlcnR5SW5mbyxmYWxzZSkpey8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbi8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbnJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTt9aWYocHJvcGVydHlJbmZvLnR5cGU9PT1CT09MRUFOKXsvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4vLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxucmV0dXJuIGV4cGVjdGVkO30vLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4vLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4vLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4vLyBpbiBvdXIgY29uZmlnIGF0bS5cbnN0cmluZ1ZhbHVlPW5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO31pZihzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSxleHBlY3RlZCxwcm9wZXJ0eUluZm8sZmFsc2UpKXtyZXR1cm4gc3RyaW5nVmFsdWU9PT1udWxsP2V4cGVjdGVkOnN0cmluZ1ZhbHVlOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxufWVsc2UgaWYoc3RyaW5nVmFsdWU9PT0nJytleHBlY3RlZCl7cmV0dXJuIGV4cGVjdGVkO31lbHNle3JldHVybiBzdHJpbmdWYWx1ZTt9fX19LyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLG5hbWUsZXhwZWN0ZWQsaXNDdXN0b21Db21wb25lbnRUYWcpe3tpZighaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSl7cmV0dXJuO31pZighbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpe3JldHVybiBleHBlY3RlZD09PXVuZGVmaW5lZD91bmRlZmluZWQ6bnVsbDt9dmFyIHZhbHVlPW5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO3tjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGV4cGVjdGVkLG5hbWUpO31pZih2YWx1ZT09PScnK2V4cGVjdGVkKXtyZXR1cm4gZXhwZWN0ZWQ7fXJldHVybiB2YWx1ZTt9fS8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL2Z1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSxuYW1lLHZhbHVlLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXt2YXIgcHJvcGVydHlJbmZvPWdldFByb3BlcnR5SW5mbyhuYW1lKTtpZihzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpKXtyZXR1cm47fWlmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLHZhbHVlLHByb3BlcnR5SW5mbyxpc0N1c3RvbUNvbXBvbmVudFRhZykpe3ZhbHVlPW51bGw7fWlmKGlzQ3VzdG9tQ29tcG9uZW50VGFnfHxwcm9wZXJ0eUluZm89PT1udWxsKXtpZihpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKXt2YXIgX2F0dHJpYnV0ZU5hbWU9bmFtZTtpZih2YWx1ZT09PW51bGwpe25vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTt9ZWxzZXt7Y2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSxuYW1lKTt9bm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsJycrdmFsdWUpO319cmV0dXJuO312YXIgbXVzdFVzZVByb3BlcnR5PXByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7aWYobXVzdFVzZVByb3BlcnR5KXt2YXIgcHJvcGVydHlOYW1lPXByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7aWYodmFsdWU9PT1udWxsKXt2YXIgdHlwZT1wcm9wZXJ0eUluZm8udHlwZTtub2RlW3Byb3BlcnR5TmFtZV09dHlwZT09PUJPT0xFQU4/ZmFsc2U6Jyc7fWVsc2V7Ly8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85Llxubm9kZVtwcm9wZXJ0eU5hbWVdPXZhbHVlO31yZXR1cm47fS8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxudmFyIGF0dHJpYnV0ZU5hbWU9cHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlTmFtZXNwYWNlPXByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7aWYodmFsdWU9PT1udWxsKXtub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTt9ZWxzZXt2YXIgX3R5cGU9cHJvcGVydHlJbmZvLnR5cGU7dmFyIGF0dHJpYnV0ZVZhbHVlO2lmKF90eXBlPT09Qk9PTEVBTnx8X3R5cGU9PT1PVkVSTE9BREVEX0JPT0xFQU4mJnZhbHVlPT09dHJ1ZSl7Ly8gSWYgYXR0cmlidXRlIHR5cGUgaXMgYm9vbGVhbiwgd2Uga25vdyBmb3Igc3VyZSBpdCB3b24ndCBiZSBhbiBleGVjdXRpb24gc2lua1xuLy8gYW5kIHdlIHdvbid0IHJlcXVpcmUgVHJ1c3RlZCBUeXBlIGhlcmUuXG5hdHRyaWJ1dGVWYWx1ZT0nJzt9ZWxzZXsvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4vLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG57e2NoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsYXR0cmlidXRlTmFtZSk7fWF0dHJpYnV0ZVZhbHVlPScnK3ZhbHVlO31pZihwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpe3Nhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO319aWYoYXR0cmlidXRlTmFtZXNwYWNlKXtub2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJpYnV0ZU5hbWVzcGFjZSxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVZhbHVlKTt9ZWxzZXtub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVZhbHVlKTt9fX0vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7dmFyIFJFQUNUX1BPUlRBTF9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO3ZhciBSRUFDVF9GUkFHTUVOVF9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7dmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU9U3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTt2YXIgUkVBQ1RfUFJPRklMRVJfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO3ZhciBSRUFDVF9QUk9WSURFUl9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7dmFyIFJFQUNUX0NPTlRFWFRfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7dmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU9U3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTt2YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO3ZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU9U3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO3ZhciBSRUFDVF9NRU1PX1RZUEU9U3ltYm9sLmZvcigncmVhY3QubWVtbycpO3ZhciBSRUFDVF9MQVpZX1RZUEU9U3ltYm9sLmZvcigncmVhY3QubGF6eScpO3ZhciBSRUFDVF9TQ09QRV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7dmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFPVN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTt2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU9U3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7dmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7dmFyIFJFQUNUX0NBQ0hFX1RZUEU9U3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTt2YXIgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRT1TeW1ib2wuZm9yKCdyZWFjdC50cmFjaW5nX21hcmtlcicpO3ZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0w9U3ltYm9sLml0ZXJhdG9yO3ZhciBGQVVYX0lURVJBVE9SX1NZTUJPTD0nQEBpdGVyYXRvcic7ZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKXtpZihtYXliZUl0ZXJhYmxlPT09bnVsbHx8dHlwZW9mIG1heWJlSXRlcmFibGUhPT0nb2JqZWN0Jyl7cmV0dXJuIG51bGw7fXZhciBtYXliZUl0ZXJhdG9yPU1BWUJFX0lURVJBVE9SX1NZTUJPTCYmbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdfHxtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtpZih0eXBlb2YgbWF5YmVJdGVyYXRvcj09PSdmdW5jdGlvbicpe3JldHVybiBtYXliZUl0ZXJhdG9yO31yZXR1cm4gbnVsbDt9dmFyIGFzc2lnbj1PYmplY3QuYXNzaWduOy8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoPTA7dmFyIHByZXZMb2c7dmFyIHByZXZJbmZvO3ZhciBwcmV2V2Fybjt2YXIgcHJldkVycm9yO3ZhciBwcmV2R3JvdXA7dmFyIHByZXZHcm91cENvbGxhcHNlZDt2YXIgcHJldkdyb3VwRW5kO2Z1bmN0aW9uIGRpc2FibGVkTG9nKCl7fWRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZz10cnVlO2Z1bmN0aW9uIGRpc2FibGVMb2dzKCl7e2lmKGRpc2FibGVkRGVwdGg9PT0wKXsvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9wcmV2TG9nPWNvbnNvbGUubG9nO3ByZXZJbmZvPWNvbnNvbGUuaW5mbztwcmV2V2Fybj1jb25zb2xlLndhcm47cHJldkVycm9yPWNvbnNvbGUuZXJyb3I7cHJldkdyb3VwPWNvbnNvbGUuZ3JvdXA7cHJldkdyb3VwQ29sbGFwc2VkPWNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7cHJldkdyb3VwRW5kPWNvbnNvbGUuZ3JvdXBFbmQ7Ly8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxudmFyIHByb3BzPXtjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOnRydWUsdmFsdWU6ZGlzYWJsZWRMb2csd3JpdGFibGU6dHJ1ZX07Ly8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUse2luZm86cHJvcHMsbG9nOnByb3BzLHdhcm46cHJvcHMsZXJyb3I6cHJvcHMsZ3JvdXA6cHJvcHMsZ3JvdXBDb2xsYXBzZWQ6cHJvcHMsZ3JvdXBFbmQ6cHJvcHN9KTsvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL31kaXNhYmxlZERlcHRoKys7fX1mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKXt7ZGlzYWJsZWREZXB0aC0tO2lmKGRpc2FibGVkRGVwdGg9PT0wKXsvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi92YXIgcHJvcHM9e2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6dHJ1ZSx3cml0YWJsZTp0cnVlfTsvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSx7bG9nOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkxvZ30pLGluZm86YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2SW5mb30pLHdhcm46YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2V2Fybn0pLGVycm9yOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkVycm9yfSksZ3JvdXA6YXNzaWduKHt9LHByb3BzLHt2YWx1ZTpwcmV2R3JvdXB9KSxncm91cENvbGxhcHNlZDphc3NpZ24oe30scHJvcHMse3ZhbHVlOnByZXZHcm91cENvbGxhcHNlZH0pLGdyb3VwRW5kOmFzc2lnbih7fSxwcm9wcyx7dmFsdWU6cHJldkdyb3VwRW5kfSl9KTsvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL31pZihkaXNhYmxlZERlcHRoPDApe2Vycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJysnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX19dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjt2YXIgcHJlZml4O2Z1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsc291cmNlLG93bmVyRm4pe3tpZihwcmVmaXg9PT11bmRlZmluZWQpey8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbnRyeXt0aHJvdyBFcnJvcigpO31jYXRjaCh4KXt2YXIgbWF0Y2g9eC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtwcmVmaXg9bWF0Y2gmJm1hdGNoWzFdfHwnJzt9fS8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxucmV0dXJuJ1xcbicrcHJlZml4K25hbWU7fX12YXIgcmVlbnRyeT1mYWxzZTt2YXIgY29tcG9uZW50RnJhbWVDYWNoZTt7dmFyIFBvc3NpYmx5V2Vha01hcD10eXBlb2YgV2Vha01hcD09PSdmdW5jdGlvbic/V2Vha01hcDpNYXA7Y29tcG9uZW50RnJhbWVDYWNoZT1uZXcgUG9zc2libHlXZWFrTWFwKCk7fWZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sY29uc3RydWN0KXsvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbmlmKCFmbnx8cmVlbnRyeSl7cmV0dXJuJyc7fXt2YXIgZnJhbWU9Y29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO2lmKGZyYW1lIT09dW5kZWZpbmVkKXtyZXR1cm4gZnJhbWU7fX12YXIgY29udHJvbDtyZWVudHJ5PXRydWU7dmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U9RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7Ly8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5FcnJvci5wcmVwYXJlU3RhY2tUcmFjZT11bmRlZmluZWQ7dmFyIHByZXZpb3VzRGlzcGF0Y2hlcjt7cHJldmlvdXNEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbi8vIGZvciB3YXJuaW5ncy5cblJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudD1udWxsO2Rpc2FibGVMb2dzKCk7fXRyeXsvLyBUaGlzIHNob3VsZCB0aHJvdy5cbmlmKGNvbnN0cnVjdCl7Ly8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG52YXIgRmFrZT1mdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fTsvLyAkRmxvd0ZpeE1lXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsJ3Byb3BzJyx7c2V0OmZ1bmN0aW9uKCl7Ly8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxudGhyb3cgRXJyb3IoKTt9fSk7aWYodHlwZW9mIFJlZmxlY3Q9PT0nb2JqZWN0JyYmUmVmbGVjdC5jb25zdHJ1Y3Qpey8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbi8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG50cnl7UmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSxbXSk7fWNhdGNoKHgpe2NvbnRyb2w9eDt9UmVmbGVjdC5jb25zdHJ1Y3QoZm4sW10sRmFrZSk7fWVsc2V7dHJ5e0Zha2UuY2FsbCgpO31jYXRjaCh4KXtjb250cm9sPXg7fWZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO319ZWxzZXt0cnl7dGhyb3cgRXJyb3IoKTt9Y2F0Y2goeCl7Y29udHJvbD14O31mbigpO319Y2F0Y2goc2FtcGxlKXsvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuaWYoc2FtcGxlJiZjb250cm9sJiZ0eXBlb2Ygc2FtcGxlLnN0YWNrPT09J3N0cmluZycpey8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4vLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbnZhciBzYW1wbGVMaW5lcz1zYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO3ZhciBjb250cm9sTGluZXM9Y29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7dmFyIHM9c2FtcGxlTGluZXMubGVuZ3RoLTE7dmFyIGM9Y29udHJvbExpbmVzLmxlbmd0aC0xO3doaWxlKHM+PTEmJmM+PTAmJnNhbXBsZUxpbmVzW3NdIT09Y29udHJvbExpbmVzW2NdKXsvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbi8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbi8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4vLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbi8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuYy0tO31mb3IoO3M+PTEmJmM+PTA7cy0tLGMtLSl7Ly8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4vLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbmlmKHNhbXBsZUxpbmVzW3NdIT09Y29udHJvbExpbmVzW2NdKXsvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbi8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbi8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG5pZihzIT09MXx8YyE9PTEpe2Rve3MtLTtjLS07Ly8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5pZihjPDB8fHNhbXBsZUxpbmVzW3NdIT09Y29udHJvbExpbmVzW2NdKXsvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbnZhciBfZnJhbWU9J1xcbicrc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCcgYXQgJyk7Ly8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5pZihmbi5kaXNwbGF5TmFtZSYmX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKXtfZnJhbWU9X2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+Jyxmbi5kaXNwbGF5TmFtZSk7fXtpZih0eXBlb2YgZm49PT0nZnVuY3Rpb24nKXtjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbixfZnJhbWUpO319Ly8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxucmV0dXJuIF9mcmFtZTt9fXdoaWxlKHM+PTEmJmM+PTApO31icmVhazt9fX19ZmluYWxseXtyZWVudHJ5PWZhbHNlO3tSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ9cHJldmlvdXNEaXNwYXRjaGVyO3JlZW5hYmxlTG9ncygpO31FcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1wcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO30vLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG52YXIgbmFtZT1mbj9mbi5kaXNwbGF5TmFtZXx8Zm4ubmFtZTonJzt2YXIgc3ludGhldGljRnJhbWU9bmFtZT9kZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKTonJzt7aWYodHlwZW9mIGZuPT09J2Z1bmN0aW9uJyl7Y29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sc3ludGhldGljRnJhbWUpO319cmV0dXJuIHN5bnRoZXRpY0ZyYW1lO31mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvcixzb3VyY2Usb3duZXJGbil7e3JldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsdHJ1ZSk7fX1mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sc291cmNlLG93bmVyRm4pe3tyZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbixmYWxzZSk7fX1mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KXt2YXIgcHJvdG90eXBlPUNvbXBvbmVudC5wcm90b3R5cGU7cmV0dXJuISEocHJvdG90eXBlJiZwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7fWZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLHNvdXJjZSxvd25lckZuKXtpZih0eXBlPT1udWxsKXtyZXR1cm4nJzt9aWYodHlwZW9mIHR5cGU9PT0nZnVuY3Rpb24nKXt7cmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSxzaG91bGRDb25zdHJ1Y3QodHlwZSkpO319aWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJyl7cmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO31zd2l0Y2godHlwZSl7Y2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO31pZih0eXBlb2YgdHlwZT09PSdvYmplY3QnKXtzd2l0Y2godHlwZS4kJHR5cGVvZil7Y2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOnJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO2Nhc2UgUkVBQ1RfTUVNT19UWVBFOi8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG5yZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSxzb3VyY2Usb3duZXJGbik7Y2FzZSBSRUFDVF9MQVpZX1RZUEU6e3ZhciBsYXp5Q29tcG9uZW50PXR5cGU7dmFyIHBheWxvYWQ9bGF6eUNvbXBvbmVudC5fcGF5bG9hZDt2YXIgaW5pdD1sYXp5Q29tcG9uZW50Ll9pbml0O3RyeXsvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxucmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLHNvdXJjZSxvd25lckZuKTt9Y2F0Y2goeCl7fX19fXJldHVybicnO31mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKXt2YXIgb3duZXI9ZmliZXIuX2RlYnVnT3duZXI/ZmliZXIuX2RlYnVnT3duZXIudHlwZTpudWxsO3ZhciBzb3VyY2U9ZmliZXIuX2RlYnVnU291cmNlO3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDpyZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7Y2FzZSBMYXp5Q29tcG9uZW50OnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO2Nhc2UgU3VzcGVuc2VDb21wb25lbnQ6cmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO2Nhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OnJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OnJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7Y2FzZSBGb3J3YXJkUmVmOnJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZS5yZW5kZXIpO2Nhc2UgQ2xhc3NDb21wb25lbnQ6cmV0dXJuIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShmaWJlci50eXBlKTtkZWZhdWx0OnJldHVybicnO319ZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKXt0cnl7dmFyIGluZm89Jyc7dmFyIG5vZGU9d29ya0luUHJvZ3Jlc3M7ZG97aW5mbys9ZGVzY3JpYmVGaWJlcihub2RlKTtub2RlPW5vZGUucmV0dXJuO313aGlsZShub2RlKTtyZXR1cm4gaW5mbzt9Y2F0Y2goeCl7cmV0dXJuJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcreC5tZXNzYWdlKydcXG4nK3guc3RhY2s7fX1mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsaW5uZXJUeXBlLHdyYXBwZXJOYW1lKXt2YXIgZGlzcGxheU5hbWU9b3V0ZXJUeXBlLmRpc3BsYXlOYW1lO2lmKGRpc3BsYXlOYW1lKXtyZXR1cm4gZGlzcGxheU5hbWU7fXZhciBmdW5jdGlvbk5hbWU9aW5uZXJUeXBlLmRpc3BsYXlOYW1lfHxpbm5lclR5cGUubmFtZXx8Jyc7cmV0dXJuIGZ1bmN0aW9uTmFtZSE9PScnP3dyYXBwZXJOYW1lK1wiKFwiK2Z1bmN0aW9uTmFtZStcIilcIjp3cmFwcGVyTmFtZTt9Ly8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKXtyZXR1cm4gdHlwZS5kaXNwbGF5TmFtZXx8J0NvbnRleHQnO30vLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSl7aWYodHlwZT09bnVsbCl7Ly8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG5yZXR1cm4gbnVsbDt9e2lmKHR5cGVvZiB0eXBlLnRhZz09PSdudW1iZXInKXtlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcrJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fWlmKHR5cGVvZiB0eXBlPT09J2Z1bmN0aW9uJyl7cmV0dXJuIHR5cGUuZGlzcGxheU5hbWV8fHR5cGUubmFtZXx8bnVsbDt9aWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJyl7cmV0dXJuIHR5cGU7fXN3aXRjaCh0eXBlKXtjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6cmV0dXJuJ0ZyYWdtZW50JztjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOnJldHVybidQb3J0YWwnO2Nhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpyZXR1cm4nUHJvZmlsZXInO2Nhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpyZXR1cm4nU3RyaWN0TW9kZSc7Y2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOnJldHVybidTdXNwZW5zZSc7Y2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6cmV0dXJuJ1N1c3BlbnNlTGlzdCc7fWlmKHR5cGVvZiB0eXBlPT09J29iamVjdCcpe3N3aXRjaCh0eXBlLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTp2YXIgY29udGV4dD10eXBlO3JldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSsnLkNvbnN1bWVyJztjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6dmFyIHByb3ZpZGVyPXR5cGU7cmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSsnLlByb3ZpZGVyJztjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6cmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsdHlwZS5yZW5kZXIsJ0ZvcndhcmRSZWYnKTtjYXNlIFJFQUNUX01FTU9fVFlQRTp2YXIgb3V0ZXJOYW1lPXR5cGUuZGlzcGxheU5hbWV8fG51bGw7aWYob3V0ZXJOYW1lIT09bnVsbCl7cmV0dXJuIG91dGVyTmFtZTt9cmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpfHwnTWVtbyc7Y2FzZSBSRUFDVF9MQVpZX1RZUEU6e3ZhciBsYXp5Q29tcG9uZW50PXR5cGU7dmFyIHBheWxvYWQ9bGF6eUNvbXBvbmVudC5fcGF5bG9hZDt2YXIgaW5pdD1sYXp5Q29tcG9uZW50Ll9pbml0O3RyeXtyZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO31jYXRjaCh4KXtyZXR1cm4gbnVsbDt9fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxufX1yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsaW5uZXJUeXBlLHdyYXBwZXJOYW1lKXt2YXIgZnVuY3Rpb25OYW1lPWlubmVyVHlwZS5kaXNwbGF5TmFtZXx8aW5uZXJUeXBlLm5hbWV8fCcnO3JldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWV8fChmdW5jdGlvbk5hbWUhPT0nJz93cmFwcGVyTmFtZStcIihcIitmdW5jdGlvbk5hbWUrXCIpXCI6d3JhcHBlck5hbWUpO30vLyBLZWVwIGluIHN5bmMgd2l0aCBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSQxKHR5cGUpe3JldHVybiB0eXBlLmRpc3BsYXlOYW1lfHwnQ29udGV4dCc7fWZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpe3ZhciB0YWc9ZmliZXIudGFnLHR5cGU9ZmliZXIudHlwZTtzd2l0Y2godGFnKXtjYXNlIENhY2hlQ29tcG9uZW50OnJldHVybidDYWNoZSc7Y2FzZSBDb250ZXh0Q29uc3VtZXI6dmFyIGNvbnRleHQ9dHlwZTtyZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb250ZXh0KSsnLkNvbnN1bWVyJztjYXNlIENvbnRleHRQcm92aWRlcjp2YXIgcHJvdmlkZXI9dHlwZTtyZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShwcm92aWRlci5fY29udGV4dCkrJy5Qcm92aWRlcic7Y2FzZSBEZWh5ZHJhdGVkRnJhZ21lbnQ6cmV0dXJuJ0RlaHlkcmF0ZWRGcmFnbWVudCc7Y2FzZSBGb3J3YXJkUmVmOnJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsdHlwZS5yZW5kZXIsJ0ZvcndhcmRSZWYnKTtjYXNlIEZyYWdtZW50OnJldHVybidGcmFnbWVudCc7Y2FzZSBIb3N0Q29tcG9uZW50Oi8vIEhvc3QgY29tcG9uZW50IHR5cGUgaXMgdGhlIGRpc3BsYXkgbmFtZSAoZS5nLiBcImRpdlwiLCBcIlZpZXdcIilcbnJldHVybiB0eXBlO2Nhc2UgSG9zdFBvcnRhbDpyZXR1cm4nUG9ydGFsJztjYXNlIEhvc3RSb290OnJldHVybidSb290JztjYXNlIEhvc3RUZXh0OnJldHVybidUZXh0JztjYXNlIExhenlDb21wb25lbnQ6Ly8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbnJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7Y2FzZSBNb2RlOmlmKHR5cGU9PT1SRUFDVF9TVFJJQ1RfTU9ERV9UWVBFKXsvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxucmV0dXJuJ1N0cmljdE1vZGUnO31yZXR1cm4nTW9kZSc7Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6cmV0dXJuJ09mZnNjcmVlbic7Y2FzZSBQcm9maWxlcjpyZXR1cm4nUHJvZmlsZXInO2Nhc2UgU2NvcGVDb21wb25lbnQ6cmV0dXJuJ1Njb3BlJztjYXNlIFN1c3BlbnNlQ29tcG9uZW50OnJldHVybidTdXNwZW5zZSc7Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6cmV0dXJuJ1N1c3BlbnNlTGlzdCc7Y2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OnJldHVybidUcmFjaW5nTWFya2VyJzsvLyBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGlzIHRhZ3MgY29tZSBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHR5cGU6XG5jYXNlIENsYXNzQ29tcG9uZW50OmNhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6Y2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OmNhc2UgTWVtb0NvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6aWYodHlwZW9mIHR5cGU9PT0nZnVuY3Rpb24nKXtyZXR1cm4gdHlwZS5kaXNwbGF5TmFtZXx8dHlwZS5uYW1lfHxudWxsO31pZih0eXBlb2YgdHlwZT09PSdzdHJpbmcnKXtyZXR1cm4gdHlwZTt9YnJlYWs7fXJldHVybiBudWxsO312YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO3ZhciBjdXJyZW50PW51bGw7dmFyIGlzUmVuZGVyaW5nPWZhbHNlO2Z1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCl7e2lmKGN1cnJlbnQ9PT1udWxsKXtyZXR1cm4gbnVsbDt9dmFyIG93bmVyPWN1cnJlbnQuX2RlYnVnT3duZXI7aWYob3duZXIhPT1udWxsJiZ0eXBlb2Ygb3duZXIhPT0ndW5kZWZpbmVkJyl7cmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpO319cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKXt7aWYoY3VycmVudD09PW51bGwpe3JldHVybicnO30vLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbi8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5yZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO319ZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKXt7UmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s9bnVsbDtjdXJyZW50PW51bGw7aXNSZW5kZXJpbmc9ZmFsc2U7fX1mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpe3tSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaz1maWJlcj09PW51bGw/bnVsbDpnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O2N1cnJlbnQ9ZmliZXI7aXNSZW5kZXJpbmc9ZmFsc2U7fX1mdW5jdGlvbiBnZXRDdXJyZW50RmliZXIoKXt7cmV0dXJuIGN1cnJlbnQ7fX1mdW5jdGlvbiBzZXRJc1JlbmRlcmluZyhyZW5kZXJpbmcpe3tpc1JlbmRlcmluZz1yZW5kZXJpbmc7fX0vLyBGbG93IGRvZXMgbm90IGFsbG93IHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIG1vc3Qgbm9uLXN0cmluZyB0eXBlcy4gVG8gd29ya1xuLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgd2UgdXNlIGFuIG9wYXF1ZSB0eXBlIHRoYXQgY2FuIG9ubHkgYmUgb2J0YWluZWQgYnlcbi8vIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggZ2V0VG9TdHJpbmdWYWx1ZSBmaXJzdC5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKXsvLyBUaGUgY29lcmNpb24gc2FmZXR5IGNoZWNrIGlzIHBlcmZvcm1lZCBpbiBnZXRUb1N0cmluZ1ZhbHVlKCkuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbnJldHVybicnK3ZhbHVlO31mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKXtzd2l0Y2godHlwZW9mIHZhbHVlKXtjYXNlJ2Jvb2xlYW4nOmNhc2UnbnVtYmVyJzpjYXNlJ3N0cmluZyc6Y2FzZSd1bmRlZmluZWQnOnJldHVybiB2YWx1ZTtjYXNlJ29iamVjdCc6e2NoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSk7fXJldHVybiB2YWx1ZTtkZWZhdWx0Oi8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbnJldHVybicnO319dmFyIGhhc1JlYWRPbmx5VmFsdWU9e2J1dHRvbjp0cnVlLGNoZWNrYm94OnRydWUsaW1hZ2U6dHJ1ZSxoaWRkZW46dHJ1ZSxyYWRpbzp0cnVlLHJlc2V0OnRydWUsc3VibWl0OnRydWV9O2Z1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSxwcm9wcyl7e2lmKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXXx8cHJvcHMub25DaGFuZ2V8fHByb3BzLm9uSW5wdXR8fHByb3BzLnJlYWRPbmx5fHxwcm9wcy5kaXNhYmxlZHx8cHJvcHMudmFsdWU9PW51bGwpKXtlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcrJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJysndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnKydzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTt9aWYoIShwcm9wcy5vbkNoYW5nZXx8cHJvcHMucmVhZE9ubHl8fHByb3BzLmRpc2FibGVkfHxwcm9wcy5jaGVja2VkPT1udWxsKSl7ZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcrJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJysndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcrJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO319fWZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pe3ZhciB0eXBlPWVsZW0udHlwZTt2YXIgbm9kZU5hbWU9ZWxlbS5ub2RlTmFtZTtyZXR1cm4gbm9kZU5hbWUmJm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT0naW5wdXQnJiYodHlwZT09PSdjaGVja2JveCd8fHR5cGU9PT0ncmFkaW8nKTt9ZnVuY3Rpb24gZ2V0VHJhY2tlcihub2RlKXtyZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO31mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpe25vZGUuX3ZhbHVlVHJhY2tlcj1udWxsO31mdW5jdGlvbiBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpe3ZhciB2YWx1ZT0nJztpZighbm9kZSl7cmV0dXJuIHZhbHVlO31pZihpc0NoZWNrYWJsZShub2RlKSl7dmFsdWU9bm9kZS5jaGVja2VkPyd0cnVlJzonZmFsc2UnO31lbHNle3ZhbHVlPW5vZGUudmFsdWU7fXJldHVybiB2YWx1ZTt9ZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKXt2YXIgdmFsdWVGaWVsZD1pc0NoZWNrYWJsZShub2RlKT8nY2hlY2tlZCc6J3ZhbHVlJzt2YXIgZGVzY3JpcHRvcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLHZhbHVlRmllbGQpO3tjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24obm9kZVt2YWx1ZUZpZWxkXSk7fXZhciBjdXJyZW50VmFsdWU9Jycrbm9kZVt2YWx1ZUZpZWxkXTsvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbi8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4vLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG5pZihub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpfHx0eXBlb2YgZGVzY3JpcHRvcj09PSd1bmRlZmluZWQnfHx0eXBlb2YgZGVzY3JpcHRvci5nZXQhPT0nZnVuY3Rpb24nfHx0eXBlb2YgZGVzY3JpcHRvci5zZXQhPT0nZnVuY3Rpb24nKXtyZXR1cm47fXZhciBnZXQ9ZGVzY3JpcHRvci5nZXQsc2V0PWRlc2NyaXB0b3Iuc2V0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLHZhbHVlRmllbGQse2NvbmZpZ3VyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBnZXQuY2FsbCh0aGlzKTt9LHNldDpmdW5jdGlvbih2YWx1ZSl7e2NoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSk7fWN1cnJlbnRWYWx1ZT0nJyt2YWx1ZTtzZXQuY2FsbCh0aGlzLHZhbHVlKTt9fSk7Ly8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbi8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuLy8gQ2FsbGluZyBkZWZpbmVQcm9wZXJ0eSgpIGFnYWluIHNob3VsZCBiZSBlcXVpdmFsZW50LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsdmFsdWVGaWVsZCx7ZW51bWVyYWJsZTpkZXNjcmlwdG9yLmVudW1lcmFibGV9KTt2YXIgdHJhY2tlcj17Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gY3VycmVudFZhbHVlO30sc2V0VmFsdWU6ZnVuY3Rpb24odmFsdWUpe3tjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO31jdXJyZW50VmFsdWU9JycrdmFsdWU7fSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXtkZXRhY2hUcmFja2VyKG5vZGUpO2RlbGV0ZSBub2RlW3ZhbHVlRmllbGRdO319O3JldHVybiB0cmFja2VyO31mdW5jdGlvbiB0cmFjayhub2RlKXtpZihnZXRUcmFja2VyKG5vZGUpKXtyZXR1cm47fS8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG5ub2RlLl92YWx1ZVRyYWNrZXI9dHJhY2tWYWx1ZU9uTm9kZShub2RlKTt9ZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSl7aWYoIW5vZGUpe3JldHVybiBmYWxzZTt9dmFyIHRyYWNrZXI9Z2V0VHJhY2tlcihub2RlKTsvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuLy8gdGhhdCB0cnlpbmcgYWdhaW4gd2lsbCBzdWNjZWVkXG5pZighdHJhY2tlcil7cmV0dXJuIHRydWU7fXZhciBsYXN0VmFsdWU9dHJhY2tlci5nZXRWYWx1ZSgpO3ZhciBuZXh0VmFsdWU9Z2V0VmFsdWVGcm9tTm9kZShub2RlKTtpZihuZXh0VmFsdWUhPT1sYXN0VmFsdWUpe3RyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYyl7ZG9jPWRvY3x8KHR5cGVvZiBkb2N1bWVudCE9PSd1bmRlZmluZWQnP2RvY3VtZW50OnVuZGVmaW5lZCk7aWYodHlwZW9mIGRvYz09PSd1bmRlZmluZWQnKXtyZXR1cm4gbnVsbDt9dHJ5e3JldHVybiBkb2MuYWN0aXZlRWxlbWVudHx8ZG9jLmJvZHk7fWNhdGNoKGUpe3JldHVybiBkb2MuYm9keTt9fXZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWU9ZmFsc2U7dmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQ9ZmFsc2U7dmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQ9ZmFsc2U7dmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQ9ZmFsc2U7ZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKXt2YXIgdXNlc0NoZWNrZWQ9cHJvcHMudHlwZT09PSdjaGVja2JveCd8fHByb3BzLnR5cGU9PT0ncmFkaW8nO3JldHVybiB1c2VzQ2hlY2tlZD9wcm9wcy5jaGVja2VkIT1udWxsOnByb3BzLnZhbHVlIT1udWxsO30vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgY2hlY2tlZD1wcm9wcy5jaGVja2VkO3ZhciBob3N0UHJvcHM9YXNzaWduKHt9LHByb3BzLHtkZWZhdWx0Q2hlY2tlZDp1bmRlZmluZWQsZGVmYXVsdFZhbHVlOnVuZGVmaW5lZCx2YWx1ZTp1bmRlZmluZWQsY2hlY2tlZDpjaGVja2VkIT1udWxsP2NoZWNrZWQ6bm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSk7cmV0dXJuIGhvc3RQcm9wczt9ZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LHByb3BzKXt7Y2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLHByb3BzKTtpZihwcm9wcy5jaGVja2VkIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0Q2hlY2tlZCE9PXVuZGVmaW5lZCYmIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpe2Vycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJysnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJysnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcrJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcrJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKXx8J0EgY29tcG9uZW50Jyxwcm9wcy50eXBlKTtkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkPXRydWU7fWlmKHByb3BzLnZhbHVlIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0VmFsdWUhPT11bmRlZmluZWQmJiFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpe2Vycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnKydJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnKycoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnKydib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnKydlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCl8fCdBIGNvbXBvbmVudCcscHJvcHMudHlwZSk7ZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlPXRydWU7fX12YXIgbm9kZT1lbGVtZW50O3ZhciBkZWZhdWx0VmFsdWU9cHJvcHMuZGVmYXVsdFZhbHVlPT1udWxsPycnOnByb3BzLmRlZmF1bHRWYWx1ZTtub2RlLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOnByb3BzLmNoZWNrZWQhPW51bGw/cHJvcHMuY2hlY2tlZDpwcm9wcy5kZWZhdWx0Q2hlY2tlZCxpbml0aWFsVmFsdWU6Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSE9bnVsbD9wcm9wcy52YWx1ZTpkZWZhdWx0VmFsdWUpLGNvbnRyb2xsZWQ6aXNDb250cm9sbGVkKHByb3BzKX07fWZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgY2hlY2tlZD1wcm9wcy5jaGVja2VkO2lmKGNoZWNrZWQhPW51bGwpe3NldFZhbHVlRm9yUHJvcGVydHkobm9kZSwnY2hlY2tlZCcsY2hlY2tlZCxmYWxzZSk7fX1mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7e3ZhciBjb250cm9sbGVkPWlzQ29udHJvbGxlZChwcm9wcyk7aWYoIW5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkJiZjb250cm9sbGVkJiYhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCl7ZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCB0byBiZSBjb250cm9sbGVkLiAnKydUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gdW5kZWZpbmVkIHRvICcrJ2EgZGVmaW5lZCB2YWx1ZSwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcrJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJysnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO2RpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQ9dHJ1ZTt9aWYobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQmJiFjb250cm9sbGVkJiYhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCl7ZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCB0byBiZSB1bmNvbnRyb2xsZWQuICcrJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSBhIGRlZmluZWQgdG8gJysndW5kZWZpbmVkLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJysnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnKydlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7ZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZD10cnVlO319dXBkYXRlQ2hlY2tlZChlbGVtZW50LHByb3BzKTt2YXIgdmFsdWU9Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7dmFyIHR5cGU9cHJvcHMudHlwZTtpZih2YWx1ZSE9bnVsbCl7aWYodHlwZT09PSdudW1iZXInKXtpZih2YWx1ZT09PTAmJm5vZGUudmFsdWU9PT0nJ3x8Ly8gV2UgZXhwbGljaXRseSB3YW50IHRvIGNvZXJjZSB0byBudW1iZXIgaGVyZSBpZiBwb3NzaWJsZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxubm9kZS52YWx1ZSE9dmFsdWUpe25vZGUudmFsdWU9dG9TdHJpbmcodmFsdWUpO319ZWxzZSBpZihub2RlLnZhbHVlIT09dG9TdHJpbmcodmFsdWUpKXtub2RlLnZhbHVlPXRvU3RyaW5nKHZhbHVlKTt9fWVsc2UgaWYodHlwZT09PSdzdWJtaXQnfHx0eXBlPT09J3Jlc2V0Jyl7Ly8gU3VibWl0L3Jlc2V0IGlucHV0cyBuZWVkIHRoZSBhdHRyaWJ1dGUgcmVtb3ZlZCBjb21wbGV0ZWx5IHRvIGF2b2lkXG4vLyBibGFuay10ZXh0IGJ1dHRvbnMuXG5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtyZXR1cm47fXsvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIGNvbWVzIGZyb20gYSBjYXNjYWRlIG9mXG4vLyBwcm9wZXJ0aWVzOlxuLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuLy8gIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHlcbi8vICAzLiBPdGhlcndpc2UgdGhlcmUgc2hvdWxkIGJlIG5vIGNoYW5nZVxuaWYocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpe3NldERlZmF1bHRWYWx1ZShub2RlLHByb3BzLnR5cGUsdmFsdWUpO31lbHNlIGlmKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSl7c2V0RGVmYXVsdFZhbHVlKG5vZGUscHJvcHMudHlwZSxnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO319ey8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGl0IG9ubHkgY2hhbmdlcyB3aGVuIGl0IG5lZWRzXG4vLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG5pZihwcm9wcy5jaGVja2VkPT1udWxsJiZwcm9wcy5kZWZhdWx0Q2hlY2tlZCE9bnVsbCl7bm9kZS5kZWZhdWx0Q2hlY2tlZD0hIXByb3BzLmRlZmF1bHRDaGVja2VkO319fWZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCxwcm9wcyxpc0h5ZHJhdGluZyl7dmFyIG5vZGU9ZWxlbWVudDsvLyBEbyBub3QgYXNzaWduIHZhbHVlIGlmIGl0IGlzIGFscmVhZHkgc2V0LiBUaGlzIHByZXZlbnRzIHVzZXIgdGV4dCBpbnB1dFxuLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuaWYocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJyl8fHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSl7dmFyIHR5cGU9cHJvcHMudHlwZTt2YXIgaXNCdXR0b249dHlwZT09PSdzdWJtaXQnfHx0eXBlPT09J3Jlc2V0JzsvLyBBdm9pZCBzZXR0aW5nIHZhbHVlIGF0dHJpYnV0ZSBvbiBzdWJtaXQvcmVzZXQgaW5wdXRzIGFzIGl0IG92ZXJyaWRlcyB0aGVcbi8vIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIuIFNlZTogIzEyODcyXG5pZihpc0J1dHRvbiYmKHByb3BzLnZhbHVlPT09dW5kZWZpbmVkfHxwcm9wcy52YWx1ZT09PW51bGwpKXtyZXR1cm47fXZhciBpbml0aWFsVmFsdWU9dG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7Ly8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbi8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cbmlmKCFpc0h5ZHJhdGluZyl7ey8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgcHJvcGVydHkgc2hvdWxkIHVzZVxuLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4vL1xuLy8gICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4vLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4vLyAgIDMuIEFuIGVtcHR5IHN0cmluZ1xuaWYoaW5pdGlhbFZhbHVlIT09bm9kZS52YWx1ZSl7bm9kZS52YWx1ZT1pbml0aWFsVmFsdWU7fX19ey8vIE90aGVyd2lzZSwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBzeW5jaHJvbml6ZWQgdG8gdGhlIHByb3BlcnR5LFxuLy8gc28gd2UgYXNzaWduIGRlZmF1bHRWYWx1ZSB0byB0aGUgc2FtZSB0aGluZyBhcyB0aGUgdmFsdWUgcHJvcGVydHlcbi8vIGFzc2lnbm1lbnQgc3RlcCBhYm92ZS5cbm5vZGUuZGVmYXVsdFZhbHVlPWluaXRpYWxWYWx1ZTt9fS8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4vLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbi8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG52YXIgbmFtZT1ub2RlLm5hbWU7aWYobmFtZSE9PScnKXtub2RlLm5hbWU9Jyc7fXsvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBib3RoIHRoZSBjaGVja2VkIHByb3BlcnR5IGFuZFxuLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4vL1xuLy8gICAxLiBUaGUgY2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbi8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuLy8gICAzLiBPdGhlcndpc2UsIGZhbHNlXG5ub2RlLmRlZmF1bHRDaGVja2VkPSFub2RlLmRlZmF1bHRDaGVja2VkO25vZGUuZGVmYXVsdENoZWNrZWQ9ISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7fWlmKG5hbWUhPT0nJyl7bm9kZS5uYW1lPW5hbWU7fX1mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dXBkYXRlV3JhcHBlcihub2RlLHByb3BzKTt1cGRhdGVOYW1lZENvdXNpbnMobm9kZSxwcm9wcyk7fWZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSxwcm9wcyl7dmFyIG5hbWU9cHJvcHMubmFtZTtpZihwcm9wcy50eXBlPT09J3JhZGlvJyYmbmFtZSE9bnVsbCl7dmFyIHF1ZXJ5Um9vdD1yb290Tm9kZTt3aGlsZShxdWVyeVJvb3QucGFyZW50Tm9kZSl7cXVlcnlSb290PXF1ZXJ5Um9vdC5wYXJlbnROb2RlO30vLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4vLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2Vcbi8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuLy8gZG9jdW1lbnQuIExldCdzIGp1c3QgdXNlIHRoZSBsb2NhbCBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0XG4vLyBtaXNzIGFueXRoaW5nLlxue2NoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24obmFtZSwnbmFtZScpO312YXIgZ3JvdXA9cXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JytKU09OLnN0cmluZ2lmeSgnJytuYW1lKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IodmFyIGk9MDtpPGdyb3VwLmxlbmd0aDtpKyspe3ZhciBvdGhlck5vZGU9Z3JvdXBbaV07aWYob3RoZXJOb2RlPT09cm9vdE5vZGV8fG90aGVyTm9kZS5mb3JtIT09cm9vdE5vZGUuZm9ybSl7Y29udGludWU7fS8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3Rcbi8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4vLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxudmFyIG90aGVyUHJvcHM9Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShvdGhlck5vZGUpO2lmKCFvdGhlclByb3BzKXt0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnKydzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpO30vLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG51cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpOy8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbi8vIGFzIGFwcHJvcHJpYXRlLlxudXBkYXRlV3JhcHBlcihvdGhlck5vZGUsb3RoZXJQcm9wcyk7fX19Ly8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbmZ1bmN0aW9uIHNldERlZmF1bHRWYWx1ZShub2RlLHR5cGUsdmFsdWUpe2lmKC8vIEZvY3VzZWQgbnVtYmVyIGlucHV0cyBzeW5jaHJvbml6ZSBvbiBibHVyLiBTZWUgQ2hhbmdlRXZlbnRQbHVnaW4uanNcbnR5cGUhPT0nbnVtYmVyJ3x8Z2V0QWN0aXZlRWxlbWVudChub2RlLm93bmVyRG9jdW1lbnQpIT09bm9kZSl7aWYodmFsdWU9PW51bGwpe25vZGUuZGVmYXVsdFZhbHVlPXRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO31lbHNlIGlmKG5vZGUuZGVmYXVsdFZhbHVlIT09dG9TdHJpbmcodmFsdWUpKXtub2RlLmRlZmF1bHRWYWx1ZT10b1N0cmluZyh2YWx1ZSk7fX19dmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uPWZhbHNlO3ZhciBkaWRXYXJuSW52YWxpZENoaWxkPWZhbHNlO3ZhciBkaWRXYXJuSW52YWxpZElubmVySFRNTD1mYWxzZTsvKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LHByb3BzKXt7Ly8gSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZW4gdGhlIGNoaWxkcmVuIG11c3QgYmUgc2ltcGxlLlxuaWYocHJvcHMudmFsdWU9PW51bGwpe2lmKHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdvYmplY3QnJiZwcm9wcy5jaGlsZHJlbiE9PW51bGwpe1JlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sZnVuY3Rpb24oY2hpbGQpe2lmKGNoaWxkPT1udWxsKXtyZXR1cm47fWlmKHR5cGVvZiBjaGlsZD09PSdzdHJpbmcnfHx0eXBlb2YgY2hpbGQ9PT0nbnVtYmVyJyl7cmV0dXJuO31pZighZGlkV2FybkludmFsaWRDaGlsZCl7ZGlkV2FybkludmFsaWRDaGlsZD10cnVlO2Vycm9yKCdDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiAnKydQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTt9fSk7fWVsc2UgaWYocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPW51bGwpe2lmKCFkaWRXYXJuSW52YWxpZElubmVySFRNTCl7ZGlkV2FybkludmFsaWRJbm5lckhUTUw9dHJ1ZTtlcnJvcignUGFzcyBhIGB2YWx1ZWAgcHJvcCBpZiB5b3Ugc2V0IGRhbmdlcm91c2x5SW5uZXJIVE1MIHNvIFJlYWN0IGtub3dzICcrJ3doaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC4nKTt9fX0vLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbmlmKHByb3BzLnNlbGVjdGVkIT1udWxsJiYhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pe2Vycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnKydzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7ZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb249dHJ1ZTt9fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCxwcm9wcyl7Ly8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG5pZihwcm9wcy52YWx1ZSE9bnVsbCl7ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJyx0b1N0cmluZyhnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKSkpO319dmFyIGlzQXJyYXlJbXBsPUFycmF5LmlzQXJyYXk7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gaXNBcnJheShhKXtyZXR1cm4gaXNBcnJheUltcGwoYSk7fXZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMTt7ZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE9ZmFsc2U7fWZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpe3ZhciBvd25lck5hbWU9Z2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtpZihvd25lck5hbWUpe3JldHVybidcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJytvd25lck5hbWUrJ2AuJzt9cmV0dXJuJyc7fXZhciB2YWx1ZVByb3BOYW1lcz1bJ3ZhbHVlJywnZGVmYXVsdFZhbHVlJ107LyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL2Z1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKXt7Y2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0Jyxwcm9wcyk7Zm9yKHZhciBpPTA7aTx2YWx1ZVByb3BOYW1lcy5sZW5ndGg7aSsrKXt2YXIgcHJvcE5hbWU9dmFsdWVQcm9wTmFtZXNbaV07aWYocHJvcHNbcHJvcE5hbWVdPT1udWxsKXtjb250aW51ZTt9dmFyIHByb3BOYW1lSXNBcnJheT1pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7aWYocHJvcHMubXVsdGlwbGUmJiFwcm9wTmFtZUlzQXJyYXkpe2Vycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJysnYG11bHRpcGxlYCBpcyB0cnVlLiVzJyxwcm9wTmFtZSxnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7fWVsc2UgaWYoIXByb3BzLm11bHRpcGxlJiZwcm9wTmFtZUlzQXJyYXkpe2Vycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJysndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycscHJvcE5hbWUsZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO319fX1mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsbXVsdGlwbGUscHJvcFZhbHVlLHNldERlZmF1bHRTZWxlY3RlZCl7dmFyIG9wdGlvbnM9bm9kZS5vcHRpb25zO2lmKG11bHRpcGxlKXt2YXIgc2VsZWN0ZWRWYWx1ZXM9cHJvcFZhbHVlO3ZhciBzZWxlY3RlZFZhbHVlPXt9O2Zvcih2YXIgaT0wO2k8c2VsZWN0ZWRWYWx1ZXMubGVuZ3RoO2krKyl7Ly8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuc2VsZWN0ZWRWYWx1ZVsnJCcrc2VsZWN0ZWRWYWx1ZXNbaV1dPXRydWU7fWZvcih2YXIgX2k9MDtfaTxvcHRpb25zLmxlbmd0aDtfaSsrKXt2YXIgc2VsZWN0ZWQ9c2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcrb3B0aW9uc1tfaV0udmFsdWUpO2lmKG9wdGlvbnNbX2ldLnNlbGVjdGVkIT09c2VsZWN0ZWQpe29wdGlvbnNbX2ldLnNlbGVjdGVkPXNlbGVjdGVkO31pZihzZWxlY3RlZCYmc2V0RGVmYXVsdFNlbGVjdGVkKXtvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQ9dHJ1ZTt9fX1lbHNley8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4vLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxudmFyIF9zZWxlY3RlZFZhbHVlPXRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7dmFyIGRlZmF1bHRTZWxlY3RlZD1udWxsO2Zvcih2YXIgX2kyPTA7X2kyPG9wdGlvbnMubGVuZ3RoO19pMisrKXtpZihvcHRpb25zW19pMl0udmFsdWU9PT1fc2VsZWN0ZWRWYWx1ZSl7b3B0aW9uc1tfaTJdLnNlbGVjdGVkPXRydWU7aWYoc2V0RGVmYXVsdFNlbGVjdGVkKXtvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkPXRydWU7fXJldHVybjt9aWYoZGVmYXVsdFNlbGVjdGVkPT09bnVsbCYmIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCl7ZGVmYXVsdFNlbGVjdGVkPW9wdGlvbnNbX2kyXTt9fWlmKGRlZmF1bHRTZWxlY3RlZCE9PW51bGwpe2RlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZD10cnVlO319fS8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCxwcm9wcyl7cmV0dXJuIGFzc2lnbih7fSxwcm9wcyx7dmFsdWU6dW5kZWZpbmVkfSk7fWZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3tjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7fW5vZGUuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFwcm9wcy5tdWx0aXBsZX07e2lmKHByb3BzLnZhbHVlIT09dW5kZWZpbmVkJiZwcm9wcy5kZWZhdWx0VmFsdWUhPT11bmRlZmluZWQmJiFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSl7ZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnKycoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnKydib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJysnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7ZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE9dHJ1ZTt9fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDtub2RlLm11bHRpcGxlPSEhcHJvcHMubXVsdGlwbGU7dmFyIHZhbHVlPXByb3BzLnZhbHVlO2lmKHZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSx2YWx1ZSxmYWxzZSk7fWVsc2UgaWYocHJvcHMuZGVmYXVsdFZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSxwcm9wcy5kZWZhdWx0VmFsdWUsdHJ1ZSk7fX1mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O3ZhciB3YXNNdWx0aXBsZT1ub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7bm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhcHJvcHMubXVsdGlwbGU7dmFyIHZhbHVlPXByb3BzLnZhbHVlO2lmKHZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSx2YWx1ZSxmYWxzZSk7fWVsc2UgaWYod2FzTXVsdGlwbGUhPT0hIXByb3BzLm11bHRpcGxlKXsvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG5pZihwcm9wcy5kZWZhdWx0VmFsdWUhPW51bGwpe3VwZGF0ZU9wdGlvbnMobm9kZSwhIXByb3BzLm11bHRpcGxlLHByb3BzLmRlZmF1bHRWYWx1ZSx0cnVlKTt9ZWxzZXsvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG51cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSxwcm9wcy5tdWx0aXBsZT9bXTonJyxmYWxzZSk7fX19ZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7dmFyIHZhbHVlPXByb3BzLnZhbHVlO2lmKHZhbHVlIT1udWxsKXt1cGRhdGVPcHRpb25zKG5vZGUsISFwcm9wcy5tdWx0aXBsZSx2YWx1ZSxmYWxzZSk7fX12YXIgZGlkV2FyblZhbERlZmF1bHRWYWw9ZmFsc2U7LyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LHByb3BzKXt2YXIgbm9kZT1lbGVtZW50O2lmKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpO30vLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4vLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4vLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbi8vIHRvIGJlIGEgc3RyaW5nLlxudmFyIGhvc3RQcm9wcz1hc3NpZ24oe30scHJvcHMse3ZhbHVlOnVuZGVmaW5lZCxkZWZhdWx0VmFsdWU6dW5kZWZpbmVkLGNoaWxkcmVuOnRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpfSk7cmV0dXJuIGhvc3RQcm9wczt9ZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQscHJvcHMpe3ZhciBub2RlPWVsZW1lbnQ7e2NoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJyxwcm9wcyk7aWYocHJvcHMudmFsdWUhPT11bmRlZmluZWQmJnByb3BzLmRlZmF1bHRWYWx1ZSE9PXVuZGVmaW5lZCYmIWRpZFdhcm5WYWxEZWZhdWx0VmFsKXtlcnJvcignJXMgY29udGFpbnMgYSB0ZXh0YXJlYSB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJysnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJysnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJysnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJysnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKXx8J0EgY29tcG9uZW50Jyk7ZGlkV2FyblZhbERlZmF1bHRWYWw9dHJ1ZTt9fXZhciBpbml0aWFsVmFsdWU9cHJvcHMudmFsdWU7Ly8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbmlmKGluaXRpYWxWYWx1ZT09bnVsbCl7dmFyIGNoaWxkcmVuPXByb3BzLmNoaWxkcmVuLGRlZmF1bHRWYWx1ZT1wcm9wcy5kZWZhdWx0VmFsdWU7aWYoY2hpbGRyZW4hPW51bGwpe3tlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnKydjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO317aWYoZGVmYXVsdFZhbHVlIT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKTt9aWYoaXNBcnJheShjaGlsZHJlbikpe2lmKGNoaWxkcmVuLmxlbmd0aD4xKXt0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTt9Y2hpbGRyZW49Y2hpbGRyZW5bMF07fWRlZmF1bHRWYWx1ZT1jaGlsZHJlbjt9fWlmKGRlZmF1bHRWYWx1ZT09bnVsbCl7ZGVmYXVsdFZhbHVlPScnO31pbml0aWFsVmFsdWU9ZGVmYXVsdFZhbHVlO31ub2RlLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSl9O31mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDt2YXIgdmFsdWU9Z2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7dmFyIGRlZmF1bHRWYWx1ZT1nZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7aWYodmFsdWUhPW51bGwpey8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4vLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG52YXIgbmV3VmFsdWU9dG9TdHJpbmcodmFsdWUpOy8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG5pZihuZXdWYWx1ZSE9PW5vZGUudmFsdWUpe25vZGUudmFsdWU9bmV3VmFsdWU7fWlmKHByb3BzLmRlZmF1bHRWYWx1ZT09bnVsbCYmbm9kZS5kZWZhdWx0VmFsdWUhPT1uZXdWYWx1ZSl7bm9kZS5kZWZhdWx0VmFsdWU9bmV3VmFsdWU7fX1pZihkZWZhdWx0VmFsdWUhPW51bGwpe25vZGUuZGVmYXVsdFZhbHVlPXRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7fX1mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCxwcm9wcyl7dmFyIG5vZGU9ZWxlbWVudDsvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4vLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbnZhciB0ZXh0Q29udGVudD1ub2RlLnRleHRDb250ZW50Oy8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4vLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuaWYodGV4dENvbnRlbnQ9PT1ub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKXtpZih0ZXh0Q29udGVudCE9PScnJiZ0ZXh0Q29udGVudCE9PW51bGwpe25vZGUudmFsdWU9dGV4dENvbnRlbnQ7fX19ZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQscHJvcHMpey8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG51cGRhdGVXcmFwcGVyJDEoZWxlbWVudCxwcm9wcyk7fXZhciBIVE1MX05BTUVTUEFDRT0naHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7dmFyIE1BVEhfTkFNRVNQQUNFPSdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJzt2YXIgU1ZHX05BTUVTUEFDRT0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnOy8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKXtzd2l0Y2godHlwZSl7Y2FzZSdzdmcnOnJldHVybiBTVkdfTkFNRVNQQUNFO2Nhc2UnbWF0aCc6cmV0dXJuIE1BVEhfTkFNRVNQQUNFO2RlZmF1bHQ6cmV0dXJuIEhUTUxfTkFNRVNQQUNFO319ZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLHR5cGUpe2lmKHBhcmVudE5hbWVzcGFjZT09bnVsbHx8cGFyZW50TmFtZXNwYWNlPT09SFRNTF9OQU1FU1BBQ0Upey8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG5yZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO31pZihwYXJlbnROYW1lc3BhY2U9PT1TVkdfTkFNRVNQQUNFJiZ0eXBlPT09J2ZvcmVpZ25PYmplY3QnKXsvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbnJldHVybiBIVE1MX05BTUVTUEFDRTt9Ly8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5yZXR1cm4gcGFyZW50TmFtZXNwYWNlO30vKiBnbG9iYWxzIE1TQXBwICovIC8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi92YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbj1mdW5jdGlvbihmdW5jKXtpZih0eXBlb2YgTVNBcHAhPT0ndW5kZWZpbmVkJyYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pe3JldHVybiBmdW5jdGlvbihhcmcwLGFyZzEsYXJnMixhcmczKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBmdW5jKGFyZzAsYXJnMSxhcmcyLGFyZzMpO30pO307fWVsc2V7cmV0dXJuIGZ1bmM7fX07dmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyOy8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi92YXIgc2V0SW5uZXJIVE1MPWNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24obm9kZSxodG1sKXtpZihub2RlLm5hbWVzcGFjZVVSST09PVNWR19OQU1FU1BBQ0Upe2lmKCEoJ2lubmVySFRNTCdpbiBub2RlKSl7Ly8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4vLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4vLyB0aGUgdGFyZ2V0IG5vZGVcbnJldXNhYmxlU1ZHQ29udGFpbmVyPXJldXNhYmxlU1ZHQ29udGFpbmVyfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtyZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUw9Jzxzdmc+JytodG1sLnZhbHVlT2YoKS50b1N0cmluZygpKyc8L3N2Zz4nO3ZhciBzdmdOb2RlPXJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7d2hpbGUobm9kZS5maXJzdENoaWxkKXtub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7fXdoaWxlKHN2Z05vZGUuZmlyc3RDaGlsZCl7bm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO31yZXR1cm47fX1ub2RlLmlubmVySFRNTD1odG1sO30pOy8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL3ZhciBFTEVNRU5UX05PREU9MTt2YXIgVEVYVF9OT0RFPTM7dmFyIENPTU1FTlRfTk9ERT04O3ZhciBET0NVTUVOVF9OT0RFPTk7dmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU9MTE7LyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL3ZhciBzZXRUZXh0Q29udGVudD1mdW5jdGlvbihub2RlLHRleHQpe2lmKHRleHQpe3ZhciBmaXJzdENoaWxkPW5vZGUuZmlyc3RDaGlsZDtpZihmaXJzdENoaWxkJiZmaXJzdENoaWxkPT09bm9kZS5sYXN0Q2hpbGQmJmZpcnN0Q2hpbGQubm9kZVR5cGU9PT1URVhUX05PREUpe2ZpcnN0Q2hpbGQubm9kZVZhbHVlPXRleHQ7cmV0dXJuO319bm9kZS50ZXh0Q29udGVudD10ZXh0O307Ly8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZD17YW5pbWF0aW9uOlsnYW5pbWF0aW9uRGVsYXknLCdhbmltYXRpb25EaXJlY3Rpb24nLCdhbmltYXRpb25EdXJhdGlvbicsJ2FuaW1hdGlvbkZpbGxNb2RlJywnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCdhbmltYXRpb25OYW1lJywnYW5pbWF0aW9uUGxheVN0YXRlJywnYW5pbWF0aW9uVGltaW5nRnVuY3Rpb24nXSxiYWNrZ3JvdW5kOlsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCdiYWNrZ3JvdW5kQ2xpcCcsJ2JhY2tncm91bmRDb2xvcicsJ2JhY2tncm91bmRJbWFnZScsJ2JhY2tncm91bmRPcmlnaW4nLCdiYWNrZ3JvdW5kUG9zaXRpb25YJywnYmFja2dyb3VuZFBvc2l0aW9uWScsJ2JhY2tncm91bmRSZXBlYXQnLCdiYWNrZ3JvdW5kU2l6ZSddLGJhY2tncm91bmRQb3NpdGlvbjpbJ2JhY2tncm91bmRQb3NpdGlvblgnLCdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sYm9yZGVyOlsnYm9yZGVyQm90dG9tQ29sb3InLCdib3JkZXJCb3R0b21TdHlsZScsJ2JvcmRlckJvdHRvbVdpZHRoJywnYm9yZGVySW1hZ2VPdXRzZXQnLCdib3JkZXJJbWFnZVJlcGVhdCcsJ2JvcmRlckltYWdlU2xpY2UnLCdib3JkZXJJbWFnZVNvdXJjZScsJ2JvcmRlckltYWdlV2lkdGgnLCdib3JkZXJMZWZ0Q29sb3InLCdib3JkZXJMZWZ0U3R5bGUnLCdib3JkZXJMZWZ0V2lkdGgnLCdib3JkZXJSaWdodENvbG9yJywnYm9yZGVyUmlnaHRTdHlsZScsJ2JvcmRlclJpZ2h0V2lkdGgnLCdib3JkZXJUb3BDb2xvcicsJ2JvcmRlclRvcFN0eWxlJywnYm9yZGVyVG9wV2lkdGgnXSxib3JkZXJCbG9ja0VuZDpbJ2JvcmRlckJsb2NrRW5kQ29sb3InLCdib3JkZXJCbG9ja0VuZFN0eWxlJywnYm9yZGVyQmxvY2tFbmRXaWR0aCddLGJvcmRlckJsb2NrU3RhcnQ6Wydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCdib3JkZXJCbG9ja1N0YXJ0V2lkdGgnXSxib3JkZXJCb3R0b206Wydib3JkZXJCb3R0b21Db2xvcicsJ2JvcmRlckJvdHRvbVN0eWxlJywnYm9yZGVyQm90dG9tV2lkdGgnXSxib3JkZXJDb2xvcjpbJ2JvcmRlckJvdHRvbUNvbG9yJywnYm9yZGVyTGVmdENvbG9yJywnYm9yZGVyUmlnaHRDb2xvcicsJ2JvcmRlclRvcENvbG9yJ10sYm9yZGVySW1hZ2U6Wydib3JkZXJJbWFnZU91dHNldCcsJ2JvcmRlckltYWdlUmVwZWF0JywnYm9yZGVySW1hZ2VTbGljZScsJ2JvcmRlckltYWdlU291cmNlJywnYm9yZGVySW1hZ2VXaWR0aCddLGJvcmRlcklubGluZUVuZDpbJ2JvcmRlcklubGluZUVuZENvbG9yJywnYm9yZGVySW5saW5lRW5kU3R5bGUnLCdib3JkZXJJbmxpbmVFbmRXaWR0aCddLGJvcmRlcklubGluZVN0YXJ0OlsnYm9yZGVySW5saW5lU3RhcnRDb2xvcicsJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sYm9yZGVyTGVmdDpbJ2JvcmRlckxlZnRDb2xvcicsJ2JvcmRlckxlZnRTdHlsZScsJ2JvcmRlckxlZnRXaWR0aCddLGJvcmRlclJhZGl1czpbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCdib3JkZXJCb3R0b21SaWdodFJhZGl1cycsJ2JvcmRlclRvcExlZnRSYWRpdXMnLCdib3JkZXJUb3BSaWdodFJhZGl1cyddLGJvcmRlclJpZ2h0OlsnYm9yZGVyUmlnaHRDb2xvcicsJ2JvcmRlclJpZ2h0U3R5bGUnLCdib3JkZXJSaWdodFdpZHRoJ10sYm9yZGVyU3R5bGU6Wydib3JkZXJCb3R0b21TdHlsZScsJ2JvcmRlckxlZnRTdHlsZScsJ2JvcmRlclJpZ2h0U3R5bGUnLCdib3JkZXJUb3BTdHlsZSddLGJvcmRlclRvcDpbJ2JvcmRlclRvcENvbG9yJywnYm9yZGVyVG9wU3R5bGUnLCdib3JkZXJUb3BXaWR0aCddLGJvcmRlcldpZHRoOlsnYm9yZGVyQm90dG9tV2lkdGgnLCdib3JkZXJMZWZ0V2lkdGgnLCdib3JkZXJSaWdodFdpZHRoJywnYm9yZGVyVG9wV2lkdGgnXSxjb2x1bW5SdWxlOlsnY29sdW1uUnVsZUNvbG9yJywnY29sdW1uUnVsZVN0eWxlJywnY29sdW1uUnVsZVdpZHRoJ10sY29sdW1uczpbJ2NvbHVtbkNvdW50JywnY29sdW1uV2lkdGgnXSxmbGV4OlsnZmxleEJhc2lzJywnZmxleEdyb3cnLCdmbGV4U2hyaW5rJ10sZmxleEZsb3c6WydmbGV4RGlyZWN0aW9uJywnZmxleFdyYXAnXSxmb250OlsnZm9udEZhbWlseScsJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCdmb250S2VybmluZycsJ2ZvbnRMYW5ndWFnZU92ZXJyaWRlJywnZm9udFNpemUnLCdmb250U2l6ZUFkanVzdCcsJ2ZvbnRTdHJldGNoJywnZm9udFN0eWxlJywnZm9udFZhcmlhbnQnLCdmb250VmFyaWFudEFsdGVybmF0ZXMnLCdmb250VmFyaWFudENhcHMnLCdmb250VmFyaWFudEVhc3RBc2lhbicsJ2ZvbnRWYXJpYW50TGlnYXR1cmVzJywnZm9udFZhcmlhbnROdW1lcmljJywnZm9udFZhcmlhbnRQb3NpdGlvbicsJ2ZvbnRXZWlnaHQnLCdsaW5lSGVpZ2h0J10sZm9udFZhcmlhbnQ6Wydmb250VmFyaWFudEFsdGVybmF0ZXMnLCdmb250VmFyaWFudENhcHMnLCdmb250VmFyaWFudEVhc3RBc2lhbicsJ2ZvbnRWYXJpYW50TGlnYXR1cmVzJywnZm9udFZhcmlhbnROdW1lcmljJywnZm9udFZhcmlhbnRQb3NpdGlvbiddLGdhcDpbJ2NvbHVtbkdhcCcsJ3Jvd0dhcCddLGdyaWQ6WydncmlkQXV0b0NvbHVtbnMnLCdncmlkQXV0b0Zsb3cnLCdncmlkQXV0b1Jvd3MnLCdncmlkVGVtcGxhdGVBcmVhcycsJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCdncmlkVGVtcGxhdGVSb3dzJ10sZ3JpZEFyZWE6WydncmlkQ29sdW1uRW5kJywnZ3JpZENvbHVtblN0YXJ0JywnZ3JpZFJvd0VuZCcsJ2dyaWRSb3dTdGFydCddLGdyaWRDb2x1bW46WydncmlkQ29sdW1uRW5kJywnZ3JpZENvbHVtblN0YXJ0J10sZ3JpZENvbHVtbkdhcDpbJ2NvbHVtbkdhcCddLGdyaWRHYXA6Wydjb2x1bW5HYXAnLCdyb3dHYXAnXSxncmlkUm93OlsnZ3JpZFJvd0VuZCcsJ2dyaWRSb3dTdGFydCddLGdyaWRSb3dHYXA6Wydyb3dHYXAnXSxncmlkVGVtcGxhdGU6WydncmlkVGVtcGxhdGVBcmVhcycsJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCdncmlkVGVtcGxhdGVSb3dzJ10sbGlzdFN0eWxlOlsnbGlzdFN0eWxlSW1hZ2UnLCdsaXN0U3R5bGVQb3NpdGlvbicsJ2xpc3RTdHlsZVR5cGUnXSxtYXJnaW46WydtYXJnaW5Cb3R0b20nLCdtYXJnaW5MZWZ0JywnbWFyZ2luUmlnaHQnLCdtYXJnaW5Ub3AnXSxtYXJrZXI6WydtYXJrZXJFbmQnLCdtYXJrZXJNaWQnLCdtYXJrZXJTdGFydCddLG1hc2s6WydtYXNrQ2xpcCcsJ21hc2tDb21wb3NpdGUnLCdtYXNrSW1hZ2UnLCdtYXNrTW9kZScsJ21hc2tPcmlnaW4nLCdtYXNrUG9zaXRpb25YJywnbWFza1Bvc2l0aW9uWScsJ21hc2tSZXBlYXQnLCdtYXNrU2l6ZSddLG1hc2tQb3NpdGlvbjpbJ21hc2tQb3NpdGlvblgnLCdtYXNrUG9zaXRpb25ZJ10sb3V0bGluZTpbJ291dGxpbmVDb2xvcicsJ291dGxpbmVTdHlsZScsJ291dGxpbmVXaWR0aCddLG92ZXJmbG93Olsnb3ZlcmZsb3dYJywnb3ZlcmZsb3dZJ10scGFkZGluZzpbJ3BhZGRpbmdCb3R0b20nLCdwYWRkaW5nTGVmdCcsJ3BhZGRpbmdSaWdodCcsJ3BhZGRpbmdUb3AnXSxwbGFjZUNvbnRlbnQ6WydhbGlnbkNvbnRlbnQnLCdqdXN0aWZ5Q29udGVudCddLHBsYWNlSXRlbXM6WydhbGlnbkl0ZW1zJywnanVzdGlmeUl0ZW1zJ10scGxhY2VTZWxmOlsnYWxpZ25TZWxmJywnanVzdGlmeVNlbGYnXSx0ZXh0RGVjb3JhdGlvbjpbJ3RleHREZWNvcmF0aW9uQ29sb3InLCd0ZXh0RGVjb3JhdGlvbkxpbmUnLCd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sdGV4dEVtcGhhc2lzOlsndGV4dEVtcGhhc2lzQ29sb3InLCd0ZXh0RW1waGFzaXNTdHlsZSddLHRyYW5zaXRpb246Wyd0cmFuc2l0aW9uRGVsYXknLCd0cmFuc2l0aW9uRHVyYXRpb24nLCd0cmFuc2l0aW9uUHJvcGVydHknLCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nXSx3b3JkV3JhcDpbJ292ZXJmbG93V3JhcCddfTsvKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL3ZhciBpc1VuaXRsZXNzTnVtYmVyPXthbmltYXRpb25JdGVyYXRpb25Db3VudDp0cnVlLGFzcGVjdFJhdGlvOnRydWUsYm9yZGVySW1hZ2VPdXRzZXQ6dHJ1ZSxib3JkZXJJbWFnZVNsaWNlOnRydWUsYm9yZGVySW1hZ2VXaWR0aDp0cnVlLGJveEZsZXg6dHJ1ZSxib3hGbGV4R3JvdXA6dHJ1ZSxib3hPcmRpbmFsR3JvdXA6dHJ1ZSxjb2x1bW5Db3VudDp0cnVlLGNvbHVtbnM6dHJ1ZSxmbGV4OnRydWUsZmxleEdyb3c6dHJ1ZSxmbGV4UG9zaXRpdmU6dHJ1ZSxmbGV4U2hyaW5rOnRydWUsZmxleE5lZ2F0aXZlOnRydWUsZmxleE9yZGVyOnRydWUsZ3JpZEFyZWE6dHJ1ZSxncmlkUm93OnRydWUsZ3JpZFJvd0VuZDp0cnVlLGdyaWRSb3dTcGFuOnRydWUsZ3JpZFJvd1N0YXJ0OnRydWUsZ3JpZENvbHVtbjp0cnVlLGdyaWRDb2x1bW5FbmQ6dHJ1ZSxncmlkQ29sdW1uU3Bhbjp0cnVlLGdyaWRDb2x1bW5TdGFydDp0cnVlLGZvbnRXZWlnaHQ6dHJ1ZSxsaW5lQ2xhbXA6dHJ1ZSxsaW5lSGVpZ2h0OnRydWUsb3BhY2l0eTp0cnVlLG9yZGVyOnRydWUsb3JwaGFuczp0cnVlLHRhYlNpemU6dHJ1ZSx3aWRvd3M6dHJ1ZSx6SW5kZXg6dHJ1ZSx6b29tOnRydWUsLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuZmlsbE9wYWNpdHk6dHJ1ZSxmbG9vZE9wYWNpdHk6dHJ1ZSxzdG9wT3BhY2l0eTp0cnVlLHN0cm9rZURhc2hhcnJheTp0cnVlLHN0cm9rZURhc2hvZmZzZXQ6dHJ1ZSxzdHJva2VNaXRlcmxpbWl0OnRydWUsc3Ryb2tlT3BhY2l0eTp0cnVlLHN0cm9rZVdpZHRoOnRydWV9Oy8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCxrZXkpe3JldHVybiBwcmVmaXgra2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2tleS5zdWJzdHJpbmcoMSk7fS8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi92YXIgcHJlZml4ZXM9WydXZWJraXQnLCdtcycsJ01veicsJ08nXTsvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7cHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpe2lzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCxwcm9wKV09aXNVbml0bGVzc051bWJlcltwcm9wXTt9KTt9KTsvKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLHZhbHVlLGlzQ3VzdG9tUHJvcGVydHkpey8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbi8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbi8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3Rcbi8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbi8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4vLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcbnZhciBpc0VtcHR5PXZhbHVlPT1udWxsfHx0eXBlb2YgdmFsdWU9PT0nYm9vbGVhbid8fHZhbHVlPT09Jyc7aWYoaXNFbXB0eSl7cmV0dXJuJyc7fWlmKCFpc0N1c3RvbVByb3BlcnR5JiZ0eXBlb2YgdmFsdWU9PT0nbnVtYmVyJyYmdmFsdWUhPT0wJiYhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkmJmlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKXtyZXR1cm4gdmFsdWUrJ3B4JzsvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xufXtjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsbmFtZSk7fXJldHVybignJyt2YWx1ZSkudHJpbSgpO312YXIgdXBwZXJjYXNlUGF0dGVybj0vKFtBLVpdKS9nO3ZhciBtc1BhdHRlcm49L15tcy0vOy8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpe3JldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwnLW1zLScpO312YXIgd2FyblZhbGlkU3R5bGU9ZnVuY3Rpb24oKXt9O3svLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG52YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuPS9eKD86d2Via2l0fG1venxvKVtBLVpdLzt2YXIgbXNQYXR0ZXJuJDE9L14tbXMtLzt2YXIgaHlwaGVuUGF0dGVybj0vLSguKS9nOy8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxudmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybj0vO1xccyokLzt2YXIgd2FybmVkU3R5bGVOYW1lcz17fTt2YXIgd2FybmVkU3R5bGVWYWx1ZXM9e307dmFyIHdhcm5lZEZvck5hTlZhbHVlPWZhbHNlO3ZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlPWZhbHNlO3ZhciBjYW1lbGl6ZT1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLGZ1bmN0aW9uKF8sY2hhcmFjdGVyKXtyZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7fSk7fTt2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWU9ZnVuY3Rpb24obmFtZSl7aWYod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSYmd2FybmVkU3R5bGVOYW1lc1tuYW1lXSl7cmV0dXJuO313YXJuZWRTdHlsZU5hbWVzW25hbWVdPXRydWU7ZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JyxuYW1lLC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbi8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbi8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbmNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwnbXMtJykpKTt9O3ZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWU9ZnVuY3Rpb24obmFtZSl7aWYod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSYmd2FybmVkU3R5bGVOYW1lc1tuYW1lXSl7cmV0dXJuO313YXJuZWRTdHlsZU5hbWVzW25hbWVdPXRydWU7ZXJyb3IoJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsbmFtZSxuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK25hbWUuc2xpY2UoMSkpO307dmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbj1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZih3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkmJndhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSl7cmV0dXJuO313YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV09dHJ1ZTtlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIrJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxuYW1lLHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCcnKSk7fTt2YXIgd2FyblN0eWxlVmFsdWVJc05hTj1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZih3YXJuZWRGb3JOYU5WYWx1ZSl7cmV0dXJuO313YXJuZWRGb3JOYU5WYWx1ZT10cnVlO2Vycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJyxuYW1lKTt9O3ZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHk9ZnVuY3Rpb24obmFtZSx2YWx1ZSl7aWYod2FybmVkRm9ySW5maW5pdHlWYWx1ZSl7cmV0dXJuO313YXJuZWRGb3JJbmZpbml0eVZhbHVlPXRydWU7ZXJyb3IoJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsbmFtZSk7fTt3YXJuVmFsaWRTdHlsZT1mdW5jdGlvbihuYW1lLHZhbHVlKXtpZihuYW1lLmluZGV4T2YoJy0nKT4tMSl7d2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7fWVsc2UgaWYoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpe3dhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTt9ZWxzZSBpZihiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpe3dhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLHZhbHVlKTt9aWYodHlwZW9mIHZhbHVlPT09J251bWJlcicpe2lmKGlzTmFOKHZhbHVlKSl7d2FyblN0eWxlVmFsdWVJc05hTihuYW1lLHZhbHVlKTt9ZWxzZSBpZighaXNGaW5pdGUodmFsdWUpKXt3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSx2YWx1ZSk7fX19O312YXIgd2FyblZhbGlkU3R5bGUkMT13YXJuVmFsaWRTdHlsZTsvKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqLyAvKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcyl7e3ZhciBzZXJpYWxpemVkPScnO3ZhciBkZWxpbWl0ZXI9Jyc7Zm9yKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKXtpZighc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpe2NvbnRpbnVlO312YXIgc3R5bGVWYWx1ZT1zdHlsZXNbc3R5bGVOYW1lXTtpZihzdHlsZVZhbHVlIT1udWxsKXt2YXIgaXNDdXN0b21Qcm9wZXJ0eT1zdHlsZU5hbWUuaW5kZXhPZignLS0nKT09PTA7c2VyaWFsaXplZCs9ZGVsaW1pdGVyKyhpc0N1c3RvbVByb3BlcnR5P3N0eWxlTmFtZTpoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkrJzonO3NlcmlhbGl6ZWQrPWRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLHN0eWxlVmFsdWUsaXNDdXN0b21Qcm9wZXJ0eSk7ZGVsaW1pdGVyPSc7Jzt9fXJldHVybiBzZXJpYWxpemVkfHxudWxsO319LyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL2Z1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsc3R5bGVzKXt2YXIgc3R5bGU9bm9kZS5zdHlsZTtmb3IodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpe2lmKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSl7Y29udGludWU7fXZhciBpc0N1c3RvbVByb3BlcnR5PXN0eWxlTmFtZS5pbmRleE9mKCctLScpPT09MDt7aWYoIWlzQ3VzdG9tUHJvcGVydHkpe3dhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLHN0eWxlc1tzdHlsZU5hbWVdKTt9fXZhciBzdHlsZVZhbHVlPWRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLHN0eWxlc1tzdHlsZU5hbWVdLGlzQ3VzdG9tUHJvcGVydHkpO2lmKHN0eWxlTmFtZT09PSdmbG9hdCcpe3N0eWxlTmFtZT0nY3NzRmxvYXQnO31pZihpc0N1c3RvbVByb3BlcnR5KXtzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsc3R5bGVWYWx1ZSk7fWVsc2V7c3R5bGVbc3R5bGVOYW1lXT1zdHlsZVZhbHVlO319fWZ1bmN0aW9uIGlzVmFsdWVFbXB0eSh2YWx1ZSl7cmV0dXJuIHZhbHVlPT1udWxsfHx0eXBlb2YgdmFsdWU9PT0nYm9vbGVhbid8fHZhbHVlPT09Jyc7fS8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9mdW5jdGlvbiBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVzKXt2YXIgZXhwYW5kZWQ9e307Zm9yKHZhciBrZXkgaW4gc3R5bGVzKXt2YXIgbG9uZ2hhbmRzPXNob3J0aGFuZFRvTG9uZ2hhbmRba2V5XXx8W2tleV07Zm9yKHZhciBpPTA7aTxsb25naGFuZHMubGVuZ3RoO2krKyl7ZXhwYW5kZWRbbG9uZ2hhbmRzW2ldXT1rZXk7fX1yZXR1cm4gZXhwYW5kZWQ7fS8qKlxuICogV2hlbiBtaXhpbmcgc2hvcnRoYW5kIGFuZCBsb25naGFuZCBwcm9wZXJ0eSBuYW1lcywgd2Ugd2FybiBkdXJpbmcgdXBkYXRlcyBpZlxuICogd2UgZXhwZWN0IGFuIGluY29ycmVjdCByZXN1bHQgdG8gb2NjdXIuIEluIHBhcnRpY3VsYXIsIHdlIHdhcm4gZm9yOlxuICpcbiAqIFVwZGF0aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIG92ZXJ3cml0dGVuKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnYmF6JywgZm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJ2JheidcbiAqIFJlbW92aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIGxvc3QgdG9vKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnJ1xuICogUmVtb3ZpbmcgYSBsb25naGFuZCBwcm9wZXJ0eSAoc2hvdWxkIHJldmVydCB0byBzaG9ydGhhbmQ7IGRvZXNuJ3QpOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdmb28nfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250VmFyaWFudCA9ICcnXG4gKi9mdW5jdGlvbiB2YWxpZGF0ZVNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uSW5EZXYoc3R5bGVVcGRhdGVzLG5leHRTdHlsZXMpe3tpZighbmV4dFN0eWxlcyl7cmV0dXJuO312YXIgZXhwYW5kZWRVcGRhdGVzPWV4cGFuZFNob3J0aGFuZE1hcChzdHlsZVVwZGF0ZXMpO3ZhciBleHBhbmRlZFN0eWxlcz1leHBhbmRTaG9ydGhhbmRNYXAobmV4dFN0eWxlcyk7dmFyIHdhcm5lZEFib3V0PXt9O2Zvcih2YXIga2V5IGluIGV4cGFuZGVkVXBkYXRlcyl7dmFyIG9yaWdpbmFsS2V5PWV4cGFuZGVkVXBkYXRlc1trZXldO3ZhciBjb3JyZWN0T3JpZ2luYWxLZXk9ZXhwYW5kZWRTdHlsZXNba2V5XTtpZihjb3JyZWN0T3JpZ2luYWxLZXkmJm9yaWdpbmFsS2V5IT09Y29ycmVjdE9yaWdpbmFsS2V5KXt2YXIgd2FybmluZ0tleT1vcmlnaW5hbEtleSsnLCcrY29ycmVjdE9yaWdpbmFsS2V5O2lmKHdhcm5lZEFib3V0W3dhcm5pbmdLZXldKXtjb250aW51ZTt9d2FybmVkQWJvdXRbd2FybmluZ0tleV09dHJ1ZTtlcnJvcignJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgJysnY29uZmxpY3RpbmcgcHJvcGVydHkgaXMgc2V0ICglcykgY2FuIGxlYWQgdG8gc3R5bGluZyBidWdzLiBUbyAnK1wiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiKydmb3IgdGhlIHNhbWUgdmFsdWU7IGluc3RlYWQsIHJlcGxhY2UgdGhlIHNob3J0aGFuZCB3aXRoICcrJ3NlcGFyYXRlIHZhbHVlcy4nLGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKT8nUmVtb3ZpbmcnOidVcGRhdGluZycsb3JpZ2luYWxLZXksY29ycmVjdE9yaWdpbmFsS2V5KTt9fX19Ly8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncz17YXJlYTp0cnVlLGJhc2U6dHJ1ZSxicjp0cnVlLGNvbDp0cnVlLGVtYmVkOnRydWUsaHI6dHJ1ZSxpbWc6dHJ1ZSxpbnB1dDp0cnVlLGtleWdlbjp0cnVlLGxpbms6dHJ1ZSxtZXRhOnRydWUscGFyYW06dHJ1ZSxzb3VyY2U6dHJ1ZSx0cmFjazp0cnVlLHdicjp0cnVlLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbn07Ly8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxudmFyIHZvaWRFbGVtZW50VGFncz1hc3NpZ24oe21lbnVpdGVtOnRydWV9LG9taXR0ZWRDbG9zZVRhZ3MpO3ZhciBIVE1MPSdfX2h0bWwnO2Z1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLHByb3BzKXtpZighcHJvcHMpe3JldHVybjt9Ly8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbmlmKHZvaWRFbGVtZW50VGFnc1t0YWddKXtpZihwcm9wcy5jaGlsZHJlbiE9bnVsbHx8cHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPW51bGwpe3Rocm93IG5ldyBFcnJvcih0YWcrXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIisndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7fX1pZihwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCE9bnVsbCl7aWYocHJvcHMuY2hpbGRyZW4hPW51bGwpe3Rocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7fWlmKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCE9PSdvYmplY3QnfHwhKEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKXt0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcrJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJysnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7fX17aWYoIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyYmcHJvcHMuY29udGVudEVkaXRhYmxlJiZwcm9wcy5jaGlsZHJlbiE9bnVsbCl7ZXJyb3IoJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJysnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJysndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcrJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTt9fWlmKHByb3BzLnN0eWxlIT1udWxsJiZ0eXBlb2YgcHJvcHMuc3R5bGUhPT0nb2JqZWN0Jyl7dGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcrXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIrJ3VzaW5nIEpTWC4nKTt9fWZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUscHJvcHMpe2lmKHRhZ05hbWUuaW5kZXhPZignLScpPT09LTEpe3JldHVybiB0eXBlb2YgcHJvcHMuaXM9PT0nc3RyaW5nJzt9c3dpdGNoKHRhZ05hbWUpey8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbi8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4vLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuY2FzZSdhbm5vdGF0aW9uLXhtbCc6Y2FzZSdjb2xvci1wcm9maWxlJzpjYXNlJ2ZvbnQtZmFjZSc6Y2FzZSdmb250LWZhY2Utc3JjJzpjYXNlJ2ZvbnQtZmFjZS11cmknOmNhc2UnZm9udC1mYWNlLWZvcm1hdCc6Y2FzZSdmb250LWZhY2UtbmFtZSc6Y2FzZSdtaXNzaW5nLWdseXBoJzpyZXR1cm4gZmFsc2U7ZGVmYXVsdDpyZXR1cm4gdHJ1ZTt9fS8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcz17Ly8gSFRNTFxuYWNjZXB0OidhY2NlcHQnLGFjY2VwdGNoYXJzZXQ6J2FjY2VwdENoYXJzZXQnLCdhY2NlcHQtY2hhcnNldCc6J2FjY2VwdENoYXJzZXQnLGFjY2Vzc2tleTonYWNjZXNzS2V5JyxhY3Rpb246J2FjdGlvbicsYWxsb3dmdWxsc2NyZWVuOidhbGxvd0Z1bGxTY3JlZW4nLGFsdDonYWx0JyxhczonYXMnLGFzeW5jOidhc3luYycsYXV0b2NhcGl0YWxpemU6J2F1dG9DYXBpdGFsaXplJyxhdXRvY29tcGxldGU6J2F1dG9Db21wbGV0ZScsYXV0b2NvcnJlY3Q6J2F1dG9Db3JyZWN0JyxhdXRvZm9jdXM6J2F1dG9Gb2N1cycsYXV0b3BsYXk6J2F1dG9QbGF5JyxhdXRvc2F2ZTonYXV0b1NhdmUnLGNhcHR1cmU6J2NhcHR1cmUnLGNlbGxwYWRkaW5nOidjZWxsUGFkZGluZycsY2VsbHNwYWNpbmc6J2NlbGxTcGFjaW5nJyxjaGFsbGVuZ2U6J2NoYWxsZW5nZScsY2hhcnNldDonY2hhclNldCcsY2hlY2tlZDonY2hlY2tlZCcsY2hpbGRyZW46J2NoaWxkcmVuJyxjaXRlOidjaXRlJyxjbGFzczonY2xhc3NOYW1lJyxjbGFzc2lkOidjbGFzc0lEJyxjbGFzc25hbWU6J2NsYXNzTmFtZScsY29sczonY29scycsY29sc3BhbjonY29sU3BhbicsY29udGVudDonY29udGVudCcsY29udGVudGVkaXRhYmxlOidjb250ZW50RWRpdGFibGUnLGNvbnRleHRtZW51Oidjb250ZXh0TWVudScsY29udHJvbHM6J2NvbnRyb2xzJyxjb250cm9sc2xpc3Q6J2NvbnRyb2xzTGlzdCcsY29vcmRzOidjb29yZHMnLGNyb3Nzb3JpZ2luOidjcm9zc09yaWdpbicsZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6J2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxkYXRhOidkYXRhJyxkYXRldGltZTonZGF0ZVRpbWUnLGRlZmF1bHQ6J2RlZmF1bHQnLGRlZmF1bHRjaGVja2VkOidkZWZhdWx0Q2hlY2tlZCcsZGVmYXVsdHZhbHVlOidkZWZhdWx0VmFsdWUnLGRlZmVyOidkZWZlcicsZGlyOidkaXInLGRpc2FibGVkOidkaXNhYmxlZCcsZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6J2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxkaXNhYmxlcmVtb3RlcGxheWJhY2s6J2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsZG93bmxvYWQ6J2Rvd25sb2FkJyxkcmFnZ2FibGU6J2RyYWdnYWJsZScsZW5jdHlwZTonZW5jVHlwZScsZW50ZXJrZXloaW50OidlbnRlcktleUhpbnQnLGZvcjonaHRtbEZvcicsZm9ybTonZm9ybScsZm9ybW1ldGhvZDonZm9ybU1ldGhvZCcsZm9ybWFjdGlvbjonZm9ybUFjdGlvbicsZm9ybWVuY3R5cGU6J2Zvcm1FbmNUeXBlJyxmb3Jtbm92YWxpZGF0ZTonZm9ybU5vVmFsaWRhdGUnLGZvcm10YXJnZXQ6J2Zvcm1UYXJnZXQnLGZyYW1lYm9yZGVyOidmcmFtZUJvcmRlcicsaGVhZGVyczonaGVhZGVycycsaGVpZ2h0OidoZWlnaHQnLGhpZGRlbjonaGlkZGVuJyxoaWdoOidoaWdoJyxocmVmOidocmVmJyxocmVmbGFuZzonaHJlZkxhbmcnLGh0bWxmb3I6J2h0bWxGb3InLGh0dHBlcXVpdjonaHR0cEVxdWl2JywnaHR0cC1lcXVpdic6J2h0dHBFcXVpdicsaWNvbjonaWNvbicsaWQ6J2lkJyxpbWFnZXNpemVzOidpbWFnZVNpemVzJyxpbWFnZXNyY3NldDonaW1hZ2VTcmNTZXQnLGlubmVyaHRtbDonaW5uZXJIVE1MJyxpbnB1dG1vZGU6J2lucHV0TW9kZScsaW50ZWdyaXR5OidpbnRlZ3JpdHknLGlzOidpcycsaXRlbWlkOidpdGVtSUQnLGl0ZW1wcm9wOidpdGVtUHJvcCcsaXRlbXJlZjonaXRlbVJlZicsaXRlbXNjb3BlOidpdGVtU2NvcGUnLGl0ZW10eXBlOidpdGVtVHlwZScsa2V5cGFyYW1zOidrZXlQYXJhbXMnLGtleXR5cGU6J2tleVR5cGUnLGtpbmQ6J2tpbmQnLGxhYmVsOidsYWJlbCcsbGFuZzonbGFuZycsbGlzdDonbGlzdCcsbG9vcDonbG9vcCcsbG93Oidsb3cnLG1hbmlmZXN0OidtYW5pZmVzdCcsbWFyZ2lud2lkdGg6J21hcmdpbldpZHRoJyxtYXJnaW5oZWlnaHQ6J21hcmdpbkhlaWdodCcsbWF4OidtYXgnLG1heGxlbmd0aDonbWF4TGVuZ3RoJyxtZWRpYTonbWVkaWEnLG1lZGlhZ3JvdXA6J21lZGlhR3JvdXAnLG1ldGhvZDonbWV0aG9kJyxtaW46J21pbicsbWlubGVuZ3RoOidtaW5MZW5ndGgnLG11bHRpcGxlOidtdWx0aXBsZScsbXV0ZWQ6J211dGVkJyxuYW1lOiduYW1lJyxub21vZHVsZTonbm9Nb2R1bGUnLG5vbmNlOidub25jZScsbm92YWxpZGF0ZTonbm9WYWxpZGF0ZScsb3Blbjonb3Blbicsb3B0aW11bTonb3B0aW11bScscGF0dGVybjoncGF0dGVybicscGxhY2Vob2xkZXI6J3BsYWNlaG9sZGVyJyxwbGF5c2lubGluZToncGxheXNJbmxpbmUnLHBvc3RlcjoncG9zdGVyJyxwcmVsb2FkOidwcmVsb2FkJyxwcm9maWxlOidwcm9maWxlJyxyYWRpb2dyb3VwOidyYWRpb0dyb3VwJyxyZWFkb25seToncmVhZE9ubHknLHJlZmVycmVycG9saWN5OidyZWZlcnJlclBvbGljeScscmVsOidyZWwnLHJlcXVpcmVkOidyZXF1aXJlZCcscmV2ZXJzZWQ6J3JldmVyc2VkJyxyb2xlOidyb2xlJyxyb3dzOidyb3dzJyxyb3dzcGFuOidyb3dTcGFuJyxzYW5kYm94OidzYW5kYm94JyxzY29wZTonc2NvcGUnLHNjb3BlZDonc2NvcGVkJyxzY3JvbGxpbmc6J3Njcm9sbGluZycsc2VhbWxlc3M6J3NlYW1sZXNzJyxzZWxlY3RlZDonc2VsZWN0ZWQnLHNoYXBlOidzaGFwZScsc2l6ZTonc2l6ZScsc2l6ZXM6J3NpemVzJyxzcGFuOidzcGFuJyxzcGVsbGNoZWNrOidzcGVsbENoZWNrJyxzcmM6J3NyYycsc3JjZG9jOidzcmNEb2MnLHNyY2xhbmc6J3NyY0xhbmcnLHNyY3NldDonc3JjU2V0JyxzdGFydDonc3RhcnQnLHN0ZXA6J3N0ZXAnLHN0eWxlOidzdHlsZScsc3VtbWFyeTonc3VtbWFyeScsdGFiaW5kZXg6J3RhYkluZGV4Jyx0YXJnZXQ6J3RhcmdldCcsdGl0bGU6J3RpdGxlJyx0eXBlOid0eXBlJyx1c2VtYXA6J3VzZU1hcCcsdmFsdWU6J3ZhbHVlJyx3aWR0aDond2lkdGgnLHdtb2RlOid3bW9kZScsd3JhcDond3JhcCcsLy8gU1ZHXG5hYm91dDonYWJvdXQnLGFjY2VudGhlaWdodDonYWNjZW50SGVpZ2h0JywnYWNjZW50LWhlaWdodCc6J2FjY2VudEhlaWdodCcsYWNjdW11bGF0ZTonYWNjdW11bGF0ZScsYWRkaXRpdmU6J2FkZGl0aXZlJyxhbGlnbm1lbnRiYXNlbGluZTonYWxpZ25tZW50QmFzZWxpbmUnLCdhbGlnbm1lbnQtYmFzZWxpbmUnOidhbGlnbm1lbnRCYXNlbGluZScsYWxsb3dyZW9yZGVyOidhbGxvd1Jlb3JkZXInLGFscGhhYmV0aWM6J2FscGhhYmV0aWMnLGFtcGxpdHVkZTonYW1wbGl0dWRlJyxhcmFiaWNmb3JtOidhcmFiaWNGb3JtJywnYXJhYmljLWZvcm0nOidhcmFiaWNGb3JtJyxhc2NlbnQ6J2FzY2VudCcsYXR0cmlidXRlbmFtZTonYXR0cmlidXRlTmFtZScsYXR0cmlidXRldHlwZTonYXR0cmlidXRlVHlwZScsYXV0b3JldmVyc2U6J2F1dG9SZXZlcnNlJyxhemltdXRoOidhemltdXRoJyxiYXNlZnJlcXVlbmN5OidiYXNlRnJlcXVlbmN5JyxiYXNlbGluZXNoaWZ0OidiYXNlbGluZVNoaWZ0JywnYmFzZWxpbmUtc2hpZnQnOidiYXNlbGluZVNoaWZ0JyxiYXNlcHJvZmlsZTonYmFzZVByb2ZpbGUnLGJib3g6J2Jib3gnLGJlZ2luOidiZWdpbicsYmlhczonYmlhcycsYnk6J2J5JyxjYWxjbW9kZTonY2FsY01vZGUnLGNhcGhlaWdodDonY2FwSGVpZ2h0JywnY2FwLWhlaWdodCc6J2NhcEhlaWdodCcsY2xpcDonY2xpcCcsY2xpcHBhdGg6J2NsaXBQYXRoJywnY2xpcC1wYXRoJzonY2xpcFBhdGgnLGNsaXBwYXRodW5pdHM6J2NsaXBQYXRoVW5pdHMnLGNsaXBydWxlOidjbGlwUnVsZScsJ2NsaXAtcnVsZSc6J2NsaXBSdWxlJyxjb2xvcjonY29sb3InLGNvbG9yaW50ZXJwb2xhdGlvbjonY29sb3JJbnRlcnBvbGF0aW9uJywnY29sb3ItaW50ZXJwb2xhdGlvbic6J2NvbG9ySW50ZXJwb2xhdGlvbicsY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczonY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6J2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLGNvbG9ycHJvZmlsZTonY29sb3JQcm9maWxlJywnY29sb3ItcHJvZmlsZSc6J2NvbG9yUHJvZmlsZScsY29sb3JyZW5kZXJpbmc6J2NvbG9yUmVuZGVyaW5nJywnY29sb3ItcmVuZGVyaW5nJzonY29sb3JSZW5kZXJpbmcnLGNvbnRlbnRzY3JpcHR0eXBlOidjb250ZW50U2NyaXB0VHlwZScsY29udGVudHN0eWxldHlwZTonY29udGVudFN0eWxlVHlwZScsY3Vyc29yOidjdXJzb3InLGN4OidjeCcsY3k6J2N5JyxkOidkJyxkYXRhdHlwZTonZGF0YXR5cGUnLGRlY2VsZXJhdGU6J2RlY2VsZXJhdGUnLGRlc2NlbnQ6J2Rlc2NlbnQnLGRpZmZ1c2Vjb25zdGFudDonZGlmZnVzZUNvbnN0YW50JyxkaXJlY3Rpb246J2RpcmVjdGlvbicsZGlzcGxheTonZGlzcGxheScsZGl2aXNvcjonZGl2aXNvcicsZG9taW5hbnRiYXNlbGluZTonZG9taW5hbnRCYXNlbGluZScsJ2RvbWluYW50LWJhc2VsaW5lJzonZG9taW5hbnRCYXNlbGluZScsZHVyOidkdXInLGR4OidkeCcsZHk6J2R5JyxlZGdlbW9kZTonZWRnZU1vZGUnLGVsZXZhdGlvbjonZWxldmF0aW9uJyxlbmFibGViYWNrZ3JvdW5kOidlbmFibGVCYWNrZ3JvdW5kJywnZW5hYmxlLWJhY2tncm91bmQnOidlbmFibGVCYWNrZ3JvdW5kJyxlbmQ6J2VuZCcsZXhwb25lbnQ6J2V4cG9uZW50JyxleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOidleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxmaWxsOidmaWxsJyxmaWxsb3BhY2l0eTonZmlsbE9wYWNpdHknLCdmaWxsLW9wYWNpdHknOidmaWxsT3BhY2l0eScsZmlsbHJ1bGU6J2ZpbGxSdWxlJywnZmlsbC1ydWxlJzonZmlsbFJ1bGUnLGZpbHRlcjonZmlsdGVyJyxmaWx0ZXJyZXM6J2ZpbHRlclJlcycsZmlsdGVydW5pdHM6J2ZpbHRlclVuaXRzJyxmbG9vZG9wYWNpdHk6J2Zsb29kT3BhY2l0eScsJ2Zsb29kLW9wYWNpdHknOidmbG9vZE9wYWNpdHknLGZsb29kY29sb3I6J2Zsb29kQ29sb3InLCdmbG9vZC1jb2xvcic6J2Zsb29kQ29sb3InLGZvY3VzYWJsZTonZm9jdXNhYmxlJyxmb250ZmFtaWx5Oidmb250RmFtaWx5JywnZm9udC1mYW1pbHknOidmb250RmFtaWx5Jyxmb250c2l6ZTonZm9udFNpemUnLCdmb250LXNpemUnOidmb250U2l6ZScsZm9udHNpemVhZGp1c3Q6J2ZvbnRTaXplQWRqdXN0JywnZm9udC1zaXplLWFkanVzdCc6J2ZvbnRTaXplQWRqdXN0Jyxmb250c3RyZXRjaDonZm9udFN0cmV0Y2gnLCdmb250LXN0cmV0Y2gnOidmb250U3RyZXRjaCcsZm9udHN0eWxlOidmb250U3R5bGUnLCdmb250LXN0eWxlJzonZm9udFN0eWxlJyxmb250dmFyaWFudDonZm9udFZhcmlhbnQnLCdmb250LXZhcmlhbnQnOidmb250VmFyaWFudCcsZm9udHdlaWdodDonZm9udFdlaWdodCcsJ2ZvbnQtd2VpZ2h0JzonZm9udFdlaWdodCcsZm9ybWF0Oidmb3JtYXQnLGZyb206J2Zyb20nLGZ4OidmeCcsZnk6J2Z5JyxnMTonZzEnLGcyOidnMicsZ2x5cGhuYW1lOidnbHlwaE5hbWUnLCdnbHlwaC1uYW1lJzonZ2x5cGhOYW1lJyxnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDonZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLCdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzonZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDonZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJywnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOidnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLGdseXBocmVmOidnbHlwaFJlZicsZ3JhZGllbnR0cmFuc2Zvcm06J2dyYWRpZW50VHJhbnNmb3JtJyxncmFkaWVudHVuaXRzOidncmFkaWVudFVuaXRzJyxoYW5naW5nOidoYW5naW5nJyxob3JpemFkdng6J2hvcml6QWR2WCcsJ2hvcml6LWFkdi14JzonaG9yaXpBZHZYJyxob3Jpem9yaWdpbng6J2hvcml6T3JpZ2luWCcsJ2hvcml6LW9yaWdpbi14JzonaG9yaXpPcmlnaW5YJyxpZGVvZ3JhcGhpYzonaWRlb2dyYXBoaWMnLGltYWdlcmVuZGVyaW5nOidpbWFnZVJlbmRlcmluZycsJ2ltYWdlLXJlbmRlcmluZyc6J2ltYWdlUmVuZGVyaW5nJyxpbjI6J2luMicsaW46J2luJyxpbmxpc3Q6J2lubGlzdCcsaW50ZXJjZXB0OidpbnRlcmNlcHQnLGsxOidrMScsazI6J2syJyxrMzonazMnLGs0OidrNCcsazonaycsa2VybmVsbWF0cml4OidrZXJuZWxNYXRyaXgnLGtlcm5lbHVuaXRsZW5ndGg6J2tlcm5lbFVuaXRMZW5ndGgnLGtlcm5pbmc6J2tlcm5pbmcnLGtleXBvaW50czona2V5UG9pbnRzJyxrZXlzcGxpbmVzOidrZXlTcGxpbmVzJyxrZXl0aW1lczona2V5VGltZXMnLGxlbmd0aGFkanVzdDonbGVuZ3RoQWRqdXN0JyxsZXR0ZXJzcGFjaW5nOidsZXR0ZXJTcGFjaW5nJywnbGV0dGVyLXNwYWNpbmcnOidsZXR0ZXJTcGFjaW5nJyxsaWdodGluZ2NvbG9yOidsaWdodGluZ0NvbG9yJywnbGlnaHRpbmctY29sb3InOidsaWdodGluZ0NvbG9yJyxsaW1pdGluZ2NvbmVhbmdsZTonbGltaXRpbmdDb25lQW5nbGUnLGxvY2FsOidsb2NhbCcsbWFya2VyZW5kOidtYXJrZXJFbmQnLCdtYXJrZXItZW5kJzonbWFya2VyRW5kJyxtYXJrZXJoZWlnaHQ6J21hcmtlckhlaWdodCcsbWFya2VybWlkOidtYXJrZXJNaWQnLCdtYXJrZXItbWlkJzonbWFya2VyTWlkJyxtYXJrZXJzdGFydDonbWFya2VyU3RhcnQnLCdtYXJrZXItc3RhcnQnOidtYXJrZXJTdGFydCcsbWFya2VydW5pdHM6J21hcmtlclVuaXRzJyxtYXJrZXJ3aWR0aDonbWFya2VyV2lkdGgnLG1hc2s6J21hc2snLG1hc2tjb250ZW50dW5pdHM6J21hc2tDb250ZW50VW5pdHMnLG1hc2t1bml0czonbWFza1VuaXRzJyxtYXRoZW1hdGljYWw6J21hdGhlbWF0aWNhbCcsbW9kZTonbW9kZScsbnVtb2N0YXZlczonbnVtT2N0YXZlcycsb2Zmc2V0OidvZmZzZXQnLG9wYWNpdHk6J29wYWNpdHknLG9wZXJhdG9yOidvcGVyYXRvcicsb3JkZXI6J29yZGVyJyxvcmllbnQ6J29yaWVudCcsb3JpZW50YXRpb246J29yaWVudGF0aW9uJyxvcmlnaW46J29yaWdpbicsb3ZlcmZsb3c6J292ZXJmbG93JyxvdmVybGluZXBvc2l0aW9uOidvdmVybGluZVBvc2l0aW9uJywnb3ZlcmxpbmUtcG9zaXRpb24nOidvdmVybGluZVBvc2l0aW9uJyxvdmVybGluZXRoaWNrbmVzczonb3ZlcmxpbmVUaGlja25lc3MnLCdvdmVybGluZS10aGlja25lc3MnOidvdmVybGluZVRoaWNrbmVzcycscGFpbnRvcmRlcjoncGFpbnRPcmRlcicsJ3BhaW50LW9yZGVyJzoncGFpbnRPcmRlcicscGFub3NlMToncGFub3NlMScsJ3Bhbm9zZS0xJzoncGFub3NlMScscGF0aGxlbmd0aDoncGF0aExlbmd0aCcscGF0dGVybmNvbnRlbnR1bml0czoncGF0dGVybkNvbnRlbnRVbml0cycscGF0dGVybnRyYW5zZm9ybToncGF0dGVyblRyYW5zZm9ybScscGF0dGVybnVuaXRzOidwYXR0ZXJuVW5pdHMnLHBvaW50ZXJldmVudHM6J3BvaW50ZXJFdmVudHMnLCdwb2ludGVyLWV2ZW50cyc6J3BvaW50ZXJFdmVudHMnLHBvaW50czoncG9pbnRzJyxwb2ludHNhdHg6J3BvaW50c0F0WCcscG9pbnRzYXR5Oidwb2ludHNBdFknLHBvaW50c2F0ejoncG9pbnRzQXRaJyxwcmVmaXg6J3ByZWZpeCcscHJlc2VydmVhbHBoYToncHJlc2VydmVBbHBoYScscHJlc2VydmVhc3BlY3RyYXRpbzoncHJlc2VydmVBc3BlY3RSYXRpbycscHJpbWl0aXZldW5pdHM6J3ByaW1pdGl2ZVVuaXRzJyxwcm9wZXJ0eToncHJvcGVydHknLHI6J3InLHJhZGl1czoncmFkaXVzJyxyZWZ4OidyZWZYJyxyZWZ5OidyZWZZJyxyZW5kZXJpbmdpbnRlbnQ6J3JlbmRlcmluZ0ludGVudCcsJ3JlbmRlcmluZy1pbnRlbnQnOidyZW5kZXJpbmdJbnRlbnQnLHJlcGVhdGNvdW50OidyZXBlYXRDb3VudCcscmVwZWF0ZHVyOidyZXBlYXREdXInLHJlcXVpcmVkZXh0ZW5zaW9uczoncmVxdWlyZWRFeHRlbnNpb25zJyxyZXF1aXJlZGZlYXR1cmVzOidyZXF1aXJlZEZlYXR1cmVzJyxyZXNvdXJjZToncmVzb3VyY2UnLHJlc3RhcnQ6J3Jlc3RhcnQnLHJlc3VsdDoncmVzdWx0JyxyZXN1bHRzOidyZXN1bHRzJyxyb3RhdGU6J3JvdGF0ZScscng6J3J4JyxyeToncnknLHNjYWxlOidzY2FsZScsc2VjdXJpdHk6J3NlY3VyaXR5JyxzZWVkOidzZWVkJyxzaGFwZXJlbmRlcmluZzonc2hhcGVSZW5kZXJpbmcnLCdzaGFwZS1yZW5kZXJpbmcnOidzaGFwZVJlbmRlcmluZycsc2xvcGU6J3Nsb3BlJyxzcGFjaW5nOidzcGFjaW5nJyxzcGVjdWxhcmNvbnN0YW50OidzcGVjdWxhckNvbnN0YW50JyxzcGVjdWxhcmV4cG9uZW50OidzcGVjdWxhckV4cG9uZW50JyxzcGVlZDonc3BlZWQnLHNwcmVhZG1ldGhvZDonc3ByZWFkTWV0aG9kJyxzdGFydG9mZnNldDonc3RhcnRPZmZzZXQnLHN0ZGRldmlhdGlvbjonc3RkRGV2aWF0aW9uJyxzdGVtaDonc3RlbWgnLHN0ZW12OidzdGVtdicsc3RpdGNodGlsZXM6J3N0aXRjaFRpbGVzJyxzdG9wY29sb3I6J3N0b3BDb2xvcicsJ3N0b3AtY29sb3InOidzdG9wQ29sb3InLHN0b3BvcGFjaXR5OidzdG9wT3BhY2l0eScsJ3N0b3Atb3BhY2l0eSc6J3N0b3BPcGFjaXR5JyxzdHJpa2V0aHJvdWdocG9zaXRpb246J3N0cmlrZXRocm91Z2hQb3NpdGlvbicsJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOidzdHJpa2V0aHJvdWdoUG9zaXRpb24nLHN0cmlrZXRocm91Z2h0aGlja25lc3M6J3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6J3N0cmlrZXRocm91Z2hUaGlja25lc3MnLHN0cmluZzonc3RyaW5nJyxzdHJva2U6J3N0cm9rZScsc3Ryb2tlZGFzaGFycmF5OidzdHJva2VEYXNoYXJyYXknLCdzdHJva2UtZGFzaGFycmF5Jzonc3Ryb2tlRGFzaGFycmF5JyxzdHJva2VkYXNob2Zmc2V0OidzdHJva2VEYXNob2Zmc2V0Jywnc3Ryb2tlLWRhc2hvZmZzZXQnOidzdHJva2VEYXNob2Zmc2V0JyxzdHJva2VsaW5lY2FwOidzdHJva2VMaW5lY2FwJywnc3Ryb2tlLWxpbmVjYXAnOidzdHJva2VMaW5lY2FwJyxzdHJva2VsaW5lam9pbjonc3Ryb2tlTGluZWpvaW4nLCdzdHJva2UtbGluZWpvaW4nOidzdHJva2VMaW5lam9pbicsc3Ryb2tlbWl0ZXJsaW1pdDonc3Ryb2tlTWl0ZXJsaW1pdCcsJ3N0cm9rZS1taXRlcmxpbWl0Jzonc3Ryb2tlTWl0ZXJsaW1pdCcsc3Ryb2tld2lkdGg6J3N0cm9rZVdpZHRoJywnc3Ryb2tlLXdpZHRoJzonc3Ryb2tlV2lkdGgnLHN0cm9rZW9wYWNpdHk6J3N0cm9rZU9wYWNpdHknLCdzdHJva2Utb3BhY2l0eSc6J3N0cm9rZU9wYWNpdHknLHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzonc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6J3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsc3VyZmFjZXNjYWxlOidzdXJmYWNlU2NhbGUnLHN5c3RlbWxhbmd1YWdlOidzeXN0ZW1MYW5ndWFnZScsdGFibGV2YWx1ZXM6J3RhYmxlVmFsdWVzJyx0YXJnZXR4Oid0YXJnZXRYJyx0YXJnZXR5Oid0YXJnZXRZJyx0ZXh0YW5jaG9yOid0ZXh0QW5jaG9yJywndGV4dC1hbmNob3InOid0ZXh0QW5jaG9yJyx0ZXh0ZGVjb3JhdGlvbjondGV4dERlY29yYXRpb24nLCd0ZXh0LWRlY29yYXRpb24nOid0ZXh0RGVjb3JhdGlvbicsdGV4dGxlbmd0aDondGV4dExlbmd0aCcsdGV4dHJlbmRlcmluZzondGV4dFJlbmRlcmluZycsJ3RleHQtcmVuZGVyaW5nJzondGV4dFJlbmRlcmluZycsdG86J3RvJyx0cmFuc2Zvcm06J3RyYW5zZm9ybScsdHlwZW9mOid0eXBlb2YnLHUxOid1MScsdTI6J3UyJyx1bmRlcmxpbmVwb3NpdGlvbjondW5kZXJsaW5lUG9zaXRpb24nLCd1bmRlcmxpbmUtcG9zaXRpb24nOid1bmRlcmxpbmVQb3NpdGlvbicsdW5kZXJsaW5ldGhpY2tuZXNzOid1bmRlcmxpbmVUaGlja25lc3MnLCd1bmRlcmxpbmUtdGhpY2tuZXNzJzondW5kZXJsaW5lVGhpY2tuZXNzJyx1bmljb2RlOid1bmljb2RlJyx1bmljb2RlYmlkaTondW5pY29kZUJpZGknLCd1bmljb2RlLWJpZGknOid1bmljb2RlQmlkaScsdW5pY29kZXJhbmdlOid1bmljb2RlUmFuZ2UnLCd1bmljb2RlLXJhbmdlJzondW5pY29kZVJhbmdlJyx1bml0c3BlcmVtOid1bml0c1BlckVtJywndW5pdHMtcGVyLWVtJzondW5pdHNQZXJFbScsdW5zZWxlY3RhYmxlOid1bnNlbGVjdGFibGUnLHZhbHBoYWJldGljOid2QWxwaGFiZXRpYycsJ3YtYWxwaGFiZXRpYyc6J3ZBbHBoYWJldGljJyx2YWx1ZXM6J3ZhbHVlcycsdmVjdG9yZWZmZWN0Oid2ZWN0b3JFZmZlY3QnLCd2ZWN0b3ItZWZmZWN0JzondmVjdG9yRWZmZWN0Jyx2ZXJzaW9uOid2ZXJzaW9uJyx2ZXJ0YWR2eTondmVydEFkdlknLCd2ZXJ0LWFkdi15JzondmVydEFkdlknLHZlcnRvcmlnaW54Oid2ZXJ0T3JpZ2luWCcsJ3ZlcnQtb3JpZ2luLXgnOid2ZXJ0T3JpZ2luWCcsdmVydG9yaWdpbnk6J3ZlcnRPcmlnaW5ZJywndmVydC1vcmlnaW4teSc6J3ZlcnRPcmlnaW5ZJyx2aGFuZ2luZzondkhhbmdpbmcnLCd2LWhhbmdpbmcnOid2SGFuZ2luZycsdmlkZW9ncmFwaGljOid2SWRlb2dyYXBoaWMnLCd2LWlkZW9ncmFwaGljJzondklkZW9ncmFwaGljJyx2aWV3Ym94Oid2aWV3Qm94Jyx2aWV3dGFyZ2V0Oid2aWV3VGFyZ2V0Jyx2aXNpYmlsaXR5Oid2aXNpYmlsaXR5Jyx2bWF0aGVtYXRpY2FsOid2TWF0aGVtYXRpY2FsJywndi1tYXRoZW1hdGljYWwnOid2TWF0aGVtYXRpY2FsJyx2b2NhYjondm9jYWInLHdpZHRoczond2lkdGhzJyx3b3Jkc3BhY2luZzond29yZFNwYWNpbmcnLCd3b3JkLXNwYWNpbmcnOid3b3JkU3BhY2luZycsd3JpdGluZ21vZGU6J3dyaXRpbmdNb2RlJywnd3JpdGluZy1tb2RlJzond3JpdGluZ01vZGUnLHgxOid4MScseDI6J3gyJyx4Oid4Jyx4Y2hhbm5lbHNlbGVjdG9yOid4Q2hhbm5lbFNlbGVjdG9yJyx4aGVpZ2h0Oid4SGVpZ2h0JywneC1oZWlnaHQnOid4SGVpZ2h0Jyx4bGlua2FjdHVhdGU6J3hsaW5rQWN0dWF0ZScsJ3hsaW5rOmFjdHVhdGUnOid4bGlua0FjdHVhdGUnLHhsaW5rYXJjcm9sZToneGxpbmtBcmNyb2xlJywneGxpbms6YXJjcm9sZSc6J3hsaW5rQXJjcm9sZScseGxpbmtocmVmOid4bGlua0hyZWYnLCd4bGluazpocmVmJzoneGxpbmtIcmVmJyx4bGlua3JvbGU6J3hsaW5rUm9sZScsJ3hsaW5rOnJvbGUnOid4bGlua1JvbGUnLHhsaW5rc2hvdzoneGxpbmtTaG93JywneGxpbms6c2hvdyc6J3hsaW5rU2hvdycseGxpbmt0aXRsZToneGxpbmtUaXRsZScsJ3hsaW5rOnRpdGxlJzoneGxpbmtUaXRsZScseGxpbmt0eXBlOid4bGlua1R5cGUnLCd4bGluazp0eXBlJzoneGxpbmtUeXBlJyx4bWxiYXNlOid4bWxCYXNlJywneG1sOmJhc2UnOid4bWxCYXNlJyx4bWxsYW5nOid4bWxMYW5nJywneG1sOmxhbmcnOid4bWxMYW5nJyx4bWxuczoneG1sbnMnLCd4bWw6c3BhY2UnOid4bWxTcGFjZScseG1sbnN4bGluazoneG1sbnNYbGluaycsJ3htbG5zOnhsaW5rJzoneG1sbnNYbGluaycseG1sc3BhY2U6J3htbFNwYWNlJyx5MToneTEnLHkyOid5MicseToneScseWNoYW5uZWxzZWxlY3RvcjoneUNoYW5uZWxTZWxlY3Rvcicsejoneicsem9vbWFuZHBhbjonem9vbUFuZFBhbid9O3ZhciBhcmlhUHJvcGVydGllcz17J2FyaWEtY3VycmVudCc6MCwvLyBzdGF0ZVxuJ2FyaWEtZGVzY3JpcHRpb24nOjAsJ2FyaWEtZGV0YWlscyc6MCwnYXJpYS1kaXNhYmxlZCc6MCwvLyBzdGF0ZVxuJ2FyaWEtaGlkZGVuJzowLC8vIHN0YXRlXG4nYXJpYS1pbnZhbGlkJzowLC8vIHN0YXRlXG4nYXJpYS1rZXlzaG9ydGN1dHMnOjAsJ2FyaWEtbGFiZWwnOjAsJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzowLC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4nYXJpYS1hdXRvY29tcGxldGUnOjAsJ2FyaWEtY2hlY2tlZCc6MCwnYXJpYS1leHBhbmRlZCc6MCwnYXJpYS1oYXNwb3B1cCc6MCwnYXJpYS1sZXZlbCc6MCwnYXJpYS1tb2RhbCc6MCwnYXJpYS1tdWx0aWxpbmUnOjAsJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzowLCdhcmlhLW9yaWVudGF0aW9uJzowLCdhcmlhLXBsYWNlaG9sZGVyJzowLCdhcmlhLXByZXNzZWQnOjAsJ2FyaWEtcmVhZG9ubHknOjAsJ2FyaWEtcmVxdWlyZWQnOjAsJ2FyaWEtc2VsZWN0ZWQnOjAsJ2FyaWEtc29ydCc6MCwnYXJpYS12YWx1ZW1heCc6MCwnYXJpYS12YWx1ZW1pbic6MCwnYXJpYS12YWx1ZW5vdyc6MCwnYXJpYS12YWx1ZXRleHQnOjAsLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuJ2FyaWEtYXRvbWljJzowLCdhcmlhLWJ1c3knOjAsJ2FyaWEtbGl2ZSc6MCwnYXJpYS1yZWxldmFudCc6MCwvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbidhcmlhLWRyb3BlZmZlY3QnOjAsJ2FyaWEtZ3JhYmJlZCc6MCwvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6MCwnYXJpYS1jb2xjb3VudCc6MCwnYXJpYS1jb2xpbmRleCc6MCwnYXJpYS1jb2xzcGFuJzowLCdhcmlhLWNvbnRyb2xzJzowLCdhcmlhLWRlc2NyaWJlZGJ5JzowLCdhcmlhLWVycm9ybWVzc2FnZSc6MCwnYXJpYS1mbG93dG8nOjAsJ2FyaWEtbGFiZWxsZWRieSc6MCwnYXJpYS1vd25zJzowLCdhcmlhLXBvc2luc2V0JzowLCdhcmlhLXJvd2NvdW50JzowLCdhcmlhLXJvd2luZGV4JzowLCdhcmlhLXJvd3NwYW4nOjAsJ2FyaWEtc2V0c2l6ZSc6MH07dmFyIHdhcm5lZFByb3BlcnRpZXM9e307dmFyIHJBUklBPW5ldyBSZWdFeHAoJ14oYXJpYSktWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7dmFyIHJBUklBQ2FtZWw9bmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7ZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLG5hbWUpe3tpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsbmFtZSkmJndhcm5lZFByb3BlcnRpZXNbbmFtZV0pe3JldHVybiB0cnVlO31pZihyQVJJQUNhbWVsLnRlc3QobmFtZSkpe3ZhciBhcmlhTmFtZT0nYXJpYS0nK25hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTt2YXIgY29ycmVjdE5hbWU9YXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpP2FyaWFOYW1lOm51bGw7Ly8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4vLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5pZihjb3JyZWN0TmFtZT09bnVsbCl7ZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsbmFtZSk7d2FybmVkUHJvcGVydGllc1tuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbmlmKG5hbWUhPT1jb3JyZWN0TmFtZSl7ZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JyxuYW1lLGNvcnJlY3ROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fX1pZihyQVJJQS50ZXN0KG5hbWUpKXt2YXIgbG93ZXJDYXNlZE5hbWU9bmFtZS50b0xvd2VyQ2FzZSgpO3ZhciBzdGFuZGFyZE5hbWU9YXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpP2xvd2VyQ2FzZWROYW1lOm51bGw7Ly8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4vLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5pZihzdGFuZGFyZE5hbWU9PW51bGwpe3dhcm5lZFByb3BlcnRpZXNbbmFtZV09dHJ1ZTtyZXR1cm4gZmFsc2U7fS8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuaWYobmFtZSE9PXN0YW5kYXJkTmFtZSl7ZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JyxuYW1lLHN0YW5kYXJkTmFtZSk7d2FybmVkUHJvcGVydGllc1tuYW1lXT10cnVlO3JldHVybiB0cnVlO319fXJldHVybiB0cnVlO31mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLHByb3BzKXt7dmFyIGludmFsaWRQcm9wcz1bXTtmb3IodmFyIGtleSBpbiBwcm9wcyl7dmFyIGlzVmFsaWQ9dmFsaWRhdGVQcm9wZXJ0eSh0eXBlLGtleSk7aWYoIWlzVmFsaWQpe2ludmFsaWRQcm9wcy5wdXNoKGtleSk7fX12YXIgdW5rbm93blByb3BTdHJpbmc9aW52YWxpZFByb3BzLm1hcChmdW5jdGlvbihwcm9wKXtyZXR1cm4nYCcrcHJvcCsnYCc7fSkuam9pbignLCAnKTtpZihpbnZhbGlkUHJvcHMubGVuZ3RoPT09MSl7ZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnKydGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLHVua25vd25Qcm9wU3RyaW5nLHR5cGUpO31lbHNlIGlmKGludmFsaWRQcm9wcy5sZW5ndGg+MSl7ZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJysnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJyx1bmtub3duUHJvcFN0cmluZyx0eXBlKTt9fX1mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSxwcm9wcyl7aWYoaXNDdXN0b21Db21wb25lbnQodHlwZSxwcm9wcykpe3JldHVybjt9d2FybkludmFsaWRBUklBUHJvcHModHlwZSxwcm9wcyk7fXZhciBkaWRXYXJuVmFsdWVOdWxsPWZhbHNlO2Z1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUscHJvcHMpe3tpZih0eXBlIT09J2lucHV0JyYmdHlwZSE9PSd0ZXh0YXJlYScmJnR5cGUhPT0nc2VsZWN0Jyl7cmV0dXJuO31pZihwcm9wcyE9bnVsbCYmcHJvcHMudmFsdWU9PT1udWxsJiYhZGlkV2FyblZhbHVlTnVsbCl7ZGlkV2FyblZhbHVlTnVsbD10cnVlO2lmKHR5cGU9PT0nc2VsZWN0JyYmcHJvcHMubXVsdGlwbGUpe2Vycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcrJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcrJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsdHlwZSk7fWVsc2V7ZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJysnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJysnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsdHlwZSk7fX19fXZhciB2YWxpZGF0ZVByb3BlcnR5JDE9ZnVuY3Rpb24oKXt9O3t2YXIgd2FybmVkUHJvcGVydGllcyQxPXt9O3ZhciBFVkVOVF9OQU1FX1JFR0VYPS9eb24uLzt2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYPS9eb25bXkEtWl0vO3ZhciByQVJJQSQxPW5ldyBSZWdFeHAoJ14oYXJpYSktWycrQVRUUklCVVRFX05BTUVfQ0hBUisnXSokJyk7dmFyIHJBUklBQ2FtZWwkMT1uZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJytBVFRSSUJVVEVfTkFNRV9DSEFSKyddKiQnKTt2YWxpZGF0ZVByb3BlcnR5JDE9ZnVuY3Rpb24odGFnTmFtZSxuYW1lLHZhbHVlLGV2ZW50UmVnaXN0cnkpe2lmKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLG5hbWUpJiZ3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pe3JldHVybiB0cnVlO312YXIgbG93ZXJDYXNlZE5hbWU9bmFtZS50b0xvd2VyQ2FzZSgpO2lmKGxvd2VyQ2FzZWROYW1lPT09J29uZm9jdXNpbid8fGxvd2VyQ2FzZWROYW1lPT09J29uZm9jdXNvdXQnKXtlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcrJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJysnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cbmlmKGV2ZW50UmVnaXN0cnkhPW51bGwpe3ZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzPWV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzPWV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKXtyZXR1cm4gdHJ1ZTt9dmFyIHJlZ2lzdHJhdGlvbk5hbWU9cG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSk/cG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV06bnVsbDtpZihyZWdpc3RyYXRpb25OYW1lIT1udWxsKXtlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsbmFtZSxyZWdpc3RyYXRpb25OYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWYoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKXtlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLG5hbWUpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO319ZWxzZSBpZihFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpey8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4vLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4vLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG5pZihJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSl7ZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnKydSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLG5hbWUpO313YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9Ly8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuaWYockFSSUEkMS50ZXN0KG5hbWUpfHxyQVJJQUNhbWVsJDEudGVzdChuYW1lKSl7cmV0dXJuIHRydWU7fWlmKGxvd2VyQ2FzZWROYW1lPT09J2lubmVyaHRtbCcpe2Vycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcrJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO3dhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO31pZihsb3dlckNhc2VkTmFtZT09PSdhcmlhJyl7ZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnKydQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fWlmKGxvd2VyQ2FzZWROYW1lPT09J2lzJyYmdmFsdWUhPT1udWxsJiZ2YWx1ZSE9PXVuZGVmaW5lZCYmdHlwZW9mIHZhbHVlIT09J3N0cmluZycpe2Vycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcrJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLHR5cGVvZiB2YWx1ZSk7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIHRydWU7fWlmKHR5cGVvZiB2YWx1ZT09PSdudW1iZXInJiZpc05hTih2YWx1ZSkpe2Vycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnKyd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJyxuYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9dmFyIHByb3BlcnR5SW5mbz1nZXRQcm9wZXJ0eUluZm8obmFtZSk7dmFyIGlzUmVzZXJ2ZWQ9cHJvcGVydHlJbmZvIT09bnVsbCYmcHJvcGVydHlJbmZvLnR5cGU9PT1SRVNFUlZFRDsvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuaWYocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSl7dmFyIHN0YW5kYXJkTmFtZT1wb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO2lmKHN0YW5kYXJkTmFtZSE9PW5hbWUpe2Vycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLG5hbWUsc3RhbmRhcmROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9fWVsc2UgaWYoIWlzUmVzZXJ2ZWQmJm5hbWUhPT1sb3dlckNhc2VkTmFtZSl7Ly8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4vLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG5lcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcrJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnKydhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcrJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJysnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJyxuYW1lLGxvd2VyQ2FzZWROYW1lKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9aWYodHlwZW9mIHZhbHVlPT09J2Jvb2xlYW4nJiZzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLHZhbHVlLHByb3BlcnR5SW5mbyxmYWxzZSkpe2lmKHZhbHVlKXtlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nKydJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcrJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJyx2YWx1ZSxuYW1lLG5hbWUsdmFsdWUsbmFtZSk7fWVsc2V7ZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJysnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnKyclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicrJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnKydwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLHZhbHVlLG5hbWUsbmFtZSx2YWx1ZSxuYW1lLG5hbWUsbmFtZSk7fXdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXT10cnVlO3JldHVybiB0cnVlO30vLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbi8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5pZihpc1Jlc2VydmVkKXtyZXR1cm4gdHJ1ZTt9Ly8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbmlmKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsdmFsdWUscHJvcGVydHlJbmZvLGZhbHNlKSl7d2FybmVkUHJvcGVydGllcyQxW25hbWVdPXRydWU7cmV0dXJuIGZhbHNlO30vLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG5pZigodmFsdWU9PT0nZmFsc2UnfHx2YWx1ZT09PSd0cnVlJykmJnByb3BlcnR5SW5mbyE9PW51bGwmJnByb3BlcnR5SW5mby50eXBlPT09Qk9PTEVBTil7ZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcrJyVzICcrJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsdmFsdWUsbmFtZSx2YWx1ZT09PSdmYWxzZSc/J1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLic6J0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJyxuYW1lLHZhbHVlKTt3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV09dHJ1ZTtyZXR1cm4gdHJ1ZTt9cmV0dXJuIHRydWU7fTt9dmFyIHdhcm5Vbmtub3duUHJvcGVydGllcz1mdW5jdGlvbih0eXBlLHByb3BzLGV2ZW50UmVnaXN0cnkpe3t2YXIgdW5rbm93blByb3BzPVtdO2Zvcih2YXIga2V5IGluIHByb3BzKXt2YXIgaXNWYWxpZD12YWxpZGF0ZVByb3BlcnR5JDEodHlwZSxrZXkscHJvcHNba2V5XSxldmVudFJlZ2lzdHJ5KTtpZighaXNWYWxpZCl7dW5rbm93blByb3BzLnB1c2goa2V5KTt9fXZhciB1bmtub3duUHJvcFN0cmluZz11bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uKHByb3Ape3JldHVybidgJytwcm9wKydgJzt9KS5qb2luKCcsICcpO2lmKHVua25vd25Qcm9wcy5sZW5ndGg9PT0xKXtlcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnKydvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcrJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLHVua25vd25Qcm9wU3RyaW5nLHR5cGUpO31lbHNlIGlmKHVua25vd25Qcm9wcy5sZW5ndGg+MSl7ZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcrJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnKydGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJyx1bmtub3duUHJvcFN0cmluZyx0eXBlKTt9fX07ZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSxwcm9wcyxldmVudFJlZ2lzdHJ5KXtpZihpc0N1c3RvbUNvbXBvbmVudCh0eXBlLHByb3BzKSl7cmV0dXJuO313YXJuVW5rbm93blByb3BlcnRpZXModHlwZSxwcm9wcyxldmVudFJlZ2lzdHJ5KTt9dmFyIElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFPTE7dmFyIElTX05PTl9ERUxFR0FURUQ9MTw8MTt2YXIgSVNfQ0FQVFVSRV9QSEFTRT0xPDwyOy8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG52YXIgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlM9SVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREV8SVNfTk9OX0RFTEVHQVRFRHxJU19DQVBUVVJFX1BIQVNFOy8vIFRoaXMgZXhpc3RzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBSZWFjdERPTUV2ZW50UmVwbGF5aW5nXG4vLyBhbmQgRE9NUGx1Z2luRXZlbnRTeXN0ZW0uXG52YXIgY3VycmVudFJlcGxheWluZ0V2ZW50PW51bGw7ZnVuY3Rpb24gc2V0UmVwbGF5aW5nRXZlbnQoZXZlbnQpe3tpZihjdXJyZW50UmVwbGF5aW5nRXZlbnQhPT1udWxsKXtlcnJvcignRXhwZWN0ZWQgY3VycmVudGx5IHJlcGxheWluZyBldmVudCB0byBiZSBudWxsLiBUaGlzIGVycm9yICcrJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319Y3VycmVudFJlcGxheWluZ0V2ZW50PWV2ZW50O31mdW5jdGlvbiByZXNldFJlcGxheWluZ0V2ZW50KCl7e2lmKGN1cnJlbnRSZXBsYXlpbmdFdmVudD09PW51bGwpe2Vycm9yKCdFeHBlY3RlZCBjdXJyZW50bHkgcmVwbGF5aW5nIGV2ZW50IHRvIG5vdCBiZSBudWxsLiBUaGlzIGVycm9yICcrJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319Y3VycmVudFJlcGxheWluZ0V2ZW50PW51bGw7fWZ1bmN0aW9uIGlzUmVwbGF5aW5nRXZlbnQoZXZlbnQpe3JldHVybiBldmVudD09PWN1cnJlbnRSZXBsYXlpbmdFdmVudDt9LyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL2Z1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KXsvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDZcbnZhciB0YXJnZXQ9bmF0aXZlRXZlbnQudGFyZ2V0fHxuYXRpdmVFdmVudC5zcmNFbGVtZW50fHx3aW5kb3c7Ly8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuaWYodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KXt0YXJnZXQ9dGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O30vLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbnJldHVybiB0YXJnZXQubm9kZVR5cGU9PT1URVhUX05PREU/dGFyZ2V0LnBhcmVudE5vZGU6dGFyZ2V0O312YXIgcmVzdG9yZUltcGw9bnVsbDt2YXIgcmVzdG9yZVRhcmdldD1udWxsO3ZhciByZXN0b3JlUXVldWU9bnVsbDtmdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpey8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2Vcbi8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbnZhciBpbnRlcm5hbEluc3RhbmNlPWdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtpZighaW50ZXJuYWxJbnN0YW5jZSl7Ly8gVW5tb3VudGVkXG5yZXR1cm47fWlmKHR5cGVvZiByZXN0b3JlSW1wbCE9PSdmdW5jdGlvbicpe3Rocm93IG5ldyBFcnJvcignc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKCkgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSBhIHRhcmdldCBmb3IgY29udHJvbGxlZCAnKydldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXZhciBzdGF0ZU5vZGU9aW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGU7Ly8gR3VhcmQgYWdhaW5zdCBGaWJlciBiZWluZyB1bm1vdW50ZWQuXG5pZihzdGF0ZU5vZGUpe3ZhciBfcHJvcHM9Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO3Jlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLGludGVybmFsSW5zdGFuY2UudHlwZSxfcHJvcHMpO319ZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpe3Jlc3RvcmVJbXBsPWltcGw7fWZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KXtpZihyZXN0b3JlVGFyZ2V0KXtpZihyZXN0b3JlUXVldWUpe3Jlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7fWVsc2V7cmVzdG9yZVF1ZXVlPVt0YXJnZXRdO319ZWxzZXtyZXN0b3JlVGFyZ2V0PXRhcmdldDt9fWZ1bmN0aW9uIG5lZWRzU3RhdGVSZXN0b3JlKCl7cmV0dXJuIHJlc3RvcmVUYXJnZXQhPT1udWxsfHxyZXN0b3JlUXVldWUhPT1udWxsO31mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpe2lmKCFyZXN0b3JlVGFyZ2V0KXtyZXR1cm47fXZhciB0YXJnZXQ9cmVzdG9yZVRhcmdldDt2YXIgcXVldWVkVGFyZ2V0cz1yZXN0b3JlUXVldWU7cmVzdG9yZVRhcmdldD1udWxsO3Jlc3RvcmVRdWV1ZT1udWxsO3Jlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7aWYocXVldWVkVGFyZ2V0cyl7Zm9yKHZhciBpPTA7aTxxdWV1ZWRUYXJnZXRzLmxlbmd0aDtpKyspe3Jlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO319fS8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuLy8gRGVmYXVsdHNcbnZhciBiYXRjaGVkVXBkYXRlc0ltcGw9ZnVuY3Rpb24oZm4sYm9va2tlZXBpbmcpe3JldHVybiBmbihib29ra2VlcGluZyk7fTt2YXIgZmx1c2hTeW5jSW1wbD1mdW5jdGlvbigpe307dmFyIGlzSW5zaWRlRXZlbnRIYW5kbGVyPWZhbHNlO2Z1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpey8vIEhlcmUgd2Ugd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuLy8gVGhlbiB3ZSByZXN0b3JlIHN0YXRlIG9mIGFueSBjb250cm9sbGVkIGNvbXBvbmVudC5cbnZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcz1uZWVkc1N0YXRlUmVzdG9yZSgpO2lmKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKXsvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3Rcbi8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbi8vIFRPRE86IFJlc3RvcmUgc3RhdGUgaW4gdGhlIG1pY3JvdGFzaywgYWZ0ZXIgdGhlIGRpc2NyZXRlIHVwZGF0ZXMgZmx1c2gsXG4vLyBpbnN0ZWFkIG9mIGVhcmx5IGZsdXNoaW5nIHRoZW0gaGVyZS5cbmZsdXNoU3luY0ltcGwoKTtyZXN0b3JlU3RhdGVJZk5lZWRlZCgpO319ZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sYSxiKXtpZihpc0luc2lkZUV2ZW50SGFuZGxlcil7Ly8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4vLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbnJldHVybiBmbihhLGIpO31pc0luc2lkZUV2ZW50SGFuZGxlcj10cnVlO3RyeXtyZXR1cm4gYmF0Y2hlZFVwZGF0ZXNJbXBsKGZuLGEsYik7fWZpbmFsbHl7aXNJbnNpZGVFdmVudEhhbmRsZXI9ZmFsc2U7ZmluaXNoRXZlbnRIYW5kbGVyKCk7fX0vLyBUT0RPOiBSZXBsYWNlIHdpdGggZmx1c2hTeW5jXG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKF9iYXRjaGVkVXBkYXRlc0ltcGwsX2Rpc2NyZXRlVXBkYXRlc0ltcGwsX2ZsdXNoU3luY0ltcGwpe2JhdGNoZWRVcGRhdGVzSW1wbD1fYmF0Y2hlZFVwZGF0ZXNJbXBsO2ZsdXNoU3luY0ltcGw9X2ZsdXNoU3luY0ltcGw7fWZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKXtyZXR1cm4gdGFnPT09J2J1dHRvbid8fHRhZz09PSdpbnB1dCd8fHRhZz09PSdzZWxlY3QnfHx0YWc9PT0ndGV4dGFyZWEnO31mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLHR5cGUscHJvcHMpe3N3aXRjaChuYW1lKXtjYXNlJ29uQ2xpY2snOmNhc2Unb25DbGlja0NhcHR1cmUnOmNhc2Unb25Eb3VibGVDbGljayc6Y2FzZSdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6Y2FzZSdvbk1vdXNlRG93bic6Y2FzZSdvbk1vdXNlRG93bkNhcHR1cmUnOmNhc2Unb25Nb3VzZU1vdmUnOmNhc2Unb25Nb3VzZU1vdmVDYXB0dXJlJzpjYXNlJ29uTW91c2VVcCc6Y2FzZSdvbk1vdXNlVXBDYXB0dXJlJzpjYXNlJ29uTW91c2VFbnRlcic6cmV0dXJuISEocHJvcHMuZGlzYWJsZWQmJmlzSW50ZXJhY3RpdmUodHlwZSkpO2RlZmF1bHQ6cmV0dXJuIGZhbHNlO319LyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCxyZWdpc3RyYXRpb25OYW1lKXt2YXIgc3RhdGVOb2RlPWluc3Quc3RhdGVOb2RlO2lmKHN0YXRlTm9kZT09PW51bGwpey8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxucmV0dXJuIG51bGw7fXZhciBwcm9wcz1nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7aWYocHJvcHM9PT1udWxsKXsvLyBXb3JrIGluIHByb2dyZXNzLlxucmV0dXJuIG51bGw7fXZhciBsaXN0ZW5lcj1wcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtpZihzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLGluc3QudHlwZSxwcm9wcykpe3JldHVybiBudWxsO31pZihsaXN0ZW5lciYmdHlwZW9mIGxpc3RlbmVyIT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiK3JlZ2lzdHJhdGlvbk5hbWUrXCJgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYFwiK3R5cGVvZiBsaXN0ZW5lcitcImAgdHlwZS5cIik7fXJldHVybiBsaXN0ZW5lcjt9dmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkPWZhbHNlOy8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuaWYoY2FuVXNlRE9NKXt0cnl7dmFyIG9wdGlvbnM9e307Ly8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywncGFzc2l2ZScse2dldDpmdW5jdGlvbigpe3Bhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkPXRydWU7fX0pO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JyxvcHRpb25zLG9wdGlvbnMpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JyxvcHRpb25zLG9wdGlvbnMpO31jYXRjaChlKXtwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZD1mYWxzZTt9fWZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpe3ZhciBmdW5jQXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2Z1bmMuYXBwbHkoY29udGV4dCxmdW5jQXJncyk7fWNhdGNoKGVycm9yKXt0aGlzLm9uRXJyb3IoZXJyb3IpO319dmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw9aW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDt7Ly8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbi8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbi8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4vLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbi8vIHVuaW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbi8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuLy9cbi8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbi8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbi8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbi8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4vLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbi8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4vLyB0cnktY2F0Y2guIE5lYXQhXG4vLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4vLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbmlmKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJyYmdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50PT09J2Z1bmN0aW9uJyYmdHlwZW9mIGRvY3VtZW50IT09J3VuZGVmaW5lZCcmJnR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudD09PSdmdW5jdGlvbicpe3ZhciBmYWtlTm9kZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO2ludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw9ZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2KG5hbWUsZnVuYyxjb250ZXh0LGEsYixjLGQsZSxmKXsvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4vLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4vLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG5pZih0eXBlb2YgZG9jdW1lbnQ9PT0ndW5kZWZpbmVkJ3x8ZG9jdW1lbnQ9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnKydkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJysnc2NoZWR1bGVzIGFuIHVwZGF0ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBjYWxsYmFjaywgYnV0IHRoZSB0ZXN0IGhhcyBhbHJlYWR5ICcrJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnKyd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJysnY2FuY2VsZWQgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YCksIG9yIHlvdSBjYW4gY2hhbmdlIHRoZSB0ZXN0IGl0c2VsZiAnKyd0byBiZSBhc3luY2hyb25vdXMuJyk7fXZhciBldnQ9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7dmFyIGRpZENhbGw9ZmFsc2U7Ly8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2Vcbi8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbi8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbi8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4vLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxudmFyIGRpZEVycm9yPXRydWU7Ly8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4vLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG52YXIgd2luZG93RXZlbnQ9d2luZG93LmV2ZW50Oy8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4vLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxudmFyIHdpbmRvd0V2ZW50RGVzY3JpcHRvcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywnZXZlbnQnKTtmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpey8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4vLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuLy8gaW4gdGhlIHN0YWNrLlxuZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLGNhbGxDYWxsYmFjayxmYWxzZSk7Ly8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4vLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3Rcbi8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuaWYodHlwZW9mIHdpbmRvdy5ldmVudCE9PSd1bmRlZmluZWQnJiZ3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50Jykpe3dpbmRvdy5ldmVudD13aW5kb3dFdmVudDt9fS8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4vLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2Vcbi8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG52YXIgZnVuY0FyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO2Z1bmN0aW9uIGNhbGxDYWxsYmFjaygpe2RpZENhbGw9dHJ1ZTtyZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO2Z1bmMuYXBwbHkoY29udGV4dCxmdW5jQXJncyk7ZGlkRXJyb3I9ZmFsc2U7fS8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4vLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4vLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4vLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4vLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbi8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG52YXIgZXJyb3I7Ly8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG52YXIgZGlkU2V0RXJyb3I9ZmFsc2U7dmFyIGlzQ3Jvc3NPcmlnaW5FcnJvcj1mYWxzZTtmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCl7ZXJyb3I9ZXZlbnQuZXJyb3I7ZGlkU2V0RXJyb3I9dHJ1ZTtpZihlcnJvcj09PW51bGwmJmV2ZW50LmNvbG5vPT09MCYmZXZlbnQubGluZW5vPT09MCl7aXNDcm9zc09yaWdpbkVycm9yPXRydWU7fWlmKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpey8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4vLyBCcm93c2VycyBzaWxlbmNlIHRoZSBlcnJvciByZXBvcnQgaWYgdGhpcyBoYXBwZW5zLlxuLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuaWYoZXJyb3IhPW51bGwmJnR5cGVvZiBlcnJvcj09PSdvYmplY3QnKXt0cnl7ZXJyb3IuX3N1cHByZXNzTG9nZ2luZz10cnVlO31jYXRjaChpbm5lcil7Ly8gSWdub3JlLlxufX19fS8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbnZhciBldnRUeXBlPVwicmVhY3QtXCIrKG5hbWU/bmFtZTonaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7Ly8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJyxoYW5kbGVXaW5kb3dFcnJvcik7ZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLGNhbGxDYWxsYmFjayxmYWxzZSk7Ly8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbi8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbmV2dC5pbml0RXZlbnQoZXZ0VHlwZSxmYWxzZSxmYWxzZSk7ZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO2lmKHdpbmRvd0V2ZW50RGVzY3JpcHRvcil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywnZXZlbnQnLHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7fWlmKGRpZENhbGwmJmRpZEVycm9yKXtpZighZGlkU2V0RXJyb3Ipey8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbmVycm9yPW5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcrXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiKydmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJysnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnK1wiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiKyd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcrJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJysnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWVsc2UgaWYoaXNDcm9zc09yaWdpbkVycm9yKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuZXJyb3I9bmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIisndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7fXRoaXMub25FcnJvcihlcnJvcik7fS8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLGhhbmRsZVdpbmRvd0Vycm9yKTtpZighZGlkQ2FsbCl7Ly8gU29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nLCBhbmQgb3VyIGV2ZW50IHdhcyBub3QgZGlzcGF0Y2hlZC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY1ODVcbi8vIEZhbGwgYmFjayB0byB0aGUgcHJvZHVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbnJlc3RvcmVBZnRlckRpc3BhdGNoKCk7cmV0dXJuIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QuYXBwbHkodGhpcyxhcmd1bWVudHMpO319O319dmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMT1pbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO3ZhciBoYXNFcnJvcj1mYWxzZTt2YXIgY2F1Z2h0RXJyb3I9bnVsbDsvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIGhhc1JldGhyb3dFcnJvcj1mYWxzZTt2YXIgcmV0aHJvd0Vycm9yPW51bGw7dmFyIHJlcG9ydGVyPXtvbkVycm9yOmZ1bmN0aW9uKGVycm9yKXtoYXNFcnJvcj10cnVlO2NhdWdodEVycm9yPWVycm9yO319Oy8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpe2hhc0Vycm9yPWZhbHNlO2NhdWdodEVycm9yPW51bGw7aW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLGFyZ3VtZW50cyk7fS8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSxmdW5jLGNvbnRleHQsYSxiLGMsZCxlLGYpe2ludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoaGFzRXJyb3Ipe3ZhciBlcnJvcj1jbGVhckNhdWdodEVycm9yKCk7aWYoIWhhc1JldGhyb3dFcnJvcil7aGFzUmV0aHJvd0Vycm9yPXRydWU7cmV0aHJvd0Vycm9yPWVycm9yO319fS8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9mdW5jdGlvbiByZXRocm93Q2F1Z2h0RXJyb3IoKXtpZihoYXNSZXRocm93RXJyb3Ipe3ZhciBlcnJvcj1yZXRocm93RXJyb3I7aGFzUmV0aHJvd0Vycm9yPWZhbHNlO3JldGhyb3dFcnJvcj1udWxsO3Rocm93IGVycm9yO319ZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKXtyZXR1cm4gaGFzRXJyb3I7fWZ1bmN0aW9uIGNsZWFyQ2F1Z2h0RXJyb3IoKXtpZihoYXNFcnJvcil7dmFyIGVycm9yPWNhdWdodEVycm9yO2hhc0Vycm9yPWZhbHNlO2NhdWdodEVycm9yPW51bGw7cmV0dXJuIGVycm9yO31lbHNle3Rocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJysnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX0vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9mdW5jdGlvbiBnZXQoa2V5KXtyZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsczt9ZnVuY3Rpb24gaGFzKGtleSl7cmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHMhPT11bmRlZmluZWQ7fWZ1bmN0aW9uIHNldChrZXksdmFsdWUpe2tleS5fcmVhY3RJbnRlcm5hbHM9dmFsdWU7fS8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3M9LyogICAgICAgICAgICAgICAgICAgICAgKi8wO3ZhciBQZXJmb3JtZWRXb3JrPS8qICAgICAgICAgICAgICAgICovMTsvLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQ9LyogICAgICAgICAgICAgICAgICAgICovMjt2YXIgVXBkYXRlPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzQ7dmFyIENoaWxkRGVsZXRpb249LyogICAgICAgICAgICAgICAgKi8xNjt2YXIgQ29udGVudFJlc2V0PS8qICAgICAgICAgICAgICAgICAqLzMyO3ZhciBDYWxsYmFjaz0vKiAgICAgICAgICAgICAgICAgICAgICovNjQ7dmFyIERpZENhcHR1cmU9LyogICAgICAgICAgICAgICAgICAgKi8xMjg7dmFyIEZvcmNlQ2xpZW50UmVuZGVyPS8qICAgICAgICAgICAgKi8yNTY7dmFyIFJlZj0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi81MTI7dmFyIFNuYXBzaG90PS8qICAgICAgICAgICAgICAgICAgICAgKi8xMDI0O3ZhciBQYXNzaXZlPS8qICAgICAgICAgICAgICAgICAgICAgICovMjA0ODt2YXIgSHlkcmF0aW5nPS8qICAgICAgICAgICAgICAgICAgICAqLzQwOTY7dmFyIFZpc2liaWxpdHk9LyogICAgICAgICAgICAgICAgICAgKi84MTkyO3ZhciBTdG9yZUNvbnNpc3RlbmN5PS8qICAgICAgICAgICAgICovMTYzODQ7dmFyIExpZmVjeWNsZUVmZmVjdE1hc2s9UGFzc2l2ZXxVcGRhdGV8Q2FsbGJhY2t8UmVmfFNuYXBzaG90fFN0b3JlQ29uc2lzdGVuY3k7Ly8gVW5pb24gb2YgYWxsIGNvbW1pdCBmbGFncyAoZmxhZ3Mgd2l0aCB0aGUgbGlmZXRpbWUgb2YgYSBwYXJ0aWN1bGFyIGNvbW1pdClcbnZhciBIb3N0RWZmZWN0TWFzaz0vKiAgICAgICAgICAgICAgICovMzI3Njc7Ly8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cbnZhciBJbmNvbXBsZXRlPS8qICAgICAgICAgICAgICAgICAgICovMzI3Njg7dmFyIFNob3VsZENhcHR1cmU9LyogICAgICAgICAgICAgICAgKi82NTUzNjt2YXIgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZT0vKiAqLzEzMTA3Mjt2YXIgRm9ya2VkPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzEwNDg1NzY7Ly8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcbi8vIGUuZy4gYSBmaWJlciB1c2VzIGEgcGFzc2l2ZSBlZmZlY3QgKGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHVwZGF0ZXMgb24gdGhpcyBwYXJ0aWN1bGFyIHJlbmRlcikuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGVmZXIgbW9yZSB3b3JrIGluIHRoZSB1bm1vdW50IGNhc2UsXG4vLyBzaW5jZSB3ZSBjYW4gZGVmZXIgdHJhdmVyc2luZyB0aGUgdHJlZSBkdXJpbmcgbGF5b3V0IHRvIGxvb2sgZm9yIFBhc3NpdmUgZWZmZWN0cyxcbi8vIGFuZCBpbnN0ZWFkIHJlbHkgb24gdGhlIHN0YXRpYyBmbGFnIGFzIGEgc2lnbmFsIHRoYXQgdGhlcmUgbWF5IGJlIGNsZWFudXAgd29yay5cbnZhciBSZWZTdGF0aWM9LyogICAgICAgICAgICAgICAgICAgICovMjA5NzE1Mjt2YXIgTGF5b3V0U3RhdGljPS8qICAgICAgICAgICAgICAgICAqLzQxOTQzMDQ7dmFyIFBhc3NpdmVTdGF0aWM9LyogICAgICAgICAgICAgICAgKi84Mzg4NjA4Oy8vIFRoZXNlIGZsYWdzIGFsbG93IHVzIHRvIHRyYXZlcnNlIHRvIGZpYmVycyB0aGF0IGhhdmUgZWZmZWN0cyBvbiBtb3VudFxuLy8gd2l0aG91dCB0cmF2ZXJzaW5nIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBldmVyeSBjb21taXQgZm9yXG4vLyBkb3VibGUgaW52b2tpbmdcbnZhciBNb3VudExheW91dERldj0vKiAgICAgICAgICAgICAgICovMTY3NzcyMTY7dmFyIE1vdW50UGFzc2l2ZURldj0vKiAgICAgICAgICAgICAgKi8zMzU1NDQzMjsvLyBHcm91cHMgb2YgZmxhZ3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgY29tbWl0IHBoYXNlIHRvIHNraXAgb3ZlciB0cmVlcyB0aGF0XG4vLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cbnZhciBCZWZvcmVNdXRhdGlvbk1hc2s9Ly8gVE9ETzogUmVtb3ZlIFVwZGF0ZSBmbGFnIGZyb20gYmVmb3JlIG11dGF0aW9uIHBoYXNlIGJ5IHJlLWxhbmRpbmcgVmlzaWJpbGl0eVxuLy8gZmxhZyBsb2dpYyAoc2VlICMyMDA0MylcblVwZGF0ZXxTbmFwc2hvdHwwO3ZhciBNdXRhdGlvbk1hc2s9UGxhY2VtZW50fFVwZGF0ZXxDaGlsZERlbGV0aW9ufENvbnRlbnRSZXNldHxSZWZ8SHlkcmF0aW5nfFZpc2liaWxpdHk7dmFyIExheW91dE1hc2s9VXBkYXRlfENhbGxiYWNrfFJlZnxWaXNpYmlsaXR5Oy8vIFRPRE86IFNwbGl0IGludG8gUGFzc2l2ZU1vdW50TWFzayBhbmQgUGFzc2l2ZVVubW91bnRNYXNrXG52YXIgUGFzc2l2ZU1hc2s9UGFzc2l2ZXxDaGlsZERlbGV0aW9uOy8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cbnZhciBTdGF0aWNNYXNrPUxheW91dFN0YXRpY3xQYXNzaXZlU3RhdGljfFJlZlN0YXRpYzt2YXIgUmVhY3RDdXJyZW50T3duZXI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7ZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcil7dmFyIG5vZGU9ZmliZXI7dmFyIG5lYXJlc3RNb3VudGVkPWZpYmVyO2lmKCFmaWJlci5hbHRlcm5hdGUpey8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbi8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxudmFyIG5leHROb2RlPW5vZGU7ZG97bm9kZT1uZXh0Tm9kZTtpZigobm9kZS5mbGFncyYoUGxhY2VtZW50fEh5ZHJhdGluZykpIT09Tm9GbGFncyl7Ly8gVGhpcyBpcyBhbiBpbnNlcnRpb24gb3IgaW4tcHJvZ3Jlc3MgaHlkcmF0aW9uLiBUaGUgbmVhcmVzdCBwb3NzaWJsZVxuLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbi8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG5uZWFyZXN0TW91bnRlZD1ub2RlLnJldHVybjt9bmV4dE5vZGU9bm9kZS5yZXR1cm47fXdoaWxlKG5leHROb2RlKTt9ZWxzZXt3aGlsZShub2RlLnJldHVybil7bm9kZT1ub2RlLnJldHVybjt9fWlmKG5vZGUudGFnPT09SG9zdFJvb3Qpey8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4vLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbnJldHVybiBuZWFyZXN0TW91bnRlZDt9Ly8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4vLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbnJldHVybiBudWxsO31mdW5jdGlvbiBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKGZpYmVyKXtpZihmaWJlci50YWc9PT1TdXNwZW5zZUNvbXBvbmVudCl7dmFyIHN1c3BlbnNlU3RhdGU9ZmliZXIubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlPT09bnVsbCl7dmFyIGN1cnJlbnQ9ZmliZXIuYWx0ZXJuYXRlO2lmKGN1cnJlbnQhPT1udWxsKXtzdXNwZW5zZVN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt9fWlmKHN1c3BlbnNlU3RhdGUhPT1udWxsKXtyZXR1cm4gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO319cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldENvbnRhaW5lckZyb21GaWJlcihmaWJlcil7cmV0dXJuIGZpYmVyLnRhZz09PUhvc3RSb290P2ZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7fWZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKXtyZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik9PT1maWJlcjt9ZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCl7e3ZhciBvd25lcj1SZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O2lmKG93bmVyIT09bnVsbCYmb3duZXIudGFnPT09Q2xhc3NDb21wb25lbnQpe3ZhciBvd25lckZpYmVyPW93bmVyO3ZhciBpbnN0YW5jZT1vd25lckZpYmVyLnN0YXRlTm9kZTtpZighaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKXtlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnKydyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcrJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcrJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcrJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKXx8J0EgY29tcG9uZW50Jyk7fWluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcj10cnVlO319dmFyIGZpYmVyPWdldChjb21wb25lbnQpO2lmKCFmaWJlcil7cmV0dXJuIGZhbHNlO31yZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik9PT1maWJlcjt9ZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKXtpZihnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSE9PWZpYmVyKXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9fWZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKXt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZighYWx0ZXJuYXRlKXsvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG52YXIgbmVhcmVzdE1vdW50ZWQ9Z2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7aWYobmVhcmVzdE1vdW50ZWQ9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9aWYobmVhcmVzdE1vdW50ZWQhPT1maWJlcil7cmV0dXJuIG51bGw7fXJldHVybiBmaWJlcjt9Ly8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4vLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbi8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxudmFyIGE9ZmliZXI7dmFyIGI9YWx0ZXJuYXRlO3doaWxlKHRydWUpe3ZhciBwYXJlbnRBPWEucmV0dXJuO2lmKHBhcmVudEE9PT1udWxsKXsvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbmJyZWFrO312YXIgcGFyZW50Qj1wYXJlbnRBLmFsdGVybmF0ZTtpZihwYXJlbnRCPT09bnVsbCl7Ly8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4vLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbnZhciBuZXh0UGFyZW50PXBhcmVudEEucmV0dXJuO2lmKG5leHRQYXJlbnQhPT1udWxsKXthPWI9bmV4dFBhcmVudDtjb250aW51ZTt9Ly8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuYnJlYWs7fS8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4vLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5pZihwYXJlbnRBLmNoaWxkPT09cGFyZW50Qi5jaGlsZCl7dmFyIGNoaWxkPXBhcmVudEEuY2hpbGQ7d2hpbGUoY2hpbGQpe2lmKGNoaWxkPT09YSl7Ly8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO3JldHVybiBmaWJlcjt9aWYoY2hpbGQ9PT1iKXsvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG5hc3NlcnRJc01vdW50ZWQocGFyZW50QSk7cmV0dXJuIGFsdGVybmF0ZTt9Y2hpbGQ9Y2hpbGQuc2libGluZzt9Ly8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbi8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbnRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO31pZihhLnJldHVybiE9PWIucmV0dXJuKXsvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4vLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4vLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4vLyBzZXQgb2YgQi5yZXR1cm4uXG5hPXBhcmVudEE7Yj1wYXJlbnRCO31lbHNley8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbi8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuLy9cbi8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxudmFyIGRpZEZpbmRDaGlsZD1mYWxzZTt2YXIgX2NoaWxkPXBhcmVudEEuY2hpbGQ7d2hpbGUoX2NoaWxkKXtpZihfY2hpbGQ9PT1hKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTthPXBhcmVudEE7Yj1wYXJlbnRCO2JyZWFrO31pZihfY2hpbGQ9PT1iKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTtiPXBhcmVudEE7YT1wYXJlbnRCO2JyZWFrO31fY2hpbGQ9X2NoaWxkLnNpYmxpbmc7fWlmKCFkaWRGaW5kQ2hpbGQpey8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuX2NoaWxkPXBhcmVudEIuY2hpbGQ7d2hpbGUoX2NoaWxkKXtpZihfY2hpbGQ9PT1hKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTthPXBhcmVudEI7Yj1wYXJlbnRBO2JyZWFrO31pZihfY2hpbGQ9PT1iKXtkaWRGaW5kQ2hpbGQ9dHJ1ZTtiPXBhcmVudEI7YT1wYXJlbnRBO2JyZWFrO31fY2hpbGQ9X2NoaWxkLnNpYmxpbmc7fWlmKCFkaWRGaW5kQ2hpbGQpe3Rocm93IG5ldyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJysnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319fWlmKGEuYWx0ZXJuYXRlIT09Yil7dGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIisnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9fS8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4vLyB1bm1vdW50ZWQuXG5pZihhLnRhZyE9PUhvc3RSb290KXt0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTt9aWYoYS5zdGF0ZU5vZGUuY3VycmVudD09PWEpey8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbnJldHVybiBmaWJlcjt9Ly8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxucmV0dXJuIGFsdGVybmF0ZTt9ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KXt2YXIgY3VycmVudFBhcmVudD1maW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO3JldHVybiBjdXJyZW50UGFyZW50IT09bnVsbD9maW5kQ3VycmVudEhvc3RGaWJlckltcGwoY3VycmVudFBhcmVudCk6bnVsbDt9ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpey8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5pZihub2RlLnRhZz09PUhvc3RDb21wb25lbnR8fG5vZGUudGFnPT09SG9zdFRleHQpe3JldHVybiBub2RlO312YXIgY2hpbGQ9bm9kZS5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe3ZhciBtYXRjaD1maW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO2lmKG1hdGNoIT09bnVsbCl7cmV0dXJuIG1hdGNoO31jaGlsZD1jaGlsZC5zaWJsaW5nO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCl7dmFyIGN1cnJlbnRQYXJlbnQ9ZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtyZXR1cm4gY3VycmVudFBhcmVudCE9PW51bGw/ZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjdXJyZW50UGFyZW50KTpudWxsO31mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpey8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5pZihub2RlLnRhZz09PUhvc3RDb21wb25lbnR8fG5vZGUudGFnPT09SG9zdFRleHQpe3JldHVybiBub2RlO312YXIgY2hpbGQ9bm9kZS5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe2lmKGNoaWxkLnRhZyE9PUhvc3RQb3J0YWwpe3ZhciBtYXRjaD1maW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGNoaWxkKTtpZihtYXRjaCE9PW51bGwpe3JldHVybiBtYXRjaDt9fWNoaWxkPWNoaWxkLnNpYmxpbmc7fXJldHVybiBudWxsO30vLyBUaGlzIG1vZHVsZSBvbmx5IGV4aXN0cyBhcyBhbiBFU00gd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIENvbW1vbkpTXG52YXIgc2NoZWR1bGVDYWxsYmFjaz1TY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjazt2YXIgY2FuY2VsQ2FsbGJhY2s9U2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO3ZhciBzaG91bGRZaWVsZD1TY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQ7dmFyIHJlcXVlc3RQYWludD1TY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50O3ZhciBub3c9U2NoZWR1bGVyLnVuc3RhYmxlX25vdzt2YXIgZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw9U2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO3ZhciBJbW1lZGlhdGVQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHk7dmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5PVNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTt2YXIgTm9ybWFsUHJpb3JpdHk9U2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5O3ZhciBMb3dQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfTG93UHJpb3JpdHk7dmFyIElkbGVQcmlvcml0eT1TY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5Oy8vIHRoaXMgZG9lc24ndCBhY3R1YWxseSBleGlzdCBvbiB0aGUgc2NoZWR1bGVyLCBidXQgaXQgKmRvZXMqXG4vLyBvbiBzY2hlZHVsZXIvdW5zdGFibGVfbW9jaywgd2hpY2ggd2UnbGwgbmVlZCBmb3IgaW50ZXJuYWwgdGVzdGluZ1xudmFyIHVuc3RhYmxlX3lpZWxkVmFsdWU9U2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWU7dmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlPVNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZTt2YXIgcmVuZGVyZXJJRD1udWxsO3ZhciBpbmplY3RlZEhvb2s9bnVsbDt2YXIgaW5qZWN0ZWRQcm9maWxpbmdIb29rcz1udWxsO3ZhciBoYXNMb2dnZWRFcnJvcj1mYWxzZTt2YXIgaXNEZXZUb29sc1ByZXNlbnQ9dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyE9PSd1bmRlZmluZWQnO2Z1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpe2lmKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX189PT0ndW5kZWZpbmVkJyl7Ly8gTm8gRGV2VG9vbHNcbnJldHVybiBmYWxzZTt9dmFyIGhvb2s9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGhvb2suaXNEaXNhYmxlZCl7Ly8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbi8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG5yZXR1cm4gdHJ1ZTt9aWYoIWhvb2suc3VwcG9ydHNGaWJlcil7e2Vycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnKyd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycpO30vLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbnJldHVybiB0cnVlO310cnl7aWYoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKXsvLyBDb25kaXRpb25hbGx5IGluamVjdCB0aGVzZSBob29rcyBvbmx5IGlmIFRpbWVsaW5lIHByb2ZpbGVyIGlzIHN1cHBvcnRlZCBieSB0aGlzIGJ1aWxkLlxuLy8gVGhpcyBnaXZlcyBEZXZUb29scyBhIHdheSB0byBmZWF0dXJlIGRldGVjdCB0aGF0IGlzbid0IHRpZWQgdG8gdmVyc2lvbiBudW1iZXJcbi8vIChzaW5jZSBwcm9maWxpbmcgYW5kIHRpbWVsaW5lIGFyZSBjb250cm9sbGVkIGJ5IGRpZmZlcmVudCBmZWF0dXJlIGZsYWdzKS5cbmludGVybmFscz1hc3NpZ24oe30saW50ZXJuYWxzLHtnZXRMYW5lTGFiZWxNYXA6Z2V0TGFuZUxhYmVsTWFwLGluamVjdFByb2ZpbGluZ0hvb2tzOmluamVjdFByb2ZpbGluZ0hvb2tzfSk7fXJlbmRlcmVySUQ9aG9vay5pbmplY3QoaW50ZXJuYWxzKTsvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuaW5qZWN0ZWRIb29rPWhvb2s7fWNhdGNoKGVycil7Ly8gQ2F0Y2ggYWxsIGVycm9ycyBiZWNhdXNlIGl0IGlzIHVuc2FmZSB0byB0aHJvdyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG57ZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJyxlcnIpO319aWYoaG9vay5jaGVja0RDRSl7Ly8gVGhpcyBpcyB0aGUgcmVhbCBEZXZUb29scy5cbnJldHVybiB0cnVlO31lbHNley8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG5yZXR1cm4gZmFsc2U7fX1mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LGNoaWxkcmVuKXt7aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3Q9PT0nZnVuY3Rpb24nKXt0cnl7aW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QocmVuZGVyZXJJRCxyb290LGNoaWxkcmVuKTt9Y2F0Y2goZXJyKXtpZighaGFzTG9nZ2VkRXJyb3Ipe2hhc0xvZ2dlZEVycm9yPXRydWU7ZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLGVycik7fX19fX1mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCxldmVudFByaW9yaXR5KXtpZihpbmplY3RlZEhvb2smJnR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3Q9PT0nZnVuY3Rpb24nKXt0cnl7dmFyIGRpZEVycm9yPShyb290LmN1cnJlbnQuZmxhZ3MmRGlkQ2FwdHVyZSk9PT1EaWRDYXB0dXJlO2lmKGVuYWJsZVByb2ZpbGVyVGltZXIpe3ZhciBzY2hlZHVsZXJQcmlvcml0eTtzd2l0Y2goZXZlbnRQcmlvcml0eSl7Y2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHk9SW1tZWRpYXRlUHJpb3JpdHk7YnJlYWs7Y2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eT1Vc2VyQmxvY2tpbmdQcmlvcml0eTticmVhaztjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5PU5vcm1hbFByaW9yaXR5O2JyZWFrO2Nhc2UgSWRsZUV2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHk9SWRsZVByaW9yaXR5O2JyZWFrO2RlZmF1bHQ6c2NoZWR1bGVyUHJpb3JpdHk9Tm9ybWFsUHJpb3JpdHk7YnJlYWs7fWluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELHJvb3Qsc2NoZWR1bGVyUHJpb3JpdHksZGlkRXJyb3IpO31lbHNle2luamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELHJvb3QsdW5kZWZpbmVkLGRpZEVycm9yKTt9fWNhdGNoKGVycil7e2lmKCFoYXNMb2dnZWRFcnJvcil7aGFzTG9nZ2VkRXJyb3I9dHJ1ZTtlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsZXJyKTt9fX19fWZ1bmN0aW9uIG9uUG9zdENvbW1pdFJvb3Qocm9vdCl7aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdD09PSdmdW5jdGlvbicpe3RyeXtpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQscm9vdCk7fWNhdGNoKGVycil7e2lmKCFoYXNMb2dnZWRFcnJvcil7aGFzTG9nZ2VkRXJyb3I9dHJ1ZTtlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsZXJyKTt9fX19fWZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcil7aWYoaW5qZWN0ZWRIb29rJiZ0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50PT09J2Z1bmN0aW9uJyl7dHJ5e2luamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELGZpYmVyKTt9Y2F0Y2goZXJyKXt7aWYoIWhhc0xvZ2dlZEVycm9yKXtoYXNMb2dnZWRFcnJvcj10cnVlO2Vycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxlcnIpO319fX19ZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKXt7aWYodHlwZW9mIHVuc3RhYmxlX3lpZWxkVmFsdWU9PT0nZnVuY3Rpb24nKXsvLyBXZSdyZSBpbiBhIHRlc3QgYmVjYXVzZSBTY2hlZHVsZXIudW5zdGFibGVfeWllbGRWYWx1ZSBvbmx5IGV4aXN0c1xuLy8gaW4gU2NoZWR1bGVyTW9jay4gVG8gcmVkdWNlIHRoZSBub2lzZSBpbiBzdHJpY3QgbW9kZSB0ZXN0cyxcbi8vIHN1cHByZXNzIHdhcm5pbmdzIGFuZCBkaXNhYmxlIHNjaGVkdWxlciB5aWVsZGluZyBkdXJpbmcgdGhlIGRvdWJsZSByZW5kZXJcbnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7c2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7fWlmKGluamVjdGVkSG9vayYmdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlPT09J2Z1bmN0aW9uJyl7dHJ5e2luamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsbmV3SXNTdHJpY3RNb2RlKTt9Y2F0Y2goZXJyKXt7aWYoIWhhc0xvZ2dlZEVycm9yKXtoYXNMb2dnZWRFcnJvcj10cnVlO2Vycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJyxlcnIpO319fX19fS8vIFByb2ZpbGVyIEFQSSBob29rc1xuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3Mpe2luamVjdGVkUHJvZmlsaW5nSG9va3M9cHJvZmlsaW5nSG9va3M7fWZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpe3t2YXIgbWFwPW5ldyBNYXAoKTt2YXIgbGFuZT0xO2Zvcih2YXIgaW5kZXg9MDtpbmRleDxUb3RhbExhbmVzO2luZGV4Kyspe3ZhciBsYWJlbD1nZXRMYWJlbEZvckxhbmUobGFuZSk7bWFwLnNldChsYW5lLGxhYmVsKTtsYW5lKj0yO31yZXR1cm4gbWFwO319ZnVuY3Rpb24gbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcil7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcil7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7fX19ZnVuY3Rpb24gbWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsdGhyb3duVmFsdWUsbGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLHRocm93blZhbHVlLGxhbmVzKTt9fX1mdW5jdGlvbiBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGZpYmVyLHdha2VhYmxlLGxhbmVzKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsd2FrZWFibGUsbGFuZXMpO319fWZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7fX19ZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO319fWZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7fX19ZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO319fWZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7fX19ZnVuY3Rpb24gbWFya1JlbmRlcllpZWxkZWQoKXt7aWYoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyE9PW51bGwmJnR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkPT09J2Z1bmN0aW9uJyl7aW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpO319fWZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQoKTt9fX1mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpe3tpZihpbmplY3RlZFByb2ZpbGluZ0hvb2tzIT09bnVsbCYmdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZD09PSdmdW5jdGlvbicpe2luamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTt9fX1mdW5jdGlvbiBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fX1mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSl7e2lmKGluamVjdGVkUHJvZmlsaW5nSG9va3MhPT1udWxsJiZ0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQ9PT0nZnVuY3Rpb24nKXtpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fX12YXIgTm9Nb2RlPS8qICAgICAgICAgICAgICAgICAgICAgICAgICovMDsvLyBUT0RPOiBSZW1vdmUgQ29uY3VycmVudE1vZGUgYnkgcmVhZGluZyBmcm9tIHRoZSByb290IHRhZyBpbnN0ZWFkXG52YXIgQ29uY3VycmVudE1vZGU9LyogICAgICAgICAgICAgICAgICovMTt2YXIgUHJvZmlsZU1vZGU9LyogICAgICAgICAgICAgICAgICAgICovMjt2YXIgU3RyaWN0TGVnYWN5TW9kZT0vKiAgICAgICAgICAgICAgICovODt2YXIgU3RyaWN0RWZmZWN0c01vZGU9LyogICAgICAgICAgICAgICovMTY7Ly8gVE9ETzogVGhpcyBpcyBwcmV0dHkgd2VsbCBzdXBwb3J0ZWQgYnkgYnJvd3NlcnMuIE1heWJlIHdlIGNhbiBkcm9wIGl0LlxudmFyIGNsejMyPU1hdGguY2x6MzI/TWF0aC5jbHozMjpjbHozMkZhbGxiYWNrOy8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcbnZhciBsb2c9TWF0aC5sb2c7dmFyIExOMj1NYXRoLkxOMjtmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpe3ZhciBhc1VpbnQ9eD4+PjA7aWYoYXNVaW50PT09MCl7cmV0dXJuIDMyO31yZXR1cm4gMzEtKGxvZyhhc1VpbnQpL0xOMnwwKXwwO30vLyBJZiB0aG9zZSB2YWx1ZXMgYXJlIGNoYW5nZWQgdGhhdCBwYWNrYWdlIHNob3VsZCBiZSByZWJ1aWx0IGFuZCByZWRlcGxveWVkLlxudmFyIFRvdGFsTGFuZXM9MzE7dmFyIE5vTGFuZXM9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzA7dmFyIE5vTGFuZT0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi8wO3ZhciBTeW5jTGFuZT0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMTt2YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZT0vKiAgICAqLzI7dmFyIElucHV0Q29udGludW91c0xhbmU9LyogICAgICAgICAgICAgKi80O3ZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAgICovODt2YXIgRGVmYXVsdExhbmU9LyogICAgICAgICAgICAgICAgICAgICAqLzE2O3ZhciBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAgICAgICAqLzMyO3ZhciBUcmFuc2l0aW9uTGFuZXM9LyogICAgICAgICAgICAgICAgICAgICAgICovNDE5NDI0MDt2YXIgVHJhbnNpdGlvbkxhbmUxPS8qICAgICAgICAgICAgICAgICAgICAgICAgKi82NDt2YXIgVHJhbnNpdGlvbkxhbmUyPS8qICAgICAgICAgICAgICAgICAgICAgICAgKi8xMjg7dmFyIFRyYW5zaXRpb25MYW5lMz0vKiAgICAgICAgICAgICAgICAgICAgICAgICovMjU2O3ZhciBUcmFuc2l0aW9uTGFuZTQ9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzUxMjt2YXIgVHJhbnNpdGlvbkxhbmU1PS8qICAgICAgICAgICAgICAgICAgICAgICAgKi8xMDI0O3ZhciBUcmFuc2l0aW9uTGFuZTY9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzIwNDg7dmFyIFRyYW5zaXRpb25MYW5lNz0vKiAgICAgICAgICAgICAgICAgICAgICAgICovNDA5Njt2YXIgVHJhbnNpdGlvbkxhbmU4PS8qICAgICAgICAgICAgICAgICAgICAgICAgKi84MTkyO3ZhciBUcmFuc2l0aW9uTGFuZTk9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzE2Mzg0O3ZhciBUcmFuc2l0aW9uTGFuZTEwPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzMyNzY4O3ZhciBUcmFuc2l0aW9uTGFuZTExPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzY1NTM2O3ZhciBUcmFuc2l0aW9uTGFuZTEyPS8qICAgICAgICAgICAgICAgICAgICAgICAqLzEzMTA3Mjt2YXIgVHJhbnNpdGlvbkxhbmUxMz0vKiAgICAgICAgICAgICAgICAgICAgICAgKi8yNjIxNDQ7dmFyIFRyYW5zaXRpb25MYW5lMTQ9LyogICAgICAgICAgICAgICAgICAgICAgICovNTI0Mjg4O3ZhciBUcmFuc2l0aW9uTGFuZTE1PS8qICAgICAgICAgICAgICAgICAgICAgICAqLzEwNDg1NzY7dmFyIFRyYW5zaXRpb25MYW5lMTY9LyogICAgICAgICAgICAgICAgICAgICAgICovMjA5NzE1Mjt2YXIgUmV0cnlMYW5lcz0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqLzEzMDAyMzQyNDt2YXIgUmV0cnlMYW5lMT0vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi80MTk0MzA0O3ZhciBSZXRyeUxhbmUyPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqLzgzODg2MDg7dmFyIFJldHJ5TGFuZTM9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovMTY3NzcyMTY7dmFyIFJldHJ5TGFuZTQ9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovMzM1NTQ0MzI7dmFyIFJldHJ5TGFuZTU9LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovNjcxMDg4NjQ7dmFyIFNvbWVSZXRyeUxhbmU9UmV0cnlMYW5lMTt2YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZT0vKiAgICAgICAgICAqLzEzNDIxNzcyODt2YXIgTm9uSWRsZUxhbmVzPS8qICAgICAgICAgICAgICAgICAgICAgICAgICAqLzI2ODQzNTQ1NTt2YXIgSWRsZUh5ZHJhdGlvbkxhbmU9LyogICAgICAgICAgICAgICAqLzI2ODQzNTQ1Njt2YXIgSWRsZUxhbmU9LyogICAgICAgICAgICAgICAgICAgICAgICAqLzUzNjg3MDkxMjt2YXIgT2Zmc2NyZWVuTGFuZT0vKiAgICAgICAgICAgICAgICAgICAqLzEwNzM3NDE4MjQ7Ly8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciB0aGUgZXhwZXJpbWVudGFsIHRpbWVsaW5lIChyZWFjdC1kZXZ0b29scy10aW1lbGluZSlcbi8vIEl0IHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgTGFuZXMgdmFsdWVzIGFib3ZlLlxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpe3tpZihsYW5lJlN5bmNMYW5lKXtyZXR1cm4nU3luYyc7fWlmKGxhbmUmSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSl7cmV0dXJuJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7fWlmKGxhbmUmSW5wdXRDb250aW51b3VzTGFuZSl7cmV0dXJuJ0lucHV0Q29udGludW91cyc7fWlmKGxhbmUmRGVmYXVsdEh5ZHJhdGlvbkxhbmUpe3JldHVybidEZWZhdWx0SHlkcmF0aW9uJzt9aWYobGFuZSZEZWZhdWx0TGFuZSl7cmV0dXJuJ0RlZmF1bHQnO31pZihsYW5lJlRyYW5zaXRpb25IeWRyYXRpb25MYW5lKXtyZXR1cm4nVHJhbnNpdGlvbkh5ZHJhdGlvbic7fWlmKGxhbmUmVHJhbnNpdGlvbkxhbmVzKXtyZXR1cm4nVHJhbnNpdGlvbic7fWlmKGxhbmUmUmV0cnlMYW5lcyl7cmV0dXJuJ1JldHJ5Jzt9aWYobGFuZSZTZWxlY3RpdmVIeWRyYXRpb25MYW5lKXtyZXR1cm4nU2VsZWN0aXZlSHlkcmF0aW9uJzt9aWYobGFuZSZJZGxlSHlkcmF0aW9uTGFuZSl7cmV0dXJuJ0lkbGVIeWRyYXRpb24nO31pZihsYW5lJklkbGVMYW5lKXtyZXR1cm4nSWRsZSc7fWlmKGxhbmUmT2Zmc2NyZWVuTGFuZSl7cmV0dXJuJ09mZnNjcmVlbic7fX19dmFyIE5vVGltZXN0YW1wPS0xO3ZhciBuZXh0VHJhbnNpdGlvbkxhbmU9VHJhbnNpdGlvbkxhbmUxO3ZhciBuZXh0UmV0cnlMYW5lPVJldHJ5TGFuZTE7ZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpe3N3aXRjaChnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSl7Y2FzZSBTeW5jTGFuZTpyZXR1cm4gU3luY0xhbmU7Y2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOnJldHVybiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO2Nhc2UgSW5wdXRDb250aW51b3VzTGFuZTpyZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOnJldHVybiBEZWZhdWx0SHlkcmF0aW9uTGFuZTtjYXNlIERlZmF1bHRMYW5lOnJldHVybiBEZWZhdWx0TGFuZTtjYXNlIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lOnJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtjYXNlIFRyYW5zaXRpb25MYW5lMTpjYXNlIFRyYW5zaXRpb25MYW5lMjpjYXNlIFRyYW5zaXRpb25MYW5lMzpjYXNlIFRyYW5zaXRpb25MYW5lNDpjYXNlIFRyYW5zaXRpb25MYW5lNTpjYXNlIFRyYW5zaXRpb25MYW5lNjpjYXNlIFRyYW5zaXRpb25MYW5lNzpjYXNlIFRyYW5zaXRpb25MYW5lODpjYXNlIFRyYW5zaXRpb25MYW5lOTpjYXNlIFRyYW5zaXRpb25MYW5lMTA6Y2FzZSBUcmFuc2l0aW9uTGFuZTExOmNhc2UgVHJhbnNpdGlvbkxhbmUxMjpjYXNlIFRyYW5zaXRpb25MYW5lMTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTE0OmNhc2UgVHJhbnNpdGlvbkxhbmUxNTpjYXNlIFRyYW5zaXRpb25MYW5lMTY6cmV0dXJuIGxhbmVzJlRyYW5zaXRpb25MYW5lcztjYXNlIFJldHJ5TGFuZTE6Y2FzZSBSZXRyeUxhbmUyOmNhc2UgUmV0cnlMYW5lMzpjYXNlIFJldHJ5TGFuZTQ6Y2FzZSBSZXRyeUxhbmU1OnJldHVybiBsYW5lcyZSZXRyeUxhbmVzO2Nhc2UgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTpyZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtjYXNlIElkbGVIeWRyYXRpb25MYW5lOnJldHVybiBJZGxlSHlkcmF0aW9uTGFuZTtjYXNlIElkbGVMYW5lOnJldHVybiBJZGxlTGFuZTtjYXNlIE9mZnNjcmVlbkxhbmU6cmV0dXJuIE9mZnNjcmVlbkxhbmU7ZGVmYXVsdDp7ZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO30vLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxucmV0dXJuIGxhbmVzO319ZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3Qsd2lwTGFuZXMpey8vIEVhcmx5IGJhaWxvdXQgaWYgdGhlcmUncyBubyBwZW5kaW5nIHdvcmsgbGVmdC5cbnZhciBwZW5kaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXM7aWYocGVuZGluZ0xhbmVzPT09Tm9MYW5lcyl7cmV0dXJuIE5vTGFuZXM7fXZhciBuZXh0TGFuZXM9Tm9MYW5lczt2YXIgc3VzcGVuZGVkTGFuZXM9cm9vdC5zdXNwZW5kZWRMYW5lczt2YXIgcGluZ2VkTGFuZXM9cm9vdC5waW5nZWRMYW5lczsvLyBEbyBub3Qgd29yayBvbiBhbnkgaWRsZSB3b3JrIHVudGlsIGFsbCB0aGUgbm9uLWlkbGUgd29yayBoYXMgZmluaXNoZWQsXG4vLyBldmVuIGlmIHRoZSB3b3JrIGlzIHN1c3BlbmRlZC5cbnZhciBub25JZGxlUGVuZGluZ0xhbmVzPXBlbmRpbmdMYW5lcyZOb25JZGxlTGFuZXM7aWYobm9uSWRsZVBlbmRpbmdMYW5lcyE9PU5vTGFuZXMpe3ZhciBub25JZGxlVW5ibG9ja2VkTGFuZXM9bm9uSWRsZVBlbmRpbmdMYW5lcyZ+c3VzcGVuZGVkTGFuZXM7aWYobm9uSWRsZVVuYmxvY2tlZExhbmVzIT09Tm9MYW5lcyl7bmV4dExhbmVzPWdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7fWVsc2V7dmFyIG5vbklkbGVQaW5nZWRMYW5lcz1ub25JZGxlUGVuZGluZ0xhbmVzJnBpbmdlZExhbmVzO2lmKG5vbklkbGVQaW5nZWRMYW5lcyE9PU5vTGFuZXMpe25leHRMYW5lcz1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGluZ2VkTGFuZXMpO319fWVsc2V7Ly8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbnZhciB1bmJsb2NrZWRMYW5lcz1wZW5kaW5nTGFuZXMmfnN1c3BlbmRlZExhbmVzO2lmKHVuYmxvY2tlZExhbmVzIT09Tm9MYW5lcyl7bmV4dExhbmVzPWdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTt9ZWxzZXtpZihwaW5nZWRMYW5lcyE9PU5vTGFuZXMpe25leHRMYW5lcz1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcyk7fX19aWYobmV4dExhbmVzPT09Tm9MYW5lcyl7Ly8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4vLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG5yZXR1cm4gTm9MYW5lczt9Ly8gSWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyLCBzd2l0Y2hpbmcgbGFuZXMgd2lsbCBpbnRlcnJ1cHRcbi8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuLy8gaGlnaGVyIHByaW9yaXR5LlxuaWYod2lwTGFuZXMhPT1Ob0xhbmVzJiZ3aXBMYW5lcyE9PW5leHRMYW5lcyYmLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuLy8gYm90aGVyIHdhaXRpbmcgdW50aWwgdGhlIHJvb3QgaXMgY29tcGxldGUuXG4od2lwTGFuZXMmc3VzcGVuZGVkTGFuZXMpPT09Tm9MYW5lcyl7dmFyIG5leHRMYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTt2YXIgd2lwTGFuZT1nZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtpZigvLyBUZXN0cyB3aGV0aGVyIHRoZSBuZXh0IGxhbmUgaXMgZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHkgdGhhbiB0aGUgd2lwXG4vLyBvbmUuIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0cyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbm5leHRMYW5lPj13aXBMYW5lfHwvLyBEZWZhdWx0IHByaW9yaXR5IHVwZGF0ZXMgc2hvdWxkIG5vdCBpbnRlcnJ1cHQgdHJhbnNpdGlvbiB1cGRhdGVzLiBUaGVcbi8vIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGRlZmF1bHQgdXBkYXRlcyBhbmQgdHJhbnNpdGlvbiB1cGRhdGVzIGlzIHRoYXRcbi8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxubmV4dExhbmU9PT1EZWZhdWx0TGFuZSYmKHdpcExhbmUmVHJhbnNpdGlvbkxhbmVzKSE9PU5vTGFuZXMpey8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbnJldHVybiB3aXBMYW5lczt9fWlmKChuZXh0TGFuZXMmSW5wdXRDb250aW51b3VzTGFuZSkhPT1Ob0xhbmVzKXsvLyBXaGVuIHVwZGF0ZXMgYXJlIHN5bmMgYnkgZGVmYXVsdCwgd2UgZW50YW5nbGUgY29udGludW91cyBwcmlvcml0eSB1cGRhdGVzXG4vLyBhbmQgZGVmYXVsdCB1cGRhdGVzLCBzbyB0aGV5IHJlbmRlciBpbiB0aGUgc2FtZSBiYXRjaC4gVGhlIG9ubHkgcmVhc29uXG4vLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4vLyB0cmFuc2l0aW9ucywgYnV0IGRlZmF1bHQgdXBkYXRlcyBzaG91bGQgbm90LlxubmV4dExhbmVzfD1wZW5kaW5nTGFuZXMmRGVmYXVsdExhbmU7fS8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbi8vXG4vLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbi8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4vLyB3aGVuIG11bHRpcGxlIHVwZGF0ZXMgaGF2ZSB0aGUgc2FtZSBzb3VyY2UsIGFuZCB3ZSBvbmx5IHdhbnQgdG8gcmVzcG9uZCB0b1xuLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4vL1xuLy8gTm90ZSB0aGF0IHdlIGFwcGx5IGVudGFuZ2xlbWVudHMgKmFmdGVyKiBjaGVja2luZyBmb3IgcGFydGlhbCB3b3JrIGFib3ZlLlxuLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4vLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4vLyBlbnRhbmdsZW1lbnQgaXMgdXN1YWxseSBcImJlc3QgZWZmb3J0XCI6IHdlJ2xsIHRyeSBvdXIgYmVzdCB0byByZW5kZXIgdGhlXG4vLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbi8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuLy8gVE9ETzogUmVjb25zaWRlciB0aGlzLiBUaGUgY291bnRlci1hcmd1bWVudCBpcyB0aGF0IHRoZSBwYXJ0aWFsIHdvcmtcbi8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4vLyBBbmQgYnkgc3BlbmRpbmcgZXh0cmEgdGltZSBmaW5pc2hpbmcgaXQsIHdlJ3JlIGluY3JlYXNpbmcgdGhlIGFtb3VudCBvZlxuLy8gdGltZSBpdCB0YWtlcyB0byBzaG93IHRoZSBmaW5hbCBzdGF0ZSwgd2hpY2ggaXMgd2hhdCB0aGV5IGFyZSBhY3R1YWxseVxuLy8gd2FpdGluZyBmb3IuXG4vL1xuLy8gRm9yIHRob3NlIGV4Y2VwdGlvbnMgd2hlcmUgZW50YW5nbGVtZW50IGlzIHNlbWFudGljYWxseSBpbXBvcnRhbnQsIGxpa2Vcbi8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4vLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG52YXIgZW50YW5nbGVkTGFuZXM9cm9vdC5lbnRhbmdsZWRMYW5lcztpZihlbnRhbmdsZWRMYW5lcyE9PU5vTGFuZXMpe3ZhciBlbnRhbmdsZW1lbnRzPXJvb3QuZW50YW5nbGVtZW50czt2YXIgbGFuZXM9bmV4dExhbmVzJmVudGFuZ2xlZExhbmVzO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDtuZXh0TGFuZXN8PWVudGFuZ2xlbWVudHNbaW5kZXhdO2xhbmVzJj1+bGFuZTt9fXJldHVybiBuZXh0TGFuZXM7fWZ1bmN0aW9uIGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCxsYW5lcyl7dmFyIGV2ZW50VGltZXM9cm9vdC5ldmVudFRpbWVzO3ZhciBtb3N0UmVjZW50RXZlbnRUaW1lPU5vVGltZXN0YW1wO3doaWxlKGxhbmVzPjApe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDt2YXIgZXZlbnRUaW1lPWV2ZW50VGltZXNbaW5kZXhdO2lmKGV2ZW50VGltZT5tb3N0UmVjZW50RXZlbnRUaW1lKXttb3N0UmVjZW50RXZlbnRUaW1lPWV2ZW50VGltZTt9bGFuZXMmPX5sYW5lO31yZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTt9ZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsY3VycmVudFRpbWUpe3N3aXRjaChsYW5lKXtjYXNlIFN5bmNMYW5lOmNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTpjYXNlIElucHV0Q29udGludW91c0xhbmU6Ly8gVXNlciBpbnRlcmFjdGlvbnMgc2hvdWxkIGV4cGlyZSBzbGlnaHRseSBtb3JlIHF1aWNrbHkuXG4vL1xuLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLlxuLy8gV2hlbiB3ZSBtYWRlIGl0IGxhcmdlciwgYSBwcm9kdWN0IG1ldHJpYyBpbiB3d3cgcmVncmVzc2VkLCBzdWdnZXN0aW5nXG4vLyB0aGVyZSdzIGEgdXNlciBpbnRlcmFjdGlvbiB0aGF0J3MgYmVpbmcgc3RhcnZlZCBieSBhIHNlcmllcyBvZlxuLy8gc3luY2hyb25vdXMgdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpc1xuLy8gdG8gZml4IHRoZSBzdGFydmF0aW9uLiBIb3dldmVyLCB0aGlzIHNjZW5hcmlvIHN1cHBvcnRzIHRoZSBpZGVhIHRoYXRcbi8vIGV4cGlyYXRpb24gdGltZXMgYXJlIGFuIGltcG9ydGFudCBzYWZlZ3VhcmQgd2hlbiBzdGFydmF0aW9uXG4vLyBkb2VzIGhhcHBlbi5cbnJldHVybiBjdXJyZW50VGltZSsyNTA7Y2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZTpjYXNlIERlZmF1bHRMYW5lOmNhc2UgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU6Y2FzZSBUcmFuc2l0aW9uTGFuZTE6Y2FzZSBUcmFuc2l0aW9uTGFuZTI6Y2FzZSBUcmFuc2l0aW9uTGFuZTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTQ6Y2FzZSBUcmFuc2l0aW9uTGFuZTU6Y2FzZSBUcmFuc2l0aW9uTGFuZTY6Y2FzZSBUcmFuc2l0aW9uTGFuZTc6Y2FzZSBUcmFuc2l0aW9uTGFuZTg6Y2FzZSBUcmFuc2l0aW9uTGFuZTk6Y2FzZSBUcmFuc2l0aW9uTGFuZTEwOmNhc2UgVHJhbnNpdGlvbkxhbmUxMTpjYXNlIFRyYW5zaXRpb25MYW5lMTI6Y2FzZSBUcmFuc2l0aW9uTGFuZTEzOmNhc2UgVHJhbnNpdGlvbkxhbmUxNDpjYXNlIFRyYW5zaXRpb25MYW5lMTU6Y2FzZSBUcmFuc2l0aW9uTGFuZTE2OnJldHVybiBjdXJyZW50VGltZSs1MDAwO2Nhc2UgUmV0cnlMYW5lMTpjYXNlIFJldHJ5TGFuZTI6Y2FzZSBSZXRyeUxhbmUzOmNhc2UgUmV0cnlMYW5lNDpjYXNlIFJldHJ5TGFuZTU6Ly8gVE9ETzogUmV0cmllcyBzaG91bGQgYmUgYWxsb3dlZCB0byBleHBpcmUgaWYgdGhleSBhcmUgQ1BVIGJvdW5kIGZvclxuLy8gdG9vIGxvbmcsIGJ1dCB3aGVuIEkgbWFkZSB0aGlzIGNoYW5nZSBpdCBjYXVzZWQgYSBzcGlrZSBpbiBicm93c2VyXG4vLyBjcmFzaGVzLiBUaGVyZSBtdXN0IGJlIHNvbWUgb3RoZXIgdW5kZXJseWluZyBidWc7IG5vdCBzdXBlciB1cmdlbnQgYnV0XG4vLyBpZGVhbGx5IHNob3VsZCBmaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBVbmZvcnR1bmF0ZWx5IHdlIGRvbid0IGhhdmVcbi8vIGEgcmVwcm8gZm9yIHRoZSBjcmFzaGVzLCBvbmx5IGRldGVjdGVkIHZpYSBwcm9kdWN0aW9uIG1ldHJpY3MuXG5yZXR1cm4gTm9UaW1lc3RhbXA7Y2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOmNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6Y2FzZSBJZGxlTGFuZTpjYXNlIE9mZnNjcmVlbkxhbmU6Ly8gQW55dGhpbmcgaWRsZSBwcmlvcml0eSBvciBsb3dlciBzaG91bGQgbmV2ZXIgZXhwaXJlLlxucmV0dXJuIE5vVGltZXN0YW1wO2RlZmF1bHQ6e2Vycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTt9cmV0dXJuIE5vVGltZXN0YW1wO319ZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LGN1cnJlbnRUaW1lKXsvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4vLyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lIG9uIHRoZSByb290LiBUaGVuIHVzZSB0aGF0IHRvIHF1aWNrbHkgYmFpbCBvdXRcbi8vIG9mIHRoaXMgZnVuY3Rpb24uXG52YXIgcGVuZGluZ0xhbmVzPXJvb3QucGVuZGluZ0xhbmVzO3ZhciBzdXNwZW5kZWRMYW5lcz1yb290LnN1c3BlbmRlZExhbmVzO3ZhciBwaW5nZWRMYW5lcz1yb290LnBpbmdlZExhbmVzO3ZhciBleHBpcmF0aW9uVGltZXM9cm9vdC5leHBpcmF0aW9uVGltZXM7Ly8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4vLyBleHBpcmF0aW9uIHRpbWUuIElmIHNvLCB3ZSdsbCBhc3N1bWUgdGhlIHVwZGF0ZSBpcyBiZWluZyBzdGFydmVkIGFuZCBtYXJrXG4vLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cbnZhciBsYW5lcz1wZW5kaW5nTGFuZXM7d2hpbGUobGFuZXM+MCl7dmFyIGluZGV4PXBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciBleHBpcmF0aW9uVGltZT1leHBpcmF0aW9uVGltZXNbaW5kZXhdO2lmKGV4cGlyYXRpb25UaW1lPT09Tm9UaW1lc3RhbXApey8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4vLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbmlmKChsYW5lJnN1c3BlbmRlZExhbmVzKT09PU5vTGFuZXN8fChsYW5lJnBpbmdlZExhbmVzKSE9PU5vTGFuZXMpey8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuZXhwaXJhdGlvblRpbWVzW2luZGV4XT1jb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSxjdXJyZW50VGltZSk7fX1lbHNlIGlmKGV4cGlyYXRpb25UaW1lPD1jdXJyZW50VGltZSl7Ly8gVGhpcyBsYW5lIGV4cGlyZWRcbnJvb3QuZXhwaXJlZExhbmVzfD1sYW5lO31sYW5lcyY9fmxhbmU7fX0vLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyhyb290KXtyZXR1cm4gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocm9vdC5wZW5kaW5nTGFuZXMpO31mdW5jdGlvbiBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KXt2YXIgZXZlcnl0aGluZ0J1dE9mZnNjcmVlbj1yb290LnBlbmRpbmdMYW5lcyZ+T2Zmc2NyZWVuTGFuZTtpZihldmVyeXRoaW5nQnV0T2Zmc2NyZWVuIT09Tm9MYW5lcyl7cmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47fWlmKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4mT2Zmc2NyZWVuTGFuZSl7cmV0dXJuIE9mZnNjcmVlbkxhbmU7fXJldHVybiBOb0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc1N5bmNMYW5lKGxhbmVzKXtyZXR1cm4obGFuZXMmU3luY0xhbmUpIT09Tm9MYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcyl7cmV0dXJuKGxhbmVzJk5vbklkbGVMYW5lcykhPT1Ob0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKXtyZXR1cm4obGFuZXMmUmV0cnlMYW5lcyk9PT1sYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMobGFuZXMpe3ZhciBVcmdlbnRMYW5lcz1TeW5jTGFuZXxJbnB1dENvbnRpbnVvdXNMYW5lfERlZmF1bHRMYW5lO3JldHVybihsYW5lcyZVcmdlbnRMYW5lcyk9PT1Ob0xhbmVzO31mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcyl7cmV0dXJuKGxhbmVzJlRyYW5zaXRpb25MYW5lcyk9PT1sYW5lczt9ZnVuY3Rpb24gaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCxsYW5lcyl7dmFyIFN5bmNEZWZhdWx0TGFuZXM9SW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZXxJbnB1dENvbnRpbnVvdXNMYW5lfERlZmF1bHRIeWRyYXRpb25MYW5lfERlZmF1bHRMYW5lO3JldHVybihsYW5lcyZTeW5jRGVmYXVsdExhbmVzKSE9PU5vTGFuZXM7fWZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCxsYW5lcyl7Ly8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4vLyBleHBpcmUgYWZ0ZXIgYSByZW5kZXIgaGFzIGFscmVhZHkgc3RhcnRlZC5cbnJldHVybihsYW5lcyZyb290LmV4cGlyZWRMYW5lcykhPT1Ob0xhbmVzO31mdW5jdGlvbiBpc1RyYW5zaXRpb25MYW5lKGxhbmUpe3JldHVybihsYW5lJlRyYW5zaXRpb25MYW5lcykhPT1Ob0xhbmVzO31mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpey8vIEN5Y2xlIHRocm91Z2ggdGhlIGxhbmVzLCBhc3NpZ25pbmcgZWFjaCBuZXcgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBsYW5lLlxuLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBtZWFucyBldmVyeSB0cmFuc2l0aW9uIGdldHMgaXRzIG93biBsYW5lLCB1bnRpbCB3ZVxuLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxudmFyIGxhbmU9bmV4dFRyYW5zaXRpb25MYW5lO25leHRUcmFuc2l0aW9uTGFuZTw8PTE7aWYoKG5leHRUcmFuc2l0aW9uTGFuZSZUcmFuc2l0aW9uTGFuZXMpPT09Tm9MYW5lcyl7bmV4dFRyYW5zaXRpb25MYW5lPVRyYW5zaXRpb25MYW5lMTt9cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGNsYWltTmV4dFJldHJ5TGFuZSgpe3ZhciBsYW5lPW5leHRSZXRyeUxhbmU7bmV4dFJldHJ5TGFuZTw8PTE7aWYoKG5leHRSZXRyeUxhbmUmUmV0cnlMYW5lcyk9PT1Ob0xhbmVzKXtuZXh0UmV0cnlMYW5lPVJldHJ5TGFuZTE7fXJldHVybiBsYW5lO31mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKXtyZXR1cm4gbGFuZXMmLWxhbmVzO31mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcyl7Ly8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGdldHMgaW5saW5lZC4gT25seSBleGlzdHMgc28gdG8gY29tbXVuaWNhdGUgdGhhdCBpdFxuLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4vLyBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIGJlY2F1c2UgaXQgcmVxdWlyZXMgdGhlIGZld2VzdCBvcGVyYXRpb25zLlxucmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO31mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKXtyZXR1cm4gMzEtY2x6MzIobGFuZXMpO31mdW5jdGlvbiBsYW5lVG9JbmRleChsYW5lKXtyZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTt9ZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLGIpe3JldHVybihhJmIpIT09Tm9MYW5lczt9ZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCxzdWJzZXQpe3JldHVybihzZXQmc3Vic2V0KT09PXN1YnNldDt9ZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLGIpe3JldHVybiBhfGI7fWZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCxzdWJzZXQpe3JldHVybiBzZXQmfnN1YnNldDt9ZnVuY3Rpb24gaW50ZXJzZWN0TGFuZXMoYSxiKXtyZXR1cm4gYSZiO30vLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSl7cmV0dXJuIGxhbmU7fWZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLGIpey8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbnJldHVybiBhIT09Tm9MYW5lJiZhPGI/YTpiO31mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpey8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuLy8gaHR0cHM6Ly92OC5kZXYvYmxvZy9lbGVtZW50cy1raW5kcyNhdm9pZC1jcmVhdGluZy1ob2xlc1xudmFyIGxhbmVNYXA9W107Zm9yKHZhciBpPTA7aTxUb3RhbExhbmVzO2krKyl7bGFuZU1hcC5wdXNoKGluaXRpYWwpO31yZXR1cm4gbGFuZU1hcDt9ZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsdXBkYXRlTGFuZSxldmVudFRpbWUpe3Jvb3QucGVuZGluZ0xhbmVzfD11cGRhdGVMYW5lOy8vIElmIHRoZXJlIGFyZSBhbnkgc3VzcGVuZGVkIHRyYW5zaXRpb25zLCBpdCdzIHBvc3NpYmxlIHRoaXMgbmV3IHVwZGF0ZVxuLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbi8vIHRoZW0gYWdhaW4uXG4vL1xuLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbi8vIGBzdWJ0cmVlTGFuZXNgIG9mIHRoZSB1cGRhdGVkIGZpYmVyLCBvciB0aGUgdXBkYXRlIGxhbmVzIG9mIHRoZSByZXR1cm5cbi8vIHBhdGguIFRoaXMgd291bGQgZXhjbHVkZSBzdXNwZW5kZWQgdXBkYXRlcyBpbiBhbiB1bnJlbGF0ZWQgc2libGluZyB0cmVlLFxuLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4vL1xuLy8gV2UgZG9uJ3QgZG8gdGhpcyBpZiB0aGUgaW5jb21pbmcgdXBkYXRlIGlzIGlkbGUsIGJlY2F1c2Ugd2UgbmV2ZXIgcHJvY2Vzc1xuLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbi8vIHdheSBpdCBjb3VsZCB1bmJsb2NrIGEgdHJhbnNpdGlvbi5cbmlmKHVwZGF0ZUxhbmUhPT1JZGxlTGFuZSl7cm9vdC5zdXNwZW5kZWRMYW5lcz1Ob0xhbmVzO3Jvb3QucGluZ2VkTGFuZXM9Tm9MYW5lczt9dmFyIGV2ZW50VGltZXM9cm9vdC5ldmVudFRpbWVzO3ZhciBpbmRleD1sYW5lVG9JbmRleCh1cGRhdGVMYW5lKTsvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3Rcbi8vIHJlY2VudCBldmVudCwgYW5kIHdlIGFzc3VtZSB0aW1lIGlzIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbmV2ZW50VGltZXNbaW5kZXhdPWV2ZW50VGltZTt9ZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCxzdXNwZW5kZWRMYW5lcyl7cm9vdC5zdXNwZW5kZWRMYW5lc3w9c3VzcGVuZGVkTGFuZXM7cm9vdC5waW5nZWRMYW5lcyY9fnN1c3BlbmRlZExhbmVzOy8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG52YXIgZXhwaXJhdGlvblRpbWVzPXJvb3QuZXhwaXJhdGlvblRpbWVzO3ZhciBsYW5lcz1zdXNwZW5kZWRMYW5lczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9cGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7ZXhwaXJhdGlvblRpbWVzW2luZGV4XT1Ob1RpbWVzdGFtcDtsYW5lcyY9fmxhbmU7fX1mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LHBpbmdlZExhbmVzLGV2ZW50VGltZSl7cm9vdC5waW5nZWRMYW5lc3w9cm9vdC5zdXNwZW5kZWRMYW5lcyZwaW5nZWRMYW5lczt9ZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChyb290LHJlbWFpbmluZ0xhbmVzKXt2YXIgbm9Mb25nZXJQZW5kaW5nTGFuZXM9cm9vdC5wZW5kaW5nTGFuZXMmfnJlbWFpbmluZ0xhbmVzO3Jvb3QucGVuZGluZ0xhbmVzPXJlbWFpbmluZ0xhbmVzOy8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5yb290LnN1c3BlbmRlZExhbmVzPU5vTGFuZXM7cm9vdC5waW5nZWRMYW5lcz1Ob0xhbmVzO3Jvb3QuZXhwaXJlZExhbmVzJj1yZW1haW5pbmdMYW5lcztyb290Lm11dGFibGVSZWFkTGFuZXMmPXJlbWFpbmluZ0xhbmVzO3Jvb3QuZW50YW5nbGVkTGFuZXMmPXJlbWFpbmluZ0xhbmVzO3ZhciBlbnRhbmdsZW1lbnRzPXJvb3QuZW50YW5nbGVtZW50czt2YXIgZXZlbnRUaW1lcz1yb290LmV2ZW50VGltZXM7dmFyIGV4cGlyYXRpb25UaW1lcz1yb290LmV4cGlyYXRpb25UaW1lczsvLyBDbGVhciB0aGUgbGFuZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBwZW5kaW5nIHdvcmtcbnZhciBsYW5lcz1ub0xvbmdlclBlbmRpbmdMYW5lczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9cGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7dmFyIGxhbmU9MTw8aW5kZXg7ZW50YW5nbGVtZW50c1tpbmRleF09Tm9MYW5lcztldmVudFRpbWVzW2luZGV4XT1Ob1RpbWVzdGFtcDtleHBpcmF0aW9uVGltZXNbaW5kZXhdPU5vVGltZXN0YW1wO2xhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsZW50YW5nbGVkTGFuZXMpey8vIEluIGFkZGl0aW9uIHRvIGVudGFuZ2xpbmcgZWFjaCBvZiB0aGUgZ2l2ZW4gbGFuZXMgd2l0aCBlYWNoIG90aGVyLCB3ZSBhbHNvXG4vLyBoYXZlIHRvIGNvbnNpZGVyIF90cmFuc2l0aXZlXyBlbnRhbmdsZW1lbnRzLiBGb3IgZWFjaCBsYW5lIHRoYXQgaXMgYWxyZWFkeVxuLy8gZW50YW5nbGVkIHdpdGggKmFueSogb2YgdGhlIGdpdmVuIGxhbmVzLCB0aGF0IGxhbmUgaXMgbm93IHRyYW5zaXRpdmVseVxuLy8gZW50YW5nbGVkIHdpdGggKmFsbCogdGhlIGdpdmVuIGxhbmVzLlxuLy9cbi8vIFRyYW5zbGF0ZWQ6IElmIEMgaXMgZW50YW5nbGVkIHdpdGggQSwgdGhlbiBlbnRhbmdsaW5nIEEgd2l0aCBCIGFsc29cbi8vIGVudGFuZ2xlcyBDIHdpdGggQi5cbi8vXG4vLyBJZiB0aGlzIGlzIGhhcmQgdG8gZ3Jhc3AsIGl0IG1pZ2h0IGhlbHAgdG8gaW50ZW50aW9uYWxseSBicmVhayB0aGlzXG4vLyBmdW5jdGlvbiBhbmQgbG9vayBhdCB0aGUgdGVzdHMgdGhhdCBmYWlsIGluIFJlYWN0VHJhbnNpdGlvbi10ZXN0LmpzLiBUcnlcbi8vIGNvbW1lbnRpbmcgb3V0IG9uZSBvZiB0aGUgY29uZGl0aW9ucyBiZWxvdy5cbnZhciByb290RW50YW5nbGVkTGFuZXM9cm9vdC5lbnRhbmdsZWRMYW5lc3w9ZW50YW5nbGVkTGFuZXM7dmFyIGVudGFuZ2xlbWVudHM9cm9vdC5lbnRhbmdsZW1lbnRzO3ZhciBsYW5lcz1yb290RW50YW5nbGVkTGFuZXM7d2hpbGUobGFuZXMpe3ZhciBpbmRleD1waWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTt2YXIgbGFuZT0xPDxpbmRleDtpZigvLyBJcyB0aGlzIG9uZSBvZiB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xubGFuZSZlbnRhbmdsZWRMYW5lc3wvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG5lbnRhbmdsZW1lbnRzW2luZGV4XSZlbnRhbmdsZWRMYW5lcyl7ZW50YW5nbGVtZW50c1tpbmRleF18PWVudGFuZ2xlZExhbmVzO31sYW5lcyY9fmxhbmU7fX1mdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QscmVuZGVyTGFuZXMpe3ZhciByZW5kZXJMYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUocmVuZGVyTGFuZXMpO3ZhciBsYW5lO3N3aXRjaChyZW5kZXJMYW5lKXtjYXNlIElucHV0Q29udGludW91c0xhbmU6bGFuZT1JbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO2JyZWFrO2Nhc2UgRGVmYXVsdExhbmU6bGFuZT1EZWZhdWx0SHlkcmF0aW9uTGFuZTticmVhaztjYXNlIFRyYW5zaXRpb25MYW5lMTpjYXNlIFRyYW5zaXRpb25MYW5lMjpjYXNlIFRyYW5zaXRpb25MYW5lMzpjYXNlIFRyYW5zaXRpb25MYW5lNDpjYXNlIFRyYW5zaXRpb25MYW5lNTpjYXNlIFRyYW5zaXRpb25MYW5lNjpjYXNlIFRyYW5zaXRpb25MYW5lNzpjYXNlIFRyYW5zaXRpb25MYW5lODpjYXNlIFRyYW5zaXRpb25MYW5lOTpjYXNlIFRyYW5zaXRpb25MYW5lMTA6Y2FzZSBUcmFuc2l0aW9uTGFuZTExOmNhc2UgVHJhbnNpdGlvbkxhbmUxMjpjYXNlIFRyYW5zaXRpb25MYW5lMTM6Y2FzZSBUcmFuc2l0aW9uTGFuZTE0OmNhc2UgVHJhbnNpdGlvbkxhbmUxNTpjYXNlIFRyYW5zaXRpb25MYW5lMTY6Y2FzZSBSZXRyeUxhbmUxOmNhc2UgUmV0cnlMYW5lMjpjYXNlIFJldHJ5TGFuZTM6Y2FzZSBSZXRyeUxhbmU0OmNhc2UgUmV0cnlMYW5lNTpsYW5lPVRyYW5zaXRpb25IeWRyYXRpb25MYW5lO2JyZWFrO2Nhc2UgSWRsZUxhbmU6bGFuZT1JZGxlSHlkcmF0aW9uTGFuZTticmVhaztkZWZhdWx0Oi8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3Rcbi8vIGJlIHJldHJpZWQgYXQgYSBoeWRyYXRpb24gbGFuZS5cbmxhbmU9Tm9MYW5lO2JyZWFrO30vLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4vLyBhbHJlYWR5IGF0dGVtcHRlZCBhbmQgZmFpbGVkIHRvIGh5ZHJhdGUgYXQgdGhhdCBsZXZlbC4gQWxzbyBjaGVjayBpZiB3ZSdyZVxuLy8gYWxyZWFkeSByZW5kZXJpbmcgdGhhdCBsYW5lLCB3aGljaCBpcyByYXJlIGJ1dCBjb3VsZCBoYXBwZW4uXG5pZigobGFuZSYocm9vdC5zdXNwZW5kZWRMYW5lc3xyZW5kZXJMYW5lcykpIT09Tm9MYW5lKXsvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbnJldHVybiBOb0xhbmU7fXJldHVybiBsYW5lO31mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCxmaWJlcixsYW5lcyl7aWYoIWlzRGV2VG9vbHNQcmVzZW50KXtyZXR1cm47fXZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwPXJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9bGFuZVRvSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciB1cGRhdGVycz1wZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTt1cGRhdGVycy5hZGQoZmliZXIpO2xhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LGxhbmVzKXtpZighaXNEZXZUb29sc1ByZXNlbnQpe3JldHVybjt9dmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXA9cm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO3ZhciBtZW1vaXplZFVwZGF0ZXJzPXJvb3QubWVtb2l6ZWRVcGRhdGVyczt3aGlsZShsYW5lcz4wKXt2YXIgaW5kZXg9bGFuZVRvSW5kZXgobGFuZXMpO3ZhciBsYW5lPTE8PGluZGV4O3ZhciB1cGRhdGVycz1wZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtpZih1cGRhdGVycy5zaXplPjApe3VwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZT09PW51bGx8fCFtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKXttZW1vaXplZFVwZGF0ZXJzLmFkZChmaWJlcik7fX0pO3VwZGF0ZXJzLmNsZWFyKCk7fWxhbmVzJj1+bGFuZTt9fWZ1bmN0aW9uIGdldFRyYW5zaXRpb25zRm9yTGFuZXMocm9vdCxsYW5lcyl7e3JldHVybiBudWxsO319dmFyIERpc2NyZXRlRXZlbnRQcmlvcml0eT1TeW5jTGFuZTt2YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHk9SW5wdXRDb250aW51b3VzTGFuZTt2YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHk9RGVmYXVsdExhbmU7dmFyIElkbGVFdmVudFByaW9yaXR5PUlkbGVMYW5lO3ZhciBjdXJyZW50VXBkYXRlUHJpb3JpdHk9Tm9MYW5lO2Z1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpe3JldHVybiBjdXJyZW50VXBkYXRlUHJpb3JpdHk7fWZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSl7Y3VycmVudFVwZGF0ZVByaW9yaXR5PW5ld1ByaW9yaXR5O31mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkocHJpb3JpdHksZm4pe3ZhciBwcmV2aW91c1ByaW9yaXR5PWN1cnJlbnRVcGRhdGVQcmlvcml0eTt0cnl7Y3VycmVudFVwZGF0ZVByaW9yaXR5PXByaW9yaXR5O3JldHVybiBmbigpO31maW5hbGx5e2N1cnJlbnRVcGRhdGVQcmlvcml0eT1wcmV2aW91c1ByaW9yaXR5O319ZnVuY3Rpb24gaGlnaGVyRXZlbnRQcmlvcml0eShhLGIpe3JldHVybiBhIT09MCYmYTxiP2E6Yjt9ZnVuY3Rpb24gbG93ZXJFdmVudFByaW9yaXR5KGEsYil7cmV0dXJuIGE9PT0wfHxhPmI/YTpiO31mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSxiKXtyZXR1cm4gYSE9PTAmJmE8Yjt9ZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpe3ZhciBsYW5lPWdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO2lmKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LGxhbmUpKXtyZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O31pZighaXNIaWdoZXJFdmVudFByaW9yaXR5KENvbnRpbnVvdXNFdmVudFByaW9yaXR5LGxhbmUpKXtyZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7fWlmKGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZSkpe3JldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTt9cmV0dXJuIElkbGVFdmVudFByaW9yaXR5O30vLyBUaGlzIGlzIGltcG9ydGVkIGJ5IHRoZSBldmVudCByZXBsYXlpbmcgaW1wbGVtZW50YXRpb24gaW4gUmVhY3QgRE9NLiBJdCdzXG4vLyBpbiBhIHNlcGFyYXRlIGZpbGUgdG8gYnJlYWsgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIHJlbmRlcmVyIGFuZFxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBpc1Jvb3REZWh5ZHJhdGVkKHJvb3Qpe3ZhciBjdXJyZW50U3RhdGU9cm9vdC5jdXJyZW50Lm1lbW9pemVkU3RhdGU7cmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7fXZhciBfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO2Z1bmN0aW9uIHNldEF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbihmbil7X2F0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbj1mbjt9ZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKXtfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKTt9dmFyIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO2Z1bmN0aW9uIHNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZuKXthdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbj1mbjt9dmFyIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eTtmdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZm4pe2F0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eT1mbjt9dmFyIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSQxO2Z1bmN0aW9uIHNldEdldEN1cnJlbnRVcGRhdGVQcmlvcml0eShmbil7Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDE9Zm47fXZhciBhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eTtmdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShmbil7YXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHk9Zm47fS8vIFRPRE86IFVwZ3JhZGUgdGhpcyBkZWZpbml0aW9uIG9uY2Ugd2UncmUgb24gYSBuZXdlciB2ZXJzaW9uIG9mIEZsb3cgdGhhdFxuLy8gaGFzIHRoaXMgZGVmaW5pdGlvbiBidWlsdC1pbi5cbnZhciBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0PWZhbHNlOy8vIFRoZSBxdWV1ZSBvZiBkaXNjcmV0ZSBldmVudHMgdG8gYmUgcmVwbGF5ZWQuXG52YXIgcXVldWVkRGlzY3JldGVFdmVudHM9W107Ly8gSW5kaWNhdGVzIGlmIGFueSBjb250aW51b3VzIGV2ZW50IHRhcmdldHMgYXJlIG5vbi1udWxsIGZvciBlYXJseSBiYWlsb3V0LlxuLy8gaWYgdGhlIGxhc3QgdGFyZ2V0IHdhcyBkZWh5ZHJhdGVkLlxudmFyIHF1ZXVlZEZvY3VzPW51bGw7dmFyIHF1ZXVlZERyYWc9bnVsbDt2YXIgcXVldWVkTW91c2U9bnVsbDsvLyBGb3IgcG9pbnRlciBldmVudHMgdGhlcmUgY2FuIGJlIG9uZSBsYXRlc3QgZXZlbnQgcGVyIHBvaW50ZXJJZC5cbnZhciBxdWV1ZWRQb2ludGVycz1uZXcgTWFwKCk7dmFyIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcz1uZXcgTWFwKCk7Ly8gV2UgY291bGQgY29uc2lkZXIgcmVwbGF5aW5nIHNlbGVjdGlvbmNoYW5nZSBhbmQgdG91Y2htb3ZlcyB0b28uXG52YXIgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzPVtdO3ZhciBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHM9Wydtb3VzZWRvd24nLCdtb3VzZXVwJywndG91Y2hjYW5jZWwnLCd0b3VjaGVuZCcsJ3RvdWNoc3RhcnQnLCdhdXhjbGljaycsJ2RibGNsaWNrJywncG9pbnRlcmNhbmNlbCcsJ3BvaW50ZXJkb3duJywncG9pbnRlcnVwJywnZHJhZ2VuZCcsJ2RyYWdzdGFydCcsJ2Ryb3AnLCdjb21wb3NpdGlvbmVuZCcsJ2NvbXBvc2l0aW9uc3RhcnQnLCdrZXlkb3duJywna2V5cHJlc3MnLCdrZXl1cCcsJ2lucHV0JywndGV4dElucHV0JywvLyBJbnRlbnRpb25hbGx5IGNhbWVsQ2FzZVxuJ2NvcHknLCdjdXQnLCdwYXN0ZScsJ2NsaWNrJywnY2hhbmdlJywnY29udGV4dG1lbnUnLCdyZXNldCcsJ3N1Ym1pdCddO2Z1bmN0aW9uIGlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbihldmVudFR5cGUpe3JldHVybiBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHMuaW5kZXhPZihldmVudFR5cGUpPi0xO31mdW5jdGlvbiBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7cmV0dXJue2Jsb2NrZWRPbjpibG9ja2VkT24sZG9tRXZlbnROYW1lOmRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzOmV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQ6bmF0aXZlRXZlbnQsdGFyZ2V0Q29udGFpbmVyczpbdGFyZ2V0Q29udGFpbmVyXX07fWZ1bmN0aW9uIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2ZvY3VzaW4nOmNhc2UnZm9jdXNvdXQnOnF1ZXVlZEZvY3VzPW51bGw7YnJlYWs7Y2FzZSdkcmFnZW50ZXInOmNhc2UnZHJhZ2xlYXZlJzpxdWV1ZWREcmFnPW51bGw7YnJlYWs7Y2FzZSdtb3VzZW92ZXInOmNhc2UnbW91c2VvdXQnOnF1ZXVlZE1vdXNlPW51bGw7YnJlYWs7Y2FzZSdwb2ludGVyb3Zlcic6Y2FzZSdwb2ludGVyb3V0Jzp7dmFyIHBvaW50ZXJJZD1uYXRpdmVFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7YnJlYWs7fWNhc2UnZ290cG9pbnRlcmNhcHR1cmUnOmNhc2UnbG9zdHBvaW50ZXJjYXB0dXJlJzp7dmFyIF9wb2ludGVySWQ9bmF0aXZlRXZlbnQucG9pbnRlcklkO3F1ZXVlZFBvaW50ZXJDYXB0dXJlcy5kZWxldGUoX3BvaW50ZXJJZCk7YnJlYWs7fX19ZnVuY3Rpb24gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChleGlzdGluZ1F1ZXVlZEV2ZW50LGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbmF0aXZlRXZlbnQpe2lmKGV4aXN0aW5nUXVldWVkRXZlbnQ9PT1udWxsfHxleGlzdGluZ1F1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50IT09bmF0aXZlRXZlbnQpe3ZhciBxdWV1ZWRFdmVudD1jcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7aWYoYmxvY2tlZE9uIT09bnVsbCl7dmFyIF9maWJlcjI9Z2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO2lmKF9maWJlcjIhPT1udWxsKXsvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKF9maWJlcjIpO319cmV0dXJuIHF1ZXVlZEV2ZW50O30vLyBJZiB3ZSBoYXZlIGFscmVhZHkgcXVldWVkIHRoaXMgZXhhY3QgZXZlbnQsIHRoZW4gaXQncyBiZWNhdXNlXG4vLyB0aGUgZGlmZmVyZW50IGV2ZW50IHN5c3RlbXMgaGF2ZSBkaWZmZXJlbnQgRE9NIGV2ZW50IGxpc3RlbmVycy5cbi8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbi8vIHN0b3JlIGEgc2luZ2xlIGV2ZW50IHRvIGJlIHJlcGxheWVkLlxuZXhpc3RpbmdRdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzfD1ldmVudFN5c3RlbUZsYWdzO3ZhciB0YXJnZXRDb250YWluZXJzPWV4aXN0aW5nUXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztpZih0YXJnZXRDb250YWluZXIhPT1udWxsJiZ0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKT09PS0xKXt0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTt9cmV0dXJuIGV4aXN0aW5nUXVldWVkRXZlbnQ7fWZ1bmN0aW9uIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoYmxvY2tlZE9uLGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7Ly8gVGhlc2Ugc2V0IHJlbGF0ZWRUYXJnZXQgdG8gbnVsbCBiZWNhdXNlIHRoZSByZXBsYXllZCBldmVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgd2Vcbi8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuLy8gSW5zdGVhZCBvZiBtdXRhdGluZyB3ZSBjb3VsZCBjbG9uZSB0aGUgZXZlbnQuXG5zd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2ZvY3VzaW4nOnt2YXIgZm9jdXNFdmVudD1uYXRpdmVFdmVudDtxdWV1ZWRGb2N1cz1hY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsZm9jdXNFdmVudCk7cmV0dXJuIHRydWU7fWNhc2UnZHJhZ2VudGVyJzp7dmFyIGRyYWdFdmVudD1uYXRpdmVFdmVudDtxdWV1ZWREcmFnPWFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRHJhZyxibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLGRyYWdFdmVudCk7cmV0dXJuIHRydWU7fWNhc2UnbW91c2VvdmVyJzp7dmFyIG1vdXNlRXZlbnQ9bmF0aXZlRXZlbnQ7cXVldWVkTW91c2U9YWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRNb3VzZSxibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG1vdXNlRXZlbnQpO3JldHVybiB0cnVlO31jYXNlJ3BvaW50ZXJvdmVyJzp7dmFyIHBvaW50ZXJFdmVudD1uYXRpdmVFdmVudDt2YXIgcG9pbnRlcklkPXBvaW50ZXJFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlcnMuc2V0KHBvaW50ZXJJZCxhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZFBvaW50ZXJzLmdldChwb2ludGVySWQpfHxudWxsLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIscG9pbnRlckV2ZW50KSk7cmV0dXJuIHRydWU7fWNhc2UnZ290cG9pbnRlcmNhcHR1cmUnOnt2YXIgX3BvaW50ZXJFdmVudD1uYXRpdmVFdmVudDt2YXIgX3BvaW50ZXJJZDI9X3BvaW50ZXJFdmVudC5wb2ludGVySWQ7cXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMixhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5nZXQoX3BvaW50ZXJJZDIpfHxudWxsLGJsb2NrZWRPbixkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsX3BvaW50ZXJFdmVudCkpO3JldHVybiB0cnVlO319cmV0dXJuIGZhbHNlO30vLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cbmZ1bmN0aW9uIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpey8vIFRPRE86IFRoaXMgZnVuY3Rpb24gc2hhcmVzIGEgbG90IG9mIGxvZ2ljIHdpdGggZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudC5cbi8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbi8vIHZhbHVlcy5cbnZhciB0YXJnZXRJbnN0PWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO2lmKHRhcmdldEluc3QhPT1udWxsKXt2YXIgbmVhcmVzdE1vdW50ZWQ9Z2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtpZihuZWFyZXN0TW91bnRlZCE9PW51bGwpe3ZhciB0YWc9bmVhcmVzdE1vdW50ZWQudGFnO2lmKHRhZz09PVN1c3BlbnNlQ29tcG9uZW50KXt2YXIgaW5zdGFuY2U9Z2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7aWYoaW5zdGFuY2UhPT1udWxsKXsvLyBXZSdyZSBibG9ja2VkIG9uIGh5ZHJhdGluZyB0aGlzIGJvdW5kYXJ5LlxuLy8gSW5jcmVhc2UgaXRzIHByaW9yaXR5LlxucXVldWVkVGFyZ2V0LmJsb2NrZWRPbj1pbnN0YW5jZTthdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShxdWV1ZWRUYXJnZXQucHJpb3JpdHksZnVuY3Rpb24oKXthdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkobmVhcmVzdE1vdW50ZWQpO30pO3JldHVybjt9fWVsc2UgaWYodGFnPT09SG9zdFJvb3Qpe3ZhciByb290PW5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtpZihpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKXtxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPWdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7Ly8gV2UgZG9uJ3QgY3VycmVudGx5IGhhdmUgYSB3YXkgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mXG4vLyBhIHJvb3Qgb3RoZXIgdGhhbiBzeW5jLlxucmV0dXJuO319fX1xdWV1ZWRUYXJnZXQuYmxvY2tlZE9uPW51bGw7fWZ1bmN0aW9uIHF1ZXVlRXhwbGljaXRIeWRyYXRpb25UYXJnZXQodGFyZ2V0KXsvLyBUT0RPOiBUaGlzIHdpbGwgcmVhZCB0aGUgcHJpb3JpdHkgaWYgaXQncyBkaXNwYXRjaGVkIGJ5IHRoZSBSZWFjdFxuLy8gZXZlbnQgc3lzdGVtIGJ1dCBub3QgbmF0aXZlIGV2ZW50cy4gU2hvdWxkIHJlYWQgd2luZG93LmV2ZW50LnR5cGUsIGxpa2Vcbi8vIHdlIGRvIGZvciB1cGRhdGVzIChnZXRDdXJyZW50RXZlbnRQcmlvcml0eSkuXG52YXIgdXBkYXRlUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDEoKTt2YXIgcXVldWVkVGFyZ2V0PXtibG9ja2VkT246bnVsbCx0YXJnZXQ6dGFyZ2V0LHByaW9yaXR5OnVwZGF0ZVByaW9yaXR5fTt2YXIgaT0wO2Zvcig7aTxxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoO2krKyl7Ly8gU3RvcCBvbmNlIHdlIGhpdCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggbG93ZXIgcHJpb3JpdHkgdGhhblxuaWYoIWlzSGlnaGVyRXZlbnRQcmlvcml0eSh1cGRhdGVQcmlvcml0eSxxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbaV0ucHJpb3JpdHkpKXticmVhazt9fXF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zcGxpY2UoaSwwLHF1ZXVlZFRhcmdldCk7aWYoaT09PTApe2F0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpO319ZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCl7aWYocXVldWVkRXZlbnQuYmxvY2tlZE9uIT09bnVsbCl7cmV0dXJuIGZhbHNlO312YXIgdGFyZ2V0Q29udGFpbmVycz1xdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO3doaWxlKHRhcmdldENvbnRhaW5lcnMubGVuZ3RoPjApe3ZhciB0YXJnZXRDb250YWluZXI9dGFyZ2V0Q29udGFpbmVyc1swXTt2YXIgbmV4dEJsb2NrZWRPbj1maW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KHF1ZXVlZEV2ZW50LmRvbUV2ZW50TmFtZSxxdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7aWYobmV4dEJsb2NrZWRPbj09PW51bGwpe3t2YXIgbmF0aXZlRXZlbnQ9cXVldWVkRXZlbnQubmF0aXZlRXZlbnQ7dmFyIG5hdGl2ZUV2ZW50Q2xvbmU9bmV3IG5hdGl2ZUV2ZW50LmNvbnN0cnVjdG9yKG5hdGl2ZUV2ZW50LnR5cGUsbmF0aXZlRXZlbnQpO3NldFJlcGxheWluZ0V2ZW50KG5hdGl2ZUV2ZW50Q2xvbmUpO25hdGl2ZUV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KG5hdGl2ZUV2ZW50Q2xvbmUpO3Jlc2V0UmVwbGF5aW5nRXZlbnQoKTt9fWVsc2V7Ly8gV2UncmUgc3RpbGwgYmxvY2tlZC4gVHJ5IGFnYWluIGxhdGVyLlxudmFyIF9maWJlcjM9Z2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKTtpZihfZmliZXIzIT09bnVsbCl7YXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMyk7fXF1ZXVlZEV2ZW50LmJsb2NrZWRPbj1uZXh0QmxvY2tlZE9uO3JldHVybiBmYWxzZTt9Ly8gVGhpcyB0YXJnZXQgY29udGFpbmVyIHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZC4gVHJ5IHRoZSBuZXh0LlxudGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LGtleSxtYXApe2lmKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpKXttYXAuZGVsZXRlKGtleSk7fX1mdW5jdGlvbiByZXBsYXlVbmJsb2NrZWRFdmVudHMoKXtoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0PWZhbHNlO2lmKHF1ZXVlZEZvY3VzIT09bnVsbCYmYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykpe3F1ZXVlZEZvY3VzPW51bGw7fWlmKHF1ZXVlZERyYWchPT1udWxsJiZhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpKXtxdWV1ZWREcmFnPW51bGw7fWlmKHF1ZXVlZE1vdXNlIT09bnVsbCYmYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkpe3F1ZXVlZE1vdXNlPW51bGw7fXF1ZXVlZFBvaW50ZXJzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO31mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsdW5ibG9ja2VkKXtpZihxdWV1ZWRFdmVudC5ibG9ja2VkT249PT11bmJsb2NrZWQpe3F1ZXVlZEV2ZW50LmJsb2NrZWRPbj1udWxsO2lmKCFoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0KXtoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0PXRydWU7Ly8gU2NoZWR1bGUgYSBjYWxsYmFjayB0byBhdHRlbXB0IHJlcGxheWluZyBhcyBtYW55IGV2ZW50cyBhcyBhcmVcbi8vIG5vdyB1bmJsb2NrZWQuIFRoaXMgZmlyc3QgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHVuYmxvY2tlZCB5ZXQuXG4vLyBXZSBjb3VsZCBjaGVjayBpdCBlYXJseSB0byBhdm9pZCBzY2hlZHVsaW5nIGFuIHVubmVjZXNzYXJ5IGNhbGxiYWNrLlxuU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LHJlcGxheVVuYmxvY2tlZEV2ZW50cyk7fX19ZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpey8vIE1hcmsgYW55dGhpbmcgdGhhdCB3YXMgYmxvY2tlZCBvbiB0aGlzIGFzIG5vIGxvbmdlciBibG9ja2VkXG4vLyBhbmQgZWxpZ2libGUgZm9yIGEgcmVwbGF5LlxuaWYocXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoPjApe3NjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXSx1bmJsb2NrZWQpOy8vIFRoaXMgaXMgYSBleHBvbmVudGlhbCBzZWFyY2ggZm9yIGVhY2ggYm91bmRhcnkgdGhhdCBjb21taXRzLiBJIHRoaW5rIGl0J3Ncbi8vIHdvcnRoIGl0IGJlY2F1c2Ugd2UgZXhwZWN0IHZlcnkgZmV3IGRpc2NyZXRlIGV2ZW50cyB0byBxdWV1ZSB1cCBhbmQgb25jZVxuLy8gd2UgYXJlIGFjdHVhbGx5IGZ1bGx5IHVuYmxvY2tlZCBpdCB3aWxsIGJlIGZhc3QgdG8gcmVwbGF5IHRoZW0uXG5mb3IodmFyIGk9MTtpPHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aDtpKyspe3ZhciBxdWV1ZWRFdmVudD1xdWV1ZWREaXNjcmV0ZUV2ZW50c1tpXTtpZihxdWV1ZWRFdmVudC5ibG9ja2VkT249PT11bmJsb2NrZWQpe3F1ZXVlZEV2ZW50LmJsb2NrZWRPbj1udWxsO319fWlmKHF1ZXVlZEZvY3VzIT09bnVsbCl7c2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEZvY3VzLHVuYmxvY2tlZCk7fWlmKHF1ZXVlZERyYWchPT1udWxsKXtzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRHJhZyx1bmJsb2NrZWQpO31pZihxdWV1ZWRNb3VzZSE9PW51bGwpe3NjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRNb3VzZSx1bmJsb2NrZWQpO312YXIgdW5ibG9jaz1mdW5jdGlvbihxdWV1ZWRFdmVudCl7cmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCx1bmJsb2NrZWQpO307cXVldWVkUG9pbnRlcnMuZm9yRWFjaCh1bmJsb2NrKTtxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaCh1bmJsb2NrKTtmb3IodmFyIF9pPTA7X2k8cXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aDtfaSsrKXt2YXIgcXVldWVkVGFyZ2V0PXF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tfaV07aWYocXVldWVkVGFyZ2V0LmJsb2NrZWRPbj09PXVuYmxvY2tlZCl7cXVldWVkVGFyZ2V0LmJsb2NrZWRPbj1udWxsO319d2hpbGUocXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aD4wKXt2YXIgbmV4dEV4cGxpY2l0VGFyZ2V0PXF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1swXTtpZihuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uIT09bnVsbCl7Ly8gV2UncmUgc3RpbGwgYmxvY2tlZC5cbmJyZWFrO31lbHNle2F0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChuZXh0RXhwbGljaXRUYXJnZXQpO2lmKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT249PT1udWxsKXsvLyBXZSdyZSB1bmJsb2NrZWQuXG5xdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc2hpZnQoKTt9fX19dmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOy8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZD10cnVlOy8vIFRoaXMgaXMgZXhwb3J0ZWQgaW4gRkIgYnVpbGRzIGZvciB1c2UgYnkgbGVnYWN5IEZCIGxheWVyIGluZnJhLlxuLy8gV2UnZCBsaWtlIHRvIHJlbW92ZSB0aGlzIGJ1dCBpdCdzIG5vdCBjbGVhciBpZiB0aGlzIGlzIHNhZmUuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpe19lbmFibGVkPSEhZW5hYmxlZDt9ZnVuY3Rpb24gaXNFbmFibGVkKCl7cmV0dXJuIF9lbmFibGVkO31mdW5jdGlvbiBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3Mpe3ZhciBldmVudFByaW9yaXR5PWdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKTt2YXIgbGlzdGVuZXJXcmFwcGVyO3N3aXRjaChldmVudFByaW9yaXR5KXtjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpsaXN0ZW5lcldyYXBwZXI9ZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O2JyZWFrO2Nhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6bGlzdGVuZXJXcmFwcGVyPWRpc3BhdGNoQ29udGludW91c0V2ZW50O2JyZWFrO2Nhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6ZGVmYXVsdDpsaXN0ZW5lcldyYXBwZXI9ZGlzcGF0Y2hFdmVudDticmVhazt9cmV0dXJuIGxpc3RlbmVyV3JhcHBlci5iaW5kKG51bGwsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKTt9ZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCl7dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247UmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbj1udWxsO3RyeXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247fX1mdW5jdGlvbiBkaXNwYXRjaENvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxjb250YWluZXIsbmF0aXZlRXZlbnQpe3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb249bnVsbDt0cnl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KENvbnRpbnVvdXNFdmVudFByaW9yaXR5KTtkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLGNvbnRhaW5lcixuYXRpdmVFdmVudCk7fWZpbmFsbHl7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247fX1mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7aWYoIV9lbmFibGVkKXtyZXR1cm47fXtkaXNwYXRjaEV2ZW50V2l0aEVuYWJsZUNhcHR1cmVQaGFzZVNlbGVjdGl2ZUh5ZHJhdGlvbldpdGhvdXREaXNjcmV0ZUV2ZW50UmVwbGF5KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7fX1mdW5jdGlvbiBkaXNwYXRjaEV2ZW50V2l0aEVuYWJsZUNhcHR1cmVQaGFzZVNlbGVjdGl2ZUh5ZHJhdGlvbldpdGhvdXREaXNjcmV0ZUV2ZW50UmVwbGF5KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCl7dmFyIGJsb2NrZWRPbj1maW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcixuYXRpdmVFdmVudCk7aWYoYmxvY2tlZE9uPT09bnVsbCl7ZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSxldmVudFN5c3RlbUZsYWdzLG5hdGl2ZUV2ZW50LHJldHVybl90YXJnZXRJbnN0LHRhcmdldENvbnRhaW5lcik7Y2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO3JldHVybjt9aWYocXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KSl7bmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuO30vLyBXZSBuZWVkIHRvIGNsZWFyIG9ubHkgaWYgd2UgZGlkbid0IHF1ZXVlIGJlY2F1c2Vcbi8vIHF1ZXVlaW5nIGlzIGFjY3VtdWxhdGl2ZS5cbmNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KTtpZihldmVudFN5c3RlbUZsYWdzJklTX0NBUFRVUkVfUEhBU0UmJmlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbihkb21FdmVudE5hbWUpKXt3aGlsZShibG9ja2VkT24hPT1udWxsKXt2YXIgZmliZXI9Z2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO2lmKGZpYmVyIT09bnVsbCl7YXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKTt9dmFyIG5leHRCbG9ja2VkT249ZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIsbmF0aXZlRXZlbnQpO2lmKG5leHRCbG9ja2VkT249PT1udWxsKXtkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQscmV0dXJuX3RhcmdldEluc3QsdGFyZ2V0Q29udGFpbmVyKTt9aWYobmV4dEJsb2NrZWRPbj09PWJsb2NrZWRPbil7YnJlYWs7fWJsb2NrZWRPbj1uZXh0QmxvY2tlZE9uO31pZihibG9ja2VkT24hPT1udWxsKXtuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTt9cmV0dXJuO30vLyBUaGlzIGlzIG5vdCByZXBsYXlhYmxlIHNvIHdlJ2xsIGludm9rZSBpdCBidXQgd2l0aG91dCBhIHRhcmdldCxcbi8vIGluIGNhc2UgdGhlIGV2ZW50IHN5c3RlbSBuZWVkcyB0byB0cmFjZSBpdC5cbmRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCxudWxsLHRhcmdldENvbnRhaW5lcik7fXZhciByZXR1cm5fdGFyZ2V0SW5zdD1udWxsOy8vIFJldHVybnMgYSBTdXNwZW5zZUluc3RhbmNlIG9yIENvbnRhaW5lciBpZiBpdCdzIGJsb2NrZWQuXG4vLyBUaGUgcmV0dXJuX3RhcmdldEluc3QgZmllbGQgYWJvdmUgaXMgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZS5cbmZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyLG5hdGl2ZUV2ZW50KXsvLyBUT0RPOiBXYXJuIGlmIF9lbmFibGVkIGlzIGZhbHNlLlxucmV0dXJuX3RhcmdldEluc3Q9bnVsbDt2YXIgbmF0aXZlRXZlbnRUYXJnZXQ9Z2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO3ZhciB0YXJnZXRJbnN0PWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtpZih0YXJnZXRJbnN0IT09bnVsbCl7dmFyIG5lYXJlc3RNb3VudGVkPWdldE5lYXJlc3RNb3VudGVkRmliZXIodGFyZ2V0SW5zdCk7aWYobmVhcmVzdE1vdW50ZWQ9PT1udWxsKXsvLyBUaGlzIHRyZWUgaGFzIGJlZW4gdW5tb3VudGVkIGFscmVhZHkuIERpc3BhdGNoIHdpdGhvdXQgYSB0YXJnZXQuXG50YXJnZXRJbnN0PW51bGw7fWVsc2V7dmFyIHRhZz1uZWFyZXN0TW91bnRlZC50YWc7aWYodGFnPT09U3VzcGVuc2VDb21wb25lbnQpe3ZhciBpbnN0YW5jZT1nZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtpZihpbnN0YW5jZSE9PW51bGwpey8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2Vcbi8vIGRvbid0IHdhbnQgdGhpcyBldmVudCBkaXNwYXRjaGVkIHR3aWNlIHRocm91Z2ggdGhlIGV2ZW50IHN5c3RlbS5cbi8vIFRPRE86IElmIHRoaXMgaXMgdGhlIGZpcnN0IGRpc2NyZXRlIGV2ZW50IGluIHRoZSBxdWV1ZS4gU2NoZWR1bGUgYW4gaW5jcmVhc2VkXG4vLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbnJldHVybiBpbnN0YW5jZTt9Ly8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbi8vIHRoZSB3aG9sZSBzeXN0ZW0sIGRpc3BhdGNoIHRoZSBldmVudCB3aXRob3V0IGEgdGFyZ2V0LlxuLy8gVE9ETzogV2Fybi5cbnRhcmdldEluc3Q9bnVsbDt9ZWxzZSBpZih0YWc9PT1Ib3N0Um9vdCl7dmFyIHJvb3Q9bmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO2lmKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpey8vIElmIHRoaXMgaGFwcGVucyBkdXJpbmcgYSByZXBsYXkgc29tZXRoaW5nIHdlbnQgd3JvbmcgYW5kIGl0IG1pZ2h0IGJsb2NrXG4vLyB0aGUgd2hvbGUgc3lzdGVtLlxucmV0dXJuIGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7fXRhcmdldEluc3Q9bnVsbDt9ZWxzZSBpZihuZWFyZXN0TW91bnRlZCE9PXRhcmdldEluc3Qpey8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbi8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4vLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4vLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbnRhcmdldEluc3Q9bnVsbDt9fX1yZXR1cm5fdGFyZ2V0SW5zdD10YXJnZXRJbnN0Oy8vIFdlJ3JlIG5vdCBibG9ja2VkIG9uIGFueXRoaW5nLlxucmV0dXJuIG51bGw7fWZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKXtzd2l0Y2goZG9tRXZlbnROYW1lKXsvLyBVc2VkIGJ5IFNpbXBsZUV2ZW50UGx1Z2luOlxuY2FzZSdjYW5jZWwnOmNhc2UnY2xpY2snOmNhc2UnY2xvc2UnOmNhc2UnY29udGV4dG1lbnUnOmNhc2UnY29weSc6Y2FzZSdjdXQnOmNhc2UnYXV4Y2xpY2snOmNhc2UnZGJsY2xpY2snOmNhc2UnZHJhZ2VuZCc6Y2FzZSdkcmFnc3RhcnQnOmNhc2UnZHJvcCc6Y2FzZSdmb2N1c2luJzpjYXNlJ2ZvY3Vzb3V0JzpjYXNlJ2lucHV0JzpjYXNlJ2ludmFsaWQnOmNhc2Una2V5ZG93bic6Y2FzZSdrZXlwcmVzcyc6Y2FzZSdrZXl1cCc6Y2FzZSdtb3VzZWRvd24nOmNhc2UnbW91c2V1cCc6Y2FzZSdwYXN0ZSc6Y2FzZSdwYXVzZSc6Y2FzZSdwbGF5JzpjYXNlJ3BvaW50ZXJjYW5jZWwnOmNhc2UncG9pbnRlcmRvd24nOmNhc2UncG9pbnRlcnVwJzpjYXNlJ3JhdGVjaGFuZ2UnOmNhc2UncmVzZXQnOmNhc2UncmVzaXplJzpjYXNlJ3NlZWtlZCc6Y2FzZSdzdWJtaXQnOmNhc2UndG91Y2hjYW5jZWwnOmNhc2UndG91Y2hlbmQnOmNhc2UndG91Y2hzdGFydCc6Y2FzZSd2b2x1bWVjaGFuZ2UnOi8vIFVzZWQgYnkgcG9seWZpbGxzOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5jYXNlJ2NoYW5nZSc6Y2FzZSdzZWxlY3Rpb25jaGFuZ2UnOmNhc2UndGV4dElucHV0JzpjYXNlJ2NvbXBvc2l0aW9uc3RhcnQnOmNhc2UnY29tcG9zaXRpb25lbmQnOmNhc2UnY29tcG9zaXRpb251cGRhdGUnOi8vIE9ubHkgZW5hYmxlQ3JlYXRlRXZlbnRIYW5kbGVBUEk6XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UnYmVmb3JlYmx1cic6Y2FzZSdhZnRlcmJsdXInOi8vIE5vdCB1c2VkIGJ5IFJlYWN0IGJ1dCBjb3VsZCBiZSBieSB1c2VyIGNvZGU6XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UnYmVmb3JlaW5wdXQnOmNhc2UnYmx1cic6Y2FzZSdmdWxsc2NyZWVuY2hhbmdlJzpjYXNlJ2ZvY3VzJzpjYXNlJ2hhc2hjaGFuZ2UnOmNhc2UncG9wc3RhdGUnOmNhc2Unc2VsZWN0JzpjYXNlJ3NlbGVjdHN0YXJ0JzpyZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O2Nhc2UnZHJhZyc6Y2FzZSdkcmFnZW50ZXInOmNhc2UnZHJhZ2V4aXQnOmNhc2UnZHJhZ2xlYXZlJzpjYXNlJ2RyYWdvdmVyJzpjYXNlJ21vdXNlbW92ZSc6Y2FzZSdtb3VzZW91dCc6Y2FzZSdtb3VzZW92ZXInOmNhc2UncG9pbnRlcm1vdmUnOmNhc2UncG9pbnRlcm91dCc6Y2FzZSdwb2ludGVyb3Zlcic6Y2FzZSdzY3JvbGwnOmNhc2UndG9nZ2xlJzpjYXNlJ3RvdWNobW92ZSc6Y2FzZSd3aGVlbCc6Ly8gTm90IHVzZWQgYnkgUmVhY3QgYnV0IGNvdWxkIGJlIGJ5IHVzZXIgY29kZTpcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSdtb3VzZWVudGVyJzpjYXNlJ21vdXNlbGVhdmUnOmNhc2UncG9pbnRlcmVudGVyJzpjYXNlJ3BvaW50ZXJsZWF2ZSc6cmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O2Nhc2UnbWVzc2FnZSc6ey8vIFdlIG1pZ2h0IGJlIGluIHRoZSBTY2hlZHVsZXIgY2FsbGJhY2suXG4vLyBFdmVudHVhbGx5IHRoaXMgbWVjaGFuaXNtIHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBjaGVja1xuLy8gb2YgdGhlIGN1cnJlbnQgcHJpb3JpdHkgb24gdGhlIG5hdGl2ZSBzY2hlZHVsZXIuXG52YXIgc2NoZWR1bGVyUHJpb3JpdHk9Z2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtzd2l0Y2goc2NoZWR1bGVyUHJpb3JpdHkpe2Nhc2UgSW1tZWRpYXRlUHJpb3JpdHk6cmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OnJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtjYXNlIE5vcm1hbFByaW9yaXR5OmNhc2UgTG93UHJpb3JpdHk6Ly8gVE9ETzogSGFuZGxlIExvd1NjaGVkdWxlclByaW9yaXR5LCBzb21laG93LiBNYXliZSB0aGUgc2FtZSBsYW5lIGFzIGh5ZHJhdGlvbi5cbnJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtjYXNlIElkbGVQcmlvcml0eTpyZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7ZGVmYXVsdDpyZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7fX1kZWZhdWx0OnJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTt9fWZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0LGV2ZW50VHlwZSxsaXN0ZW5lcil7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLGZhbHNlKTtyZXR1cm4gbGlzdGVuZXI7fWZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldCxldmVudFR5cGUsbGlzdGVuZXIpe3RhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSxsaXN0ZW5lcix0cnVlKTtyZXR1cm4gbGlzdGVuZXI7fWZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldCxldmVudFR5cGUsbGlzdGVuZXIscGFzc2l2ZSl7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLHtjYXB0dXJlOnRydWUscGFzc2l2ZTpwYXNzaXZlfSk7cmV0dXJuIGxpc3RlbmVyO31mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldCxldmVudFR5cGUsbGlzdGVuZXIscGFzc2l2ZSl7dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLGxpc3RlbmVyLHtwYXNzaXZlOnBhc3NpdmV9KTtyZXR1cm4gbGlzdGVuZXI7fS8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL3ZhciByb290PW51bGw7dmFyIHN0YXJ0VGV4dD1udWxsO3ZhciBmYWxsYmFja1RleHQ9bnVsbDtmdW5jdGlvbiBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KXtyb290PW5hdGl2ZUV2ZW50VGFyZ2V0O3N0YXJ0VGV4dD1nZXRUZXh0KCk7cmV0dXJuIHRydWU7fWZ1bmN0aW9uIHJlc2V0KCl7cm9vdD1udWxsO3N0YXJ0VGV4dD1udWxsO2ZhbGxiYWNrVGV4dD1udWxsO31mdW5jdGlvbiBnZXREYXRhKCl7aWYoZmFsbGJhY2tUZXh0KXtyZXR1cm4gZmFsbGJhY2tUZXh0O312YXIgc3RhcnQ7dmFyIHN0YXJ0VmFsdWU9c3RhcnRUZXh0O3ZhciBzdGFydExlbmd0aD1zdGFydFZhbHVlLmxlbmd0aDt2YXIgZW5kO3ZhciBlbmRWYWx1ZT1nZXRUZXh0KCk7dmFyIGVuZExlbmd0aD1lbmRWYWx1ZS5sZW5ndGg7Zm9yKHN0YXJ0PTA7c3RhcnQ8c3RhcnRMZW5ndGg7c3RhcnQrKyl7aWYoc3RhcnRWYWx1ZVtzdGFydF0hPT1lbmRWYWx1ZVtzdGFydF0pe2JyZWFrO319dmFyIG1pbkVuZD1zdGFydExlbmd0aC1zdGFydDtmb3IoZW5kPTE7ZW5kPD1taW5FbmQ7ZW5kKyspe2lmKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGgtZW5kXSE9PWVuZFZhbHVlW2VuZExlbmd0aC1lbmRdKXticmVhazt9fXZhciBzbGljZVRhaWw9ZW5kPjE/MS1lbmQ6dW5kZWZpbmVkO2ZhbGxiYWNrVGV4dD1lbmRWYWx1ZS5zbGljZShzdGFydCxzbGljZVRhaWwpO3JldHVybiBmYWxsYmFja1RleHQ7fWZ1bmN0aW9uIGdldFRleHQoKXtpZigndmFsdWUnaW4gcm9vdCl7cmV0dXJuIHJvb3QudmFsdWU7fXJldHVybiByb290LnRleHRDb250ZW50O30vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCl7dmFyIGNoYXJDb2RlO3ZhciBrZXlDb2RlPW5hdGl2ZUV2ZW50LmtleUNvZGU7aWYoJ2NoYXJDb2RlJ2luIG5hdGl2ZUV2ZW50KXtjaGFyQ29kZT1uYXRpdmVFdmVudC5jaGFyQ29kZTsvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG5pZihjaGFyQ29kZT09PTAmJmtleUNvZGU9PT0xMyl7Y2hhckNvZGU9MTM7fX1lbHNley8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG5jaGFyQ29kZT1rZXlDb2RlO30vLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4vLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5pZihjaGFyQ29kZT09PTEwKXtjaGFyQ29kZT0xMzt9Ly8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4vLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuaWYoY2hhckNvZGU+PTMyfHxjaGFyQ29kZT09PTEzKXtyZXR1cm4gY2hhckNvZGU7fXJldHVybiAwO31mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpe3JldHVybiB0cnVlO31mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKXtyZXR1cm4gZmFsc2U7fS8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhIGZhY3Rvcnkgc28gdGhhdCB3ZSBoYXZlIGRpZmZlcmVudCByZXR1cm5lZCBjb25zdHJ1Y3RvcnMuXG4vLyBJZiB3ZSBoYWQgYSBzaW5nbGUgY29uc3RydWN0b3IsIGl0IHdvdWxkIGJlIG1lZ2Ftb3JwaGljIGFuZCBlbmdpbmVzIHdvdWxkIGRlb3B0LlxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKXsvKipcbiAgICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICAgKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICAgKlxuICAgKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICAgKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAgICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICAgKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICAgKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gICAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gICAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAgICovZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSxyZWFjdEV2ZW50VHlwZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KXt0aGlzLl9yZWFjdE5hbWU9cmVhY3ROYW1lO3RoaXMuX3RhcmdldEluc3Q9dGFyZ2V0SW5zdDt0aGlzLnR5cGU9cmVhY3RFdmVudFR5cGU7dGhpcy5uYXRpdmVFdmVudD1uYXRpdmVFdmVudDt0aGlzLnRhcmdldD1uYXRpdmVFdmVudFRhcmdldDt0aGlzLmN1cnJlbnRUYXJnZXQ9bnVsbDtmb3IodmFyIF9wcm9wTmFtZSBpbiBJbnRlcmZhY2Upe2lmKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSl7Y29udGludWU7fXZhciBub3JtYWxpemU9SW50ZXJmYWNlW19wcm9wTmFtZV07aWYobm9ybWFsaXplKXt0aGlzW19wcm9wTmFtZV09bm9ybWFsaXplKG5hdGl2ZUV2ZW50KTt9ZWxzZXt0aGlzW19wcm9wTmFtZV09bmF0aXZlRXZlbnRbX3Byb3BOYW1lXTt9fXZhciBkZWZhdWx0UHJldmVudGVkPW5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQhPW51bGw/bmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZDpuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZT09PWZhbHNlO2lmKGRlZmF1bHRQcmV2ZW50ZWQpe3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPWZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO31lbHNle3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPWZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTt9dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1mdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7cmV0dXJuIHRoaXM7fWFzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLHtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD10cnVlO3ZhciBldmVudD10aGlzLm5hdGl2ZUV2ZW50O2lmKCFldmVudCl7cmV0dXJuO31pZihldmVudC5wcmV2ZW50RGVmYXVsdCl7ZXZlbnQucHJldmVudERlZmF1bHQoKTsvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG59ZWxzZSBpZih0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUhPT0ndW5rbm93bicpe2V2ZW50LnJldHVyblZhbHVlPWZhbHNlO310aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1mdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTt9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBldmVudD10aGlzLm5hdGl2ZUV2ZW50O2lmKCFldmVudCl7cmV0dXJuO31pZihldmVudC5zdG9wUHJvcGFnYXRpb24pe2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpOy8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbn1lbHNlIGlmKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUhPT0ndW5rbm93bicpey8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4vLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4vLyBJRSBzcGVjaWZpYykuXG5ldmVudC5jYW5jZWxCdWJibGU9dHJ1ZTt9dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1mdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTt9LC8qKlxuICAgICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICovcGVyc2lzdDpmdW5jdGlvbigpey8vIE1vZGVybiBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbn0sLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovaXNQZXJzaXN0ZW50OmZ1bmN0aW9uVGhhdFJldHVybnNUcnVlfSk7cmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDt9LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL3ZhciBFdmVudEludGVyZmFjZT17ZXZlbnRQaGFzZTowLGJ1YmJsZXM6MCxjYW5jZWxhYmxlOjAsdGltZVN0YW1wOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4gZXZlbnQudGltZVN0YW1wfHxEYXRlLm5vdygpO30sZGVmYXVsdFByZXZlbnRlZDowLGlzVHJ1c3RlZDowfTt2YXIgU3ludGhldGljRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoRXZlbnRJbnRlcmZhY2UpO3ZhciBVSUV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7dmlldzowLGRldGFpbDowfSk7dmFyIFN5bnRoZXRpY1VJRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoVUlFdmVudEludGVyZmFjZSk7dmFyIGxhc3RNb3ZlbWVudFg7dmFyIGxhc3RNb3ZlbWVudFk7dmFyIGxhc3RNb3VzZUV2ZW50O2Z1bmN0aW9uIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KXtpZihldmVudCE9PWxhc3RNb3VzZUV2ZW50KXtpZihsYXN0TW91c2VFdmVudCYmZXZlbnQudHlwZT09PSdtb3VzZW1vdmUnKXtsYXN0TW92ZW1lbnRYPWV2ZW50LnNjcmVlblgtbGFzdE1vdXNlRXZlbnQuc2NyZWVuWDtsYXN0TW92ZW1lbnRZPWV2ZW50LnNjcmVlblktbGFzdE1vdXNlRXZlbnQuc2NyZWVuWTt9ZWxzZXtsYXN0TW92ZW1lbnRYPTA7bGFzdE1vdmVtZW50WT0wO31sYXN0TW91c2VFdmVudD1ldmVudDt9fS8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL3ZhciBNb3VzZUV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxVSUV2ZW50SW50ZXJmYWNlLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOmdldEV2ZW50TW9kaWZpZXJTdGF0ZSxidXR0b246MCxidXR0b25zOjAscmVsYXRlZFRhcmdldDpmdW5jdGlvbihldmVudCl7aWYoZXZlbnQucmVsYXRlZFRhcmdldD09PXVuZGVmaW5lZClyZXR1cm4gZXZlbnQuZnJvbUVsZW1lbnQ9PT1ldmVudC5zcmNFbGVtZW50P2V2ZW50LnRvRWxlbWVudDpldmVudC5mcm9tRWxlbWVudDtyZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldDt9LG1vdmVtZW50WDpmdW5jdGlvbihldmVudCl7aWYoJ21vdmVtZW50WCdpbiBldmVudCl7cmV0dXJuIGV2ZW50Lm1vdmVtZW50WDt9dXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpO3JldHVybiBsYXN0TW92ZW1lbnRYO30sbW92ZW1lbnRZOmZ1bmN0aW9uKGV2ZW50KXtpZignbW92ZW1lbnRZJ2luIGV2ZW50KXtyZXR1cm4gZXZlbnQubW92ZW1lbnRZO30vLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4vLyBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBoYXZlIGFscmVhZHkgcnVuIHdoZW4gbW92ZW1lbnRYXG4vLyB3YXMgY29waWVkLlxucmV0dXJuIGxhc3RNb3ZlbWVudFk7fX0pO3ZhciBTeW50aGV0aWNNb3VzZUV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KE1vdXNlRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIERyYWdFdmVudEludGVyZmFjZT1hc3NpZ24oe30sTW91c2VFdmVudEludGVyZmFjZSx7ZGF0YVRyYW5zZmVyOjB9KTt2YXIgU3ludGhldGljRHJhZ0V2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIEZvY3VzRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LFVJRXZlbnRJbnRlcmZhY2Use3JlbGF0ZWRUYXJnZXQ6MH0pO3ZhciBTeW50aGV0aWNGb2N1c0V2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL3ZhciBBbmltYXRpb25FdmVudEludGVyZmFjZT1hc3NpZ24oe30sRXZlbnRJbnRlcmZhY2Use2FuaW1hdGlvbk5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pO3ZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovdmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihldmVudCl7cmV0dXJuJ2NsaXBib2FyZERhdGEnaW4gZXZlbnQ/ZXZlbnQuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YTt9fSk7dmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL3ZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxFdmVudEludGVyZmFjZSx7ZGF0YTowfSk7dmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi8gLy8gSGFwcGVucyB0byBzaGFyZSB0aGUgc2FtZSBsaXN0IGZvciBub3cuXG52YXIgU3ludGhldGljSW5wdXRFdmVudD1TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Oy8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL3ZhciBub3JtYWxpemVLZXk9e0VzYzonRXNjYXBlJyxTcGFjZWJhcjonICcsTGVmdDonQXJyb3dMZWZ0JyxVcDonQXJyb3dVcCcsUmlnaHQ6J0Fycm93UmlnaHQnLERvd246J0Fycm93RG93bicsRGVsOidEZWxldGUnLFdpbjonT1MnLE1lbnU6J0NvbnRleHRNZW51JyxBcHBzOidDb250ZXh0TWVudScsU2Nyb2xsOidTY3JvbGxMb2NrJyxNb3pQcmludGFibGVLZXk6J1VuaWRlbnRpZmllZCd9Oy8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovdmFyIHRyYW5zbGF0ZVRvS2V5PXsnOCc6J0JhY2tzcGFjZScsJzknOidUYWInLCcxMic6J0NsZWFyJywnMTMnOidFbnRlcicsJzE2JzonU2hpZnQnLCcxNyc6J0NvbnRyb2wnLCcxOCc6J0FsdCcsJzE5JzonUGF1c2UnLCcyMCc6J0NhcHNMb2NrJywnMjcnOidFc2NhcGUnLCczMic6JyAnLCczMyc6J1BhZ2VVcCcsJzM0JzonUGFnZURvd24nLCczNSc6J0VuZCcsJzM2JzonSG9tZScsJzM3JzonQXJyb3dMZWZ0JywnMzgnOidBcnJvd1VwJywnMzknOidBcnJvd1JpZ2h0JywnNDAnOidBcnJvd0Rvd24nLCc0NSc6J0luc2VydCcsJzQ2JzonRGVsZXRlJywnMTEyJzonRjEnLCcxMTMnOidGMicsJzExNCc6J0YzJywnMTE1JzonRjQnLCcxMTYnOidGNScsJzExNyc6J0Y2JywnMTE4JzonRjcnLCcxMTknOidGOCcsJzEyMCc6J0Y5JywnMTIxJzonRjEwJywnMTIyJzonRjExJywnMTIzJzonRjEyJywnMTQ0JzonTnVtTG9jaycsJzE0NSc6J1Njcm9sbExvY2snLCcyMjQnOidNZXRhJ307LyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCl7aWYobmF0aXZlRXZlbnQua2V5KXsvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbi8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cbi8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4vLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbnZhciBrZXk9bm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV18fG5hdGl2ZUV2ZW50LmtleTtpZihrZXkhPT0nVW5pZGVudGlmaWVkJyl7cmV0dXJuIGtleTt9fS8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbmlmKG5hdGl2ZUV2ZW50LnR5cGU9PT0na2V5cHJlc3MnKXt2YXIgY2hhckNvZGU9Z2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7Ly8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4vLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbnJldHVybiBjaGFyQ29kZT09PTEzPydFbnRlcic6U3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7fWlmKG5hdGl2ZUV2ZW50LnR5cGU9PT0na2V5ZG93bid8fG5hdGl2ZUV2ZW50LnR5cGU9PT0na2V5dXAnKXsvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4vLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxucmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdfHwnVW5pZGVudGlmaWVkJzt9cmV0dXJuJyc7fS8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi92YXIgbW9kaWZpZXJLZXlUb1Byb3A9e0FsdDonYWx0S2V5JyxDb250cm9sOidjdHJsS2V5JyxNZXRhOidtZXRhS2V5JyxTaGlmdDonc2hpZnRLZXknfTsvLyBPbGRlciBicm93c2VycyAoU2FmYXJpIDw9IDEwLCBpT1MgU2FmYXJpIDw9IDEwLjIpIGRvIG5vdCBzdXBwb3J0XG4vLyBnZXRNb2RpZmllclN0YXRlLiBJZiBnZXRNb2RpZmllclN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIG1hcCBpdCB0byBhIHNldCBvZlxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudC4gSW4gdGhpcyBjYXNlLCBMb2NrLWtleXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZyl7dmFyIHN5bnRoZXRpY0V2ZW50PXRoaXM7dmFyIG5hdGl2ZUV2ZW50PXN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O2lmKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpe3JldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7fXZhciBrZXlQcm9wPW1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107cmV0dXJuIGtleVByb3A/ISFuYXRpdmVFdmVudFtrZXlQcm9wXTpmYWxzZTt9ZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KXtyZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjt9LyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovdmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LFVJRXZlbnRJbnRlcmZhY2Use2tleTpnZXRFdmVudEtleSxjb2RlOjAsbG9jYXRpb246MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxhbHRLZXk6MCxtZXRhS2V5OjAscmVwZWF0OjAsbG9jYWxlOjAsZ2V0TW9kaWZpZXJTdGF0ZTpnZXRFdmVudE1vZGlmaWVyU3RhdGUsLy8gTGVnYWN5IEludGVyZmFjZVxuY2hhckNvZGU6ZnVuY3Rpb24oZXZlbnQpey8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3Rcbi8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbmlmKGV2ZW50LnR5cGU9PT0na2V5cHJlc3MnKXtyZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7fXJldHVybiAwO30sa2V5Q29kZTpmdW5jdGlvbihldmVudCl7Ly8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4vLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbi8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbi8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG5pZihldmVudC50eXBlPT09J2tleWRvd24nfHxldmVudC50eXBlPT09J2tleXVwJyl7cmV0dXJuIGV2ZW50LmtleUNvZGU7fXJldHVybiAwO30sd2hpY2g6ZnVuY3Rpb24oZXZlbnQpey8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4vLyB0eXBlIG9mIHRoZSBldmVudC5cbmlmKGV2ZW50LnR5cGU9PT0na2V5cHJlc3MnKXtyZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7fWlmKGV2ZW50LnR5cGU9PT0na2V5ZG93bid8fGV2ZW50LnR5cGU9PT0na2V5dXAnKXtyZXR1cm4gZXZlbnQua2V5Q29kZTt9cmV0dXJuIDA7fX0pO3ZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL3ZhciBQb2ludGVyRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LE1vdXNlRXZlbnRJbnRlcmZhY2Use3BvaW50ZXJJZDowLHdpZHRoOjAsaGVpZ2h0OjAscHJlc3N1cmU6MCx0YW5nZW50aWFsUHJlc3N1cmU6MCx0aWx0WDowLHRpbHRZOjAsdHdpc3Q6MCxwb2ludGVyVHlwZTowLGlzUHJpbWFyeTowfSk7dmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudD1jcmVhdGVTeW50aGV0aWNFdmVudChQb2ludGVyRXZlbnRJbnRlcmZhY2UpOy8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL3ZhciBUb3VjaEV2ZW50SW50ZXJmYWNlPWFzc2lnbih7fSxVSUV2ZW50SW50ZXJmYWNlLHt0b3VjaGVzOjAsdGFyZ2V0VG91Y2hlczowLGNoYW5nZWRUb3VjaGVzOjAsYWx0S2V5OjAsbWV0YUtleTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGdldE1vZGlmaWVyU3RhdGU6Z2V0RXZlbnRNb2RpZmllclN0YXRlfSk7dmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoVG91Y2hFdmVudEludGVyZmFjZSk7LyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL3ZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2U9YXNzaWduKHt9LEV2ZW50SW50ZXJmYWNlLHtwcm9wZXJ0eU5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pO3ZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ9Y3JlYXRlU3ludGhldGljRXZlbnQoVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTsvKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi92YXIgV2hlZWxFdmVudEludGVyZmFjZT1hc3NpZ24oe30sTW91c2VFdmVudEludGVyZmFjZSx7ZGVsdGFYOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4nZGVsdGFYJ2luIGV2ZW50P2V2ZW50LmRlbHRhWDovLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuJ3doZWVsRGVsdGFYJ2luIGV2ZW50Py1ldmVudC53aGVlbERlbHRhWDowO30sZGVsdGFZOmZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4nZGVsdGFZJ2luIGV2ZW50P2V2ZW50LmRlbHRhWTovLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4nd2hlZWxEZWx0YVknaW4gZXZlbnQ/LWV2ZW50LndoZWVsRGVsdGFZOi8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbid3aGVlbERlbHRhJ2luIGV2ZW50Py1ldmVudC53aGVlbERlbHRhOjA7fSxkZWx0YVo6MCwvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbi8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4vLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG5kZWx0YU1vZGU6MH0pO3ZhciBTeW50aGV0aWNXaGVlbEV2ZW50PWNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpO3ZhciBFTkRfS0VZQ09ERVM9WzksMTMsMjcsMzJdOy8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERT0yMjk7dmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQ9Y2FuVXNlRE9NJiYnQ29tcG9zaXRpb25FdmVudCdpbiB3aW5kb3c7dmFyIGRvY3VtZW50TW9kZT1udWxsO2lmKGNhblVzZURPTSYmJ2RvY3VtZW50TW9kZSdpbiBkb2N1bWVudCl7ZG9jdW1lbnRNb2RlPWRvY3VtZW50LmRvY3VtZW50TW9kZTt9Ly8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudD1jYW5Vc2VET00mJidUZXh0RXZlbnQnaW4gd2luZG93JiYhZG9jdW1lbnRNb2RlOy8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGE9Y2FuVXNlRE9NJiYoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnR8fGRvY3VtZW50TW9kZSYmZG9jdW1lbnRNb2RlPjgmJmRvY3VtZW50TW9kZTw9MTEpO3ZhciBTUEFDRUJBUl9DT0RFPTMyO3ZhciBTUEFDRUJBUl9DSEFSPVN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7ZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoKXtyZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQmVmb3JlSW5wdXQnLFsnY29tcG9zaXRpb25lbmQnLCdrZXlwcmVzcycsJ3RleHRJbnB1dCcsJ3Bhc3RlJ10pO3JlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvbkVuZCcsWydjb21wb3NpdGlvbmVuZCcsJ2ZvY3Vzb3V0Jywna2V5ZG93bicsJ2tleXByZXNzJywna2V5dXAnLCdtb3VzZWRvd24nXSk7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uU3RhcnQnLFsnY29tcG9zaXRpb25zdGFydCcsJ2ZvY3Vzb3V0Jywna2V5ZG93bicsJ2tleXByZXNzJywna2V5dXAnLCdtb3VzZWRvd24nXSk7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uVXBkYXRlJyxbJ2NvbXBvc2l0aW9udXBkYXRlJywnZm9jdXNvdXQnLCdrZXlkb3duJywna2V5cHJlc3MnLCdrZXl1cCcsJ21vdXNlZG93biddKTt9Ly8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3M9ZmFsc2U7LyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL2Z1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KXtyZXR1cm4obmF0aXZlRXZlbnQuY3RybEtleXx8bmF0aXZlRXZlbnQuYWx0S2V5fHxuYXRpdmVFdmVudC5tZXRhS2V5KSYmLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4hKG5hdGl2ZUV2ZW50LmN0cmxLZXkmJm5hdGl2ZUV2ZW50LmFsdEtleSk7fS8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKi9mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpe3N3aXRjaChkb21FdmVudE5hbWUpe2Nhc2UnY29tcG9zaXRpb25zdGFydCc6cmV0dXJuJ29uQ29tcG9zaXRpb25TdGFydCc7Y2FzZSdjb21wb3NpdGlvbmVuZCc6cmV0dXJuJ29uQ29tcG9zaXRpb25FbmQnO2Nhc2UnY29tcG9zaXRpb251cGRhdGUnOnJldHVybidvbkNvbXBvc2l0aW9uVXBkYXRlJzt9fS8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKi9mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpe3JldHVybiBkb21FdmVudE5hbWU9PT0na2V5ZG93bicmJm5hdGl2ZUV2ZW50LmtleUNvZGU9PT1TVEFSVF9LRVlDT0RFO30vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKi9mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLG5hdGl2ZUV2ZW50KXtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2tleXVwJzovLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbnJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSE9PS0xO2Nhc2Una2V5ZG93bic6Ly8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG5yZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSE9PVNUQVJUX0tFWUNPREU7Y2FzZSdrZXlwcmVzcyc6Y2FzZSdtb3VzZWRvd24nOmNhc2UnZm9jdXNvdXQnOi8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG5yZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZTt9fS8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KXt2YXIgZGV0YWlsPW5hdGl2ZUV2ZW50LmRldGFpbDtpZih0eXBlb2YgZGV0YWlsPT09J29iamVjdCcmJidkYXRhJ2luIGRldGFpbCl7cmV0dXJuIGRldGFpbC5kYXRhO31yZXR1cm4gbnVsbDt9LyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvc2l0aW9uIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgS29yZWFuIElNRS5cbiAqIE91ciBmYWxsYmFjayBtb2RlIGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIElFJ3MgS29yZWFuIElNRSxcbiAqIHNvIGp1c3QgdXNlIG5hdGl2ZSBjb21wb3NpdGlvbiBldmVudHMgd2hlbiBLb3JlYW4gSU1FIGlzIHVzZWQuXG4gKiBBbHRob3VnaCBDb21wb3NpdGlvbkV2ZW50LmxvY2FsZSBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLFxuICogaXQgaXMgYXZhaWxhYmxlIGluIElFLCB3aGVyZSBvdXIgZmFsbGJhY2sgbW9kZSBpcyBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL2Z1bmN0aW9uIGlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpe3JldHVybiBuYXRpdmVFdmVudC5sb2NhbGU9PT0na28nO30vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3Npbmc9ZmFsc2U7LyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KXt2YXIgZXZlbnRUeXBlO3ZhciBmYWxsYmFja0RhdGE7aWYoY2FuVXNlQ29tcG9zaXRpb25FdmVudCl7ZXZlbnRUeXBlPWdldENvbXBvc2l0aW9uRXZlbnRUeXBlKGRvbUV2ZW50TmFtZSk7fWVsc2UgaWYoIWlzQ29tcG9zaW5nKXtpZihpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpKXtldmVudFR5cGU9J29uQ29tcG9zaXRpb25TdGFydCc7fX1lbHNlIGlmKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpKXtldmVudFR5cGU9J29uQ29tcG9zaXRpb25FbmQnO31pZighZXZlbnRUeXBlKXtyZXR1cm4gbnVsbDt9aWYodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEmJiFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSl7Ly8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4vLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG5pZighaXNDb21wb3NpbmcmJmV2ZW50VHlwZT09PSdvbkNvbXBvc2l0aW9uU3RhcnQnKXtpc0NvbXBvc2luZz1pbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTt9ZWxzZSBpZihldmVudFR5cGU9PT0nb25Db21wb3NpdGlvbkVuZCcpe2lmKGlzQ29tcG9zaW5nKXtmYWxsYmFja0RhdGE9Z2V0RGF0YSgpO319fXZhciBsaXN0ZW5lcnM9YWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsZXZlbnRUeXBlKTtpZihsaXN0ZW5lcnMubGVuZ3RoPjApe3ZhciBldmVudD1uZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChldmVudFR5cGUsZG9tRXZlbnROYW1lLG51bGwsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO2lmKGZhbGxiYWNrRGF0YSl7Ly8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4vLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuZXZlbnQuZGF0YT1mYWxsYmFja0RhdGE7fWVsc2V7dmFyIGN1c3RvbURhdGE9Z2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7aWYoY3VzdG9tRGF0YSE9PW51bGwpe2V2ZW50LmRhdGE9Y3VzdG9tRGF0YTt9fX19ZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpe3N3aXRjaChkb21FdmVudE5hbWUpe2Nhc2UnY29tcG9zaXRpb25lbmQnOnJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtjYXNlJ2tleXByZXNzJzovKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovdmFyIHdoaWNoPW5hdGl2ZUV2ZW50LndoaWNoO2lmKHdoaWNoIT09U1BBQ0VCQVJfQ09ERSl7cmV0dXJuIG51bGw7fWhhc1NwYWNlS2V5cHJlc3M9dHJ1ZTtyZXR1cm4gU1BBQ0VCQVJfQ0hBUjtjYXNlJ3RleHRJbnB1dCc6Ly8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG52YXIgY2hhcnM9bmF0aXZlRXZlbnQuZGF0YTsvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGlnbm9yZSBpdC5cbmlmKGNoYXJzPT09U1BBQ0VCQVJfQ0hBUiYmaGFzU3BhY2VLZXlwcmVzcyl7cmV0dXJuIG51bGw7fXJldHVybiBjaGFycztkZWZhdWx0Oi8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG5yZXR1cm4gbnVsbDt9fS8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL2Z1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpey8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbi8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbmlmKGlzQ29tcG9zaW5nKXtpZihkb21FdmVudE5hbWU9PT0nY29tcG9zaXRpb25lbmQnfHwhY2FuVXNlQ29tcG9zaXRpb25FdmVudCYmaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSxuYXRpdmVFdmVudCkpe3ZhciBjaGFycz1nZXREYXRhKCk7cmVzZXQoKTtpc0NvbXBvc2luZz1mYWxzZTtyZXR1cm4gY2hhcnM7fXJldHVybiBudWxsO31zd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ3Bhc3RlJzovLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4vLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG5yZXR1cm4gbnVsbDtjYXNlJ2tleXByZXNzJzovKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovaWYoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSl7Ly8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4vLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbi8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbi8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4vLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuLy8gdXNpbmcgYHdoaWNoYC5cbmlmKG5hdGl2ZUV2ZW50LmNoYXImJm5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoPjEpe3JldHVybiBuYXRpdmVFdmVudC5jaGFyO31lbHNlIGlmKG5hdGl2ZUV2ZW50LndoaWNoKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7fX1yZXR1cm4gbnVsbDtjYXNlJ2NvbXBvc2l0aW9uZW5kJzpyZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEmJiFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KT9udWxsOm5hdGl2ZUV2ZW50LmRhdGE7ZGVmYXVsdDpyZXR1cm4gbnVsbDt9fS8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL2Z1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpe3ZhciBjaGFycztpZihjYW5Vc2VUZXh0SW5wdXRFdmVudCl7Y2hhcnM9Z2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO31lbHNle2NoYXJzPWdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsbmF0aXZlRXZlbnQpO30vLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4vLyBiZSBmaXJlZC5cbmlmKCFjaGFycyl7cmV0dXJuIG51bGw7fXZhciBsaXN0ZW5lcnM9YWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsJ29uQmVmb3JlSW5wdXQnKTtpZihsaXN0ZW5lcnMubGVuZ3RoPjApe3ZhciBldmVudD1uZXcgU3ludGhldGljSW5wdXRFdmVudCgnb25CZWZvcmVJbnB1dCcsJ2JlZm9yZWlucHV0JyxudWxsLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50OmV2ZW50LGxpc3RlbmVyczpsaXN0ZW5lcnN9KTtldmVudC5kYXRhPWNoYXJzO319LyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0LGV2ZW50U3lzdGVtRmxhZ3MsdGFyZ2V0Q29udGFpbmVyKXtleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTt9LyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL3ZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzPXtjb2xvcjp0cnVlLGRhdGU6dHJ1ZSxkYXRldGltZTp0cnVlLCdkYXRldGltZS1sb2NhbCc6dHJ1ZSxlbWFpbDp0cnVlLG1vbnRoOnRydWUsbnVtYmVyOnRydWUscGFzc3dvcmQ6dHJ1ZSxyYW5nZTp0cnVlLHNlYXJjaDp0cnVlLHRlbDp0cnVlLHRleHQ6dHJ1ZSx0aW1lOnRydWUsdXJsOnRydWUsd2Vlazp0cnVlfTtmdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSl7dmFyIG5vZGVOYW1lPWVsZW0mJmVsZW0ubm9kZU5hbWUmJmVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihub2RlTmFtZT09PSdpbnB1dCcpe3JldHVybiEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO31pZihub2RlTmFtZT09PSd0ZXh0YXJlYScpe3JldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fS8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgpe2lmKCFjYW5Vc2VET00pe3JldHVybiBmYWxzZTt9dmFyIGV2ZW50TmFtZT0nb24nK2V2ZW50TmFtZVN1ZmZpeDt2YXIgaXNTdXBwb3J0ZWQ9KGV2ZW50TmFtZSBpbiBkb2N1bWVudCk7aWYoIWlzU3VwcG9ydGVkKXt2YXIgZWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsJ3JldHVybjsnKTtpc1N1cHBvcnRlZD10eXBlb2YgZWxlbWVudFtldmVudE5hbWVdPT09J2Z1bmN0aW9uJzt9cmV0dXJuIGlzU3VwcG9ydGVkO31mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQxKCl7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNoYW5nZScsWydjaGFuZ2UnLCdjbGljaycsJ2ZvY3VzaW4nLCdmb2N1c291dCcsJ2lucHV0Jywna2V5ZG93bicsJ2tleXVwJywnc2VsZWN0aW9uY2hhbmdlJ10pO31mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSxpbnN0LG5hdGl2ZUV2ZW50LHRhcmdldCl7Ly8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO3ZhciBsaXN0ZW5lcnM9YWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGluc3QsJ29uQ2hhbmdlJyk7aWYobGlzdGVuZXJzLmxlbmd0aD4wKXt2YXIgZXZlbnQ9bmV3IFN5bnRoZXRpY0V2ZW50KCdvbkNoYW5nZScsJ2NoYW5nZScsbnVsbCxuYXRpdmVFdmVudCx0YXJnZXQpO2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO319LyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL3ZhciBhY3RpdmVFbGVtZW50PW51bGw7dmFyIGFjdGl2ZUVsZW1lbnRJbnN0PW51bGw7LyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL2Z1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pe3ZhciBub2RlTmFtZT1lbGVtLm5vZGVOYW1lJiZlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG5vZGVOYW1lPT09J3NlbGVjdCd8fG5vZGVOYW1lPT09J2lucHV0JyYmZWxlbS50eXBlPT09J2ZpbGUnO31mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KXt2YXIgZGlzcGF0Y2hRdWV1ZT1bXTtjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSxhY3RpdmVFbGVtZW50SW5zdCxuYXRpdmVFdmVudCxnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpOy8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4vLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4vLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbi8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuLy9cbi8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbi8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4vLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbi8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCxkaXNwYXRjaFF1ZXVlKTt9ZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpe3Byb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsMCk7fWZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KXt2YXIgdGFyZ2V0Tm9kZT1nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO2lmKHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKHRhcmdldE5vZGUpKXtyZXR1cm4gdGFyZ2V0SW5zdDt9fWZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2NoYW5nZScpe3JldHVybiB0YXJnZXRJbnN0O319LyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovdmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZD1mYWxzZTtpZihjYW5Vc2VET00pey8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG5pc0lucHV0RXZlbnRTdXBwb3J0ZWQ9aXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fGRvY3VtZW50LmRvY3VtZW50TW9kZT45KTt9LyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL2Z1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsdGFyZ2V0SW5zdCl7YWN0aXZlRWxlbWVudD10YXJnZXQ7YWN0aXZlRWxlbWVudEluc3Q9dGFyZ2V0SW5zdDthY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJyxoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7fS8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL2Z1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCl7aWYoIWFjdGl2ZUVsZW1lbnQpe3JldHVybjt9YWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsaGFuZGxlUHJvcGVydHlDaGFuZ2UpO2FjdGl2ZUVsZW1lbnQ9bnVsbDthY3RpdmVFbGVtZW50SW5zdD1udWxsO30vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL2Z1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KXtpZihuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUhPT0ndmFsdWUnKXtyZXR1cm47fWlmKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpe21hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO319ZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSx0YXJnZXQsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2ZvY3VzaW4nKXsvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4vLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4vLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbi8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4vL1xuLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93Llxuc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LHRhcmdldEluc3QpO31lbHNlIGlmKGRvbUV2ZW50TmFtZT09PSdmb2N1c291dCcpe3N0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7fX0vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0KXtpZihkb21FdmVudE5hbWU9PT0nc2VsZWN0aW9uY2hhbmdlJ3x8ZG9tRXZlbnROYW1lPT09J2tleXVwJ3x8ZG9tRXZlbnROYW1lPT09J2tleWRvd24nKXsvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3Rcbi8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuLy9cbi8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbi8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4vLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4vLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4vLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbi8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4vLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbnJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO319LyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKXsvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbi8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4vLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxudmFyIG5vZGVOYW1lPWVsZW0ubm9kZU5hbWU7cmV0dXJuIG5vZGVOYW1lJiZub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09J2lucHV0JyYmKGVsZW0udHlwZT09PSdjaGVja2JveCd8fGVsZW0udHlwZT09PSdyYWRpbycpO31mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCl7aWYoZG9tRXZlbnROYW1lPT09J2NsaWNrJyl7cmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTt9fWZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLHRhcmdldEluc3Qpe2lmKGRvbUV2ZW50TmFtZT09PSdpbnB1dCd8fGRvbUV2ZW50TmFtZT09PSdjaGFuZ2UnKXtyZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO319ZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKXt2YXIgc3RhdGU9bm9kZS5fd3JhcHBlclN0YXRlO2lmKCFzdGF0ZXx8IXN0YXRlLmNvbnRyb2xsZWR8fG5vZGUudHlwZSE9PSdudW1iZXInKXtyZXR1cm47fXsvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG5zZXREZWZhdWx0VmFsdWUobm9kZSwnbnVtYmVyJyxub2RlLnZhbHVlKTt9fS8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcil7dmFyIHRhcmdldE5vZGU9dGFyZ2V0SW5zdD9nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpOndpbmRvdzt2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsaGFuZGxlRXZlbnRGdW5jO2lmKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKXtnZXRUYXJnZXRJbnN0RnVuYz1nZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7fWVsc2UgaWYoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKXtpZihpc0lucHV0RXZlbnRTdXBwb3J0ZWQpe2dldFRhcmdldEluc3RGdW5jPWdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7fWVsc2V7Z2V0VGFyZ2V0SW5zdEZ1bmM9Z2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtoYW5kbGVFdmVudEZ1bmM9aGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsO319ZWxzZSBpZihzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKXtnZXRUYXJnZXRJbnN0RnVuYz1nZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDt9aWYoZ2V0VGFyZ2V0SW5zdEZ1bmMpe3ZhciBpbnN0PWdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0KTtpZihpbnN0KXtjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSxpbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtyZXR1cm47fX1pZihoYW5kbGVFdmVudEZ1bmMpe2hhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsdGFyZ2V0Tm9kZSx0YXJnZXRJbnN0KTt9Ly8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbmlmKGRvbUV2ZW50TmFtZT09PSdmb2N1c291dCcpe2hhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7fX1mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQyKCl7cmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUVudGVyJyxbJ21vdXNlb3V0JywnbW91c2VvdmVyJ10pO3JlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uTW91c2VMZWF2ZScsWydtb3VzZW91dCcsJ21vdXNlb3ZlciddKTtyZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJFbnRlcicsWydwb2ludGVyb3V0JywncG9pbnRlcm92ZXInXSk7cmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Qb2ludGVyTGVhdmUnLFsncG9pbnRlcm91dCcsJ3BvaW50ZXJvdmVyJ10pO30vKipcbiAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gKi9mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzLHRhcmdldENvbnRhaW5lcil7dmFyIGlzT3ZlckV2ZW50PWRvbUV2ZW50TmFtZT09PSdtb3VzZW92ZXInfHxkb21FdmVudE5hbWU9PT0ncG9pbnRlcm92ZXInO3ZhciBpc091dEV2ZW50PWRvbUV2ZW50TmFtZT09PSdtb3VzZW91dCd8fGRvbUV2ZW50TmFtZT09PSdwb2ludGVyb3V0JztpZihpc092ZXJFdmVudCYmIWlzUmVwbGF5aW5nRXZlbnQobmF0aXZlRXZlbnQpKXsvLyBJZiB0aGlzIGlzIGFuIG92ZXIgZXZlbnQgd2l0aCBhIHRhcmdldCwgd2UgbWlnaHQgaGF2ZSBhbHJlYWR5IGRpc3BhdGNoZWRcbi8vIHRoZSBldmVudCBpbiB0aGUgb3V0IGV2ZW50IG9mIHRoZSBvdGhlciB0YXJnZXQuIElmIHRoaXMgaXMgcmVwbGF5ZWQsXG4vLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbi8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgbm93IGluc3RlYWQuXG52YXIgcmVsYXRlZD1uYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0fHxuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtpZihyZWxhdGVkKXsvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4vLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG5pZihnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKXx8aXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpe3JldHVybjt9fX1pZighaXNPdXRFdmVudCYmIWlzT3ZlckV2ZW50KXsvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG5yZXR1cm47fXZhciB3aW47Ly8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5pZihuYXRpdmVFdmVudFRhcmdldC53aW5kb3c9PT1uYXRpdmVFdmVudFRhcmdldCl7Ly8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG53aW49bmF0aXZlRXZlbnRUYXJnZXQ7fWVsc2V7Ly8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxudmFyIGRvYz1uYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O2lmKGRvYyl7d2luPWRvYy5kZWZhdWx0Vmlld3x8ZG9jLnBhcmVudFdpbmRvdzt9ZWxzZXt3aW49d2luZG93O319dmFyIGZyb207dmFyIHRvO2lmKGlzT3V0RXZlbnQpe3ZhciBfcmVsYXRlZD1uYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0fHxuYXRpdmVFdmVudC50b0VsZW1lbnQ7ZnJvbT10YXJnZXRJbnN0O3RvPV9yZWxhdGVkP2dldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKF9yZWxhdGVkKTpudWxsO2lmKHRvIT09bnVsbCl7dmFyIG5lYXJlc3RNb3VudGVkPWdldE5lYXJlc3RNb3VudGVkRmliZXIodG8pO2lmKHRvIT09bmVhcmVzdE1vdW50ZWR8fHRvLnRhZyE9PUhvc3RDb21wb25lbnQmJnRvLnRhZyE9PUhvc3RUZXh0KXt0bz1udWxsO319fWVsc2V7Ly8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbmZyb209bnVsbDt0bz10YXJnZXRJbnN0O31pZihmcm9tPT09dG8pey8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbnJldHVybjt9dmFyIFN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNNb3VzZUV2ZW50O3ZhciBsZWF2ZUV2ZW50VHlwZT0nb25Nb3VzZUxlYXZlJzt2YXIgZW50ZXJFdmVudFR5cGU9J29uTW91c2VFbnRlcic7dmFyIGV2ZW50VHlwZVByZWZpeD0nbW91c2UnO2lmKGRvbUV2ZW50TmFtZT09PSdwb2ludGVyb3V0J3x8ZG9tRXZlbnROYW1lPT09J3BvaW50ZXJvdmVyJyl7U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1BvaW50ZXJFdmVudDtsZWF2ZUV2ZW50VHlwZT0nb25Qb2ludGVyTGVhdmUnO2VudGVyRXZlbnRUeXBlPSdvblBvaW50ZXJFbnRlcic7ZXZlbnRUeXBlUHJlZml4PSdwb2ludGVyJzt9dmFyIGZyb21Ob2RlPWZyb209PW51bGw/d2luOmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7dmFyIHRvTm9kZT10bz09bnVsbD93aW46Z2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7dmFyIGxlYXZlPW5ldyBTeW50aGV0aWNFdmVudEN0b3IobGVhdmVFdmVudFR5cGUsZXZlbnRUeXBlUHJlZml4KydsZWF2ZScsZnJvbSxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7bGVhdmUudGFyZ2V0PWZyb21Ob2RlO2xlYXZlLnJlbGF0ZWRUYXJnZXQ9dG9Ob2RlO3ZhciBlbnRlcj1udWxsOy8vIFdlIHNob3VsZCBvbmx5IHByb2Nlc3MgdGhpcyBuYXRpdmVFdmVudCBpZiB3ZSBhcmUgcHJvY2Vzc2luZ1xuLy8gdGhlIGZpcnN0IGFuY2VzdG9yLiBOZXh0IHRpbWUsIHdlIHdpbGwgaWdub3JlIHRoZSBldmVudC5cbnZhciBuYXRpdmVUYXJnZXRJbnN0PWdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtpZihuYXRpdmVUYXJnZXRJbnN0PT09dGFyZ2V0SW5zdCl7dmFyIGVudGVyRXZlbnQ9bmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihlbnRlckV2ZW50VHlwZSxldmVudFR5cGVQcmVmaXgrJ2VudGVyJyx0byxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZW50ZXJFdmVudC50YXJnZXQ9dG9Ob2RlO2VudGVyRXZlbnQucmVsYXRlZFRhcmdldD1mcm9tTm9kZTtlbnRlcj1lbnRlckV2ZW50O31hY2N1bXVsYXRlRW50ZXJMZWF2ZVR3b1BoYXNlTGlzdGVuZXJzKGRpc3BhdGNoUXVldWUsbGVhdmUsZW50ZXIsZnJvbSx0byk7fS8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9mdW5jdGlvbiBpcyh4LHkpe3JldHVybiB4PT09eSYmKHghPT0wfHwxL3g9PT0xL3kpfHx4IT09eCYmeSE9PXkvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuO312YXIgb2JqZWN0SXM9dHlwZW9mIE9iamVjdC5pcz09PSdmdW5jdGlvbic/T2JqZWN0LmlzOmlzOy8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL2Z1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLG9iakIpe2lmKG9iamVjdElzKG9iakEsb2JqQikpe3JldHVybiB0cnVlO31pZih0eXBlb2Ygb2JqQSE9PSdvYmplY3QnfHxvYmpBPT09bnVsbHx8dHlwZW9mIG9iakIhPT0nb2JqZWN0J3x8b2JqQj09PW51bGwpe3JldHVybiBmYWxzZTt9dmFyIGtleXNBPU9iamVjdC5rZXlzKG9iakEpO3ZhciBrZXlzQj1PYmplY3Qua2V5cyhvYmpCKTtpZihrZXlzQS5sZW5ndGghPT1rZXlzQi5sZW5ndGgpe3JldHVybiBmYWxzZTt9Ly8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbmZvcih2YXIgaT0wO2k8a2V5c0EubGVuZ3RoO2krKyl7dmFyIGN1cnJlbnRLZXk9a2V5c0FbaV07aWYoIWhhc093blByb3BlcnR5LmNhbGwob2JqQixjdXJyZW50S2V5KXx8IW9iamVjdElzKG9iakFbY3VycmVudEtleV0sb2JqQltjdXJyZW50S2V5XSkpe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO30vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSl7d2hpbGUobm9kZSYmbm9kZS5maXJzdENoaWxkKXtub2RlPW5vZGUuZmlyc3RDaGlsZDt9cmV0dXJuIG5vZGU7fS8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKXt3aGlsZShub2RlKXtpZihub2RlLm5leHRTaWJsaW5nKXtyZXR1cm4gbm9kZS5uZXh0U2libGluZzt9bm9kZT1ub2RlLnBhcmVudE5vZGU7fX0vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3Qsb2Zmc2V0KXt2YXIgbm9kZT1nZXRMZWFmTm9kZShyb290KTt2YXIgbm9kZVN0YXJ0PTA7dmFyIG5vZGVFbmQ9MDt3aGlsZShub2RlKXtpZihub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFKXtub2RlRW5kPW5vZGVTdGFydCtub2RlLnRleHRDb250ZW50Lmxlbmd0aDtpZihub2RlU3RhcnQ8PW9mZnNldCYmbm9kZUVuZD49b2Zmc2V0KXtyZXR1cm57bm9kZTpub2RlLG9mZnNldDpvZmZzZXQtbm9kZVN0YXJ0fTt9bm9kZVN0YXJ0PW5vZGVFbmQ7fW5vZGU9Z2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO319LyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL2Z1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKXt2YXIgb3duZXJEb2N1bWVudD1vdXRlck5vZGUub3duZXJEb2N1bWVudDt2YXIgd2luPW93bmVyRG9jdW1lbnQmJm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdzt2YXIgc2VsZWN0aW9uPXdpbi5nZXRTZWxlY3Rpb24mJndpbi5nZXRTZWxlY3Rpb24oKTtpZighc2VsZWN0aW9ufHxzZWxlY3Rpb24ucmFuZ2VDb3VudD09PTApe3JldHVybiBudWxsO312YXIgYW5jaG9yTm9kZT1zZWxlY3Rpb24uYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ9c2VsZWN0aW9uLmFuY2hvck9mZnNldCxmb2N1c05vZGU9c2VsZWN0aW9uLmZvY3VzTm9kZSxmb2N1c09mZnNldD1zZWxlY3Rpb24uZm9jdXNPZmZzZXQ7Ly8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4vLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4vLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4vLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbi8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG50cnl7LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovYW5jaG9yTm9kZS5ub2RlVHlwZTtmb2N1c05vZGUubm9kZVR5cGU7LyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi99Y2F0Y2goZSl7cmV0dXJuIG51bGw7fXJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQsZm9jdXNOb2RlLGZvY3VzT2Zmc2V0KTt9LyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQsZm9jdXNOb2RlLGZvY3VzT2Zmc2V0KXt2YXIgbGVuZ3RoPTA7dmFyIHN0YXJ0PS0xO3ZhciBlbmQ9LTE7dmFyIGluZGV4V2l0aGluQW5jaG9yPTA7dmFyIGluZGV4V2l0aGluRm9jdXM9MDt2YXIgbm9kZT1vdXRlck5vZGU7dmFyIHBhcmVudE5vZGU9bnVsbDtvdXRlcjp3aGlsZSh0cnVlKXt2YXIgbmV4dD1udWxsO3doaWxlKHRydWUpe2lmKG5vZGU9PT1hbmNob3JOb2RlJiYoYW5jaG9yT2Zmc2V0PT09MHx8bm9kZS5ub2RlVHlwZT09PVRFWFRfTk9ERSkpe3N0YXJ0PWxlbmd0aCthbmNob3JPZmZzZXQ7fWlmKG5vZGU9PT1mb2N1c05vZGUmJihmb2N1c09mZnNldD09PTB8fG5vZGUubm9kZVR5cGU9PT1URVhUX05PREUpKXtlbmQ9bGVuZ3RoK2ZvY3VzT2Zmc2V0O31pZihub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFKXtsZW5ndGgrPW5vZGUubm9kZVZhbHVlLmxlbmd0aDt9aWYoKG5leHQ9bm9kZS5maXJzdENoaWxkKT09PW51bGwpe2JyZWFrO30vLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbnBhcmVudE5vZGU9bm9kZTtub2RlPW5leHQ7fXdoaWxlKHRydWUpe2lmKG5vZGU9PT1vdXRlck5vZGUpey8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4vLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbi8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbi8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbmJyZWFrIG91dGVyO31pZihwYXJlbnROb2RlPT09YW5jaG9yTm9kZSYmKytpbmRleFdpdGhpbkFuY2hvcj09PWFuY2hvck9mZnNldCl7c3RhcnQ9bGVuZ3RoO31pZihwYXJlbnROb2RlPT09Zm9jdXNOb2RlJiYrK2luZGV4V2l0aGluRm9jdXM9PT1mb2N1c09mZnNldCl7ZW5kPWxlbmd0aDt9aWYoKG5leHQ9bm9kZS5uZXh0U2libGluZykhPT1udWxsKXticmVhazt9bm9kZT1wYXJlbnROb2RlO3BhcmVudE5vZGU9bm9kZS5wYXJlbnROb2RlO30vLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG5ub2RlPW5leHQ7fWlmKHN0YXJ0PT09LTF8fGVuZD09PS0xKXsvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3Rcbi8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxucmV0dXJuIG51bGw7fXJldHVybntzdGFydDpzdGFydCxlbmQ6ZW5kfTt9LyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsb2Zmc2V0cyl7dmFyIGRvYz1ub2RlLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50O3ZhciB3aW49ZG9jJiZkb2MuZGVmYXVsdFZpZXd8fHdpbmRvdzsvLyBFZGdlIGZhaWxzIHdpdGggXCJPYmplY3QgZXhwZWN0ZWRcIiBpbiBzb21lIHNjZW5hcmlvcy5cbi8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4vLyBmYWlscyB3aGVuIHBhc3RpbmcgMTAwKyBpdGVtcylcbmlmKCF3aW4uZ2V0U2VsZWN0aW9uKXtyZXR1cm47fXZhciBzZWxlY3Rpb249d2luLmdldFNlbGVjdGlvbigpO3ZhciBsZW5ndGg9bm9kZS50ZXh0Q29udGVudC5sZW5ndGg7dmFyIHN0YXJ0PU1hdGgubWluKG9mZnNldHMuc3RhcnQsbGVuZ3RoKTt2YXIgZW5kPW9mZnNldHMuZW5kPT09dW5kZWZpbmVkP3N0YXJ0Ok1hdGgubWluKG9mZnNldHMuZW5kLGxlbmd0aCk7Ly8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG5pZighc2VsZWN0aW9uLmV4dGVuZCYmc3RhcnQ+ZW5kKXt2YXIgdGVtcD1lbmQ7ZW5kPXN0YXJ0O3N0YXJ0PXRlbXA7fXZhciBzdGFydE1hcmtlcj1nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsc3RhcnQpO3ZhciBlbmRNYXJrZXI9Z2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLGVuZCk7aWYoc3RhcnRNYXJrZXImJmVuZE1hcmtlcil7aWYoc2VsZWN0aW9uLnJhbmdlQ291bnQ9PT0xJiZzZWxlY3Rpb24uYW5jaG9yTm9kZT09PXN0YXJ0TWFya2VyLm5vZGUmJnNlbGVjdGlvbi5hbmNob3JPZmZzZXQ9PT1zdGFydE1hcmtlci5vZmZzZXQmJnNlbGVjdGlvbi5mb2N1c05vZGU9PT1lbmRNYXJrZXIubm9kZSYmc2VsZWN0aW9uLmZvY3VzT2Zmc2V0PT09ZW5kTWFya2VyLm9mZnNldCl7cmV0dXJuO312YXIgcmFuZ2U9ZG9jLmNyZWF0ZVJhbmdlKCk7cmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSxzdGFydE1hcmtlci5vZmZzZXQpO3NlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtpZihzdGFydD5lbmQpe3NlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7c2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSxlbmRNYXJrZXIub2Zmc2V0KTt9ZWxzZXtyYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsZW5kTWFya2VyLm9mZnNldCk7c2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTt9fX1mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpe3JldHVybiBub2RlJiZub2RlLm5vZGVUeXBlPT09VEVYVF9OT0RFO31mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLGlubmVyTm9kZSl7aWYoIW91dGVyTm9kZXx8IWlubmVyTm9kZSl7cmV0dXJuIGZhbHNlO31lbHNlIGlmKG91dGVyTm9kZT09PWlubmVyTm9kZSl7cmV0dXJuIHRydWU7fWVsc2UgaWYoaXNUZXh0Tm9kZShvdXRlck5vZGUpKXtyZXR1cm4gZmFsc2U7fWVsc2UgaWYoaXNUZXh0Tm9kZShpbm5lck5vZGUpKXtyZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSxpbm5lck5vZGUucGFyZW50Tm9kZSk7fWVsc2UgaWYoJ2NvbnRhaW5zJ2luIG91dGVyTm9kZSl7cmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO31lbHNlIGlmKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbil7cmV0dXJuISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkmMTYpO31lbHNle3JldHVybiBmYWxzZTt9fWZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKXtyZXR1cm4gbm9kZSYmbm9kZS5vd25lckRvY3VtZW50JiZjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxub2RlKTt9ZnVuY3Rpb24gaXNTYW1lT3JpZ2luRnJhbWUoaWZyYW1lKXt0cnl7Ly8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbi8vIHRvIHRocm93LCBlLmcuIGlmIGl0IGhhcyBhIGNyb3NzLW9yaWdpbiBzcmMgYXR0cmlidXRlLlxuLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4vLyBpZnJhbWUuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuLy8gQSBzYWZldHkgd2F5IGlzIHRvIGFjY2VzcyBvbmUgb2YgdGhlIGNyb3NzIG9yaWdpbiBwcm9wZXJ0aWVzOiBXaW5kb3cgb3IgTG9jYXRpb25cbi8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjaW50ZWdyYXRpb24td2l0aC1pZGxcbnJldHVybiB0eXBlb2YgaWZyYW1lLmNvbnRlbnRXaW5kb3cubG9jYXRpb24uaHJlZj09PSdzdHJpbmcnO31jYXRjaChlcnIpe3JldHVybiBmYWxzZTt9fWZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCl7dmFyIHdpbj13aW5kb3c7dmFyIGVsZW1lbnQ9Z2V0QWN0aXZlRWxlbWVudCgpO3doaWxlKGVsZW1lbnQgaW5zdGFuY2VvZiB3aW4uSFRNTElGcmFtZUVsZW1lbnQpe2lmKGlzU2FtZU9yaWdpbkZyYW1lKGVsZW1lbnQpKXt3aW49ZWxlbWVudC5jb250ZW50V2luZG93O31lbHNle3JldHVybiBlbGVtZW50O31lbGVtZW50PWdldEFjdGl2ZUVsZW1lbnQod2luLmRvY3VtZW50KTt9cmV0dXJuIGVsZW1lbnQ7fS8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovIC8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pe3ZhciBub2RlTmFtZT1lbGVtJiZlbGVtLm5vZGVOYW1lJiZlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG5vZGVOYW1lJiYobm9kZU5hbWU9PT0naW5wdXQnJiYoZWxlbS50eXBlPT09J3RleHQnfHxlbGVtLnR5cGU9PT0nc2VhcmNoJ3x8ZWxlbS50eXBlPT09J3RlbCd8fGVsZW0udHlwZT09PSd1cmwnfHxlbGVtLnR5cGU9PT0ncGFzc3dvcmQnKXx8bm9kZU5hbWU9PT0ndGV4dGFyZWEnfHxlbGVtLmNvbnRlbnRFZGl0YWJsZT09PSd0cnVlJyk7fWZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCl7dmFyIGZvY3VzZWRFbGVtPWdldEFjdGl2ZUVsZW1lbnREZWVwKCk7cmV0dXJue2ZvY3VzZWRFbGVtOmZvY3VzZWRFbGVtLHNlbGVjdGlvblJhbmdlOmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSk/Z2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKTpudWxsfTt9LyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pe3ZhciBjdXJGb2N1c2VkRWxlbT1nZXRBY3RpdmVFbGVtZW50RGVlcCgpO3ZhciBwcmlvckZvY3VzZWRFbGVtPXByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07dmFyIHByaW9yU2VsZWN0aW9uUmFuZ2U9cHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtpZihjdXJGb2N1c2VkRWxlbSE9PXByaW9yRm9jdXNlZEVsZW0mJmlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSl7aWYocHJpb3JTZWxlY3Rpb25SYW5nZSE9PW51bGwmJmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSl7c2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0scHJpb3JTZWxlY3Rpb25SYW5nZSk7fS8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG52YXIgYW5jZXN0b3JzPVtdO3ZhciBhbmNlc3Rvcj1wcmlvckZvY3VzZWRFbGVtO3doaWxlKGFuY2VzdG9yPWFuY2VzdG9yLnBhcmVudE5vZGUpe2lmKGFuY2VzdG9yLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFKXthbmNlc3RvcnMucHVzaCh7ZWxlbWVudDphbmNlc3RvcixsZWZ0OmFuY2VzdG9yLnNjcm9sbExlZnQsdG9wOmFuY2VzdG9yLnNjcm9sbFRvcH0pO319aWYodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXM9PT0nZnVuY3Rpb24nKXtwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7fWZvcih2YXIgaT0wO2k8YW5jZXN0b3JzLmxlbmd0aDtpKyspe3ZhciBpbmZvPWFuY2VzdG9yc1tpXTtpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdD1pbmZvLmxlZnQ7aW5mby5lbGVtZW50LnNjcm9sbFRvcD1pbmZvLnRvcDt9fX0vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9mdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpe3ZhciBzZWxlY3Rpb247aWYoJ3NlbGVjdGlvblN0YXJ0J2luIGlucHV0KXsvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuc2VsZWN0aW9uPXtzdGFydDppbnB1dC5zZWxlY3Rpb25TdGFydCxlbmQ6aW5wdXQuc2VsZWN0aW9uRW5kfTt9ZWxzZXsvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbnNlbGVjdGlvbj1nZXRPZmZzZXRzKGlucHV0KTt9cmV0dXJuIHNlbGVjdGlvbnx8e3N0YXJ0OjAsZW5kOjB9O30vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LG9mZnNldHMpe3ZhciBzdGFydD1vZmZzZXRzLnN0YXJ0O3ZhciBlbmQ9b2Zmc2V0cy5lbmQ7aWYoZW5kPT09dW5kZWZpbmVkKXtlbmQ9c3RhcnQ7fWlmKCdzZWxlY3Rpb25TdGFydCdpbiBpbnB1dCl7aW5wdXQuc2VsZWN0aW9uU3RhcnQ9c3RhcnQ7aW5wdXQuc2VsZWN0aW9uRW5kPU1hdGgubWluKGVuZCxpbnB1dC52YWx1ZS5sZW5ndGgpO31lbHNle3NldE9mZnNldHMoaW5wdXQsb2Zmc2V0cyk7fX12YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50PWNhblVzZURPTSYmJ2RvY3VtZW50TW9kZSdpbiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRNb2RlPD0xMTtmdW5jdGlvbiByZWdpc3RlckV2ZW50cyQzKCl7cmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvblNlbGVjdCcsWydmb2N1c291dCcsJ2NvbnRleHRtZW51JywnZHJhZ2VuZCcsJ2ZvY3VzaW4nLCdrZXlkb3duJywna2V5dXAnLCdtb3VzZWRvd24nLCdtb3VzZXVwJywnc2VsZWN0aW9uY2hhbmdlJ10pO312YXIgYWN0aXZlRWxlbWVudCQxPW51bGw7dmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDE9bnVsbDt2YXIgbGFzdFNlbGVjdGlvbj1udWxsO3ZhciBtb3VzZURvd249ZmFsc2U7LyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICovZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEobm9kZSl7aWYoJ3NlbGVjdGlvblN0YXJ0J2luIG5vZGUmJmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSl7cmV0dXJue3N0YXJ0Om5vZGUuc2VsZWN0aW9uU3RhcnQsZW5kOm5vZGUuc2VsZWN0aW9uRW5kfTt9ZWxzZXt2YXIgd2luPW5vZGUub3duZXJEb2N1bWVudCYmbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3c7dmFyIHNlbGVjdGlvbj13aW4uZ2V0U2VsZWN0aW9uKCk7cmV0dXJue2FuY2hvck5vZGU6c2VsZWN0aW9uLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OnNlbGVjdGlvbi5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOnNlbGVjdGlvbi5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6c2VsZWN0aW9uLmZvY3VzT2Zmc2V0fTt9fS8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICovZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCl7cmV0dXJuIGV2ZW50VGFyZ2V0LndpbmRvdz09PWV2ZW50VGFyZ2V0P2V2ZW50VGFyZ2V0LmRvY3VtZW50OmV2ZW50VGFyZ2V0Lm5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERT9ldmVudFRhcmdldDpldmVudFRhcmdldC5vd25lckRvY3VtZW50O30vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCl7Ly8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4vLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4vLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4vLyB3b24ndCBkaXNwYXRjaC5cbnZhciBkb2M9Z2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7aWYobW91c2VEb3dufHxhY3RpdmVFbGVtZW50JDE9PW51bGx8fGFjdGl2ZUVsZW1lbnQkMSE9PWdldEFjdGl2ZUVsZW1lbnQoZG9jKSl7cmV0dXJuO30vLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG52YXIgY3VycmVudFNlbGVjdGlvbj1nZXRTZWxlY3Rpb24kMShhY3RpdmVFbGVtZW50JDEpO2lmKCFsYXN0U2VsZWN0aW9ufHwhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sY3VycmVudFNlbGVjdGlvbikpe2xhc3RTZWxlY3Rpb249Y3VycmVudFNlbGVjdGlvbjt2YXIgbGlzdGVuZXJzPWFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCQxLCdvblNlbGVjdCcpO2lmKGxpc3RlbmVycy5sZW5ndGg+MCl7dmFyIGV2ZW50PW5ldyBTeW50aGV0aWNFdmVudCgnb25TZWxlY3QnLCdzZWxlY3QnLG51bGwsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO2V2ZW50LnRhcmdldD1hY3RpdmVFbGVtZW50JDE7fX19LyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpe3ZhciB0YXJnZXROb2RlPXRhcmdldEluc3Q/Z2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KTp3aW5kb3c7c3dpdGNoKGRvbUV2ZW50TmFtZSl7Ly8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG5jYXNlJ2ZvY3VzaW4nOmlmKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKXx8dGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGU9PT0ndHJ1ZScpe2FjdGl2ZUVsZW1lbnQkMT10YXJnZXROb2RlO2FjdGl2ZUVsZW1lbnRJbnN0JDE9dGFyZ2V0SW5zdDtsYXN0U2VsZWN0aW9uPW51bGw7fWJyZWFrO2Nhc2UnZm9jdXNvdXQnOmFjdGl2ZUVsZW1lbnQkMT1udWxsO2FjdGl2ZUVsZW1lbnRJbnN0JDE9bnVsbDtsYXN0U2VsZWN0aW9uPW51bGw7YnJlYWs7Ly8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbi8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbmNhc2UnbW91c2Vkb3duJzptb3VzZURvd249dHJ1ZTticmVhaztjYXNlJ2NvbnRleHRtZW51JzpjYXNlJ21vdXNldXAnOmNhc2UnZHJhZ2VuZCc6bW91c2VEb3duPWZhbHNlO2NvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2JyZWFrOy8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4vLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3Rcbi8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuLy9cbi8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbi8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4vLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbi8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbmNhc2Unc2VsZWN0aW9uY2hhbmdlJzppZihza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpe2JyZWFrO30vLyBmYWxscyB0aHJvdWdoXG5jYXNlJ2tleWRvd24nOmNhc2Una2V5dXAnOmNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO319LyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCxldmVudE5hbWUpe3ZhciBwcmVmaXhlcz17fTtwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV09ZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7cHJlZml4ZXNbJ1dlYmtpdCcrc3R5bGVQcm9wXT0nd2Via2l0JytldmVudE5hbWU7cHJlZml4ZXNbJ01veicrc3R5bGVQcm9wXT0nbW96JytldmVudE5hbWU7cmV0dXJuIHByZWZpeGVzO30vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL3ZhciB2ZW5kb3JQcmVmaXhlcz17YW5pbWF0aW9uZW5kOm1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsJ0FuaW1hdGlvbkVuZCcpLGFuaW1hdGlvbml0ZXJhdGlvbjptYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCdBbmltYXRpb25JdGVyYXRpb24nKSxhbmltYXRpb25zdGFydDptYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCdBbmltYXRpb25TdGFydCcpLHRyYW5zaXRpb25lbmQ6bWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsJ1RyYW5zaXRpb25FbmQnKX07LyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi92YXIgcHJlZml4ZWRFdmVudE5hbWVzPXt9Oy8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi92YXIgc3R5bGU9e307LyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovaWYoY2FuVXNlRE9NKXtzdHlsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTsvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4vLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbi8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5pZighKCdBbmltYXRpb25FdmVudCdpbiB3aW5kb3cpKXtkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO30vLyBTYW1lIGFzIGFib3ZlXG5pZighKCdUcmFuc2l0aW9uRXZlbnQnaW4gd2luZG93KSl7ZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjt9fS8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpe2lmKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKXtyZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07fWVsc2UgaWYoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pe3JldHVybiBldmVudE5hbWU7fXZhciBwcmVmaXhNYXA9dmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtmb3IodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApe2lmKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApJiZzdHlsZVByb3AgaW4gc3R5bGUpe3JldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXT1wcmVmaXhNYXBbc3R5bGVQcm9wXTt9fXJldHVybiBldmVudE5hbWU7fXZhciBBTklNQVRJT05fRU5EPWdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKTt2YXIgQU5JTUFUSU9OX0lURVJBVElPTj1nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7dmFyIEFOSU1BVElPTl9TVEFSVD1nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKTt2YXIgVFJBTlNJVElPTl9FTkQ9Z2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKTt2YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXM9bmV3IE1hcCgpOy8vIE5PVEU6IENhcGl0YWxpemF0aW9uIGlzIGltcG9ydGFudCBpbiB0aGlzIGxpc3QhXG4vL1xuLy8gRS5nLiBpdCBuZWVkcyBcInBvaW50ZXJEb3duXCIsIG5vdCBcInBvaW50ZXJkb3duXCIuXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2UgZGVyaXZlIGJvdGggUmVhY3QgbmFtZSAoXCJvblBvaW50ZXJEb3duXCIpXG4vLyBhbmQgRE9NIG5hbWUgKFwicG9pbnRlcmRvd25cIikgZnJvbSB0aGUgc2FtZSBsaXN0LlxuLy9cbi8vIEV4Y2VwdGlvbnMgdGhhdCBkb24ndCBtYXRjaCB0aGlzIGNvbnZlbnRpb24gYXJlIGxpc3RlZCBzZXBhcmF0ZWx5LlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzPVsnYWJvcnQnLCdhdXhDbGljaycsJ2NhbmNlbCcsJ2NhblBsYXknLCdjYW5QbGF5VGhyb3VnaCcsJ2NsaWNrJywnY2xvc2UnLCdjb250ZXh0TWVudScsJ2NvcHknLCdjdXQnLCdkcmFnJywnZHJhZ0VuZCcsJ2RyYWdFbnRlcicsJ2RyYWdFeGl0JywnZHJhZ0xlYXZlJywnZHJhZ092ZXInLCdkcmFnU3RhcnQnLCdkcm9wJywnZHVyYXRpb25DaGFuZ2UnLCdlbXB0aWVkJywnZW5jcnlwdGVkJywnZW5kZWQnLCdlcnJvcicsJ2dvdFBvaW50ZXJDYXB0dXJlJywnaW5wdXQnLCdpbnZhbGlkJywna2V5RG93bicsJ2tleVByZXNzJywna2V5VXAnLCdsb2FkJywnbG9hZGVkRGF0YScsJ2xvYWRlZE1ldGFkYXRhJywnbG9hZFN0YXJ0JywnbG9zdFBvaW50ZXJDYXB0dXJlJywnbW91c2VEb3duJywnbW91c2VNb3ZlJywnbW91c2VPdXQnLCdtb3VzZU92ZXInLCdtb3VzZVVwJywncGFzdGUnLCdwYXVzZScsJ3BsYXknLCdwbGF5aW5nJywncG9pbnRlckNhbmNlbCcsJ3BvaW50ZXJEb3duJywncG9pbnRlck1vdmUnLCdwb2ludGVyT3V0JywncG9pbnRlck92ZXInLCdwb2ludGVyVXAnLCdwcm9ncmVzcycsJ3JhdGVDaGFuZ2UnLCdyZXNldCcsJ3Jlc2l6ZScsJ3NlZWtlZCcsJ3NlZWtpbmcnLCdzdGFsbGVkJywnc3VibWl0Jywnc3VzcGVuZCcsJ3RpbWVVcGRhdGUnLCd0b3VjaENhbmNlbCcsJ3RvdWNoRW5kJywndG91Y2hTdGFydCcsJ3ZvbHVtZUNoYW5nZScsJ3Njcm9sbCcsJ3RvZ2dsZScsJ3RvdWNoTW92ZScsJ3dhaXRpbmcnLCd3aGVlbCddO2Z1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLHJlYWN0TmFtZSl7dG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KGRvbUV2ZW50TmFtZSxyZWFjdE5hbWUpO3JlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsW2RvbUV2ZW50TmFtZV0pO31mdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50cygpe2Zvcih2YXIgaT0wO2k8c2ltcGxlRXZlbnRQbHVnaW5FdmVudHMubGVuZ3RoO2krKyl7dmFyIGV2ZW50TmFtZT1zaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpXTt2YXIgZG9tRXZlbnROYW1lPWV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO3ZhciBjYXBpdGFsaXplZEV2ZW50PWV2ZW50TmFtZVswXS50b1VwcGVyQ2FzZSgpK2V2ZW50TmFtZS5zbGljZSgxKTtyZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSwnb24nK2NhcGl0YWxpemVkRXZlbnQpO30vLyBTcGVjaWFsIGNhc2VzIHdoZXJlIGV2ZW50IG5hbWVzIGRvbid0IG1hdGNoLlxucmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fRU5ELCdvbkFuaW1hdGlvbkVuZCcpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoQU5JTUFUSU9OX0lURVJBVElPTiwnb25BbmltYXRpb25JdGVyYXRpb24nKTtyZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9TVEFSVCwnb25BbmltYXRpb25TdGFydCcpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoJ2RibGNsaWNrJywnb25Eb3VibGVDbGljaycpO3JlZ2lzdGVyU2ltcGxlRXZlbnQoJ2ZvY3VzaW4nLCdvbkZvY3VzJyk7cmVnaXN0ZXJTaW1wbGVFdmVudCgnZm9jdXNvdXQnLCdvbkJsdXInKTtyZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fRU5ELCdvblRyYW5zaXRpb25FbmQnKTt9ZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpe3ZhciByZWFjdE5hbWU9dG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuZ2V0KGRvbUV2ZW50TmFtZSk7aWYocmVhY3ROYW1lPT09dW5kZWZpbmVkKXtyZXR1cm47fXZhciBTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRXZlbnQ7dmFyIHJlYWN0RXZlbnRUeXBlPWRvbUV2ZW50TmFtZTtzd2l0Y2goZG9tRXZlbnROYW1lKXtjYXNlJ2tleXByZXNzJzovLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbi8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG5pZihnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KT09PTApe3JldHVybjt9LyogZmFsbHMgdGhyb3VnaCAqL2Nhc2Una2V5ZG93bic6Y2FzZSdrZXl1cCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7YnJlYWs7Y2FzZSdmb2N1c2luJzpyZWFjdEV2ZW50VHlwZT0nZm9jdXMnO1N5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNGb2N1c0V2ZW50O2JyZWFrO2Nhc2UnZm9jdXNvdXQnOnJlYWN0RXZlbnRUeXBlPSdibHVyJztTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRm9jdXNFdmVudDticmVhaztjYXNlJ2JlZm9yZWJsdXInOmNhc2UnYWZ0ZXJibHVyJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljRm9jdXNFdmVudDticmVhaztjYXNlJ2NsaWNrJzovLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbi8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbmlmKG5hdGl2ZUV2ZW50LmJ1dHRvbj09PTIpe3JldHVybjt9LyogZmFsbHMgdGhyb3VnaCAqL2Nhc2UnYXV4Y2xpY2snOmNhc2UnZGJsY2xpY2snOmNhc2UnbW91c2Vkb3duJzpjYXNlJ21vdXNlbW92ZSc6Y2FzZSdtb3VzZXVwJzovLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4vKiBmYWxscyB0aHJvdWdoICovY2FzZSdtb3VzZW91dCc6Y2FzZSdtb3VzZW92ZXInOmNhc2UnY29udGV4dG1lbnUnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNNb3VzZUV2ZW50O2JyZWFrO2Nhc2UnZHJhZyc6Y2FzZSdkcmFnZW5kJzpjYXNlJ2RyYWdlbnRlcic6Y2FzZSdkcmFnZXhpdCc6Y2FzZSdkcmFnbGVhdmUnOmNhc2UnZHJhZ292ZXInOmNhc2UnZHJhZ3N0YXJ0JzpjYXNlJ2Ryb3AnOlN5bnRoZXRpY0V2ZW50Q3Rvcj1TeW50aGV0aWNEcmFnRXZlbnQ7YnJlYWs7Y2FzZSd0b3VjaGNhbmNlbCc6Y2FzZSd0b3VjaGVuZCc6Y2FzZSd0b3VjaG1vdmUnOmNhc2UndG91Y2hzdGFydCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1RvdWNoRXZlbnQ7YnJlYWs7Y2FzZSBBTklNQVRJT05fRU5EOmNhc2UgQU5JTUFUSU9OX0lURVJBVElPTjpjYXNlIEFOSU1BVElPTl9TVEFSVDpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljQW5pbWF0aW9uRXZlbnQ7YnJlYWs7Y2FzZSBUUkFOU0lUSU9OX0VORDpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljVHJhbnNpdGlvbkV2ZW50O2JyZWFrO2Nhc2Unc2Nyb2xsJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljVUlFdmVudDticmVhaztjYXNlJ3doZWVsJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljV2hlZWxFdmVudDticmVhaztjYXNlJ2NvcHknOmNhc2UnY3V0JzpjYXNlJ3Bhc3RlJzpTeW50aGV0aWNFdmVudEN0b3I9U3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7YnJlYWs7Y2FzZSdnb3Rwb2ludGVyY2FwdHVyZSc6Y2FzZSdsb3N0cG9pbnRlcmNhcHR1cmUnOmNhc2UncG9pbnRlcmNhbmNlbCc6Y2FzZSdwb2ludGVyZG93bic6Y2FzZSdwb2ludGVybW92ZSc6Y2FzZSdwb2ludGVyb3V0JzpjYXNlJ3BvaW50ZXJvdmVyJzpjYXNlJ3BvaW50ZXJ1cCc6U3ludGhldGljRXZlbnRDdG9yPVN5bnRoZXRpY1BvaW50ZXJFdmVudDticmVhazt9dmFyIGluQ2FwdHVyZVBoYXNlPShldmVudFN5c3RlbUZsYWdzJklTX0NBUFRVUkVfUEhBU0UpIT09MDt7Ly8gU29tZSBldmVudHMgZG9uJ3QgYnViYmxlIGluIHRoZSBicm93c2VyLlxuLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbi8vIFdlJ3JlIGdvaW5nIHRvIHRyeSBhbGlnbmluZyBjbG9zZXIgdG8gdGhlIGJyb3dzZXIgYmVoYXZpb3IgYnkgbm90IGJ1YmJsaW5nXG4vLyB0aGVtIGluIFJlYWN0IGVpdGhlci4gV2UnbGwgc3RhcnQgYnkgbm90IGJ1YmJsaW5nIG9uU2Nyb2xsLCBhbmQgdGhlbiBleHBhbmQuXG52YXIgYWNjdW11bGF0ZVRhcmdldE9ubHk9IWluQ2FwdHVyZVBoYXNlJiYvLyBUT0RPOiBpZGVhbGx5LCB3ZSdkIGV2ZW50dWFsbHkgYWRkIGFsbCBldmVudHMgZnJvbVxuLy8gbm9uRGVsZWdhdGVkRXZlbnRzIGxpc3QgaW4gRE9NUGx1Z2luRXZlbnRTeXN0ZW0uXG4vLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4vLyBUaGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlIHRoYXQgY2FuIHdhaXQgdW50aWwgUmVhY3QgMTguXG5kb21FdmVudE5hbWU9PT0nc2Nyb2xsJzt2YXIgX2xpc3RlbmVycz1hY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCxyZWFjdE5hbWUsbmF0aXZlRXZlbnQudHlwZSxpbkNhcHR1cmVQaGFzZSxhY2N1bXVsYXRlVGFyZ2V0T25seSk7aWYoX2xpc3RlbmVycy5sZW5ndGg+MCl7Ly8gSW50ZW50aW9uYWxseSBjcmVhdGUgZXZlbnQgbGF6aWx5LlxudmFyIF9ldmVudD1uZXcgU3ludGhldGljRXZlbnRDdG9yKHJlYWN0TmFtZSxyZWFjdEV2ZW50VHlwZSxudWxsLG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtkaXNwYXRjaFF1ZXVlLnB1c2goe2V2ZW50Ol9ldmVudCxsaXN0ZW5lcnM6X2xpc3RlbmVyc30pO319fS8vIFRPRE86IHJlbW92ZSB0b3AtbGV2ZWwgc2lkZSBlZmZlY3QuXG5yZWdpc3RlclNpbXBsZUV2ZW50cygpO3JlZ2lzdGVyRXZlbnRzJDIoKTtyZWdpc3RlckV2ZW50cyQxKCk7cmVnaXN0ZXJFdmVudHMkMygpO3JlZ2lzdGVyRXZlbnRzKCk7ZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyx0YXJnZXRDb250YWluZXIpey8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4vLyBUaGlzIGlzIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXR5IG9mIHRoZSBldmVudCBzeXN0ZW0uIEFsbFxuLy8gdGhlIG90aGVyIHBsdWdpbnMgYXJlIGVzc2VudGlhbGx5IHBvbHlmaWxscy4gU28gdGhlIHBsdWdpblxuLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuLy8gYmUgY29yZSB0aGUgdG8gZXZlbnQgc3lzdGVtLiBUaGlzIHdvdWxkIHBvdGVudGlhbGx5IGFsbG93XG4vLyB1cyB0byBzaGlwIGJ1aWxkcyBvZiBSZWFjdCB3aXRob3V0IHRoZSBwb2x5ZmlsbGVkIHBsdWdpbnMgYmVsb3cuXG5leHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCxldmVudFN5c3RlbUZsYWdzKTt2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucz0oZXZlbnRTeXN0ZW1GbGFncyZTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyk9PT0wOy8vIFdlIGRvbid0IHByb2Nlc3MgdGhlc2UgZXZlbnRzIHVubGVzcyB3ZSBhcmUgaW4gdGhlXG4vLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4vLyBub3QgaW4gdGhlIGNhcHR1cmUgcGhhc2UuIFRoYXQncyBiZWNhdXNlIHdlIGVtdWxhdGVcbi8vIHRoZSBjYXB0dXJlIHBoYXNlIGhlcmUgc3RpbGwuIFRoaXMgaXMgYSB0cmFkZS1vZmYsXG4vLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2Vcbi8vIHRoZSBwaGFzZXMgcHJvcGVybHksIGxpa2Ugd2UgZG8gd2l0aCB0aGUgU2ltcGxlRXZlbnRcbi8vIHBsdWdpbi4gSG93ZXZlciwgdGhlIHBsdWdpbnMgYmVsb3cgZWl0aGVyIGV4cGVjdFxuLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbi8vIHBsdWdpbiAoQmVmb3JlSW5wdXQsIENoYW5nZSwgU2VsZWN0KS4gVGhlIHN0YXRlIGluXG4vLyB0aGVzZSBtb2R1bGVzIGNvbXBsaWNhdGVzIHRoaW5ncywgYXMgeW91J2xsIGVzc2VudGlhbGx5XG4vLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4vLyBzdGF0ZSwgb25seSBmb3IgdGhlIGZvbGxvd2luZyBidWJibGUgZXZlbnQgdG8gY29tZSBpblxuLy8gbGF0ZXIgYW5kIG5vdCB0cmlnZ2VyIGFueXRoaW5nIGFzIHRoZSBzdGF0ZSBub3dcbi8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4vLyBjb3VsZCBhbHRlciBhbGwgdGhlc2UgcGx1Z2lucyB0byB3b3JrIGluIHN1Y2ggd2F5cywgYnV0XG4vLyB0aGF0IG1pZ2h0IGNhdXNlIG90aGVyIHVua25vd24gc2lkZS1lZmZlY3RzIHRoYXQgd2Vcbi8vIGNhbid0IGZvcmVzZWUgcmlnaHQgbm93LlxuaWYoc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyl7ZXh0cmFjdEV2ZW50cyQyKGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQpO2V4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTtleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSxkb21FdmVudE5hbWUsdGFyZ2V0SW5zdCxuYXRpdmVFdmVudCxuYXRpdmVFdmVudFRhcmdldCk7ZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLGRvbUV2ZW50TmFtZSx0YXJnZXRJbnN0LG5hdGl2ZUV2ZW50LG5hdGl2ZUV2ZW50VGFyZ2V0KTt9fS8vIExpc3Qgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudHMuXG52YXIgbWVkaWFFdmVudFR5cGVzPVsnYWJvcnQnLCdjYW5wbGF5JywnY2FucGxheXRocm91Z2gnLCdkdXJhdGlvbmNoYW5nZScsJ2VtcHRpZWQnLCdlbmNyeXB0ZWQnLCdlbmRlZCcsJ2Vycm9yJywnbG9hZGVkZGF0YScsJ2xvYWRlZG1ldGFkYXRhJywnbG9hZHN0YXJ0JywncGF1c2UnLCdwbGF5JywncGxheWluZycsJ3Byb2dyZXNzJywncmF0ZWNoYW5nZScsJ3Jlc2l6ZScsJ3NlZWtlZCcsJ3NlZWtpbmcnLCdzdGFsbGVkJywnc3VzcGVuZCcsJ3RpbWV1cGRhdGUnLCd2b2x1bWVjaGFuZ2UnLCd3YWl0aW5nJ107Ly8gV2Ugc2hvdWxkIG5vdCBkZWxlZ2F0ZSB0aGVzZSBldmVudHMgdG8gdGhlIGNvbnRhaW5lciwgYnV0IHJhdGhlclxuLy8gc2V0IHRoZW0gb24gdGhlIGFjdHVhbCB0YXJnZXQgZWxlbWVudCBpdHNlbGYuIFRoaXMgaXMgcHJpbWFyaWx5XG4vLyBiZWNhdXNlIHRoZXNlIGV2ZW50cyBkbyBub3QgY29uc2lzdGVudGx5IGJ1YmJsZSBpbiB0aGUgRE9NLlxudmFyIG5vbkRlbGVnYXRlZEV2ZW50cz1uZXcgU2V0KFsnY2FuY2VsJywnY2xvc2UnLCdpbnZhbGlkJywnbG9hZCcsJ3Njcm9sbCcsJ3RvZ2dsZSddLmNvbmNhdChtZWRpYUV2ZW50VHlwZXMpKTtmdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsbGlzdGVuZXIsY3VycmVudFRhcmdldCl7dmFyIHR5cGU9ZXZlbnQudHlwZXx8J3Vua25vd24tZXZlbnQnO2V2ZW50LmN1cnJlbnRUYXJnZXQ9Y3VycmVudFRhcmdldDtpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSxsaXN0ZW5lcix1bmRlZmluZWQsZXZlbnQpO2V2ZW50LmN1cnJlbnRUYXJnZXQ9bnVsbDt9ZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsZGlzcGF0Y2hMaXN0ZW5lcnMsaW5DYXB0dXJlUGhhc2Upe3ZhciBwcmV2aW91c0luc3RhbmNlO2lmKGluQ2FwdHVyZVBoYXNlKXtmb3IodmFyIGk9ZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaT1kaXNwYXRjaExpc3RlbmVyc1tpXSxpbnN0YW5jZT1fZGlzcGF0Y2hMaXN0ZW5lcnMkaS5pbnN0YW5jZSxjdXJyZW50VGFyZ2V0PV9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQsbGlzdGVuZXI9X2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7aWYoaW5zdGFuY2UhPT1wcmV2aW91c0luc3RhbmNlJiZldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtyZXR1cm47fWV4ZWN1dGVEaXNwYXRjaChldmVudCxsaXN0ZW5lcixjdXJyZW50VGFyZ2V0KTtwcmV2aW91c0luc3RhbmNlPWluc3RhbmNlO319ZWxzZXtmb3IodmFyIF9pPTA7X2k8ZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoO19pKyspe3ZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2k9ZGlzcGF0Y2hMaXN0ZW5lcnNbX2ldLF9pbnN0YW5jZT1fZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuaW5zdGFuY2UsX2N1cnJlbnRUYXJnZXQ9X2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmN1cnJlbnRUYXJnZXQsX2xpc3RlbmVyPV9kaXNwYXRjaExpc3RlbmVycyRfaS5saXN0ZW5lcjtpZihfaW5zdGFuY2UhPT1wcmV2aW91c0luc3RhbmNlJiZldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtyZXR1cm47fWV4ZWN1dGVEaXNwYXRjaChldmVudCxfbGlzdGVuZXIsX2N1cnJlbnRUYXJnZXQpO3ByZXZpb3VzSW5zdGFuY2U9X2luc3RhbmNlO319fWZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsZXZlbnRTeXN0ZW1GbGFncyl7dmFyIGluQ2FwdHVyZVBoYXNlPShldmVudFN5c3RlbUZsYWdzJklTX0NBUFRVUkVfUEhBU0UpIT09MDtmb3IodmFyIGk9MDtpPGRpc3BhdGNoUXVldWUubGVuZ3RoO2krKyl7dmFyIF9kaXNwYXRjaFF1ZXVlJGk9ZGlzcGF0Y2hRdWV1ZVtpXSxldmVudD1fZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50LGxpc3RlbmVycz1fZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlcihldmVudCxsaXN0ZW5lcnMsaW5DYXB0dXJlUGhhc2UpOy8vICBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbn0vLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbnJldGhyb3dDYXVnaHRFcnJvcigpO31mdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsbmF0aXZlRXZlbnQsdGFyZ2V0SW5zdCx0YXJnZXRDb250YWluZXIpe3ZhciBuYXRpdmVFdmVudFRhcmdldD1nZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7dmFyIGRpc3BhdGNoUXVldWU9W107ZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsZG9tRXZlbnROYW1lLHRhcmdldEluc3QsbmF0aXZlRXZlbnQsbmF0aXZlRXZlbnRUYXJnZXQsZXZlbnRTeXN0ZW1GbGFncyk7cHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSxldmVudFN5c3RlbUZsYWdzKTt9ZnVuY3Rpb24gbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChkb21FdmVudE5hbWUsdGFyZ2V0RWxlbWVudCl7e2lmKCFub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpe2Vycm9yKCdEaWQgbm90IGV4cGVjdCBhIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoKSBjYWxsIGZvciBcIiVzXCIuICcrJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsZG9tRXZlbnROYW1lKTt9fXZhciBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyPWZhbHNlO3ZhciBsaXN0ZW5lclNldD1nZXRFdmVudExpc3RlbmVyU2V0KHRhcmdldEVsZW1lbnQpO3ZhciBsaXN0ZW5lclNldEtleT1nZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7aWYoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpe2FkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsZG9tRXZlbnROYW1lLElTX05PTl9ERUxFR0FURUQsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7bGlzdGVuZXJTZXQuYWRkKGxpc3RlbmVyU2V0S2V5KTt9fWZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsdGFyZ2V0KXt7aWYobm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpJiYhaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcil7ZXJyb3IoJ0RpZCBub3QgZXhwZWN0IGEgbGlzdGVuVG9OYXRpdmVFdmVudCgpIGNhbGwgZm9yIFwiJXNcIiBpbiB0aGUgYnViYmxlIHBoYXNlLiAnKydUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGRvbUV2ZW50TmFtZSk7fX12YXIgZXZlbnRTeXN0ZW1GbGFncz0wO2lmKGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpe2V2ZW50U3lzdGVtRmxhZ3N8PUlTX0NBUFRVUkVfUEhBU0U7fWFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCxkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTt9Ly8gVGhpcyBpcyBvbmx5IHVzZWQgYnkgY3JlYXRlRXZlbnRIYW5kbGUgd2hlbiB0aGVcbnZhciBsaXN0ZW5pbmdNYXJrZXI9J19yZWFjdExpc3RlbmluZycrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7ZnVuY3Rpb24gbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpe2lmKCFyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKXtyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdPXRydWU7YWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZG9tRXZlbnROYW1lKXsvLyBXZSBoYW5kbGUgc2VsZWN0aW9uY2hhbmdlIHNlcGFyYXRlbHkgYmVjYXVzZSBpdFxuLy8gZG9lc24ndCBidWJibGUgYW5kIG5lZWRzIHRvIGJlIG9uIHRoZSBkb2N1bWVudC5cbmlmKGRvbUV2ZW50TmFtZSE9PSdzZWxlY3Rpb25jaGFuZ2UnKXtpZighbm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpKXtsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSxmYWxzZSxyb290Q29udGFpbmVyRWxlbWVudCk7fWxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLHRydWUscm9vdENvbnRhaW5lckVsZW1lbnQpO319KTt2YXIgb3duZXJEb2N1bWVudD1yb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZT09PURPQ1VNRU5UX05PREU/cm9vdENvbnRhaW5lckVsZW1lbnQ6cm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtpZihvd25lckRvY3VtZW50IT09bnVsbCl7Ly8gVGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCBhbHNvIG5lZWRzIGRlZHVwbGljYXRpb25cbi8vIGJ1dCBpdCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG5pZighb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdKXtvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl09dHJ1ZTtsaXN0ZW5Ub05hdGl2ZUV2ZW50KCdzZWxlY3Rpb25jaGFuZ2UnLGZhbHNlLG93bmVyRG9jdW1lbnQpO319fX1mdW5jdGlvbiBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MsaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcixpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQpe3ZhciBsaXN0ZW5lcj1jcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGV2ZW50U3lzdGVtRmxhZ3MpOy8vIElmIHBhc3NpdmUgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZW4gdGhlIGV2ZW50IHdpbGwgYmVcbi8vIGFjdGl2ZSBhbmQgbm90IHBhc3NpdmUuXG52YXIgaXNQYXNzaXZlTGlzdGVuZXI9dW5kZWZpbmVkO2lmKHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkKXsvLyBCcm93c2VycyBpbnRyb2R1Y2VkIGFuIGludGVydmVudGlvbiwgbWFraW5nIHRoZXNlIGV2ZW50c1xuLy8gcGFzc2l2ZSBieSBkZWZhdWx0IG9uIGRvY3VtZW50LiBSZWFjdCBkb2Vzbid0IGJpbmQgdGhlbVxuLy8gdG8gZG9jdW1lbnQgYW55bW9yZSwgYnV0IGNoYW5naW5nIHRoaXMgbm93IHdvdWxkIHVuZG9cbi8vIHRoZSBwZXJmb3JtYW5jZSB3aW5zIGZyb20gdGhlIGNoYW5nZS4gU28gd2UgZW11bGF0ZVxuLy8gdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG1hbnVhbGx5IG9uIHRoZSByb290cyBub3cuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5NjUxXG5pZihkb21FdmVudE5hbWU9PT0ndG91Y2hzdGFydCd8fGRvbUV2ZW50TmFtZT09PSd0b3VjaG1vdmUnfHxkb21FdmVudE5hbWU9PT0nd2hlZWwnKXtpc1Bhc3NpdmVMaXN0ZW5lcj10cnVlO319dGFyZ2V0Q29udGFpbmVyPXRhcmdldENvbnRhaW5lcjt2YXIgdW5zdWJzY3JpYmVMaXN0ZW5lcjsvLyBXaGVuIGxlZ2FjeUZCU3VwcG9ydCBpcyBlbmFibGVkLCBpdCdzIGZvciB3aGVuIHdlXG5pZihpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKXtpZihpc1Bhc3NpdmVMaXN0ZW5lciE9PXVuZGVmaW5lZCl7dW5zdWJzY3JpYmVMaXN0ZW5lcj1hZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGxpc3RlbmVyLGlzUGFzc2l2ZUxpc3RlbmVyKTt9ZWxzZXt1bnN1YnNjcmliZUxpc3RlbmVyPWFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lcixkb21FdmVudE5hbWUsbGlzdGVuZXIpO319ZWxzZXtpZihpc1Bhc3NpdmVMaXN0ZW5lciE9PXVuZGVmaW5lZCl7dW5zdWJzY3JpYmVMaXN0ZW5lcj1hZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldENvbnRhaW5lcixkb21FdmVudE5hbWUsbGlzdGVuZXIsaXNQYXNzaXZlTGlzdGVuZXIpO31lbHNle3Vuc3Vic2NyaWJlTGlzdGVuZXI9YWRkRXZlbnRCdWJibGVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsZG9tRXZlbnROYW1lLGxpc3RlbmVyKTt9fX1mdW5jdGlvbiBpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lcix0YXJnZXRDb250YWluZXIpe3JldHVybiBncmFuZENvbnRhaW5lcj09PXRhcmdldENvbnRhaW5lcnx8Z3JhbmRDb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREUmJmdyYW5kQ29udGFpbmVyLnBhcmVudE5vZGU9PT10YXJnZXRDb250YWluZXI7fWZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCx0YXJnZXRJbnN0LHRhcmdldENvbnRhaW5lcil7dmFyIGFuY2VzdG9ySW5zdD10YXJnZXRJbnN0O2lmKChldmVudFN5c3RlbUZsYWdzJklTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFKT09PTAmJihldmVudFN5c3RlbUZsYWdzJklTX05PTl9ERUxFR0FURUQpPT09MCl7dmFyIHRhcmdldENvbnRhaW5lck5vZGU9dGFyZ2V0Q29udGFpbmVyOy8vIElmIHdlIGFyZSB1c2luZyB0aGUgbGVnYWN5IEZCIHN1cHBvcnQgZmxhZywgd2VcbmlmKHRhcmdldEluc3QhPT1udWxsKXsvLyBUaGUgYmVsb3cgbG9naWMgYXR0ZW1wdHMgdG8gd29yayBvdXQgaWYgd2UgbmVlZCB0byBjaGFuZ2Vcbi8vIHRoZSB0YXJnZXQgZmliZXIgdG8gYSBkaWZmZXJlbnQgYW5jZXN0b3IuIFdlIGhhZCBzaW1pbGFyIGxvZ2ljXG4vLyBpbiB0aGUgbGVnYWN5IGV2ZW50IHN5c3RlbSwgZXhjZXB0IHRoZSBiaWcgZGlmZmVyZW5jZSBiZXR3ZWVuXG4vLyBzeXN0ZW1zIGlzIHRoYXQgdGhlIG1vZGVybiBldmVudCBzeXN0ZW0gbm93IGhhcyBhbiBldmVudCBsaXN0ZW5lclxuLy8gYXR0YWNoZWQgdG8gZWFjaCBSZWFjdCBSb290IGFuZCBSZWFjdCBQb3J0YWwgUm9vdC4gVG9nZXRoZXIsXG4vLyB0aGUgRE9NIG5vZGVzIHJlcHJlc2VudGluZyB0aGVzZSByb290cyBhcmUgdGhlIFwicm9vdENvbnRhaW5lclwiLlxuLy8gVG8gZmlndXJlIG91dCB3aGljaCBhbmNlc3RvciBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLCB3ZSB0cmF2ZXJzZVxuLy8gdXAgdGhlIGZpYmVyIHRyZWUgZnJvbSB0aGUgdGFyZ2V0IGluc3RhbmNlIGFuZCBhdHRlbXB0IHRvIGZpbmRcbi8vIHJvb3QgYm91bmRhcmllcyB0aGF0IG1hdGNoIHRoYXQgb2Ygb3VyIGN1cnJlbnQgXCJyb290Q29udGFpbmVyXCIuXG4vLyBJZiB3ZSBmaW5kIHRoYXQgXCJyb290Q29udGFpbmVyXCIsIHdlIGZpbmQgdGhlIHBhcmVudCBmaWJlclxuLy8gc3ViLXRyZWUgZm9yIHRoYXQgcm9vdCBhbmQgbWFrZSB0aGF0IG91ciBhbmNlc3RvciBpbnN0YW5jZS5cbnZhciBub2RlPXRhcmdldEluc3Q7bWFpbkxvb3A6d2hpbGUodHJ1ZSl7aWYobm9kZT09PW51bGwpe3JldHVybjt9dmFyIG5vZGVUYWc9bm9kZS50YWc7aWYobm9kZVRhZz09PUhvc3RSb290fHxub2RlVGFnPT09SG9zdFBvcnRhbCl7dmFyIGNvbnRhaW5lcj1ub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGNvbnRhaW5lcix0YXJnZXRDb250YWluZXJOb2RlKSl7YnJlYWs7fWlmKG5vZGVUYWc9PT1Ib3N0UG9ydGFsKXsvLyBUaGUgdGFyZ2V0IGlzIGEgcG9ydGFsLCBidXQgaXQncyBub3QgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IuXG4vLyBOb3JtYWxseSBwb3J0YWxzIGhhbmRsZSB0aGVpciBvd24gZXZlbnRzIGFsbCB0aGUgd2F5IGRvd24gdG8gdGhlIHJvb3QuXG4vLyBTbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzdG9wIG5vdy4gSG93ZXZlciwgd2UgZG9uJ3Qga25vdyBpZiB0aGlzIHBvcnRhbFxuLy8gd2FzIHBhcnQgb2YgKm91ciogcm9vdC5cbnZhciBncmFuZE5vZGU9bm9kZS5yZXR1cm47d2hpbGUoZ3JhbmROb2RlIT09bnVsbCl7dmFyIGdyYW5kVGFnPWdyYW5kTm9kZS50YWc7aWYoZ3JhbmRUYWc9PT1Ib3N0Um9vdHx8Z3JhbmRUYWc9PT1Ib3N0UG9ydGFsKXt2YXIgZ3JhbmRDb250YWluZXI9Z3JhbmROb2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLHRhcmdldENvbnRhaW5lck5vZGUpKXsvLyBUaGlzIGlzIHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yIGFuZCB3ZSBmb3VuZCBpdCBhc1xuLy8gYSBwYXJlbnQgb2YgdGhlIFBvcnRhbC4gVGhhdCBtZWFucyB3ZSBjYW4gaWdub3JlIGl0IGJlY2F1c2UgdGhlXG4vLyBQb3J0YWwgd2lsbCBidWJibGUgdGhyb3VnaCB0byB1cy5cbnJldHVybjt9fWdyYW5kTm9kZT1ncmFuZE5vZGUucmV0dXJuO319Ly8gTm93IHdlIG5lZWQgdG8gZmluZCBpdCdzIGNvcnJlc3BvbmRpbmcgaG9zdCBmaWJlciBpbiB0aGUgb3RoZXJcbi8vIHRyZWUuIFRvIGRvIHRoaXMgd2UgY2FuIHVzZSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSwgYnV0IHdlXG4vLyBuZWVkIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGZpYmVyIGlzIGEgaG9zdCBpbnN0YW5jZSwgb3RoZXJ3aXNlXG4vLyB3ZSBuZWVkIHRvIHRyYXZlcnNlIHVwIHRocm91Z2ggdGhlIERPTSB0aWxsIHdlIGZpbmQgdGhlIGNvcnJlY3Rcbi8vIG5vZGUgdGhhdCBpcyBmcm9tIHRoZSBvdGhlciB0cmVlLlxud2hpbGUoY29udGFpbmVyIT09bnVsbCl7dmFyIHBhcmVudE5vZGU9Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtpZihwYXJlbnROb2RlPT09bnVsbCl7cmV0dXJuO312YXIgcGFyZW50VGFnPXBhcmVudE5vZGUudGFnO2lmKHBhcmVudFRhZz09PUhvc3RDb21wb25lbnR8fHBhcmVudFRhZz09PUhvc3RUZXh0KXtub2RlPWFuY2VzdG9ySW5zdD1wYXJlbnROb2RlO2NvbnRpbnVlIG1haW5Mb29wO31jb250YWluZXI9Y29udGFpbmVyLnBhcmVudE5vZGU7fX1ub2RlPW5vZGUucmV0dXJuO319fWJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7cmV0dXJuIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsZXZlbnRTeXN0ZW1GbGFncyxuYXRpdmVFdmVudCxhbmNlc3Rvckluc3QpO30pO31mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpe3JldHVybntpbnN0YW5jZTppbnN0YW5jZSxsaXN0ZW5lcjpsaXN0ZW5lcixjdXJyZW50VGFyZ2V0OmN1cnJlbnRUYXJnZXR9O31mdW5jdGlvbiBhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIscmVhY3ROYW1lLG5hdGl2ZUV2ZW50VHlwZSxpbkNhcHR1cmVQaGFzZSxhY2N1bXVsYXRlVGFyZ2V0T25seSxuYXRpdmVFdmVudCl7dmFyIGNhcHR1cmVOYW1lPXJlYWN0TmFtZSE9PW51bGw/cmVhY3ROYW1lKydDYXB0dXJlJzpudWxsO3ZhciByZWFjdEV2ZW50TmFtZT1pbkNhcHR1cmVQaGFzZT9jYXB0dXJlTmFtZTpyZWFjdE5hbWU7dmFyIGxpc3RlbmVycz1bXTt2YXIgaW5zdGFuY2U9dGFyZ2V0RmliZXI7dmFyIGxhc3RIb3N0Q29tcG9uZW50PW51bGw7Ly8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxud2hpbGUoaW5zdGFuY2UhPT1udWxsKXt2YXIgX2luc3RhbmNlMj1pbnN0YW5jZSxzdGF0ZU5vZGU9X2luc3RhbmNlMi5zdGF0ZU5vZGUsdGFnPV9pbnN0YW5jZTIudGFnOy8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5pZih0YWc9PT1Ib3N0Q29tcG9uZW50JiZzdGF0ZU5vZGUhPT1udWxsKXtsYXN0SG9zdENvbXBvbmVudD1zdGF0ZU5vZGU7Ly8gY3JlYXRlRXZlbnRIYW5kbGUgbGlzdGVuZXJzXG5pZihyZWFjdEV2ZW50TmFtZSE9PW51bGwpe3ZhciBsaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxyZWFjdEV2ZW50TmFtZSk7aWYobGlzdGVuZXIhPW51bGwpe2xpc3RlbmVycy5wdXNoKGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsbGlzdGVuZXIsbGFzdEhvc3RDb21wb25lbnQpKTt9fX0vLyBJZiB3ZSBhcmUgb25seSBhY2N1bXVsYXRpbmcgZXZlbnRzIGZvciB0aGUgdGFyZ2V0LCB0aGVuIHdlIGRvbid0XG4vLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4vLyBsaXN0ZW5lcnMuXG5pZihhY2N1bXVsYXRlVGFyZ2V0T25seSl7YnJlYWs7fS8vIElmIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBvbkJlZm9yZUJsdXIgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byB0YWtlXG5pbnN0YW5jZT1pbnN0YW5jZS5yZXR1cm47fXJldHVybiBsaXN0ZW5lcnM7fS8vIFdlIHNob3VsZCBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvcjpcbi8vIC0gQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuLy8gLSBDaGFuZ2VFdmVudFBsdWdpblxuLy8gLSBTZWxlY3RFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGVzZSBwbHVnaW5zXG4vLyBpbiB0aGUgYnViYmxlIHBoYXNlLCBzbyB3ZSBuZWVkIHRvIGFjY3VtdWxhdGUgdHdvXG4vLyBwaGFzZSBldmVudCBsaXN0ZW5lcnMgKHZpYSBlbXVsYXRpb24pLlxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLHJlYWN0TmFtZSl7dmFyIGNhcHR1cmVOYW1lPXJlYWN0TmFtZSsnQ2FwdHVyZSc7dmFyIGxpc3RlbmVycz1bXTt2YXIgaW5zdGFuY2U9dGFyZ2V0RmliZXI7Ly8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxud2hpbGUoaW5zdGFuY2UhPT1udWxsKXt2YXIgX2luc3RhbmNlMz1pbnN0YW5jZSxzdGF0ZU5vZGU9X2luc3RhbmNlMy5zdGF0ZU5vZGUsdGFnPV9pbnN0YW5jZTMudGFnOy8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5pZih0YWc9PT1Ib3N0Q29tcG9uZW50JiZzdGF0ZU5vZGUhPT1udWxsKXt2YXIgY3VycmVudFRhcmdldD1zdGF0ZU5vZGU7dmFyIGNhcHR1cmVMaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxjYXB0dXJlTmFtZSk7aWYoY2FwdHVyZUxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGNhcHR1cmVMaXN0ZW5lcixjdXJyZW50VGFyZ2V0KSk7fXZhciBidWJibGVMaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxyZWFjdE5hbWUpO2lmKGJ1YmJsZUxpc3RlbmVyIT1udWxsKXtsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLGJ1YmJsZUxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpKTt9fWluc3RhbmNlPWluc3RhbmNlLnJldHVybjt9cmV0dXJuIGxpc3RlbmVyczt9ZnVuY3Rpb24gZ2V0UGFyZW50KGluc3Qpe2lmKGluc3Q9PT1udWxsKXtyZXR1cm4gbnVsbDt9ZG97aW5zdD1pbnN0LnJldHVybjsvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbi8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4vLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxufXdoaWxlKGluc3QmJmluc3QudGFnIT09SG9zdENvbXBvbmVudCk7aWYoaW5zdCl7cmV0dXJuIGluc3Q7fXJldHVybiBudWxsO30vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSxpbnN0Qil7dmFyIG5vZGVBPWluc3RBO3ZhciBub2RlQj1pbnN0Qjt2YXIgZGVwdGhBPTA7Zm9yKHZhciB0ZW1wQT1ub2RlQTt0ZW1wQTt0ZW1wQT1nZXRQYXJlbnQodGVtcEEpKXtkZXB0aEErKzt9dmFyIGRlcHRoQj0wO2Zvcih2YXIgdGVtcEI9bm9kZUI7dGVtcEI7dGVtcEI9Z2V0UGFyZW50KHRlbXBCKSl7ZGVwdGhCKys7fS8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbndoaWxlKGRlcHRoQS1kZXB0aEI+MCl7bm9kZUE9Z2V0UGFyZW50KG5vZGVBKTtkZXB0aEEtLTt9Ly8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxud2hpbGUoZGVwdGhCLWRlcHRoQT4wKXtub2RlQj1nZXRQYXJlbnQobm9kZUIpO2RlcHRoQi0tO30vLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbnZhciBkZXB0aD1kZXB0aEE7d2hpbGUoZGVwdGgtLSl7aWYobm9kZUE9PT1ub2RlQnx8bm9kZUIhPT1udWxsJiZub2RlQT09PW5vZGVCLmFsdGVybmF0ZSl7cmV0dXJuIG5vZGVBO31ub2RlQT1nZXRQYXJlbnQobm9kZUEpO25vZGVCPWdldFBhcmVudChub2RlQik7fXJldHVybiBudWxsO31mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsZXZlbnQsdGFyZ2V0LGNvbW1vbixpbkNhcHR1cmVQaGFzZSl7dmFyIHJlZ2lzdHJhdGlvbk5hbWU9ZXZlbnQuX3JlYWN0TmFtZTt2YXIgbGlzdGVuZXJzPVtdO3ZhciBpbnN0YW5jZT10YXJnZXQ7d2hpbGUoaW5zdGFuY2UhPT1udWxsKXtpZihpbnN0YW5jZT09PWNvbW1vbil7YnJlYWs7fXZhciBfaW5zdGFuY2U0PWluc3RhbmNlLGFsdGVybmF0ZT1faW5zdGFuY2U0LmFsdGVybmF0ZSxzdGF0ZU5vZGU9X2luc3RhbmNlNC5zdGF0ZU5vZGUsdGFnPV9pbnN0YW5jZTQudGFnO2lmKGFsdGVybmF0ZSE9PW51bGwmJmFsdGVybmF0ZT09PWNvbW1vbil7YnJlYWs7fWlmKHRhZz09PUhvc3RDb21wb25lbnQmJnN0YXRlTm9kZSE9PW51bGwpe3ZhciBjdXJyZW50VGFyZ2V0PXN0YXRlTm9kZTtpZihpbkNhcHR1cmVQaGFzZSl7dmFyIGNhcHR1cmVMaXN0ZW5lcj1nZXRMaXN0ZW5lcihpbnN0YW5jZSxyZWdpc3RyYXRpb25OYW1lKTtpZihjYXB0dXJlTGlzdGVuZXIhPW51bGwpe2xpc3RlbmVycy51bnNoaWZ0KGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsY2FwdHVyZUxpc3RlbmVyLGN1cnJlbnRUYXJnZXQpKTt9fWVsc2UgaWYoIWluQ2FwdHVyZVBoYXNlKXt2YXIgYnViYmxlTGlzdGVuZXI9Z2V0TGlzdGVuZXIoaW5zdGFuY2UscmVnaXN0cmF0aW9uTmFtZSk7aWYoYnViYmxlTGlzdGVuZXIhPW51bGwpe2xpc3RlbmVycy5wdXNoKGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsYnViYmxlTGlzdGVuZXIsY3VycmVudFRhcmdldCkpO319fWluc3RhbmNlPWluc3RhbmNlLnJldHVybjt9aWYobGlzdGVuZXJzLmxlbmd0aCE9PTApe2Rpc3BhdGNoUXVldWUucHVzaCh7ZXZlbnQ6ZXZlbnQsbGlzdGVuZXJzOmxpc3RlbmVyc30pO319Ly8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbi8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHByb2Nlc3MgdGhpcyBwbHVnaW5cbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycy5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSxsZWF2ZUV2ZW50LGVudGVyRXZlbnQsZnJvbSx0byl7dmFyIGNvbW1vbj1mcm9tJiZ0bz9nZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLHRvKTpudWxsO2lmKGZyb20hPT1udWxsKXthY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsbGVhdmVFdmVudCxmcm9tLGNvbW1vbixmYWxzZSk7fWlmKHRvIT09bnVsbCYmZW50ZXJFdmVudCE9PW51bGwpe2FjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSxlbnRlckV2ZW50LHRvLGNvbW1vbix0cnVlKTt9fWZ1bmN0aW9uIGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSxjYXB0dXJlKXtyZXR1cm4gZG9tRXZlbnROYW1lK1wiX19cIisoY2FwdHVyZT8nY2FwdHVyZSc6J2J1YmJsZScpO312YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb249ZmFsc2U7dmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MPSdkYW5nZXJvdXNseVNldElubmVySFRNTCc7dmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORz0nc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzt2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkc9J3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7dmFyIEFVVE9GT0NVUz0nYXV0b0ZvY3VzJzt2YXIgQ0hJTERSRU49J2NoaWxkcmVuJzt2YXIgU1RZTEU9J3N0eWxlJzt2YXIgSFRNTCQxPSdfX2h0bWwnO3ZhciB3YXJuZWRVbmtub3duVGFnczt2YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudDt2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlO3ZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO3ZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXI7dmFyIGNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmc7dmFyIG5vcm1hbGl6ZUhUTUw7e3dhcm5lZFVua25vd25UYWdzPXsvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbmRpYWxvZzp0cnVlLC8vIEVsZWN0cm9uIHNoaXBzIGEgY3VzdG9tIDx3ZWJ2aWV3PiB0YWcgdG8gZGlzcGxheSBleHRlcm5hbCB3ZWIgY29udGVudCBpblxuLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4vLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbi8vIGlzIG9mdGVuIHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4vLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbndlYnZpZXc6dHJ1ZX07dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudD1mdW5jdGlvbih0eXBlLHByb3BzKXt2YWxpZGF0ZVByb3BlcnRpZXModHlwZSxwcm9wcyk7dmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSxwcm9wcyk7dmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSxwcm9wcyx7cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczpyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6cG9zc2libGVSZWdpc3RyYXRpb25OYW1lc30pO307Ly8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbi8vIGJyb3dzZXJzLiBJdCBhZGRzIHNwYWNlcyBhbmQgc29ydHMgdGhlIHByb3BlcnRpZXMgaW4gc29tZVxuLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4vLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbi8vIGBleHBlY3RlZFN0eWxlYCB0byBhIHRlbXBvcmFyeSBET00gbm9kZSB0byByZWFkIGl0cyBgc3R5bGVgIGF0dHJpYnV0ZVxuLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExODA3XG5jYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nPWNhblVzZURPTSYmIWRvY3VtZW50LmRvY3VtZW50TW9kZTt3YXJuRm9yUHJvcERpZmZlcmVuY2U9ZnVuY3Rpb24ocHJvcE5hbWUsc2VydmVyVmFsdWUsY2xpZW50VmFsdWUpe2lmKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKXtyZXR1cm47fXZhciBub3JtYWxpemVkQ2xpZW50VmFsdWU9bm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTt2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlPW5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7aWYobm9ybWFsaXplZFNlcnZlclZhbHVlPT09bm9ybWFsaXplZENsaWVudFZhbHVlKXtyZXR1cm47fWRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uPXRydWU7ZXJyb3IoJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLHByb3BOYW1lLEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7fTt3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzPWZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWVzKXtpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO3ZhciBuYW1lcz1bXTthdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe25hbWVzLnB1c2gobmFtZSk7fSk7ZXJyb3IoJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsbmFtZXMpO307d2FybkZvckludmFsaWRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHJlZ2lzdHJhdGlvbk5hbWUsbGlzdGVuZXIpe2lmKGxpc3RlbmVyPT09ZmFsc2Upe2Vycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJysnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcrJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicscmVnaXN0cmF0aW9uTmFtZSxyZWdpc3RyYXRpb25OYW1lLHJlZ2lzdHJhdGlvbk5hbWUpO31lbHNle2Vycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicscmVnaXN0cmF0aW9uTmFtZSx0eXBlb2YgbGlzdGVuZXIpO319Oy8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4vLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbm5vcm1hbGl6ZUhUTUw9ZnVuY3Rpb24ocGFyZW50LGh0bWwpey8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbi8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4vLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4vLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG52YXIgdGVzdEVsZW1lbnQ9cGFyZW50Lm5hbWVzcGFjZVVSST09PUhUTUxfTkFNRVNQQUNFP3BhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpOnBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLHBhcmVudC50YWdOYW1lKTt0ZXN0RWxlbWVudC5pbm5lckhUTUw9aHRtbDtyZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO307fS8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbi8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbnZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVg9L1xcclxcbj8vZzt2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYPS9cXHUwMDAwfFxcdUZGRkQvZztmdW5jdGlvbiBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUobWFya3VwKXt7Y2hlY2tIdG1sU3RyaW5nQ29lcmNpb24obWFya3VwKTt9dmFyIG1hcmt1cFN0cmluZz10eXBlb2YgbWFya3VwPT09J3N0cmluZyc/bWFya3VwOicnK21hcmt1cDtyZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwnJyk7fWZ1bmN0aW9uIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChzZXJ2ZXJUZXh0LGNsaWVudFRleHQsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KXt2YXIgbm9ybWFsaXplZENsaWVudFRleHQ9bm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO3ZhciBub3JtYWxpemVkU2VydmVyVGV4dD1ub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7aWYobm9ybWFsaXplZFNlcnZlclRleHQ9PT1ub3JtYWxpemVkQ2xpZW50VGV4dCl7cmV0dXJuO31pZihzaG91bGRXYXJuRGV2KXt7aWYoIWRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKXtkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LG5vcm1hbGl6ZWRDbGllbnRUZXh0KTt9fX1pZihpc0NvbmN1cnJlbnRNb2RlJiZlbmFibGVDbGllbnRSZW5kZXJGYWxsYmFja09uVGV4dE1pc21hdGNoKXsvLyBJbiBjb25jdXJyZW50IHJvb3RzLCB3ZSB0aHJvdyB3aGVuIHRoZXJlJ3MgYSB0ZXh0IG1pc21hdGNoIGFuZCByZXZlcnQgdG9cbi8vIGNsaWVudCByZW5kZXJpbmcsIHVwIHRvIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5LlxudGhyb3cgbmV3IEVycm9yKCdUZXh0IGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggc2VydmVyLXJlbmRlcmVkIEhUTUwuJyk7fX1mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpe3JldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZT09PURPQ1VNRU5UX05PREU/cm9vdENvbnRhaW5lckVsZW1lbnQ6cm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDt9ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChub2RlKXsvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4vLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4vLyByZW1vdmVkLlxuLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbm5vZGUub25jbGljaz1ub29wO31mdW5jdGlvbiBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsZG9tRWxlbWVudCxyb290Q29udGFpbmVyRWxlbWVudCxuZXh0UHJvcHMsaXNDdXN0b21Db21wb25lbnRUYWcpe2Zvcih2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpe2lmKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpe2NvbnRpbnVlO312YXIgbmV4dFByb3A9bmV4dFByb3BzW3Byb3BLZXldO2lmKHByb3BLZXk9PT1TVFlMRSl7e2lmKG5leHRQcm9wKXsvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbk9iamVjdC5mcmVlemUobmV4dFByb3ApO319Ly8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG5zZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LG5leHRQcm9wKTt9ZWxzZSBpZihwcm9wS2V5PT09REFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpe3ZhciBuZXh0SHRtbD1uZXh0UHJvcD9uZXh0UHJvcFtIVE1MJDFdOnVuZGVmaW5lZDtpZihuZXh0SHRtbCE9bnVsbCl7c2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsbmV4dEh0bWwpO319ZWxzZSBpZihwcm9wS2V5PT09Q0hJTERSRU4pe2lmKHR5cGVvZiBuZXh0UHJvcD09PSdzdHJpbmcnKXsvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4vLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4vLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbnZhciBjYW5TZXRUZXh0Q29udGVudD10YWchPT0ndGV4dGFyZWEnfHxuZXh0UHJvcCE9PScnO2lmKGNhblNldFRleHRDb250ZW50KXtzZXRUZXh0Q29udGVudChkb21FbGVtZW50LG5leHRQcm9wKTt9fWVsc2UgaWYodHlwZW9mIG5leHRQcm9wPT09J251bWJlcicpe3NldFRleHRDb250ZW50KGRvbUVsZW1lbnQsJycrbmV4dFByb3ApO319ZWxzZSBpZihwcm9wS2V5PT09U1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HfHxwcm9wS2V5PT09U1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpO2Vsc2UgaWYocHJvcEtleT09PUFVVE9GT0NVUyk7ZWxzZSBpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtpZihuZXh0UHJvcCE9bnVsbCl7aWYodHlwZW9mIG5leHRQcm9wIT09J2Z1bmN0aW9uJyl7d2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksbmV4dFByb3ApO31pZihwcm9wS2V5PT09J29uU2Nyb2xsJyl7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJyxkb21FbGVtZW50KTt9fX1lbHNlIGlmKG5leHRQcm9wIT1udWxsKXtzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQscHJvcEtleSxuZXh0UHJvcCxpc0N1c3RvbUNvbXBvbmVudFRhZyk7fX19ZnVuY3Rpb24gdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsd2FzQ3VzdG9tQ29tcG9uZW50VGFnLGlzQ3VzdG9tQ29tcG9uZW50VGFnKXsvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG5mb3IodmFyIGk9MDtpPHVwZGF0ZVBheWxvYWQubGVuZ3RoO2krPTIpe3ZhciBwcm9wS2V5PXVwZGF0ZVBheWxvYWRbaV07dmFyIHByb3BWYWx1ZT11cGRhdGVQYXlsb2FkW2krMV07aWYocHJvcEtleT09PVNUWUxFKXtzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LHByb3BWYWx1ZSk7fWVsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXtzZXRJbm5lckhUTUwoZG9tRWxlbWVudCxwcm9wVmFsdWUpO31lbHNlIGlmKHByb3BLZXk9PT1DSElMRFJFTil7c2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCxwcm9wVmFsdWUpO31lbHNle3NldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCxwcm9wS2V5LHByb3BWYWx1ZSxpc0N1c3RvbUNvbXBvbmVudFRhZyk7fX19ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLHByb3BzLHJvb3RDb250YWluZXJFbGVtZW50LHBhcmVudE5hbWVzcGFjZSl7dmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnOy8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbi8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbnZhciBvd25lckRvY3VtZW50PWdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7dmFyIGRvbUVsZW1lbnQ7dmFyIG5hbWVzcGFjZVVSST1wYXJlbnROYW1lc3BhY2U7aWYobmFtZXNwYWNlVVJJPT09SFRNTF9OQU1FU1BBQ0Upe25hbWVzcGFjZVVSST1nZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7fWlmKG5hbWVzcGFjZVVSST09PUhUTUxfTkFNRVNQQUNFKXt7aXNDdXN0b21Db21wb25lbnRUYWc9aXNDdXN0b21Db21wb25lbnQodHlwZSxwcm9wcyk7Ly8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuaWYoIWlzQ3VzdG9tQ29tcG9uZW50VGFnJiZ0eXBlIT09dHlwZS50b0xvd2VyQ2FzZSgpKXtlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcrJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnKydvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJyx0eXBlKTt9fWlmKHR5cGU9PT0nc2NyaXB0Jyl7Ly8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbnZhciBkaXY9b3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtkaXYuaW5uZXJIVE1MPSc8c2NyaXB0PjwnKycvc2NyaXB0Pic7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxuLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIHlpZWxkIGEgc2NyaXB0IGVsZW1lbnQuXG52YXIgZmlyc3RDaGlsZD1kaXYuZmlyc3RDaGlsZDtkb21FbGVtZW50PWRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTt9ZWxzZSBpZih0eXBlb2YgcHJvcHMuaXM9PT0nc3RyaW5nJyl7Ly8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG5kb21FbGVtZW50PW93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLHtpczpwcm9wcy5pc30pO31lbHNley8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuZG9tRWxlbWVudD1vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7Ly8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYCBhbmQgYHNpemVgXG4vLyBhdHRyaWJ1dGVzIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC5cbi8vIFRoaXMgcHJldmVudHM6XG4vLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbi8vICBgc2VsZWN0YCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGZpcnN0IGl0ZW0gIzEzMjIyXG4vLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgc2VsZWN0ZWQgZGVzcGl0ZSB0aGUgYHNpemVgIGF0dHJpYnV0ZSAjMTQyMzlcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDIzOVxuaWYodHlwZT09PSdzZWxlY3QnKXt2YXIgbm9kZT1kb21FbGVtZW50O2lmKHByb3BzLm11bHRpcGxlKXtub2RlLm11bHRpcGxlPXRydWU7fWVsc2UgaWYocHJvcHMuc2l6ZSl7Ly8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbi8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLlxuLy9cbi8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxubm9kZS5zaXplPXByb3BzLnNpemU7fX19fWVsc2V7ZG9tRWxlbWVudD1vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksdHlwZSk7fXtpZihuYW1lc3BhY2VVUkk9PT1IVE1MX05BTUVTUEFDRSl7aWYoIWlzQ3VzdG9tQ29tcG9uZW50VGFnJiZPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCk9PT0nW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyYmIWhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsdHlwZSkpe3dhcm5lZFVua25vd25UYWdzW3R5cGVdPXRydWU7ZXJyb3IoJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnKydJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcrJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJyx0eXBlKTt9fX1yZXR1cm4gZG9tRWxlbWVudDt9ZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCxyb290Q29udGFpbmVyRWxlbWVudCl7cmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7fWZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdGFnLHJhd1Byb3BzLHJvb3RDb250YWluZXJFbGVtZW50KXt2YXIgaXNDdXN0b21Db21wb25lbnRUYWc9aXNDdXN0b21Db21wb25lbnQodGFnLHJhd1Byb3BzKTt7dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcscmF3UHJvcHMpO30vLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxudmFyIHByb3BzO3N3aXRjaCh0YWcpe2Nhc2UnZGlhbG9nJzpsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLGRvbUVsZW1lbnQpO2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJyxkb21FbGVtZW50KTtwcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ2lmcmFtZSc6Y2FzZSdvYmplY3QnOmNhc2UnZW1iZWQnOi8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsZG9tRWxlbWVudCk7cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSd2aWRlbyc6Y2FzZSdhdWRpbyc6Ly8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbmZvcih2YXIgaT0wO2k8bWVkaWFFdmVudFR5cGVzLmxlbmd0aDtpKyspe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLGRvbUVsZW1lbnQpO31wcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ3NvdXJjZSc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLGRvbUVsZW1lbnQpO3Byb3BzPXJhd1Byb3BzO2JyZWFrO2Nhc2UnaW1nJzpjYXNlJ2ltYWdlJzpjYXNlJ2xpbmsnOi8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLGRvbUVsZW1lbnQpO2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLGRvbUVsZW1lbnQpO3Byb3BzPXJhd1Byb3BzO2JyZWFrO2Nhc2UnZGV0YWlscyc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsZG9tRWxlbWVudCk7cHJvcHM9cmF3UHJvcHM7YnJlYWs7Y2FzZSdpbnB1dCc6aW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LHJhd1Byb3BzKTtwcm9wcz1nZXRIb3N0UHJvcHMoZG9tRWxlbWVudCxyYXdQcm9wcyk7Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJyxkb21FbGVtZW50KTticmVhaztjYXNlJ29wdGlvbic6dmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LHJhd1Byb3BzKTtwcm9wcz1yYXdQcm9wczticmVhaztjYXNlJ3NlbGVjdCc6aW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQscmF3UHJvcHMpO3Byb3BzPWdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6aW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQscmF3UHJvcHMpO3Byb3BzPWdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7ZGVmYXVsdDpwcm9wcz1yYXdQcm9wczt9YXNzZXJ0VmFsaWRQcm9wcyh0YWcscHJvcHMpO3NldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZyxkb21FbGVtZW50LHJvb3RDb250YWluZXJFbGVtZW50LHByb3BzLGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtzd2l0Y2godGFnKXtjYXNlJ2lucHV0JzovLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4vLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxudHJhY2soZG9tRWxlbWVudCk7cG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LHJhd1Byb3BzLGZhbHNlKTticmVhaztjYXNlJ3RleHRhcmVhJzovLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4vLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxudHJhY2soZG9tRWxlbWVudCk7cG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2Unb3B0aW9uJzpwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCxyYXdQcm9wcyk7YnJlYWs7Y2FzZSdzZWxlY3QnOnBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LHJhd1Byb3BzKTticmVhaztkZWZhdWx0OmlmKHR5cGVvZiBwcm9wcy5vbkNsaWNrPT09J2Z1bmN0aW9uJyl7Ly8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbnRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO31icmVhazt9fS8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdGFnLGxhc3RSYXdQcm9wcyxuZXh0UmF3UHJvcHMscm9vdENvbnRhaW5lckVsZW1lbnQpe3t2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZyxuZXh0UmF3UHJvcHMpO312YXIgdXBkYXRlUGF5bG9hZD1udWxsO3ZhciBsYXN0UHJvcHM7dmFyIG5leHRQcm9wcztzd2l0Y2godGFnKXtjYXNlJ2lucHV0JzpsYXN0UHJvcHM9Z2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsbGFzdFJhd1Byb3BzKTtuZXh0UHJvcHM9Z2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsbmV4dFJhd1Byb3BzKTt1cGRhdGVQYXlsb2FkPVtdO2JyZWFrO2Nhc2Unc2VsZWN0JzpsYXN0UHJvcHM9Z2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCxsYXN0UmF3UHJvcHMpO25leHRQcm9wcz1nZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7dXBkYXRlUGF5bG9hZD1bXTticmVhaztjYXNlJ3RleHRhcmVhJzpsYXN0UHJvcHM9Z2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCxsYXN0UmF3UHJvcHMpO25leHRQcm9wcz1nZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7dXBkYXRlUGF5bG9hZD1bXTticmVhaztkZWZhdWx0Omxhc3RQcm9wcz1sYXN0UmF3UHJvcHM7bmV4dFByb3BzPW5leHRSYXdQcm9wcztpZih0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2shPT0nZnVuY3Rpb24nJiZ0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2s9PT0nZnVuY3Rpb24nKXsvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxudHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7fWJyZWFrO31hc3NlcnRWYWxpZFByb3BzKHRhZyxuZXh0UHJvcHMpO3ZhciBwcm9wS2V5O3ZhciBzdHlsZU5hbWU7dmFyIHN0eWxlVXBkYXRlcz1udWxsO2Zvcihwcm9wS2V5IGluIGxhc3RQcm9wcyl7aWYobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpfHwhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpfHxsYXN0UHJvcHNbcHJvcEtleV09PW51bGwpe2NvbnRpbnVlO31pZihwcm9wS2V5PT09U1RZTEUpe3ZhciBsYXN0U3R5bGU9bGFzdFByb3BzW3Byb3BLZXldO2ZvcihzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKXtpZihsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSl7aWYoIXN0eWxlVXBkYXRlcyl7c3R5bGVVcGRhdGVzPXt9O31zdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXT0nJzt9fX1lbHNlIGlmKHByb3BLZXk9PT1EQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTHx8cHJvcEtleT09PUNISUxEUkVOKTtlbHNlIGlmKHByb3BLZXk9PT1TVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkd8fHByb3BLZXk9PT1TVVBQUkVTU19IWURSQVRJT05fV0FSTklORyk7ZWxzZSBpZihwcm9wS2V5PT09QVVUT0ZPQ1VTKTtlbHNlIGlmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpey8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4vLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4vLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuaWYoIXVwZGF0ZVBheWxvYWQpe3VwZGF0ZVBheWxvYWQ9W107fX1lbHNley8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuLy8gdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4odXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LG51bGwpO319Zm9yKHByb3BLZXkgaW4gbmV4dFByb3BzKXt2YXIgbmV4dFByb3A9bmV4dFByb3BzW3Byb3BLZXldO3ZhciBsYXN0UHJvcD1sYXN0UHJvcHMhPW51bGw/bGFzdFByb3BzW3Byb3BLZXldOnVuZGVmaW5lZDtpZighbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpfHxuZXh0UHJvcD09PWxhc3RQcm9wfHxuZXh0UHJvcD09bnVsbCYmbGFzdFByb3A9PW51bGwpe2NvbnRpbnVlO31pZihwcm9wS2V5PT09U1RZTEUpe3tpZihuZXh0UHJvcCl7Ly8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbi8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG5PYmplY3QuZnJlZXplKG5leHRQcm9wKTt9fWlmKGxhc3RQcm9wKXsvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG5mb3Ioc3R5bGVOYW1lIGluIGxhc3RQcm9wKXtpZihsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpJiYoIW5leHRQcm9wfHwhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpe2lmKCFzdHlsZVVwZGF0ZXMpe3N0eWxlVXBkYXRlcz17fTt9c3R5bGVVcGRhdGVzW3N0eWxlTmFtZV09Jyc7fX0vLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuZm9yKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCl7aWYobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSYmbGFzdFByb3Bbc3R5bGVOYW1lXSE9PW5leHRQcm9wW3N0eWxlTmFtZV0pe2lmKCFzdHlsZVVwZGF0ZXMpe3N0eWxlVXBkYXRlcz17fTt9c3R5bGVVcGRhdGVzW3N0eWxlTmFtZV09bmV4dFByb3Bbc3R5bGVOYW1lXTt9fX1lbHNley8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuaWYoIXN0eWxlVXBkYXRlcyl7aWYoIXVwZGF0ZVBheWxvYWQpe3VwZGF0ZVBheWxvYWQ9W107fXVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LHN0eWxlVXBkYXRlcyk7fXN0eWxlVXBkYXRlcz1uZXh0UHJvcDt9fWVsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXt2YXIgbmV4dEh0bWw9bmV4dFByb3A/bmV4dFByb3BbSFRNTCQxXTp1bmRlZmluZWQ7dmFyIGxhc3RIdG1sPWxhc3RQcm9wP2xhc3RQcm9wW0hUTUwkMV06dW5kZWZpbmVkO2lmKG5leHRIdG1sIT1udWxsKXtpZihsYXN0SHRtbCE9PW5leHRIdG1sKXsodXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LG5leHRIdG1sKTt9fX1lbHNlIGlmKHByb3BLZXk9PT1DSElMRFJFTil7aWYodHlwZW9mIG5leHRQcm9wPT09J3N0cmluZyd8fHR5cGVvZiBuZXh0UHJvcD09PSdudW1iZXInKXsodXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LCcnK25leHRQcm9wKTt9fWVsc2UgaWYocHJvcEtleT09PVNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklOR3x8cHJvcEtleT09PVNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKTtlbHNlIGlmKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpe2lmKG5leHRQcm9wIT1udWxsKXsvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbmlmKHR5cGVvZiBuZXh0UHJvcCE9PSdmdW5jdGlvbicpe3dhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LG5leHRQcm9wKTt9aWYocHJvcEtleT09PSdvblNjcm9sbCcpe2xpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsZG9tRWxlbWVudCk7fX1pZighdXBkYXRlUGF5bG9hZCYmbGFzdFByb3AhPT1uZXh0UHJvcCl7Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbi8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbi8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG51cGRhdGVQYXlsb2FkPVtdO319ZWxzZXsvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4vLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSBhbGxvd2VkIHByb3BlcnR5IGxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4odXBkYXRlUGF5bG9hZD11cGRhdGVQYXlsb2FkfHxbXSkucHVzaChwcm9wS2V5LG5leHRQcm9wKTt9fWlmKHN0eWxlVXBkYXRlcyl7e3ZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsbmV4dFByb3BzW1NUWUxFXSk7fSh1cGRhdGVQYXlsb2FkPXVwZGF0ZVBheWxvYWR8fFtdKS5wdXNoKFNUWUxFLHN0eWxlVXBkYXRlcyk7fXJldHVybiB1cGRhdGVQYXlsb2FkO30vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCx1cGRhdGVQYXlsb2FkLHRhZyxsYXN0UmF3UHJvcHMsbmV4dFJhd1Byb3BzKXsvLyBVcGRhdGUgY2hlY2tlZCAqYmVmb3JlKiBuYW1lLlxuLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbi8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuaWYodGFnPT09J2lucHV0JyYmbmV4dFJhd1Byb3BzLnR5cGU9PT0ncmFkaW8nJiZuZXh0UmF3UHJvcHMubmFtZSE9bnVsbCl7dXBkYXRlQ2hlY2tlZChkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7fXZhciB3YXNDdXN0b21Db21wb25lbnRUYWc9aXNDdXN0b21Db21wb25lbnQodGFnLGxhc3RSYXdQcm9wcyk7dmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHRhZyxuZXh0UmF3UHJvcHMpOy8vIEFwcGx5IHRoZSBkaWZmLlxudXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsd2FzQ3VzdG9tQ29tcG9uZW50VGFnLGlzQ3VzdG9tQ29tcG9uZW50VGFnKTsvLyBUT0RPOiBFbnN1cmUgdGhhdCBhbiB1cGRhdGUgZ2V0cyBzY2hlZHVsZWQgaWYgYW55IG9mIHRoZSBzcGVjaWFsIHByb3BzXG4vLyBjaGFuZ2VkLlxuc3dpdGNoKHRhZyl7Y2FzZSdpbnB1dCc6Ly8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbi8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxudXBkYXRlV3JhcHBlcihkb21FbGVtZW50LG5leHRSYXdQcm9wcyk7YnJlYWs7Y2FzZSd0ZXh0YXJlYSc6dXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsbmV4dFJhd1Byb3BzKTticmVhaztjYXNlJ3NlbGVjdCc6Ly8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4vLyByZWNvbmNpbGlhdGlvblxucG9zdFVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCxuZXh0UmF3UHJvcHMpO2JyZWFrO319ZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpe3t2YXIgbG93ZXJDYXNlZE5hbWU9cHJvcE5hbWUudG9Mb3dlckNhc2UoKTtpZighcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSl7cmV0dXJuIG51bGw7fXJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdfHxudWxsO319ZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LHRhZyxyYXdQcm9wcyxwYXJlbnROYW1lc3BhY2Uscm9vdENvbnRhaW5lckVsZW1lbnQsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KXt2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7dmFyIGV4dHJhQXR0cmlidXRlTmFtZXM7e2lzQ3VzdG9tQ29tcG9uZW50VGFnPWlzQ3VzdG9tQ29tcG9uZW50KHRhZyxyYXdQcm9wcyk7dmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcscmF3UHJvcHMpO30vLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuc3dpdGNoKHRhZyl7Y2FzZSdkaWFsb2cnOmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsZG9tRWxlbWVudCk7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UnaWZyYW1lJzpjYXNlJ29iamVjdCc6Y2FzZSdlbWJlZCc6Ly8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4vLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGxvYWQgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJyxkb21FbGVtZW50KTticmVhaztjYXNlJ3ZpZGVvJzpjYXNlJ2F1ZGlvJzovLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGFsbCB0aGUgbWVkaWEgZXZlbnRzLlxuZm9yKHZhciBpPTA7aTxtZWRpYUV2ZW50VHlwZXMubGVuZ3RoO2krKyl7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sZG9tRWxlbWVudCk7fWJyZWFrO2Nhc2Unc291cmNlJzovLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdpbWcnOmNhc2UnaW1hZ2UnOmNhc2UnbGluayc6Ly8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG5saXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsZG9tRWxlbWVudCk7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdkZXRhaWxzJzovLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgdG9nZ2xlIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgndG9nZ2xlJyxkb21FbGVtZW50KTticmVhaztjYXNlJ2lucHV0Jzppbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQscmF3UHJvcHMpOy8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxubGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsZG9tRWxlbWVudCk7YnJlYWs7Y2FzZSdvcHRpb24nOnZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCxyYXdQcm9wcyk7YnJlYWs7Y2FzZSdzZWxlY3QnOmluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2UndGV4dGFyZWEnOmluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LHJhd1Byb3BzKTsvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbi8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cbmxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLGRvbUVsZW1lbnQpO2JyZWFrO31hc3NlcnRWYWxpZFByb3BzKHRhZyxyYXdQcm9wcyk7e2V4dHJhQXR0cmlidXRlTmFtZXM9bmV3IFNldCgpO3ZhciBhdHRyaWJ1dGVzPWRvbUVsZW1lbnQuYXR0cmlidXRlcztmb3IodmFyIF9pPTA7X2k8YXR0cmlidXRlcy5sZW5ndGg7X2krKyl7dmFyIG5hbWU9YXR0cmlidXRlc1tfaV0ubmFtZS50b0xvd2VyQ2FzZSgpO3N3aXRjaChuYW1lKXsvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbi8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuY2FzZSd2YWx1ZSc6YnJlYWs7Y2FzZSdjaGVja2VkJzpicmVhaztjYXNlJ3NlbGVjdGVkJzpicmVhaztkZWZhdWx0Oi8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW19pXS5uYW1lKTt9fX12YXIgdXBkYXRlUGF5bG9hZD1udWxsO2Zvcih2YXIgcHJvcEtleSBpbiByYXdQcm9wcyl7aWYoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtjb250aW51ZTt9dmFyIG5leHRQcm9wPXJhd1Byb3BzW3Byb3BLZXldO2lmKHByb3BLZXk9PT1DSElMRFJFTil7Ly8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbi8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbi8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3Rcbi8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbi8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbi8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuaWYodHlwZW9mIG5leHRQcm9wPT09J3N0cmluZycpe2lmKGRvbUVsZW1lbnQudGV4dENvbnRlbnQhPT1uZXh0UHJvcCl7aWYocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddIT09dHJ1ZSl7Y2hlY2tGb3JVbm1hdGNoZWRUZXh0KGRvbUVsZW1lbnQudGV4dENvbnRlbnQsbmV4dFByb3AsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KTt9dXBkYXRlUGF5bG9hZD1bQ0hJTERSRU4sbmV4dFByb3BdO319ZWxzZSBpZih0eXBlb2YgbmV4dFByb3A9PT0nbnVtYmVyJyl7aWYoZG9tRWxlbWVudC50ZXh0Q29udGVudCE9PScnK25leHRQcm9wKXtpZihyYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10hPT10cnVlKXtjaGVja0ZvclVubWF0Y2hlZFRleHQoZG9tRWxlbWVudC50ZXh0Q29udGVudCxuZXh0UHJvcCxpc0NvbmN1cnJlbnRNb2RlLHNob3VsZFdhcm5EZXYpO311cGRhdGVQYXlsb2FkPVtDSElMRFJFTiwnJytuZXh0UHJvcF07fX19ZWxzZSBpZihyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKXtpZihuZXh0UHJvcCE9bnVsbCl7aWYodHlwZW9mIG5leHRQcm9wIT09J2Z1bmN0aW9uJyl7d2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksbmV4dFByb3ApO31pZihwcm9wS2V5PT09J29uU2Nyb2xsJyl7bGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJyxkb21FbGVtZW50KTt9fX1lbHNlIGlmKHNob3VsZFdhcm5EZXYmJnRydWUmJi8vIENvbnZpbmNlIEZsb3cgd2UndmUgY2FsY3VsYXRlZCBpdCAoaXQncyBERVYtb25seSBpbiB0aGlzIG1ldGhvZC4pXG50eXBlb2YgaXNDdXN0b21Db21wb25lbnRUYWc9PT0nYm9vbGVhbicpey8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG52YXIgc2VydmVyVmFsdWU9dm9pZCAwO3ZhciBwcm9wZXJ0eUluZm89aXNDdXN0b21Db21wb25lbnRUYWcmJmVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQ/bnVsbDpnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7aWYocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddPT09dHJ1ZSk7ZWxzZSBpZihwcm9wS2V5PT09U1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HfHxwcm9wS2V5PT09U1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkd8fC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG5wcm9wS2V5PT09J3ZhbHVlJ3x8cHJvcEtleT09PSdjaGVja2VkJ3x8cHJvcEtleT09PSdzZWxlY3RlZCcpO2Vsc2UgaWYocHJvcEtleT09PURBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKXt2YXIgc2VydmVySFRNTD1kb21FbGVtZW50LmlubmVySFRNTDt2YXIgbmV4dEh0bWw9bmV4dFByb3A/bmV4dFByb3BbSFRNTCQxXTp1bmRlZmluZWQ7aWYobmV4dEh0bWwhPW51bGwpe3ZhciBleHBlY3RlZEhUTUw9bm9ybWFsaXplSFRNTChkb21FbGVtZW50LG5leHRIdG1sKTtpZihleHBlY3RlZEhUTUwhPT1zZXJ2ZXJIVE1MKXt3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSxzZXJ2ZXJIVE1MLGV4cGVjdGVkSFRNTCk7fX19ZWxzZSBpZihwcm9wS2V5PT09U1RZTEUpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO2lmKGNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmcpe3ZhciBleHBlY3RlZFN0eWxlPWNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7c2VydmVyVmFsdWU9ZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7aWYoZXhwZWN0ZWRTdHlsZSE9PXNlcnZlclZhbHVlKXt3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSxzZXJ2ZXJWYWx1ZSxleHBlY3RlZFN0eWxlKTt9fX1lbHNlIGlmKGlzQ3VzdG9tQ29tcG9uZW50VGFnJiYhZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCl7Ly8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtzZXJ2ZXJWYWx1ZT1nZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LHByb3BLZXksbmV4dFByb3ApO2lmKG5leHRQcm9wIT09c2VydmVyVmFsdWUpe3dhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LHNlcnZlclZhbHVlLG5leHRQcm9wKTt9fWVsc2UgaWYoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LHByb3BlcnR5SW5mbyxpc0N1c3RvbUNvbXBvbmVudFRhZykmJiFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSxuZXh0UHJvcCxwcm9wZXJ0eUluZm8saXNDdXN0b21Db21wb25lbnRUYWcpKXt2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nPWZhbHNlO2lmKHByb3BlcnR5SW5mbyE9PW51bGwpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtzZXJ2ZXJWYWx1ZT1nZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQscHJvcEtleSxuZXh0UHJvcCxwcm9wZXJ0eUluZm8pO31lbHNle3ZhciBvd25OYW1lc3BhY2U9cGFyZW50TmFtZXNwYWNlO2lmKG93bk5hbWVzcGFjZT09PUhUTUxfTkFNRVNQQUNFKXtvd25OYW1lc3BhY2U9Z2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7fWlmKG93bk5hbWVzcGFjZT09PUhUTUxfTkFNRVNQQUNFKXsvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5leHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO31lbHNle3ZhciBzdGFuZGFyZE5hbWU9Z2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcEtleSk7aWYoc3RhbmRhcmROYW1lIT09bnVsbCYmc3RhbmRhcmROYW1lIT09cHJvcEtleSl7Ly8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4vLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4vLyAoYW5kIHdvdWxkIGJlIGluY29ycmVjdGx5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQpLlxuLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbmlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZz10cnVlOy8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHN0YW5kYXJkTmFtZSk7fS8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbmV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO31zZXJ2ZXJWYWx1ZT1nZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LHByb3BLZXksbmV4dFByb3ApO312YXIgZG9udFdhcm5DdXN0b21FbGVtZW50PWVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQ7aWYoIWRvbnRXYXJuQ3VzdG9tRWxlbWVudCYmbmV4dFByb3AhPT1zZXJ2ZXJWYWx1ZSYmIWlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyl7d2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksc2VydmVyVmFsdWUsbmV4dFByb3ApO319fX17aWYoc2hvdWxkV2FybkRldil7aWYoLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplPjAmJnJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSE9PXRydWUpey8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7fX19c3dpdGNoKHRhZyl7Y2FzZSdpbnB1dCc6Ly8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbnRyYWNrKGRvbUVsZW1lbnQpO3Bvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCxyYXdQcm9wcyx0cnVlKTticmVhaztjYXNlJ3RleHRhcmVhJzovLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4vLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxudHJhY2soZG9tRWxlbWVudCk7cG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO2JyZWFrO2Nhc2Unc2VsZWN0JzpjYXNlJ29wdGlvbic6Ly8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4vLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3Jcbi8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3Rcbi8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4vLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuYnJlYWs7ZGVmYXVsdDppZih0eXBlb2YgcmF3UHJvcHMub25DbGljaz09PSdmdW5jdGlvbicpey8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG50cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTt9YnJlYWs7fXJldHVybiB1cGRhdGVQYXlsb2FkO31mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLHRleHQsaXNDb25jdXJyZW50TW9kZSl7dmFyIGlzRGlmZmVyZW50PXRleHROb2RlLm5vZGVWYWx1ZSE9PXRleHQ7cmV0dXJuIGlzRGlmZmVyZW50O31mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsY2hpbGQpe3tpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO319ZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnROb2RlLGNoaWxkKXt7aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsY2hpbGQubm9kZVZhbHVlLHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSx0YWcscHJvcHMpe3tpZihkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbil7cmV0dXJuO31kaWRXYXJuSW52YWxpZEh5ZHJhdGlvbj10cnVlO2Vycm9yKCdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsdGFnLHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSx0ZXh0KXt7aWYodGV4dD09PScnKXsvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbi8vIHRoZSBIVE1MLlxuLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuLy8gdGV4dCBub2Rlcy5cbnJldHVybjt9aWYoZGlkV2FybkludmFsaWRIeWRyYXRpb24pe3JldHVybjt9ZGlkV2FybkludmFsaWRIeWRyYXRpb249dHJ1ZTtlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJyx0ZXh0LHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCx0YWcscHJvcHMpe3N3aXRjaCh0YWcpe2Nhc2UnaW5wdXQnOnJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCxwcm9wcyk7cmV0dXJuO2Nhc2UndGV4dGFyZWEnOnJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LHByb3BzKTtyZXR1cm47Y2FzZSdzZWxlY3QnOnJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LHByb3BzKTtyZXR1cm47fX12YXIgdmFsaWRhdGVET01OZXN0aW5nPWZ1bmN0aW9uKCl7fTt2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbz1mdW5jdGlvbigpe307ey8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuLy9cbi8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4vLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4vLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4vLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4vLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbi8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG52YXIgc3BlY2lhbFRhZ3M9WydhZGRyZXNzJywnYXBwbGV0JywnYXJlYScsJ2FydGljbGUnLCdhc2lkZScsJ2Jhc2UnLCdiYXNlZm9udCcsJ2Jnc291bmQnLCdibG9ja3F1b3RlJywnYm9keScsJ2JyJywnYnV0dG9uJywnY2FwdGlvbicsJ2NlbnRlcicsJ2NvbCcsJ2NvbGdyb3VwJywnZGQnLCdkZXRhaWxzJywnZGlyJywnZGl2JywnZGwnLCdkdCcsJ2VtYmVkJywnZmllbGRzZXQnLCdmaWdjYXB0aW9uJywnZmlndXJlJywnZm9vdGVyJywnZm9ybScsJ2ZyYW1lJywnZnJhbWVzZXQnLCdoMScsJ2gyJywnaDMnLCdoNCcsJ2g1JywnaDYnLCdoZWFkJywnaGVhZGVyJywnaGdyb3VwJywnaHInLCdodG1sJywnaWZyYW1lJywnaW1nJywnaW5wdXQnLCdpc2luZGV4JywnbGknLCdsaW5rJywnbGlzdGluZycsJ21haW4nLCdtYXJxdWVlJywnbWVudScsJ21lbnVpdGVtJywnbWV0YScsJ25hdicsJ25vZW1iZWQnLCdub2ZyYW1lcycsJ25vc2NyaXB0Jywnb2JqZWN0Jywnb2wnLCdwJywncGFyYW0nLCdwbGFpbnRleHQnLCdwcmUnLCdzY3JpcHQnLCdzZWN0aW9uJywnc2VsZWN0Jywnc291cmNlJywnc3R5bGUnLCdzdW1tYXJ5JywndGFibGUnLCd0Ym9keScsJ3RkJywndGVtcGxhdGUnLCd0ZXh0YXJlYScsJ3Rmb290JywndGgnLCd0aGVhZCcsJ3RpdGxlJywndHInLCd0cmFjaycsJ3VsJywnd2JyJywneG1wJ107Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbnZhciBpblNjb3BlVGFncz1bJ2FwcGxldCcsJ2NhcHRpb24nLCdodG1sJywndGFibGUnLCd0ZCcsJ3RoJywnbWFycXVlZScsJ29iamVjdCcsJ3RlbXBsYXRlJywvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4vLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbi8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3Ncbidmb3JlaWduT2JqZWN0JywnZGVzYycsJ3RpdGxlJ107Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG52YXIgYnV0dG9uU2NvcGVUYWdzPWluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG52YXIgaW1wbGllZEVuZFRhZ3M9WydkZCcsJ2R0JywnbGknLCdvcHRpb24nLCdvcHRncm91cCcsJ3AnLCdycCcsJ3J0J107dmFyIGVtcHR5QW5jZXN0b3JJbmZvPXtjdXJyZW50Om51bGwsZm9ybVRhZzpudWxsLGFUYWdJblNjb3BlOm51bGwsYnV0dG9uVGFnSW5TY29wZTpudWxsLG5vYnJUYWdJblNjb3BlOm51bGwscFRhZ0luQnV0dG9uU2NvcGU6bnVsbCxsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOm51bGwsZGxJdGVtVGFnQXV0b2Nsb3Npbmc6bnVsbH07dXBkYXRlZEFuY2VzdG9ySW5mbz1mdW5jdGlvbihvbGRJbmZvLHRhZyl7dmFyIGFuY2VzdG9ySW5mbz1hc3NpZ24oe30sb2xkSW5mb3x8ZW1wdHlBbmNlc3RvckluZm8pO3ZhciBpbmZvPXt0YWc6dGFnfTtpZihpblNjb3BlVGFncy5pbmRleE9mKHRhZykhPT0tMSl7YW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlPW51bGw7YW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU9bnVsbDthbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU9bnVsbDt9aWYoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSE9PS0xKXthbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU9bnVsbDt9Ly8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbmlmKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSE9PS0xJiZ0YWchPT0nYWRkcmVzcycmJnRhZyE9PSdkaXYnJiZ0YWchPT0ncCcpe2FuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nPW51bGw7YW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nPW51bGw7fWFuY2VzdG9ySW5mby5jdXJyZW50PWluZm87aWYodGFnPT09J2Zvcm0nKXthbmNlc3RvckluZm8uZm9ybVRhZz1pbmZvO31pZih0YWc9PT0nYScpe2FuY2VzdG9ySW5mby5hVGFnSW5TY29wZT1pbmZvO31pZih0YWc9PT0nYnV0dG9uJyl7YW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU9aW5mbzt9aWYodGFnPT09J25vYnInKXthbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU9aW5mbzt9aWYodGFnPT09J3AnKXthbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU9aW5mbzt9aWYodGFnPT09J2xpJyl7YW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc9aW5mbzt9aWYodGFnPT09J2RkJ3x8dGFnPT09J2R0Jyl7YW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nPWluZm87fXJldHVybiBhbmNlc3RvckluZm87fTsvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL3ZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudD1mdW5jdGlvbih0YWcscGFyZW50VGFnKXsvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbnN3aXRjaChwYXJlbnRUYWcpey8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuY2FzZSdzZWxlY3QnOnJldHVybiB0YWc9PT0nb3B0aW9uJ3x8dGFnPT09J29wdGdyb3VwJ3x8dGFnPT09JyN0ZXh0JztjYXNlJ29wdGdyb3VwJzpyZXR1cm4gdGFnPT09J29wdGlvbid8fHRhZz09PScjdGV4dCc7Ly8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuLy8gYnV0XG5jYXNlJ29wdGlvbic6cmV0dXJuIHRhZz09PScjdGV4dCc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbi8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4vLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbmNhc2UndHInOnJldHVybiB0YWc9PT0ndGgnfHx0YWc9PT0ndGQnfHx0YWc9PT0nc3R5bGUnfHx0YWc9PT0nc2NyaXB0J3x8dGFnPT09J3RlbXBsYXRlJzsvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuY2FzZSd0Ym9keSc6Y2FzZSd0aGVhZCc6Y2FzZSd0Zm9vdCc6cmV0dXJuIHRhZz09PSd0cid8fHRhZz09PSdzdHlsZSd8fHRhZz09PSdzY3JpcHQnfHx0YWc9PT0ndGVtcGxhdGUnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG5jYXNlJ2NvbGdyb3VwJzpyZXR1cm4gdGFnPT09J2NvbCd8fHRhZz09PSd0ZW1wbGF0ZSc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbmNhc2UndGFibGUnOnJldHVybiB0YWc9PT0nY2FwdGlvbid8fHRhZz09PSdjb2xncm91cCd8fHRhZz09PSd0Ym9keSd8fHRhZz09PSd0Zm9vdCd8fHRhZz09PSd0aGVhZCd8fHRhZz09PSdzdHlsZSd8fHRhZz09PSdzY3JpcHQnfHx0YWc9PT0ndGVtcGxhdGUnOy8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbmNhc2UnaGVhZCc6cmV0dXJuIHRhZz09PSdiYXNlJ3x8dGFnPT09J2Jhc2Vmb250J3x8dGFnPT09J2Jnc291bmQnfHx0YWc9PT0nbGluayd8fHRhZz09PSdtZXRhJ3x8dGFnPT09J3RpdGxlJ3x8dGFnPT09J25vc2NyaXB0J3x8dGFnPT09J25vZnJhbWVzJ3x8dGFnPT09J3N0eWxlJ3x8dGFnPT09J3NjcmlwdCd8fHRhZz09PSd0ZW1wbGF0ZSc7Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuY2FzZSdodG1sJzpyZXR1cm4gdGFnPT09J2hlYWQnfHx0YWc9PT0nYm9keSd8fHRhZz09PSdmcmFtZXNldCc7Y2FzZSdmcmFtZXNldCc6cmV0dXJuIHRhZz09PSdmcmFtZSc7Y2FzZScjZG9jdW1lbnQnOnJldHVybiB0YWc9PT0naHRtbCc7fS8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3Ncbi8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbnN3aXRjaCh0YWcpe2Nhc2UnaDEnOmNhc2UnaDInOmNhc2UnaDMnOmNhc2UnaDQnOmNhc2UnaDUnOmNhc2UnaDYnOnJldHVybiBwYXJlbnRUYWchPT0naDEnJiZwYXJlbnRUYWchPT0naDInJiZwYXJlbnRUYWchPT0naDMnJiZwYXJlbnRUYWchPT0naDQnJiZwYXJlbnRUYWchPT0naDUnJiZwYXJlbnRUYWchPT0naDYnO2Nhc2UncnAnOmNhc2UncnQnOnJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZyk9PT0tMTtjYXNlJ2JvZHknOmNhc2UnY2FwdGlvbic6Y2FzZSdjb2wnOmNhc2UnY29sZ3JvdXAnOmNhc2UnZnJhbWVzZXQnOmNhc2UnZnJhbWUnOmNhc2UnaGVhZCc6Y2FzZSdodG1sJzpjYXNlJ3Rib2R5JzpjYXNlJ3RkJzpjYXNlJ3Rmb290JzpjYXNlJ3RoJzpjYXNlJ3RoZWFkJzpjYXNlJ3RyJzovLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4vLyBjYXNlcyBhcmUgaW52YWxpZC5cbnJldHVybiBwYXJlbnRUYWc9PW51bGw7fXJldHVybiB0cnVlO307LyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi92YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZz1mdW5jdGlvbih0YWcsYW5jZXN0b3JJbmZvKXtzd2l0Y2godGFnKXtjYXNlJ2FkZHJlc3MnOmNhc2UnYXJ0aWNsZSc6Y2FzZSdhc2lkZSc6Y2FzZSdibG9ja3F1b3RlJzpjYXNlJ2NlbnRlcic6Y2FzZSdkZXRhaWxzJzpjYXNlJ2RpYWxvZyc6Y2FzZSdkaXInOmNhc2UnZGl2JzpjYXNlJ2RsJzpjYXNlJ2ZpZWxkc2V0JzpjYXNlJ2ZpZ2NhcHRpb24nOmNhc2UnZmlndXJlJzpjYXNlJ2Zvb3Rlcic6Y2FzZSdoZWFkZXInOmNhc2UnaGdyb3VwJzpjYXNlJ21haW4nOmNhc2UnbWVudSc6Y2FzZSduYXYnOmNhc2Unb2wnOmNhc2UncCc6Y2FzZSdzZWN0aW9uJzpjYXNlJ3N1bW1hcnknOmNhc2UndWwnOmNhc2UncHJlJzpjYXNlJ2xpc3RpbmcnOmNhc2UndGFibGUnOmNhc2UnaHInOmNhc2UneG1wJzpjYXNlJ2gxJzpjYXNlJ2gyJzpjYXNlJ2gzJzpjYXNlJ2g0JzpjYXNlJ2g1JzpjYXNlJ2g2JzpyZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO2Nhc2UnZm9ybSc6cmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnfHxhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7Y2FzZSdsaSc6cmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO2Nhc2UnZGQnOmNhc2UnZHQnOnJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7Y2FzZSdidXR0b24nOnJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtjYXNlJ2EnOi8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxucmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtjYXNlJ25vYnInOnJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7fXJldHVybiBudWxsO307dmFyIGRpZFdhcm4kMT17fTt2YWxpZGF0ZURPTU5lc3Rpbmc9ZnVuY3Rpb24oY2hpbGRUYWcsY2hpbGRUZXh0LGFuY2VzdG9ySW5mbyl7YW5jZXN0b3JJbmZvPWFuY2VzdG9ySW5mb3x8ZW1wdHlBbmNlc3RvckluZm87dmFyIHBhcmVudEluZm89YW5jZXN0b3JJbmZvLmN1cnJlbnQ7dmFyIHBhcmVudFRhZz1wYXJlbnRJbmZvJiZwYXJlbnRJbmZvLnRhZztpZihjaGlsZFRleHQhPW51bGwpe2lmKGNoaWxkVGFnIT1udWxsKXtlcnJvcigndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7fWNoaWxkVGFnPScjdGV4dCc7fXZhciBpbnZhbGlkUGFyZW50PWlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLHBhcmVudFRhZyk/bnVsbDpwYXJlbnRJbmZvO3ZhciBpbnZhbGlkQW5jZXN0b3I9aW52YWxpZFBhcmVudD9udWxsOmZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsYW5jZXN0b3JJbmZvKTt2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3I9aW52YWxpZFBhcmVudHx8aW52YWxpZEFuY2VzdG9yO2lmKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcil7cmV0dXJuO312YXIgYW5jZXN0b3JUYWc9aW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO3ZhciB3YXJuS2V5PSEhaW52YWxpZFBhcmVudCsnfCcrY2hpbGRUYWcrJ3wnK2FuY2VzdG9yVGFnO2lmKGRpZFdhcm4kMVt3YXJuS2V5XSl7cmV0dXJuO31kaWRXYXJuJDFbd2FybktleV09dHJ1ZTt2YXIgdGFnRGlzcGxheU5hbWU9Y2hpbGRUYWc7dmFyIHdoaXRlc3BhY2VJbmZvPScnO2lmKGNoaWxkVGFnPT09JyN0ZXh0Jyl7aWYoL1xcUy8udGVzdChjaGlsZFRleHQpKXt0YWdEaXNwbGF5TmFtZT0nVGV4dCBub2Rlcyc7fWVsc2V7dGFnRGlzcGxheU5hbWU9J1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7d2hpdGVzcGFjZUluZm89XCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIisnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJzt9fWVsc2V7dGFnRGlzcGxheU5hbWU9JzwnK2NoaWxkVGFnKyc+Jzt9aWYoaW52YWxpZFBhcmVudCl7dmFyIGluZm89Jyc7aWYoYW5jZXN0b3JUYWc9PT0ndGFibGUnJiZjaGlsZFRhZz09PSd0cicpe2luZm8rPScgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcrJ3RoZSBicm93c2VyLic7fWVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcycsdGFnRGlzcGxheU5hbWUsYW5jZXN0b3JUYWcsd2hpdGVzcGFjZUluZm8saW5mbyk7fWVsc2V7ZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnKyc8JXM+LicsdGFnRGlzcGxheU5hbWUsYW5jZXN0b3JUYWcpO319O312YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMT0nc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzt2YXIgU1VTUEVOU0VfU1RBUlRfREFUQT0nJCc7dmFyIFNVU1BFTlNFX0VORF9EQVRBPScvJCc7dmFyIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQT0nJD8nO3ZhciBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBPSckISc7dmFyIFNUWUxFJDE9J3N0eWxlJzt2YXIgZXZlbnRzRW5hYmxlZD1udWxsO3ZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbj1udWxsO2Z1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2Upe3ZhciB0eXBlO3ZhciBuYW1lc3BhY2U7dmFyIG5vZGVUeXBlPXJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtzd2l0Y2gobm9kZVR5cGUpe2Nhc2UgRE9DVU1FTlRfTk9ERTpjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6e3R5cGU9bm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFPycjZG9jdW1lbnQnOicjZnJhZ21lbnQnO3ZhciByb290PXJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7bmFtZXNwYWNlPXJvb3Q/cm9vdC5uYW1lc3BhY2VVUkk6Z2V0Q2hpbGROYW1lc3BhY2UobnVsbCwnJyk7YnJlYWs7fWRlZmF1bHQ6e3ZhciBjb250YWluZXI9bm9kZVR5cGU9PT1DT01NRU5UX05PREU/cm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGU6cm9vdENvbnRhaW5lckluc3RhbmNlO3ZhciBvd25OYW1lc3BhY2U9Y29udGFpbmVyLm5hbWVzcGFjZVVSSXx8bnVsbDt0eXBlPWNvbnRhaW5lci50YWdOYW1lO25hbWVzcGFjZT1nZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsdHlwZSk7YnJlYWs7fX17dmFyIHZhbGlkYXRlZFRhZz10eXBlLnRvTG93ZXJDYXNlKCk7dmFyIGFuY2VzdG9ySW5mbz11cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsdmFsaWRhdGVkVGFnKTtyZXR1cm57bmFtZXNwYWNlOm5hbWVzcGFjZSxhbmNlc3RvckluZm86YW5jZXN0b3JJbmZvfTt9fWZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHQocGFyZW50SG9zdENvbnRleHQsdHlwZSxyb290Q29udGFpbmVySW5zdGFuY2Upe3t2YXIgcGFyZW50SG9zdENvbnRleHREZXY9cGFyZW50SG9zdENvbnRleHQ7dmFyIG5hbWVzcGFjZT1nZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsdHlwZSk7dmFyIGFuY2VzdG9ySW5mbz11cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyx0eXBlKTtyZXR1cm57bmFtZXNwYWNlOm5hbWVzcGFjZSxhbmNlc3RvckluZm86YW5jZXN0b3JJbmZvfTt9fWZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKXtyZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIHByZXBhcmVGb3JDb21taXQoY29udGFpbmVySW5mbyl7ZXZlbnRzRW5hYmxlZD1pc0VuYWJsZWQoKTtzZWxlY3Rpb25JbmZvcm1hdGlvbj1nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO3ZhciBhY3RpdmVJbnN0YW5jZT1udWxsO3NldEVuYWJsZWQoZmFsc2UpO3JldHVybiBhY3RpdmVJbnN0YW5jZTt9ZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdChjb250YWluZXJJbmZvKXtyZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO2V2ZW50c0VuYWJsZWQ9bnVsbDtzZWxlY3Rpb25JbmZvcm1hdGlvbj1udWxsO31mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLHByb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXt2YXIgcGFyZW50TmFtZXNwYWNlO3svLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxudmFyIGhvc3RDb250ZXh0RGV2PWhvc3RDb250ZXh0O3ZhbGlkYXRlRE9NTmVzdGluZyh0eXBlLG51bGwsaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtpZih0eXBlb2YgcHJvcHMuY2hpbGRyZW49PT0nc3RyaW5nJ3x8dHlwZW9mIHByb3BzLmNoaWxkcmVuPT09J251bWJlcicpe3ZhciBzdHJpbmc9JycrcHJvcHMuY2hpbGRyZW47dmFyIG93bkFuY2VzdG9ySW5mbz11cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyx0eXBlKTt2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCxzdHJpbmcsb3duQW5jZXN0b3JJbmZvKTt9cGFyZW50TmFtZXNwYWNlPWhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTt9dmFyIGRvbUVsZW1lbnQ9Y3JlYXRlRWxlbWVudCh0eXBlLHByb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxwYXJlbnROYW1lc3BhY2UpO3ByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsZG9tRWxlbWVudCk7dXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LHByb3BzKTtyZXR1cm4gZG9tRWxlbWVudDt9ZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLGNoaWxkKXtwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7fWZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGRvbUVsZW1lbnQsdHlwZSxwcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UsaG9zdENvbnRleHQpe3NldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdHlwZSxwcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UpO3N3aXRjaCh0eXBlKXtjYXNlJ2J1dHRvbic6Y2FzZSdpbnB1dCc6Y2FzZSdzZWxlY3QnOmNhc2UndGV4dGFyZWEnOnJldHVybiEhcHJvcHMuYXV0b0ZvY3VzO2Nhc2UnaW1nJzpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZTt9fWZ1bmN0aW9uIHByZXBhcmVVcGRhdGUoZG9tRWxlbWVudCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCl7e3ZhciBob3N0Q29udGV4dERldj1ob3N0Q29udGV4dDtpZih0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4hPT10eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4mJih0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW49PT0nc3RyaW5nJ3x8dHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuPT09J251bWJlcicpKXt2YXIgc3RyaW5nPScnK25ld1Byb3BzLmNoaWxkcmVuO3ZhciBvd25BbmNlc3RvckluZm89dXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sdHlwZSk7dmFsaWRhdGVET01OZXN0aW5nKG51bGwsc3RyaW5nLG93bkFuY2VzdG9ySW5mbyk7fX1yZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzKTt9ZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSxwcm9wcyl7cmV0dXJuIHR5cGU9PT0ndGV4dGFyZWEnfHx0eXBlPT09J25vc2NyaXB0J3x8dHlwZW9mIHByb3BzLmNoaWxkcmVuPT09J3N0cmluZyd8fHR5cGVvZiBwcm9wcy5jaGlsZHJlbj09PSdudW1iZXInfHx0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9PT0nb2JqZWN0JyYmcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPT1udWxsJiZwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwhPW51bGw7fWZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXt7dmFyIGhvc3RDb250ZXh0RGV2PWhvc3RDb250ZXh0O3ZhbGlkYXRlRE9NTmVzdGluZyhudWxsLHRleHQsaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTt9dmFyIHRleHROb2RlPWNyZWF0ZVRleHROb2RlKHRleHQscm9vdENvbnRhaW5lckluc3RhbmNlKTtwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLHRleHROb2RlKTtyZXR1cm4gdGV4dE5vZGU7fWZ1bmN0aW9uIGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCl7dmFyIGN1cnJlbnRFdmVudD13aW5kb3cuZXZlbnQ7aWYoY3VycmVudEV2ZW50PT09dW5kZWZpbmVkKXtyZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7fXJldHVybiBnZXRFdmVudFByaW9yaXR5KGN1cnJlbnRFdmVudC50eXBlKTt9Ly8gaWYgYSBjb21wb25lbnQganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuXG4vLyBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3QgaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC5cbnZhciBzY2hlZHVsZVRpbWVvdXQ9dHlwZW9mIHNldFRpbWVvdXQ9PT0nZnVuY3Rpb24nP3NldFRpbWVvdXQ6dW5kZWZpbmVkO3ZhciBjYW5jZWxUaW1lb3V0PXR5cGVvZiBjbGVhclRpbWVvdXQ9PT0nZnVuY3Rpb24nP2NsZWFyVGltZW91dDp1bmRlZmluZWQ7dmFyIG5vVGltZW91dD0tMTt2YXIgbG9jYWxQcm9taXNlPXR5cGVvZiBQcm9taXNlPT09J2Z1bmN0aW9uJz9Qcm9taXNlOnVuZGVmaW5lZDsvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgc2NoZWR1bGVNaWNyb3Rhc2s9dHlwZW9mIHF1ZXVlTWljcm90YXNrPT09J2Z1bmN0aW9uJz9xdWV1ZU1pY3JvdGFzazp0eXBlb2YgbG9jYWxQcm9taXNlIT09J3VuZGVmaW5lZCc/ZnVuY3Rpb24oY2FsbGJhY2spe3JldHVybiBsb2NhbFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGNhbGxiYWNrKS5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO306c2NoZWR1bGVUaW1lb3V0Oy8vIFRPRE86IERldGVybWluZSB0aGUgYmVzdCBmYWxsYmFjayBoZXJlLlxuZnVuY3Rpb24gaGFuZGxlRXJyb3JJbk5leHRUaWNrKGVycm9yKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZXJyb3I7fSk7fS8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsdHlwZSxuZXdQcm9wcyxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXsvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbi8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4vLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbi8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbi8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbnN3aXRjaCh0eXBlKXtjYXNlJ2J1dHRvbic6Y2FzZSdpbnB1dCc6Y2FzZSdzZWxlY3QnOmNhc2UndGV4dGFyZWEnOmlmKG5ld1Byb3BzLmF1dG9Gb2N1cyl7ZG9tRWxlbWVudC5mb2N1cygpO31yZXR1cm47Y2FzZSdpbWcnOntpZihuZXdQcm9wcy5zcmMpe2RvbUVsZW1lbnQuc3JjPW5ld1Byb3BzLnNyYzt9cmV0dXJuO319fWZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LHVwZGF0ZVBheWxvYWQsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyxpbnRlcm5hbEluc3RhbmNlSGFuZGxlKXsvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgRE9NIG5vZGUuXG51cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsdXBkYXRlUGF5bG9hZCx0eXBlLG9sZFByb3BzLG5ld1Byb3BzKTsvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbi8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbnVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCxuZXdQcm9wcyk7fWZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCl7c2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwnJyk7fWZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLG9sZFRleHQsbmV3VGV4dCl7dGV4dEluc3RhbmNlLm5vZGVWYWx1ZT1uZXdUZXh0O31mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSxjaGlsZCl7cGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO31mdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lcixjaGlsZCl7dmFyIHBhcmVudE5vZGU7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtwYXJlbnROb2RlPWNvbnRhaW5lci5wYXJlbnROb2RlO3BhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLGNvbnRhaW5lcik7fWVsc2V7cGFyZW50Tm9kZT1jb250YWluZXI7cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7fS8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuLy8gSWYgc29tZXRoaW5nIGluc2lkZSBhIHBvcnRhbCBpcyBjbGlja2VkLCB0aGF0IGNsaWNrIHNob3VsZCBidWJibGVcbi8vIHRocm91Z2ggdGhlIFJlYWN0IHRyZWUuIEhvd2V2ZXIsIG9uIE1vYmlsZSBTYWZhcmkgdGhlIGNsaWNrIHdvdWxkXG4vLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4vLyBldmVudCBleGlzdHMuIFNvIHdlIHdvdWxkbid0IHNlZSBpdCBhbmQgZGlzcGF0Y2ggaXQuXG4vLyBUaGlzIGlzIHdoeSB3ZSBlbnN1cmUgdGhhdCBub24gUmVhY3Qgcm9vdCBjb250YWluZXJzIGhhdmUgaW5saW5lIG9uY2xpY2tcbi8vIGRlZmluZWQuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExOTE4XG52YXIgcmVhY3RSb290Q29udGFpbmVyPWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO2lmKChyZWFjdFJvb3RDb250YWluZXI9PT1udWxsfHxyZWFjdFJvb3RDb250YWluZXI9PT11bmRlZmluZWQpJiZwYXJlbnROb2RlLm9uY2xpY2s9PT1udWxsKXsvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxudHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50Tm9kZSk7fX1mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsY2hpbGQsYmVmb3JlQ2hpbGQpe3BhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCxiZWZvcmVDaGlsZCk7fWZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lcixjaGlsZCxiZWZvcmVDaGlsZCl7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsYmVmb3JlQ2hpbGQpO31lbHNle2NvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsYmVmb3JlQ2hpbGQpO319ZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsY2hpbGQpe3BhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTt9ZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lcixjaGlsZCl7aWYoY29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXtjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7fWVsc2V7Y29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTt9fWZ1bmN0aW9uIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShwYXJlbnRJbnN0YW5jZSxzdXNwZW5zZUluc3RhbmNlKXt2YXIgbm9kZT1zdXNwZW5zZUluc3RhbmNlOy8vIERlbGV0ZSBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4vLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG52YXIgZGVwdGg9MDtkb3t2YXIgbmV4dE5vZGU9bm9kZS5uZXh0U2libGluZztwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChub2RlKTtpZihuZXh0Tm9kZSYmbmV4dE5vZGUubm9kZVR5cGU9PT1DT01NRU5UX05PREUpe3ZhciBkYXRhPW5leHROb2RlLmRhdGE7aWYoZGF0YT09PVNVU1BFTlNFX0VORF9EQVRBKXtpZihkZXB0aD09PTApe3BhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5leHROb2RlKTsvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO3JldHVybjt9ZWxzZXtkZXB0aC0tO319ZWxzZSBpZihkYXRhPT09U1VTUEVOU0VfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEpe2RlcHRoKys7fX1ub2RlPW5leHROb2RlO313aGlsZShub2RlKTsvLyBUT0RPOiBXYXJuLCB3ZSBkaWRuJ3QgZmluZCB0aGUgZW5kIGNvbW1lbnQgYm91bmRhcnkuXG4vLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5yZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO31mdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKGNvbnRhaW5lcixzdXNwZW5zZUluc3RhbmNlKXtpZihjb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREUpe2NsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIucGFyZW50Tm9kZSxzdXNwZW5zZUluc3RhbmNlKTt9ZWxzZSBpZihjb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe2NsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIsc3VzcGVuc2VJbnN0YW5jZSk7fS8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbnJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTt9ZnVuY3Rpb24gaGlkZUluc3RhbmNlKGluc3RhbmNlKXsvLyBUT0RPOiBEb2VzIHRoaXMgd29yayBmb3IgYWxsIGVsZW1lbnQgdHlwZXM/IFdoYXQgYWJvdXQgTWF0aE1MPyBTaG91bGQgd2Vcbi8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuaW5zdGFuY2U9aW5zdGFuY2U7dmFyIHN0eWxlPWluc3RhbmNlLnN0eWxlO2lmKHR5cGVvZiBzdHlsZS5zZXRQcm9wZXJ0eT09PSdmdW5jdGlvbicpe3N0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5Jywnbm9uZScsJ2ltcG9ydGFudCcpO31lbHNle3N0eWxlLmRpc3BsYXk9J25vbmUnO319ZnVuY3Rpb24gaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2Upe3RleHRJbnN0YW5jZS5ub2RlVmFsdWU9Jyc7fWZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLHByb3BzKXtpbnN0YW5jZT1pbnN0YW5jZTt2YXIgc3R5bGVQcm9wPXByb3BzW1NUWUxFJDFdO3ZhciBkaXNwbGF5PXN0eWxlUHJvcCE9PXVuZGVmaW5lZCYmc3R5bGVQcm9wIT09bnVsbCYmc3R5bGVQcm9wLmhhc093blByb3BlcnR5KCdkaXNwbGF5Jyk/c3R5bGVQcm9wLmRpc3BsYXk6bnVsbDtpbnN0YW5jZS5zdHlsZS5kaXNwbGF5PWRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLGRpc3BsYXkpO31mdW5jdGlvbiB1bmhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLHRleHQpe3RleHRJbnN0YW5jZS5ub2RlVmFsdWU9dGV4dDt9ZnVuY3Rpb24gY2xlYXJDb250YWluZXIoY29udGFpbmVyKXtpZihjb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe2NvbnRhaW5lci50ZXh0Q29udGVudD0nJzt9ZWxzZSBpZihjb250YWluZXIubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFKXtpZihjb250YWluZXIuZG9jdW1lbnRFbGVtZW50KXtjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmRvY3VtZW50RWxlbWVudCk7fX19Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLHR5cGUscHJvcHMpe2lmKGluc3RhbmNlLm5vZGVUeXBlIT09RUxFTUVOVF9OT0RFfHx0eXBlLnRvTG93ZXJDYXNlKCkhPT1pbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXtyZXR1cm4gbnVsbDt9Ly8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG5yZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsdGV4dCl7aWYodGV4dD09PScnfHxpbnN0YW5jZS5ub2RlVHlwZSE9PVRFWFRfTk9ERSl7Ly8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxucmV0dXJuIG51bGw7fS8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG5yZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKGluc3RhbmNlKXtpZihpbnN0YW5jZS5ub2RlVHlwZSE9PUNPTU1FTlRfTk9ERSl7Ly8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxucmV0dXJuIG51bGw7fS8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSBzdXNwZW5zZSBub2RlLlxucmV0dXJuIGluc3RhbmNlO31mdW5jdGlvbiBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKGluc3RhbmNlKXtyZXR1cm4gaW5zdGFuY2UuZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQTt9ZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soaW5zdGFuY2Upe3JldHVybiBpbnN0YW5jZS5kYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQTt9ZnVuY3Rpb24gZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKGluc3RhbmNlKXt2YXIgZGF0YXNldD1pbnN0YW5jZS5uZXh0U2libGluZyYmaW5zdGFuY2UubmV4dFNpYmxpbmcuZGF0YXNldDt2YXIgZGlnZXN0LG1lc3NhZ2Usc3RhY2s7aWYoZGF0YXNldCl7ZGlnZXN0PWRhdGFzZXQuZGdzdDt7bWVzc2FnZT1kYXRhc2V0Lm1zZztzdGFjaz1kYXRhc2V0LnN0Y2s7fX17cmV0dXJue21lc3NhZ2U6bWVzc2FnZSxkaWdlc3Q6ZGlnZXN0LHN0YWNrOnN0YWNrfTt9Ly8gbGV0IHZhbHVlID0ge21lc3NhZ2U6IHVuZGVmaW5lZCwgaGFzaDogdW5kZWZpbmVkfTtcbi8vIGNvbnN0IG5leHRTaWJsaW5nID0gaW5zdGFuY2UubmV4dFNpYmxpbmc7XG4vLyBpZiAobmV4dFNpYmxpbmcpIHtcbi8vICAgY29uc3QgZGF0YXNldCA9ICgobmV4dFNpYmxpbmc6IGFueSk6IEhUTUxUZW1wbGF0ZUVsZW1lbnQpLmRhdGFzZXQ7XG4vLyAgIHZhbHVlLm1lc3NhZ2UgPSBkYXRhc2V0Lm1zZztcbi8vICAgdmFsdWUuaGFzaCA9IGRhdGFzZXQuaGFzaDtcbi8vICAgaWYgKHRydWUpIHtcbi8vICAgICB2YWx1ZS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4vLyAgIH1cbi8vIH1cbi8vIHJldHVybiB2YWx1ZTtcbn1mdW5jdGlvbiByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShpbnN0YW5jZSxjYWxsYmFjayl7aW5zdGFuY2UuX3JlYWN0UmV0cnk9Y2FsbGJhY2s7fWZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlKG5vZGUpey8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG5mb3IoO25vZGUhPW51bGw7bm9kZT1ub2RlLm5leHRTaWJsaW5nKXt2YXIgbm9kZVR5cGU9bm9kZS5ub2RlVHlwZTtpZihub2RlVHlwZT09PUVMRU1FTlRfTk9ERXx8bm9kZVR5cGU9PT1URVhUX05PREUpe2JyZWFrO31pZihub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7dmFyIG5vZGVEYXRhPW5vZGUuZGF0YTtpZihub2RlRGF0YT09PVNVU1BFTlNFX1NUQVJUX0RBVEF8fG5vZGVEYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQXx8bm9kZURhdGE9PT1TVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpe2JyZWFrO31pZihub2RlRGF0YT09PVNVU1BFTlNFX0VORF9EQVRBKXtyZXR1cm4gbnVsbDt9fX1yZXR1cm4gbm9kZTt9ZnVuY3Rpb24gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGluc3RhbmNlKXtyZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO31mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSl7cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQpO31mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIpe3JldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRDb250YWluZXIuZmlyc3RDaGlsZCk7fWZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSl7cmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudEluc3RhbmNlLm5leHRTaWJsaW5nKTt9ZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLHR5cGUscHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGhvc3RDb250ZXh0LGludGVybmFsSW5zdGFuY2VIYW5kbGUsc2hvdWxkV2FybkRldil7cHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSxpbnN0YW5jZSk7Ly8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4vLyBnZXQgYXR0YWNoZWQuXG51cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLHByb3BzKTt2YXIgcGFyZW50TmFtZXNwYWNlO3t2YXIgaG9zdENvbnRleHREZXY9aG9zdENvbnRleHQ7cGFyZW50TmFtZXNwYWNlPWhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTt9Ly8gVE9ETzogVGVtcG9yYXJ5IGhhY2sgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QuIFdlIGNhbiBkZWxldGVcbi8vIHdoZW4gdGhlIGxlZ2FjeSByb290IEFQSSBpcyByZW1vdmVkLlxudmFyIGlzQ29uY3VycmVudE1vZGU9KGludGVybmFsSW5zdGFuY2VIYW5kbGUubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7cmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsdHlwZSxwcm9wcyxwYXJlbnROYW1lc3BhY2Uscm9vdENvbnRhaW5lckluc3RhbmNlLGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldik7fWZ1bmN0aW9uIGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLHRleHQsaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSxzaG91bGRXYXJuRGV2KXtwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLHRleHRJbnN0YW5jZSk7Ly8gVE9ETzogVGVtcG9yYXJ5IGhhY2sgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QuIFdlIGNhbiBkZWxldGVcbi8vIHdoZW4gdGhlIGxlZ2FjeSByb290IEFQSSBpcyByZW1vdmVkLlxudmFyIGlzQ29uY3VycmVudE1vZGU9KGludGVybmFsSW5zdGFuY2VIYW5kbGUubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7cmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLHRleHQpO31mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlLGludGVybmFsSW5zdGFuY2VIYW5kbGUpe3ByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsc3VzcGVuc2VJbnN0YW5jZSk7fWZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSl7dmFyIG5vZGU9c3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZzsvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbi8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxudmFyIGRlcHRoPTA7d2hpbGUobm9kZSl7aWYobm9kZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSl7dmFyIGRhdGE9bm9kZS5kYXRhO2lmKGRhdGE9PT1TVVNQRU5TRV9FTkRfREFUQSl7aWYoZGVwdGg9PT0wKXtyZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5vZGUpO31lbHNle2RlcHRoLS07fX1lbHNlIGlmKGRhdGE9PT1TVVNQRU5TRV9TVEFSVF9EQVRBfHxkYXRhPT09U1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQXx8ZGF0YT09PVNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSl7ZGVwdGgrKzt9fW5vZGU9bm9kZS5uZXh0U2libGluZzt9Ly8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxucmV0dXJuIG51bGw7fS8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuZnVuY3Rpb24gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXRJbnN0YW5jZSl7dmFyIG5vZGU9dGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOy8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4vLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG52YXIgZGVwdGg9MDt3aGlsZShub2RlKXtpZihub2RlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKXt2YXIgZGF0YT1ub2RlLmRhdGE7aWYoZGF0YT09PVNVU1BFTlNFX1NUQVJUX0RBVEF8fGRhdGE9PT1TVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBfHxkYXRhPT09U1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKXtpZihkZXB0aD09PTApe3JldHVybiBub2RlO31lbHNle2RlcHRoLS07fX1lbHNlIGlmKGRhdGE9PT1TVVNQRU5TRV9FTkRfREFUQSl7ZGVwdGgrKzt9fW5vZGU9bm9kZS5wcmV2aW91c1NpYmxpbmc7fXJldHVybiBudWxsO31mdW5jdGlvbiBjb21taXRIeWRyYXRlZENvbnRhaW5lcihjb250YWluZXIpey8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbnJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTt9ZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2Upey8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbnJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7fWZ1bmN0aW9uIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKHBhcmVudFR5cGUpe3JldHVybiBwYXJlbnRUeXBlIT09J2hlYWQnJiZwYXJlbnRUeXBlIT09J2JvZHknO31mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lcix0ZXh0SW5zdGFuY2UsdGV4dCxpc0NvbmN1cnJlbnRNb2RlKXt2YXIgc2hvdWxkV2FybkRldj10cnVlO2NoZWNrRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlLHRleHQsaXNDb25jdXJyZW50TW9kZSxzaG91bGRXYXJuRGV2KTt9ZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLHRleHRJbnN0YW5jZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUpe2lmKHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdIT09dHJ1ZSl7dmFyIHNob3VsZFdhcm5EZXY9dHJ1ZTtjaGVja0ZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLm5vZGVWYWx1ZSx0ZXh0LGlzQ29uY3VycmVudE1vZGUsc2hvdWxkV2FybkRldik7fX1mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLGluc3RhbmNlKXt7aWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLGluc3RhbmNlKTt9ZWxzZSBpZihpbnN0YW5jZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSk7ZWxzZXt3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lcixpbnN0YW5jZSk7fX19ZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSxpbnN0YW5jZSl7ey8vICRGbG93Rml4TWU6IE9ubHkgRWxlbWVudCBvciBEb2N1bWVudCBjYW4gYmUgcGFyZW50IG5vZGVzLlxudmFyIHBhcmVudE5vZGU9cGFyZW50SW5zdGFuY2UucGFyZW50Tm9kZTtpZihwYXJlbnROb2RlIT09bnVsbCl7aWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSxpbnN0YW5jZSk7fWVsc2UgaWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1DT01NRU5UX05PREUpO2Vsc2V7d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnROb2RlLGluc3RhbmNlKTt9fX19ZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUscGFyZW50UHJvcHMscGFyZW50SW5zdGFuY2UsaW5zdGFuY2UsaXNDb25jdXJyZW50TW9kZSl7e2lmKGlzQ29uY3VycmVudE1vZGV8fHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdIT09dHJ1ZSl7aWYoaW5zdGFuY2Uubm9kZVR5cGU9PT1FTEVNRU5UX05PREUpe3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsaW5zdGFuY2UpO31lbHNlIGlmKGluc3RhbmNlLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFKTtlbHNle3dhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsaW5zdGFuY2UpO319fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcix0eXBlLHByb3BzKXt7d2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lcix0eXBlKTt9fWZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcix0ZXh0KXt7d2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lcix0ZXh0KTt9fWZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHBhcmVudEluc3RhbmNlLHR5cGUscHJvcHMpe3svLyAkRmxvd0ZpeE1lOiBPbmx5IEVsZW1lbnQgb3IgRG9jdW1lbnQgY2FuIGJlIHBhcmVudCBub2Rlcy5cbnZhciBwYXJlbnROb2RlPXBhcmVudEluc3RhbmNlLnBhcmVudE5vZGU7aWYocGFyZW50Tm9kZSE9PW51bGwpd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsdHlwZSk7fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UsdGV4dCl7ey8vICRGbG93Rml4TWU6IE9ubHkgRWxlbWVudCBvciBEb2N1bWVudCBjYW4gYmUgcGFyZW50IG5vZGVzLlxudmFyIHBhcmVudE5vZGU9cGFyZW50SW5zdGFuY2UucGFyZW50Tm9kZTtpZihwYXJlbnROb2RlIT09bnVsbCl3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSx0ZXh0KTt9fWZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSxwYXJlbnRQcm9wcyxwYXJlbnRJbnN0YW5jZSx0eXBlLHByb3BzLGlzQ29uY3VycmVudE1vZGUpe3tpZihpc0NvbmN1cnJlbnRNb2RlfHxwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSE9PXRydWUpe3dhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSx0eXBlKTt9fX1mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLHRleHQsaXNDb25jdXJyZW50TW9kZSl7e2lmKGlzQ29uY3VycmVudE1vZGV8fHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdIT09dHJ1ZSl7d2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLHRleHQpO319fWZ1bmN0aW9uIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcil7ey8vIFRPRE86IFRoaXMgZ2V0cyBsb2dnZWQgYnkgb25SZWNvdmVyYWJsZUVycm9yLCB0b28sIHNvIHdlIHNob3VsZCBiZVxuLy8gYWJsZSB0byByZW1vdmUgaXQuXG5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVGhlIHNlcnZlciBIVE1MIHdhcyByZXBsYWNlZCB3aXRoIGNsaWVudCBjb250ZW50IGluIDwlcz4uJyxwYXJlbnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7fX1mdW5jdGlvbiBwcmVwYXJlUG9ydGFsTW91bnQocG9ydGFsSW5zdGFuY2Upe2xpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHBvcnRhbEluc3RhbmNlKTt9dmFyIHJhbmRvbUtleT1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt2YXIgaW50ZXJuYWxJbnN0YW5jZUtleT0nX19yZWFjdEZpYmVyJCcrcmFuZG9tS2V5O3ZhciBpbnRlcm5hbFByb3BzS2V5PSdfX3JlYWN0UHJvcHMkJytyYW5kb21LZXk7dmFyIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXk9J19fcmVhY3RDb250YWluZXIkJytyYW5kb21LZXk7dmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleT0nX19yZWFjdEV2ZW50cyQnK3JhbmRvbUtleTt2YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXk9J19fcmVhY3RMaXN0ZW5lcnMkJytyYW5kb21LZXk7dmFyIGludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5PSdfX3JlYWN0SGFuZGxlcyQnK3JhbmRvbUtleTtmdW5jdGlvbiBkZXRhY2hEZWxldGVkSW5zdGFuY2Uobm9kZSl7Ly8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBvbiBob3N0IGNvbXBvbmVudHMuIEkgZG9uJ3QgdGhpbmsgYWxsIG9mXG4vLyB0aGVzZSBmaWVsZHMgYXJlIHJlbGV2YW50LlxuZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxQcm9wc0tleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleV07ZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXldO31mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCxub2RlKXtub2RlW2ludGVybmFsSW5zdGFuY2VLZXldPWhvc3RJbnN0O31mdW5jdGlvbiBtYXJrQ29udGFpbmVyQXNSb290KGhvc3RSb290LG5vZGUpe25vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV09aG9zdFJvb3Q7fWZ1bmN0aW9uIHVubWFya0NvbnRhaW5lckFzUm9vdChub2RlKXtub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldPW51bGw7fWZ1bmN0aW9uIGlzQ29udGFpbmVyTWFya2VkQXNSb290KG5vZGUpe3JldHVybiEhbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTt9Ly8gR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IEhvc3RDb21wb25lbnQgb3IgSG9zdFRleHQgZmliZXIgYW5jZXN0b3IuXG4vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgcGFydCBvZiBhIGh5ZHJhdGVkIG9yIG5vdCB5ZXQgcmVuZGVyZWQgc3VidHJlZSwgdGhlblxuLy8gdGhpcyBtYXkgYWxzbyByZXR1cm4gYSBTdXNwZW5zZUNvbXBvbmVudCBvciBIb3N0Um9vdCB0byBpbmRpY2F0ZSB0aGF0LlxuLy8gQ29uY2VwdHVhbGx5IHRoZSBIb3N0Um9vdCBmaWJlciBpcyBhIGNoaWxkIG9mIHRoZSBDb250YWluZXIgbm9kZS4gU28gaWYgeW91XG4vLyBwYXNzIHRoZSBDb250YWluZXIgbm9kZSBhcyB0aGUgdGFyZ2V0Tm9kZSwgeW91IHdpbGwgbm90IGFjdHVhbGx5IGdldCB0aGVcbi8vIEhvc3RSb290IGJhY2suIFRvIGdldCB0byB0aGUgSG9zdFJvb3QsIHlvdSBuZWVkIHRvIHBhc3MgYSBjaGlsZCBvZiBpdC5cbi8vIFRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgdG8gU3VzcGVuc2UgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHRhcmdldE5vZGUpe3ZhciB0YXJnZXRJbnN0PXRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07aWYodGFyZ2V0SW5zdCl7Ly8gRG9uJ3QgcmV0dXJuIEhvc3RSb290IG9yIFN1c3BlbnNlQ29tcG9uZW50IGhlcmUuXG5yZXR1cm4gdGFyZ2V0SW5zdDt9Ly8gSWYgdGhlIGRpcmVjdCBldmVudCB0YXJnZXQgaXNuJ3QgYSBSZWFjdCBvd25lZCBET00gbm9kZSwgd2UgbmVlZCB0byBsb29rXG4vLyB0byBzZWUgaWYgb25lIG9mIGl0cyBwYXJlbnRzIGlzIGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUuXG52YXIgcGFyZW50Tm9kZT10YXJnZXROb2RlLnBhcmVudE5vZGU7d2hpbGUocGFyZW50Tm9kZSl7Ly8gV2UnbGwgY2hlY2sgaWYgdGhpcyBpcyBhIGNvbnRhaW5lciByb290IHRoYXQgY291bGQgaW5jbHVkZVxuLy8gUmVhY3Qgbm9kZXMgaW4gdGhlIGZ1dHVyZS4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0IGJlY2F1c2Vcbi8vIGlmIHdlJ3JlIGEgY2hpbGQgb2YgYSBkZWh5ZHJhdGVkIGNvbnRhaW5lciwgd2UgbmVlZCB0byBmaXJzdFxuLy8gZmluZCB0aGF0IGlubmVyIGNvbnRhaW5lciBiZWZvcmUgbW92aW5nIG9uIHRvIGZpbmRpbmcgdGhlIHBhcmVudFxuLy8gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGlzIGZpZWxkIG9uICB0aGUgdGFyZ2V0Tm9kZVxuLy8gaXRzZWxmIGJlY2F1c2UgdGhlIGZpYmVycyBhcmUgY29uY2VwdHVhbGx5IGJldHdlZW4gdGhlIGNvbnRhaW5lclxuLy8gbm9kZSBhbmQgdGhlIGZpcnN0IGNoaWxkLiBJdCBpc24ndCBzdXJyb3VuZGluZyB0aGUgY29udGFpbmVyIG5vZGUuXG4vLyBJZiBpdCdzIG5vdCBhIGNvbnRhaW5lciwgd2UgY2hlY2sgaWYgaXQncyBhbiBpbnN0YW5jZS5cbnRhcmdldEluc3Q9cGFyZW50Tm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XXx8cGFyZW50Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtpZih0YXJnZXRJbnN0KXsvLyBTaW5jZSB0aGlzIHdhc24ndCB0aGUgZGlyZWN0IHRhcmdldCBvZiB0aGUgZXZlbnQsIHdlIG1pZ2h0IGhhdmVcbi8vIHN0ZXBwZWQgcGFzdCBkZWh5ZHJhdGVkIERPTSBub2RlcyB0byBnZXQgaGVyZS4gSG93ZXZlciB0aGV5IGNvdWxkXG4vLyBhbHNvIGhhdmUgYmVlbiBub24tUmVhY3Qgbm9kZXMuIFdlIG5lZWQgdG8gYW5zd2VyIHdoaWNoIG9uZS5cbi8vIElmIHdlIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLCB0aGVuIHRoZXJlIGNhbid0IGJlXG4vLyBhIG5lc3RlZCBzdXNwZW5zZSBib3VuZGFyeSB3aXRoaW4gaXQuIFNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGZhc3Rcbi8vIGJhaWxvdXQuIE1vc3Qgb2YgdGhlIHRpbWUsIHdoZW4gcGVvcGxlIGFkZCBub24tUmVhY3QgY2hpbGRyZW4gdG9cbi8vIHRoZSB0cmVlLCBpdCBpcyB1c2luZyBhIHJlZiB0byBhIGNoaWxkLWxlc3MgRE9NIG5vZGUuXG4vLyBOb3JtYWxseSB3ZSdkIG9ubHkgbmVlZCB0byBjaGVjayBvbmUgb2YgdGhlIGZpYmVycyBiZWNhdXNlIGlmIGl0XG4vLyBoYXMgZXZlciBnb25lIGZyb20gaGF2aW5nIGNoaWxkcmVuIHRvIGRlbGV0aW5nIHRoZW0gb3IgdmljZSB2ZXJzYVxuLy8gaXQgd291bGQgaGF2ZSBkZWxldGVkIHRoZSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IG5lc3RlZCBpbnNpZGUgYWxyZWFkeS5cbi8vIEhvd2V2ZXIsIHNpbmNlIHRoZSBIb3N0Um9vdCBzdGFydHMgb3V0IHdpdGggYW4gYWx0ZXJuYXRlIGl0IG1pZ2h0XG4vLyBoYXZlIG9uZSBvbiB0aGUgYWx0ZXJuYXRlIHNvIHdlIG5lZWQgdG8gY2hlY2sgaW4gY2FzZSB0aGlzIHdhcyBhXG4vLyByb290LlxudmFyIGFsdGVybmF0ZT10YXJnZXRJbnN0LmFsdGVybmF0ZTtpZih0YXJnZXRJbnN0LmNoaWxkIT09bnVsbHx8YWx0ZXJuYXRlIT09bnVsbCYmYWx0ZXJuYXRlLmNoaWxkIT09bnVsbCl7Ly8gTmV4dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG5vZGUgdGhhdCBza2lwcGVkIHBhc3QgaXNcbi8vIG5lc3RlZCB3aXRoaW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFuZCBpZiBzbywgd2hpY2ggb25lLlxudmFyIHN1c3BlbnNlSW5zdGFuY2U9Z2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTt3aGlsZShzdXNwZW5zZUluc3RhbmNlIT09bnVsbCl7Ly8gV2UgZm91bmQgYSBzdXNwZW5zZSBpbnN0YW5jZS4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmVuJ3Rcbi8vIGh5ZHJhdGVkIGl0IHlldC4gRXZlbiB0aG91Z2ggd2UgbGVhdmUgdGhlIGNvbW1lbnRzIGluIHRoZVxuLy8gRE9NIGFmdGVyIGh5ZHJhdGluZywgYW5kIHRoZXJlIGFyZSBib3VuZGFyaWVzIGluIHRoZSBET01cbi8vIHRoYXQgY291bGQgYWxyZWFkeSBiZSBoeWRyYXRlZCwgd2Ugd291bGRuJ3QgaGF2ZSBmb3VuZCB0aGVtXG4vLyB0aHJvdWdoIHRoaXMgcGFzcyBzaW5jZSBpZiB0aGUgdGFyZ2V0IGlzIGh5ZHJhdGVkIGl0IHdvdWxkXG4vLyBoYXZlIGhhZCBhbiBpbnRlcm5hbEluc3RhbmNlS2V5IG9uIGl0LlxuLy8gTGV0J3MgZ2V0IHRoZSBmaWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIFN1c3BlbnNlQ29tcG9uZW50XG4vLyBhcyB0aGUgZGVlcGVzdCBpbnN0YW5jZS5cbnZhciB0YXJnZXRTdXNwZW5zZUluc3Q9c3VzcGVuc2VJbnN0YW5jZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtpZih0YXJnZXRTdXNwZW5zZUluc3Qpe3JldHVybiB0YXJnZXRTdXNwZW5zZUluc3Q7fS8vIElmIHdlIGRvbid0IGZpbmQgYSBGaWJlciBvbiB0aGUgY29tbWVudCwgaXQgbWlnaHQgYmUgYmVjYXVzZVxuLy8gd2UgaGF2ZW4ndCBnb3R0ZW4gdG8gaHlkcmF0ZSBpdCB5ZXQuIFRoZXJlIG1pZ2h0IHN0aWxsIGJlIGFcbi8vIHBhcmVudCBib3VuZGFyeSB0aGF0IGhhc24ndCBhYm92ZSB0aGlzIG9uZSBzbyB3ZSBuZWVkIHRvIGZpbmRcbi8vIHRoZSBvdXRlciBtb3N0IHRoYXQgaXMga25vd24uXG5zdXNwZW5zZUluc3RhbmNlPWdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7Ly8gSWYgd2UgZG9uJ3QgZmluZCBvbmUsIHRoZW4gdGhhdCBzaG91bGQgbWVhbiB0aGF0IHRoZSBwYXJlbnRcbi8vIGhvc3QgY29tcG9uZW50IGFsc28gaGFzbid0IGh5ZHJhdGVkIHlldC4gV2UgY2FuIHJldHVybiBpdFxuLy8gYmVsb3cgc2luY2UgaXQgd2lsbCBiYWlsIG91dCBvbiB0aGUgaXNNb3VudGVkIGNoZWNrIGxhdGVyLlxufX1yZXR1cm4gdGFyZ2V0SW5zdDt9dGFyZ2V0Tm9kZT1wYXJlbnROb2RlO3BhcmVudE5vZGU9dGFyZ2V0Tm9kZS5wYXJlbnROb2RlO31yZXR1cm4gbnVsbDt9LyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKXt2YXIgaW5zdD1ub2RlW2ludGVybmFsSW5zdGFuY2VLZXldfHxub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO2lmKGluc3Qpe2lmKGluc3QudGFnPT09SG9zdENvbXBvbmVudHx8aW5zdC50YWc9PT1Ib3N0VGV4dHx8aW5zdC50YWc9PT1TdXNwZW5zZUNvbXBvbmVudHx8aW5zdC50YWc9PT1Ib3N0Um9vdCl7cmV0dXJuIGluc3Q7fWVsc2V7cmV0dXJuIG51bGw7fX1yZXR1cm4gbnVsbDt9LyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL2Z1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCl7aWYoaW5zdC50YWc9PT1Ib3N0Q29tcG9uZW50fHxpbnN0LnRhZz09PUhvc3RUZXh0KXsvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbi8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxucmV0dXJuIGluc3Quc3RhdGVOb2RlO30vLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbi8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxudGhyb3cgbmV3IEVycm9yKCdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO31mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpe3JldHVybiBub2RlW2ludGVybmFsUHJvcHNLZXldfHxudWxsO31mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzKG5vZGUscHJvcHMpe25vZGVbaW50ZXJuYWxQcm9wc0tleV09cHJvcHM7fWZ1bmN0aW9uIGdldEV2ZW50TGlzdGVuZXJTZXQobm9kZSl7dmFyIGVsZW1lbnRMaXN0ZW5lclNldD1ub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07aWYoZWxlbWVudExpc3RlbmVyU2V0PT09dW5kZWZpbmVkKXtlbGVtZW50TGlzdGVuZXJTZXQ9bm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldPW5ldyBTZXQoKTt9cmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDt9dmFyIGxvZ2dlZFR5cGVGYWlsdXJlcz17fTt2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7ZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCl7e2lmKGVsZW1lbnQpe3ZhciBvd25lcj1lbGVtZW50Ll9vd25lcjt2YXIgc3RhY2s9ZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSxlbGVtZW50Ll9zb3VyY2Usb3duZXI/b3duZXIudHlwZTpudWxsKTtSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTt9ZWxzZXtSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO319fWZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcyx2YWx1ZXMsbG9jYXRpb24sY29tcG9uZW50TmFtZSxlbGVtZW50KXt7Ly8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxudmFyIGhhcz1GdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO2Zvcih2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcyl7aWYoaGFzKHR5cGVTcGVjcyx0eXBlU3BlY05hbWUpKXt2YXIgZXJyb3IkMT12b2lkIDA7Ly8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbi8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbi8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbnRyeXsvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbi8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbmlmKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSE9PSdmdW5jdGlvbicpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG52YXIgZXJyPUVycm9yKChjb21wb25lbnROYW1lfHwnUmVhY3QgY2xhc3MnKSsnOiAnK2xvY2F0aW9uKycgdHlwZSBgJyt0eXBlU3BlY05hbWUrJ2AgaXMgaW52YWxpZDsgJysnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcrdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKydgLicrJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO2Vyci5uYW1lPSdJbnZhcmlhbnQgVmlvbGF0aW9uJzt0aHJvdyBlcnI7fWVycm9yJDE9dHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLHR5cGVTcGVjTmFtZSxjb21wb25lbnROYW1lLGxvY2F0aW9uLG51bGwsJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7fWNhdGNoKGV4KXtlcnJvciQxPWV4O31pZihlcnJvciQxJiYhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpe3NldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO2Vycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJysnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnKydmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJysnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJysnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnKydzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJyxjb21wb25lbnROYW1lfHwnUmVhY3QgY2xhc3MnLGxvY2F0aW9uLHR5cGVTcGVjTmFtZSx0eXBlb2YgZXJyb3IkMSk7c2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7fWlmKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciYmIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSl7Ly8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4vLyBzYW1lIGVycm9yLlxubG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV09dHJ1ZTtzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJyxsb2NhdGlvbixlcnJvciQxLm1lc3NhZ2UpO3NldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO319fX19dmFyIHZhbHVlU3RhY2s9W107dmFyIGZpYmVyU3RhY2s7e2ZpYmVyU3RhY2s9W107fXZhciBpbmRleD0tMTtmdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKXtyZXR1cm57Y3VycmVudDpkZWZhdWx0VmFsdWV9O31mdW5jdGlvbiBwb3AoY3Vyc29yLGZpYmVyKXtpZihpbmRleDwwKXt7ZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO31yZXR1cm47fXtpZihmaWJlciE9PWZpYmVyU3RhY2tbaW5kZXhdKXtlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7fX1jdXJzb3IuY3VycmVudD12YWx1ZVN0YWNrW2luZGV4XTt2YWx1ZVN0YWNrW2luZGV4XT1udWxsO3tmaWJlclN0YWNrW2luZGV4XT1udWxsO31pbmRleC0tO31mdW5jdGlvbiBwdXNoKGN1cnNvcix2YWx1ZSxmaWJlcil7aW5kZXgrKzt2YWx1ZVN0YWNrW2luZGV4XT1jdXJzb3IuY3VycmVudDt7ZmliZXJTdGFja1tpbmRleF09ZmliZXI7fWN1cnNvci5jdXJyZW50PXZhbHVlO312YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O3t3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQ9e307fXZhciBlbXB0eUNvbnRleHRPYmplY3Q9e307e09iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTt9Ly8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3I9Y3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7Ly8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yPWNyZWF0ZUN1cnNvcihmYWxzZSk7Ly8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxudmFyIHByZXZpb3VzQ29udGV4dD1lbXB0eUNvbnRleHRPYmplY3Q7ZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpe3tpZihkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXImJmlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpey8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbi8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4vLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbnJldHVybiBwcmV2aW91c0NvbnRleHQ7fXJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDt9fWZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQsbWFza2VkQ29udGV4dCl7e3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD11bm1hc2tlZENvbnRleHQ7aW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9bWFza2VkQ29udGV4dDt9fWZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0KXt7dmFyIHR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgY29udGV4dFR5cGVzPXR5cGUuY29udGV4dFR5cGVzO2lmKCFjb250ZXh0VHlwZXMpe3JldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7fS8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4vLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbi8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbnZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYoaW5zdGFuY2UmJmluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT11bm1hc2tlZENvbnRleHQpe3JldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt9dmFyIGNvbnRleHQ9e307Zm9yKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKXtjb250ZXh0W2tleV09dW5tYXNrZWRDb250ZXh0W2tleV07fXt2YXIgbmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKXx8J1Vua25vd24nO2NoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcyxjb250ZXh0LCdjb250ZXh0JyxuYW1lKTt9Ly8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG5pZihpbnN0YW5jZSl7Y2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCxjb250ZXh0KTt9cmV0dXJuIGNvbnRleHQ7fX1mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpe3tyZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O319ZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSl7e3ZhciBjaGlsZENvbnRleHRUeXBlcz10eXBlLmNoaWxkQ29udGV4dFR5cGVzO3JldHVybiBjaGlsZENvbnRleHRUeXBlcyE9PW51bGwmJmNoaWxkQ29udGV4dFR5cGVzIT09dW5kZWZpbmVkO319ZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcil7e3BvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGZpYmVyKTtwb3AoY29udGV4dFN0YWNrQ3Vyc29yLGZpYmVyKTt9fWZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcil7e3BvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGZpYmVyKTtwb3AoY29udGV4dFN0YWNrQ3Vyc29yLGZpYmVyKTt9fWZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsY29udGV4dCxkaWRDaGFuZ2Upe3tpZihjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCE9PWVtcHR5Q29udGV4dE9iamVjdCl7dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXB1c2goY29udGV4dFN0YWNrQ3Vyc29yLGNvbnRleHQsZmliZXIpO3B1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixkaWRDaGFuZ2UsZmliZXIpO319ZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlcix0eXBlLHBhcmVudENvbnRleHQpe3t2YXIgaW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO3ZhciBjaGlsZENvbnRleHRUeXBlcz10eXBlLmNoaWxkQ29udGV4dFR5cGVzOy8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4vLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG5pZih0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0IT09J2Z1bmN0aW9uJyl7e3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnVW5rbm93bic7aWYoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSl7d2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdPXRydWU7ZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcrJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnKydjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsY29tcG9uZW50TmFtZSxjb21wb25lbnROYW1lKTt9fXJldHVybiBwYXJlbnRDb250ZXh0O312YXIgY2hpbGRDb250ZXh0PWluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpe2lmKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpe3Rocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdVbmtub3duJykrXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIrY29udGV4dEtleStcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO319e3ZhciBuYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnVW5rbm93bic7Y2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsY2hpbGRDb250ZXh0LCdjaGlsZCBjb250ZXh0JyxuYW1lKTt9cmV0dXJuIGFzc2lnbih7fSxwYXJlbnRDb250ZXh0LGNoaWxkQ29udGV4dCk7fX1mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKXt7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4vLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbi8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cbnZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1pbnN0YW5jZSYmaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fGVtcHR5Q29udGV4dE9iamVjdDsvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4vLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cbnByZXZpb3VzQ29udGV4dD1jb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtwdXNoKGNvbnRleHRTdGFja0N1cnNvcixtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCx3b3JrSW5Qcm9ncmVzcyk7cHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIHRydWU7fX1mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLHR5cGUsZGlkQ2hhbmdlKXt7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpZighaW5zdGFuY2Upe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31pZihkaWRDaGFuZ2Upey8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4vLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4vLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbnZhciBtZXJnZWRDb250ZXh0PXByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsdHlwZSxwcmV2aW91c0NvbnRleHQpO2luc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PW1lcmdlZENvbnRleHQ7Ly8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbnBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLHdvcmtJblByb2dyZXNzKTtwb3AoY29udGV4dFN0YWNrQ3Vyc29yLHdvcmtJblByb2dyZXNzKTsvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbnB1c2goY29udGV4dFN0YWNrQ3Vyc29yLG1lcmdlZENvbnRleHQsd29ya0luUHJvZ3Jlc3MpO3B1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixkaWRDaGFuZ2Usd29ya0luUHJvZ3Jlc3MpO31lbHNle3BvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLHdvcmtJblByb2dyZXNzKTtwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsZGlkQ2hhbmdlLHdvcmtJblByb2dyZXNzKTt9fX1mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcil7ey8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG5pZighaXNGaWJlck1vdW50ZWQoZmliZXIpfHxmaWJlci50YWchPT1DbGFzc0NvbXBvbmVudCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO312YXIgbm9kZT1maWJlcjtkb3tzd2l0Y2gobm9kZS50YWcpe2Nhc2UgSG9zdFJvb3Q6cmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIENvbXBvbmVudD1ub2RlLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7cmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O31icmVhazt9fW5vZGU9bm9kZS5yZXR1cm47fXdoaWxlKG5vZGUhPT1udWxsKTt0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX12YXIgTGVnYWN5Um9vdD0wO3ZhciBDb25jdXJyZW50Um9vdD0xO3ZhciBzeW5jUXVldWU9bnVsbDt2YXIgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzPWZhbHNlO3ZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlPWZhbHNlO2Z1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKXsvLyBQdXNoIHRoaXMgY2FsbGJhY2sgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gV2UnbGwgZmx1c2ggdGhlc2UgZWl0aGVyIGluXG4vLyB0aGUgbmV4dCB0aWNrLCBvciBlYXJsaWVyIGlmIHNvbWV0aGluZyBjYWxscyBgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZWAuXG5pZihzeW5jUXVldWU9PT1udWxsKXtzeW5jUXVldWU9W2NhbGxiYWNrXTt9ZWxzZXsvLyBQdXNoIG9udG8gZXhpc3RpbmcgcXVldWUuIERvbid0IG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBiZWNhdXNlXG4vLyB3ZSBhbHJlYWR5IHNjaGVkdWxlZCBvbmUgd2hlbiB3ZSBjcmVhdGVkIHRoZSBxdWV1ZS5cbnN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTt9fWZ1bmN0aW9uIHNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKGNhbGxiYWNrKXtpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3M9dHJ1ZTtzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjayk7fWZ1bmN0aW9uIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKXsvLyBPbmx5IGZsdXNoZXMgdGhlIHF1ZXVlIGlmIHRoZXJlJ3MgYSBsZWdhY3kgc3luYyBjYWxsYmFjayBzY2hlZHVsZWQuXG4vLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG4vLyBpdCBtaWdodCBtYWtlIG1vcmUgc2Vuc2UgZm9yIHRoZSBxdWV1ZSB0byBiZSBhIGxpc3Qgb2Ygcm9vdHMgaW5zdGVhZCBvZiBhXG4vLyBsaXN0IG9mIGdlbmVyaWMgY2FsbGJhY2tzLiBUaGVuIHdlIGNhbiBoYXZlIHR3bzogb25lIGZvciBsZWdhY3kgcm9vdHMsIG9uZVxuLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cbmlmKGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcyl7Zmx1c2hTeW5jQ2FsbGJhY2tzKCk7fX1mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3MoKXtpZighaXNGbHVzaGluZ1N5bmNRdWV1ZSYmc3luY1F1ZXVlIT09bnVsbCl7Ly8gUHJldmVudCByZS1lbnRyYW5jZS5cbmlzRmx1c2hpbmdTeW5jUXVldWU9dHJ1ZTt2YXIgaT0wO3ZhciBwcmV2aW91c1VwZGF0ZVByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3RyeXt2YXIgaXNTeW5jPXRydWU7dmFyIHF1ZXVlPXN5bmNRdWV1ZTsvLyBUT0RPOiBJcyB0aGlzIG5lY2Vzc2FyeSBhbnltb3JlPyBUaGUgb25seSB1c2VyIGNvZGUgdGhhdCBydW5zIGluIHRoaXNcbi8vIHF1ZXVlIGlzIGluIHRoZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlcy5cbnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO2Zvcig7aTxxdWV1ZS5sZW5ndGg7aSsrKXt2YXIgY2FsbGJhY2s9cXVldWVbaV07ZG97Y2FsbGJhY2s9Y2FsbGJhY2soaXNTeW5jKTt9d2hpbGUoY2FsbGJhY2shPT1udWxsKTt9c3luY1F1ZXVlPW51bGw7aW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzPWZhbHNlO31jYXRjaChlcnJvcil7Ly8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuaWYoc3luY1F1ZXVlIT09bnVsbCl7c3luY1F1ZXVlPXN5bmNRdWV1ZS5zbGljZShpKzEpO30vLyBSZXN1bWUgZmx1c2hpbmcgaW4gdGhlIG5leHQgdGlja1xuc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSxmbHVzaFN5bmNDYWxsYmFja3MpO3Rocm93IGVycm9yO31maW5hbGx5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZVByaW9yaXR5KTtpc0ZsdXNoaW5nU3luY1F1ZXVlPWZhbHNlO319cmV0dXJuIG51bGw7fS8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG52YXIgZm9ya1N0YWNrPVtdO3ZhciBmb3JrU3RhY2tJbmRleD0wO3ZhciB0cmVlRm9ya1Byb3ZpZGVyPW51bGw7dmFyIHRyZWVGb3JrQ291bnQ9MDt2YXIgaWRTdGFjaz1bXTt2YXIgaWRTdGFja0luZGV4PTA7dmFyIHRyZWVDb250ZXh0UHJvdmlkZXI9bnVsbDt2YXIgdHJlZUNvbnRleHRJZD0xO3ZhciB0cmVlQ29udGV4dE92ZXJmbG93PScnO2Z1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3Mpe3dhcm5JZk5vdEh5ZHJhdGluZygpO3JldHVybih3b3JrSW5Qcm9ncmVzcy5mbGFncyZGb3JrZWQpIT09Tm9GbGFnczt9ZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKXt3YXJuSWZOb3RIeWRyYXRpbmcoKTtyZXR1cm4gdHJlZUZvcmtDb3VudDt9ZnVuY3Rpb24gZ2V0VHJlZUlkKCl7dmFyIG92ZXJmbG93PXRyZWVDb250ZXh0T3ZlcmZsb3c7dmFyIGlkV2l0aExlYWRpbmdCaXQ9dHJlZUNvbnRleHRJZDt2YXIgaWQ9aWRXaXRoTGVhZGluZ0JpdCZ+Z2V0TGVhZGluZ0JpdChpZFdpdGhMZWFkaW5nQml0KTtyZXR1cm4gaWQudG9TdHJpbmcoMzIpK292ZXJmbG93O31mdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsdG90YWxDaGlsZHJlbil7Ly8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgd2UgcmVjb25jaWxlIGFuIGFycmF5IChvciBpdGVyYXRvcikgb2YgY2hpbGRcbi8vIGZpYmVycywgYmVjYXVzZSB0aGF0J3MgdGhlIG9ubHkgcGxhY2Ugd2hlcmUgd2Uga25vdyBob3cgbWFueSBjaGlsZHJlbiBpblxuLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4vLyBpbmZvcm1hdGlvbiBvbiB0aGUgZmliZXIuXG4vL1xuLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4vLyB0aGUgcmVuZGVyIHBoYXNlIG9mIHRoZSBmb3JrIHBhcmVudCwgbm90IHRoZSBjaGlsZCwgd2hpY2ggaXMgd2hlcmUgd2UgcHVzaFxuLy8gdGhlIG90aGVyIGNvbnRleHQgdmFsdWVzLlxuLy9cbi8vIEluIHRoZSBGaXp6IGltcGxlbWVudGF0aW9uIHRoaXMgaXMgbXVjaCBzaW1wbGVyIGJlY2F1c2UgdGhlIGNoaWxkIGlzXG4vLyByZW5kZXJlZCBpbiB0aGUgc2FtZSBjYWxsc3RhY2sgYXMgdGhlIHBhcmVudC5cbi8vXG4vLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCBhZGQgYSBgZm9ya3NgIGZpZWxkIHRvIHRoZSBGaWJlciB0eXBlLiBJdCB3b3VsZFxuLy8gbWFrZSB0aGlzIG1vZHVsZSBzaW1wbGVyLlxud2FybklmTm90SHlkcmF0aW5nKCk7Zm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdPXRyZWVGb3JrQ291bnQ7Zm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdPXRyZWVGb3JrUHJvdmlkZXI7dHJlZUZvcmtQcm92aWRlcj13b3JrSW5Qcm9ncmVzczt0cmVlRm9ya0NvdW50PXRvdGFsQ2hpbGRyZW47fWZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsdG90YWxDaGlsZHJlbixpbmRleCl7d2FybklmTm90SHlkcmF0aW5nKCk7aWRTdGFja1tpZFN0YWNrSW5kZXgrK109dHJlZUNvbnRleHRJZDtpZFN0YWNrW2lkU3RhY2tJbmRleCsrXT10cmVlQ29udGV4dE92ZXJmbG93O2lkU3RhY2tbaWRTdGFja0luZGV4KytdPXRyZWVDb250ZXh0UHJvdmlkZXI7dHJlZUNvbnRleHRQcm92aWRlcj13b3JrSW5Qcm9ncmVzczt2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQ9dHJlZUNvbnRleHRJZDt2YXIgYmFzZU92ZXJmbG93PXRyZWVDb250ZXh0T3ZlcmZsb3c7Ly8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbi8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG52YXIgYmFzZUxlbmd0aD1nZXRCaXRMZW5ndGgoYmFzZUlkV2l0aExlYWRpbmdCaXQpLTE7dmFyIGJhc2VJZD1iYXNlSWRXaXRoTGVhZGluZ0JpdCZ+KDE8PGJhc2VMZW5ndGgpO3ZhciBzbG90PWluZGV4KzE7dmFyIGxlbmd0aD1nZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikrYmFzZUxlbmd0aDsvLyAzMCBpcyB0aGUgbWF4IGxlbmd0aCB3ZSBjYW4gc3RvcmUgd2l0aG91dCBvdmVyZmxvd2luZywgdGFraW5nIGludG9cbi8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cbmlmKGxlbmd0aD4zMCl7Ly8gV2Ugb3ZlcmZsb3dlZCB0aGUgYml0d2lzZS1zYWZlIHJhbmdlLiBGYWxsIGJhY2sgdG8gc2xvd2VyIGFsZ29yaXRobS5cbi8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3Rcbi8vIHdvcmsgZm9yIHNtYWxsZXIgaWRzLCBiZWNhdXNlIHlvdSBuZWVkIDUgYml0cyBwZXIgY2hhcmFjdGVyLlxuLy9cbi8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuLy8gcmVtYWluaW5nIGRpZ2l0cy5cbi8vXG4vLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3Jcbi8vIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGlkIGlzIDIzIGJpdHMgbG9uZywgd2UgY2FuIGNvbnZlcnQgMjAgb2YgdGhvc2Vcbi8vIGJpdHMgaW50byBhIHN0cmluZyBvZiA0IGNoYXJhY3RlcnMsIHdpdGggMyBiaXRzIGxlZnQgb3Zlci5cbi8vXG4vLyBGaXJzdCBjYWxjdWxhdGUgaG93IG1hbnkgYml0cyBpbiB0aGUgYmFzZSBpZCByZXByZXNlbnQgYSBjb21wbGV0ZVxuLy8gc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cbnZhciBudW1iZXJPZk92ZXJmbG93Qml0cz1iYXNlTGVuZ3RoLWJhc2VMZW5ndGglNTsvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cbnZhciBuZXdPdmVyZmxvd0JpdHM9KDE8PG51bWJlck9mT3ZlcmZsb3dCaXRzKS0xOy8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxudmFyIG5ld092ZXJmbG93PShiYXNlSWQmbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7Ly8gTm93IHdlIGNhbiByZW1vdmUgdGhvc2UgYml0cyBmcm9tIHRoZSBiYXNlIGlkLlxudmFyIHJlc3RPZkJhc2VJZD1iYXNlSWQ+Pm51bWJlck9mT3ZlcmZsb3dCaXRzO3ZhciByZXN0T2ZCYXNlTGVuZ3RoPWJhc2VMZW5ndGgtbnVtYmVyT2ZPdmVyZmxvd0JpdHM7Ly8gRmluYWxseSwgZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBiaXRzIHVzaW5nIHRoZSBub3JtYWwgYWxnb3JpdGhtLiBCZWNhdXNlXG4vLyB3ZSBtYWRlIG1vcmUgcm9vbSwgdGhpcyB0aW1lIGl0IHdvbid0IG92ZXJmbG93LlxudmFyIHJlc3RPZkxlbmd0aD1nZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikrcmVzdE9mQmFzZUxlbmd0aDt2YXIgcmVzdE9mTmV3Qml0cz1zbG90PDxyZXN0T2ZCYXNlTGVuZ3RoO3ZhciBpZD1yZXN0T2ZOZXdCaXRzfHJlc3RPZkJhc2VJZDt2YXIgb3ZlcmZsb3c9bmV3T3ZlcmZsb3crYmFzZU92ZXJmbG93O3RyZWVDb250ZXh0SWQ9MTw8cmVzdE9mTGVuZ3RofGlkO3RyZWVDb250ZXh0T3ZlcmZsb3c9b3ZlcmZsb3c7fWVsc2V7Ly8gTm9ybWFsIHBhdGhcbnZhciBuZXdCaXRzPXNsb3Q8PGJhc2VMZW5ndGg7dmFyIF9pZD1uZXdCaXRzfGJhc2VJZDt2YXIgX292ZXJmbG93PWJhc2VPdmVyZmxvdzt0cmVlQ29udGV4dElkPTE8PGxlbmd0aHxfaWQ7dHJlZUNvbnRleHRPdmVyZmxvdz1fb3ZlcmZsb3c7fX1mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKXt3YXJuSWZOb3RIeWRyYXRpbmcoKTsvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuLy8gaW4gaXRzIGNoaWxkcmVuLlxudmFyIHJldHVybkZpYmVyPXdvcmtJblByb2dyZXNzLnJldHVybjtpZihyZXR1cm5GaWJlciE9PW51bGwpe3ZhciBudW1iZXJPZkZvcmtzPTE7dmFyIHNsb3RJbmRleD0wO3B1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcyxudW1iZXJPZkZvcmtzKTtwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLG51bWJlck9mRm9ya3Msc2xvdEluZGV4KTt9fWZ1bmN0aW9uIGdldEJpdExlbmd0aChudW1iZXIpe3JldHVybiAzMi1jbHozMihudW1iZXIpO31mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKXtyZXR1cm4gMTw8Z2V0Qml0TGVuZ3RoKGlkKS0xO31mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyl7Ly8gUmVzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWVzLlxuLy8gVGhpcyBpcyBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gb3RoZXIgY29udGV4dC1saWtlIG1vZHVsZXMgaW4gRmliZXJcbi8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuLy8gZGlmZmVyZW50IHJlYXNvbnMuIFdlIGhhdmUgdG8ga2VlcCBwb3BwaW5nIHVudGlsIHRoZSB3b3JrLWluLXByb2dyZXNzIGlzXG4vLyBubyBsb25nZXIgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suXG53aGlsZSh3b3JrSW5Qcm9ncmVzcz09PXRyZWVGb3JrUHJvdmlkZXIpe3RyZWVGb3JrUHJvdmlkZXI9Zm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO2ZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF09bnVsbDt0cmVlRm9ya0NvdW50PWZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdPW51bGw7fXdoaWxlKHdvcmtJblByb2dyZXNzPT09dHJlZUNvbnRleHRQcm92aWRlcil7dHJlZUNvbnRleHRQcm92aWRlcj1pZFN0YWNrWy0taWRTdGFja0luZGV4XTtpZFN0YWNrW2lkU3RhY2tJbmRleF09bnVsbDt0cmVlQ29udGV4dE92ZXJmbG93PWlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO2lkU3RhY2tbaWRTdGFja0luZGV4XT1udWxsO3RyZWVDb250ZXh0SWQ9aWRTdGFja1stLWlkU3RhY2tJbmRleF07aWRTdGFja1tpZFN0YWNrSW5kZXhdPW51bGw7fX1mdW5jdGlvbiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpe3dhcm5JZk5vdEh5ZHJhdGluZygpO2lmKHRyZWVDb250ZXh0UHJvdmlkZXIhPT1udWxsKXtyZXR1cm57aWQ6dHJlZUNvbnRleHRJZCxvdmVyZmxvdzp0cmVlQ29udGV4dE92ZXJmbG93fTt9ZWxzZXtyZXR1cm4gbnVsbDt9fWZ1bmN0aW9uIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5kZWRDb250ZXh0KXt3YXJuSWZOb3RIeWRyYXRpbmcoKTtpZFN0YWNrW2lkU3RhY2tJbmRleCsrXT10cmVlQ29udGV4dElkO2lkU3RhY2tbaWRTdGFja0luZGV4KytdPXRyZWVDb250ZXh0T3ZlcmZsb3c7aWRTdGFja1tpZFN0YWNrSW5kZXgrK109dHJlZUNvbnRleHRQcm92aWRlcjt0cmVlQ29udGV4dElkPXN1c3BlbmRlZENvbnRleHQuaWQ7dHJlZUNvbnRleHRPdmVyZmxvdz1zdXNwZW5kZWRDb250ZXh0Lm92ZXJmbG93O3RyZWVDb250ZXh0UHJvdmlkZXI9d29ya0luUHJvZ3Jlc3M7fWZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpe3tpZighZ2V0SXNIeWRyYXRpbmcoKSl7ZXJyb3IoJ0V4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJysnYW4gaXNzdWUuJyk7fX19Ly8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlcj1udWxsO3ZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlPW51bGw7dmFyIGlzSHlkcmF0aW5nPWZhbHNlOy8vIFRoaXMgZmxhZyBhbGxvd3MgZm9yIHdhcm5pbmcgc3VwcmVzc2lvbiB3aGVuIHdlIGV4cGVjdCB0aGVyZSB0byBiZSBtaXNtYXRjaGVzXG4vLyBkdWUgdG8gZWFybGllciBtaXNtYXRjaGVzIG9yIGEgc3VzcGVuZGVkIGZpYmVyLlxudmFyIGRpZFN1c3BlbmRPckVycm9yREVWPWZhbHNlOy8vIEh5ZHJhdGlvbiBlcnJvcnMgdGhhdCB3ZXJlIHRocm93biBpbnNpZGUgdGhpcyBib3VuZGFyeVxudmFyIGh5ZHJhdGlvbkVycm9ycz1udWxsO2Z1bmN0aW9uIHdhcm5JZkh5ZHJhdGluZygpe3tpZihpc0h5ZHJhdGluZyl7ZXJyb3IoJ1dlIHNob3VsZCBub3QgYmUgaHlkcmF0aW5nIGhlcmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGEgYnVnLicpO319fWZ1bmN0aW9uIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCl7e2RpZFN1c3BlbmRPckVycm9yREVWPXRydWU7fX1mdW5jdGlvbiBkaWRTdXNwZW5kT3JFcnJvcldoaWxlSHlkcmF0aW5nREVWKCl7e3JldHVybiBkaWRTdXNwZW5kT3JFcnJvckRFVjt9fWZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpe3ZhciBwYXJlbnRJbnN0YW5jZT1maWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztuZXh0SHlkcmF0YWJsZUluc3RhbmNlPWdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudEluc3RhbmNlKTtoeWRyYXRpb25QYXJlbnRGaWJlcj1maWJlcjtpc0h5ZHJhdGluZz10cnVlO2h5ZHJhdGlvbkVycm9ycz1udWxsO2RpZFN1c3BlbmRPckVycm9yREVWPWZhbHNlO3JldHVybiB0cnVlO31mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsc3VzcGVuc2VJbnN0YW5jZSx0cmVlQ29udGV4dCl7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7aXNIeWRyYXRpbmc9dHJ1ZTtoeWRyYXRpb25FcnJvcnM9bnVsbDtkaWRTdXNwZW5kT3JFcnJvckRFVj1mYWxzZTtpZih0cmVlQ29udGV4dCE9PW51bGwpe3Jlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dChmaWJlcix0cmVlQ29udGV4dCk7fXJldHVybiB0cnVlO31mdW5jdGlvbiB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLGluc3RhbmNlKXt7c3dpdGNoKHJldHVybkZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp7ZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLGluc3RhbmNlKTticmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUscmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcyxyZXR1cm5GaWJlci5zdGF0ZU5vZGUsaW5zdGFuY2UsLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbmlzQ29uY3VycmVudE1vZGUpO2JyZWFrO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50Ont2YXIgc3VzcGVuc2VTdGF0ZT1yZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQsaW5zdGFuY2UpO2JyZWFrO319fX1mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsaW5zdGFuY2Upe3dhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsaW5zdGFuY2UpO3ZhciBjaGlsZFRvRGVsZXRlPWNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7Y2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGU9aW5zdGFuY2U7Y2hpbGRUb0RlbGV0ZS5yZXR1cm49cmV0dXJuRmliZXI7dmFyIGRlbGV0aW9ucz1yZXR1cm5GaWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zPT09bnVsbCl7cmV0dXJuRmliZXIuZGVsZXRpb25zPVtjaGlsZFRvRGVsZXRlXTtyZXR1cm5GaWJlci5mbGFnc3w9Q2hpbGREZWxldGlvbjt9ZWxzZXtkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTt9fWZ1bmN0aW9uIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLGZpYmVyKXt7aWYoZGlkU3VzcGVuZE9yRXJyb3JERVYpey8vIEluc2lkZSBhIGJvdW5kYXJ5IHRoYXQgYWxyZWFkeSBzdXNwZW5kZWQuIFdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgdGhlXG4vLyBzaWJsaW5ncyBvZiBhIHN1c3BlbmRlZCBub2RlLiBUaGUgbWlzbWF0Y2ggbWF5IGJlIGR1ZSB0byB0aGUgbWlzc2luZ1xuLy8gZGF0YSwgc28gaXQncyBwcm9iYWJseSBhIGZhbHNlIHBvc2l0aXZlLlxucmV0dXJuO31zd2l0Y2gocmV0dXJuRmliZXIudGFnKXtjYXNlIEhvc3RSb290Ont2YXIgcGFyZW50Q29udGFpbmVyPXJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO3N3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp2YXIgdHlwZT1maWJlci50eXBlO3ZhciBwcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7ZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsdHlwZSk7YnJlYWs7Y2FzZSBIb3N0VGV4dDp2YXIgdGV4dD1maWJlci5wZW5kaW5nUHJvcHM7ZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyLHRleHQpO2JyZWFrO31icmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgcGFyZW50VHlwZT1yZXR1cm5GaWJlci50eXBlO3ZhciBwYXJlbnRQcm9wcz1yZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO3ZhciBwYXJlbnRJbnN0YW5jZT1yZXR1cm5GaWJlci5zdGF0ZU5vZGU7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgX3R5cGU9ZmliZXIudHlwZTt2YXIgX3Byb3BzPWZpYmVyLnBlbmRpbmdQcm9wczt2YXIgaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLF90eXBlLF9wcm9wcywvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuaXNDb25jdXJyZW50TW9kZSk7YnJlYWs7fWNhc2UgSG9zdFRleHQ6e3ZhciBfdGV4dD1maWJlci5wZW5kaW5nUHJvcHM7dmFyIF9pc0NvbmN1cnJlbnRNb2RlPShyZXR1cm5GaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZTtkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLF90ZXh0LC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG5faXNDb25jdXJyZW50TW9kZSk7YnJlYWs7fX1icmVhazt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7dmFyIHN1c3BlbnNlU3RhdGU9cmV0dXJuRmliZXIubWVtb2l6ZWRTdGF0ZTt2YXIgX3BhcmVudEluc3RhbmNlPXN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtpZihfcGFyZW50SW5zdGFuY2UhPT1udWxsKXN3aXRjaChmaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp2YXIgX3R5cGUyPWZpYmVyLnR5cGU7dmFyIF9wcm9wczI9ZmliZXIucGVuZGluZ1Byb3BzO2RpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKF9wYXJlbnRJbnN0YW5jZSxfdHlwZTIpO2JyZWFrO2Nhc2UgSG9zdFRleHQ6dmFyIF90ZXh0Mj1maWJlci5wZW5kaW5nUHJvcHM7ZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKF9wYXJlbnRJbnN0YW5jZSxfdGV4dDIpO2JyZWFrO31icmVhazt9ZGVmYXVsdDpyZXR1cm47fX19ZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlcixmaWJlcil7ZmliZXIuZmxhZ3M9ZmliZXIuZmxhZ3Mmfkh5ZHJhdGluZ3xQbGFjZW1lbnQ7d2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsZmliZXIpO31mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLG5leHRJbnN0YW5jZSl7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgdHlwZT1maWJlci50eXBlO3ZhciBwcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7dmFyIGluc3RhbmNlPWNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsdHlwZSk7aWYoaW5zdGFuY2UhPT1udWxsKXtmaWJlci5zdGF0ZU5vZGU9aW5zdGFuY2U7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChpbnN0YW5jZSk7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9Y2FzZSBIb3N0VGV4dDp7dmFyIHRleHQ9ZmliZXIucGVuZGluZ1Byb3BzO3ZhciB0ZXh0SW5zdGFuY2U9Y2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsdGV4dCk7aWYodGV4dEluc3RhbmNlIT09bnVsbCl7ZmliZXIuc3RhdGVOb2RlPXRleHRJbnN0YW5jZTtoeWRyYXRpb25QYXJlbnRGaWJlcj1maWJlcjsvLyBUZXh0IEluc3RhbmNlcyBkb24ndCBoYXZlIGNoaWxkcmVuIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBoeWRyYXRlLlxubmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1udWxsO3JldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fWNhc2UgU3VzcGVuc2VDb21wb25lbnQ6e3ZhciBzdXNwZW5zZUluc3RhbmNlPWNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSk7aWYoc3VzcGVuc2VJbnN0YW5jZSE9PW51bGwpe3ZhciBzdXNwZW5zZVN0YXRlPXtkZWh5ZHJhdGVkOnN1c3BlbnNlSW5zdGFuY2UsdHJlZUNvbnRleHQ6Z2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSxyZXRyeUxhbmU6T2Zmc2NyZWVuTGFuZX07ZmliZXIubWVtb2l6ZWRTdGF0ZT1zdXNwZW5zZVN0YXRlOy8vIFN0b3JlIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50IGFzIGEgY2hpbGQgZmliZXIuXG4vLyBUaGlzIHNpbXBsaWZpZXMgdGhlIGNvZGUgZm9yIGdldEhvc3RTaWJsaW5nIGFuZCBkZWxldGluZyBub2Rlcyxcbi8vIHNpbmNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBjb25zaWRlciBhbGwgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbi8vIGNoZWNrIGlmIHRoZXkncmUgZGVoeWRyYXRlZCBvbmVzIG9yIG5vdC5cbnZhciBkZWh5ZHJhdGVkRnJhZ21lbnQ9Y3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KHN1c3BlbnNlSW5zdGFuY2UpO2RlaHlkcmF0ZWRGcmFnbWVudC5yZXR1cm49ZmliZXI7ZmliZXIuY2hpbGQ9ZGVoeWRyYXRlZEZyYWdtZW50O2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyOy8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbi8vIGl0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSW5zdGVhZCwgd2UnbGwgcmVlbnRlciBpdCBsYXRlci5cbm5leHRIeWRyYXRhYmxlSW5zdGFuY2U9bnVsbDtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31kZWZhdWx0OnJldHVybiBmYWxzZTt9fWZ1bmN0aW9uIHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpe3JldHVybihmaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSYmKGZpYmVyLmZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFnczt9ZnVuY3Rpb24gdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKXt0aHJvdyBuZXcgRXJyb3IoJ0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyAnKydyZW5kZXJlZCBvbiB0aGUgc2VydmVyLicpO31mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcil7aWYoIWlzSHlkcmF0aW5nKXtyZXR1cm47fXZhciBuZXh0SW5zdGFuY2U9bmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtpZighbmV4dEluc3RhbmNlKXtpZihzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSl7d2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsZmliZXIpO3Rocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO30vLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlcixmaWJlcik7aXNIeWRyYXRpbmc9ZmFsc2U7aHlkcmF0aW9uUGFyZW50RmliZXI9ZmliZXI7cmV0dXJuO312YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZT1uZXh0SW5zdGFuY2U7aWYoIXRyeUh5ZHJhdGUoZmliZXIsbmV4dEluc3RhbmNlKSl7aWYoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpe3dhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLGZpYmVyKTt0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTt9Ly8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4vLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4vLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG5uZXh0SW5zdGFuY2U9Z2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO3ZhciBwcmV2SHlkcmF0aW9uUGFyZW50RmliZXI9aHlkcmF0aW9uUGFyZW50RmliZXI7aWYoIW5leHRJbnN0YW5jZXx8IXRyeUh5ZHJhdGUoZmliZXIsbmV4dEluc3RhbmNlKSl7Ly8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbmluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsZmliZXIpO2lzSHlkcmF0aW5nPWZhbHNlO2h5ZHJhdGlvblBhcmVudEZpYmVyPWZpYmVyO3JldHVybjt9Ly8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbi8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbi8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIsZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7fX1mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLHJvb3RDb250YWluZXJJbnN0YW5jZSxob3N0Q29udGV4dCl7dmFyIGluc3RhbmNlPWZpYmVyLnN0YXRlTm9kZTt2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXY9IWRpZFN1c3BlbmRPckVycm9yREVWO3ZhciB1cGRhdGVQYXlsb2FkPWh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSxmaWJlci50eXBlLGZpYmVyLm1lbW9pemVkUHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlLGhvc3RDb250ZXh0LGZpYmVyLHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTsvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbmZpYmVyLnVwZGF0ZVF1ZXVlPXVwZGF0ZVBheWxvYWQ7Ly8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4vLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbmlmKHVwZGF0ZVBheWxvYWQhPT1udWxsKXtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcil7dmFyIHRleHRJbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7dmFyIHRleHRDb250ZW50PWZpYmVyLm1lbW9pemVkUHJvcHM7dmFyIHNob3VsZFVwZGF0ZT1oeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSx0ZXh0Q29udGVudCxmaWJlcik7aWYoc2hvdWxkVXBkYXRlKXsvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxudmFyIHJldHVybkZpYmVyPWh5ZHJhdGlvblBhcmVudEZpYmVyO2lmKHJldHVybkZpYmVyIT09bnVsbCl7c3dpdGNoKHJldHVybkZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp7dmFyIHBhcmVudENvbnRhaW5lcj1yZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzt2YXIgaXNDb25jdXJyZW50TW9kZT0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsdGV4dEluc3RhbmNlLHRleHRDb250ZW50LC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG5pc0NvbmN1cnJlbnRNb2RlKTticmVhazt9Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgcGFyZW50VHlwZT1yZXR1cm5GaWJlci50eXBlO3ZhciBwYXJlbnRQcm9wcz1yZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO3ZhciBwYXJlbnRJbnN0YW5jZT1yZXR1cm5GaWJlci5zdGF0ZU5vZGU7dmFyIF9pc0NvbmN1cnJlbnRNb2RlMj0ocmV0dXJuRmliZXIubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGU7ZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLHBhcmVudFByb3BzLHBhcmVudEluc3RhbmNlLHRleHRJbnN0YW5jZSx0ZXh0Q29udGVudCwvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuX2lzQ29uY3VycmVudE1vZGUyKTticmVhazt9fX19cmV0dXJuIHNob3VsZFVwZGF0ZTt9ZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKGZpYmVyKXt2YXIgc3VzcGVuc2VTdGF0ZT1maWJlci5tZW1vaXplZFN0YXRlO3ZhciBzdXNwZW5zZUluc3RhbmNlPXN1c3BlbnNlU3RhdGUhPT1udWxsP3N1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDpudWxsO2lmKCFzdXNwZW5zZUluc3RhbmNlKXt0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJysnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9aHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSxmaWJlcik7fWZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpe3ZhciBzdXNwZW5zZVN0YXRlPWZpYmVyLm1lbW9pemVkU3RhdGU7dmFyIHN1c3BlbnNlSW5zdGFuY2U9c3VzcGVuc2VTdGF0ZSE9PW51bGw/c3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkOm51bGw7aWYoIXN1c3BlbnNlSW5zdGFuY2Upe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31yZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTt9ZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcil7dmFyIHBhcmVudD1maWJlci5yZXR1cm47d2hpbGUocGFyZW50IT09bnVsbCYmcGFyZW50LnRhZyE9PUhvc3RDb21wb25lbnQmJnBhcmVudC50YWchPT1Ib3N0Um9vdCYmcGFyZW50LnRhZyE9PVN1c3BlbnNlQ29tcG9uZW50KXtwYXJlbnQ9cGFyZW50LnJldHVybjt9aHlkcmF0aW9uUGFyZW50RmliZXI9cGFyZW50O31mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcil7aWYoZmliZXIhPT1oeWRyYXRpb25QYXJlbnRGaWJlcil7Ly8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuLy8gdHJlZS5cbnJldHVybiBmYWxzZTt9aWYoIWlzSHlkcmF0aW5nKXsvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbi8vIHNpYmxpbmdzLlxucG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7aXNIeWRyYXRpbmc9dHJ1ZTtyZXR1cm4gZmFsc2U7fS8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbi8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4vLyBzaWRlIG9mIHRoZW0uIFdlIGFsc28gZG9uJ3QgZGVsZXRlIGFueXRoaW5nIGluc2lkZSB0aGUgcm9vdCBjb250YWluZXIuXG5pZihmaWJlci50YWchPT1Ib3N0Um9vdCYmKGZpYmVyLnRhZyE9PUhvc3RDb21wb25lbnR8fHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpJiYhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSxmaWJlci5tZW1vaXplZFByb3BzKSkpe3ZhciBuZXh0SW5zdGFuY2U9bmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtpZihuZXh0SW5zdGFuY2Upe2lmKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKXt3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKTt0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTt9ZWxzZXt3aGlsZShuZXh0SW5zdGFuY2Upe2RlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcixuZXh0SW5zdGFuY2UpO25leHRJbnN0YW5jZT1nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTt9fX19cG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7aWYoZmliZXIudGFnPT09U3VzcGVuc2VDb21wb25lbnQpe25leHRIeWRyYXRhYmxlSW5zdGFuY2U9c2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7fWVsc2V7bmV4dEh5ZHJhdGFibGVJbnN0YW5jZT1oeWRyYXRpb25QYXJlbnRGaWJlcj9nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKTpudWxsO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gaGFzVW5oeWRyYXRlZFRhaWxOb2Rlcygpe3JldHVybiBpc0h5ZHJhdGluZyYmbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSE9PW51bGw7fWZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpe3ZhciBuZXh0SW5zdGFuY2U9bmV4dEh5ZHJhdGFibGVJbnN0YW5jZTt3aGlsZShuZXh0SW5zdGFuY2Upe3dhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsbmV4dEluc3RhbmNlKTtuZXh0SW5zdGFuY2U9Z2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7fX1mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCl7aHlkcmF0aW9uUGFyZW50RmliZXI9bnVsbDtuZXh0SHlkcmF0YWJsZUluc3RhbmNlPW51bGw7aXNIeWRyYXRpbmc9ZmFsc2U7ZGlkU3VzcGVuZE9yRXJyb3JERVY9ZmFsc2U7fWZ1bmN0aW9uIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCl7aWYoaHlkcmF0aW9uRXJyb3JzIT09bnVsbCl7Ly8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLiBUaGUgZXJyb3JzIHRoYXQgb2NjdXJyZWRcbi8vIGR1cmluZyB0aGUgaHlkcmF0aW9uIGF0dGVtcHQgYXJlIG5vdyByZWNvdmVyZWQuIFdlIHdpbGwgbG9nIHRoZW0gaW5cbi8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxucXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpO2h5ZHJhdGlvbkVycm9ycz1udWxsO319ZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKXtyZXR1cm4gaXNIeWRyYXRpbmc7fWZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3Ipe2lmKGh5ZHJhdGlvbkVycm9ycz09PW51bGwpe2h5ZHJhdGlvbkVycm9ycz1bZXJyb3JdO31lbHNle2h5ZHJhdGlvbkVycm9ycy5wdXNoKGVycm9yKTt9fXZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO3ZhciBOb1RyYW5zaXRpb249bnVsbDtmdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKXtyZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO312YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3M9e3JlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOmZ1bmN0aW9uKGZpYmVyLGluc3RhbmNlKXt9LGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOmZ1bmN0aW9uKCl7fSxyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzpmdW5jdGlvbihmaWJlcixpbnN0YW5jZSl7fSxmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOmZ1bmN0aW9uKCl7fSxkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOmZ1bmN0aW9uKCl7fX07e3ZhciBmaW5kU3RyaWN0Um9vdD1mdW5jdGlvbihmaWJlcil7dmFyIG1heWJlU3RyaWN0Um9vdD1udWxsO3ZhciBub2RlPWZpYmVyO3doaWxlKG5vZGUhPT1udWxsKXtpZihub2RlLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7bWF5YmVTdHJpY3RSb290PW5vZGU7fW5vZGU9bm9kZS5yZXR1cm47fXJldHVybiBtYXliZVN0cmljdFJvb3Q7fTt2YXIgc2V0VG9Tb3J0ZWRTdHJpbmc9ZnVuY3Rpb24oc2V0KXt2YXIgYXJyYXk9W107c2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpe2FycmF5LnB1c2godmFsdWUpO30pO3JldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTt9O3ZhciBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107dmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3M9W107dmFyIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107dmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO3ZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzPVtdO3ZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTsvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxudmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXM9bmV3IFNldCgpO1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzPWZ1bmN0aW9uKGZpYmVyLGluc3RhbmNlKXsvLyBEZWR1cGUgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuaWYoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpe3JldHVybjt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicmJi8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmchPT10cnVlKXtwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7fWlmKGZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSYmdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicmJmluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe3BlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7fWlmKGZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSYmdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJyYmaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIT09dHJ1ZSl7cGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTt9aWYoZmliZXIubW9kZSZTdHJpY3RMZWdhY3lNb2RlJiZ0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU9PT0nZnVuY3Rpb24nKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTt9fTtSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncz1mdW5jdGlvbigpey8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG52YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTt9dmFyIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTt9dmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGg+MCl7cGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncz1bXTt9dmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXM9bmV3IFNldCgpO2lmKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aD4wKXtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKXtVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO30pO3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzPVtdO312YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzPW5ldyBTZXQoKTtpZihwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aD4wKXtwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdDb21wb25lbnQnKTtkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTt9KTtwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzPVtdO312YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcz1uZXcgU2V0KCk7aWYocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoPjApe3BlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpe1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpfHwnQ29tcG9uZW50Jyk7ZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7fSk7cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3M9W107fS8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3Ncbi8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuaWYoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIHNvcnRlZE5hbWVzPXNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7ZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicrJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsc29ydGVkTmFtZXMpO31pZihVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIF9zb3J0ZWROYW1lcz1zZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcrJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nK1wiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCBcIisncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJysnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lcyk7fWlmKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZT4wKXt2YXIgX3NvcnRlZE5hbWVzMj1zZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcrJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lczIpO31pZihjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBfc29ydGVkTmFtZXMzPXNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTt3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nKycqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nKycqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnKyd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnKydUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcrJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicrJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsX3NvcnRlZE5hbWVzMyk7fWlmKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplPjApe3ZhciBfc29ydGVkTmFtZXM0PXNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7d2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcrJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicrJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nK1wiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiKydjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJysnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nKycqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcrJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcrJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJysnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJysnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyxfc29ydGVkTmFtZXM0KTt9aWYoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemU+MCl7dmFyIF9zb3J0ZWROYW1lczU9c2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTt3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJysnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJysnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicrJyogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgJysndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJysnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnKydgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nKydcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLF9zb3J0ZWROYW1lczUpO319O3ZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmc9bmV3IE1hcCgpOy8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG52YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dD1uZXcgU2V0KCk7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc9ZnVuY3Rpb24oZmliZXIsaW5zdGFuY2Upe3ZhciBzdHJpY3RSb290PWZpbmRTdHJpY3RSb290KGZpYmVyKTtpZihzdHJpY3RSb290PT09bnVsbCl7ZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcrJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7cmV0dXJuO30vLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5pZihkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSl7cmV0dXJuO312YXIgd2FybmluZ3NGb3JSb290PXBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7aWYoZmliZXIudHlwZS5jb250ZXh0VHlwZXMhPW51bGx8fGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMhPW51bGx8fGluc3RhbmNlIT09bnVsbCYmdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dD09PSdmdW5jdGlvbicpe2lmKHdhcm5pbmdzRm9yUm9vdD09PXVuZGVmaW5lZCl7d2FybmluZ3NGb3JSb290PVtdO3BlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCx3YXJuaW5nc0ZvclJvb3QpO313YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7fX07UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZz1mdW5jdGlvbigpe3BlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyQXJyYXksc3RyaWN0Um9vdCl7aWYoZmliZXJBcnJheS5sZW5ndGg9PT0wKXtyZXR1cm47fXZhciBmaXJzdEZpYmVyPWZpYmVyQXJyYXlbMF07dmFyIHVuaXF1ZU5hbWVzPW5ldyBTZXQoKTtmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24oZmliZXIpe3VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J0NvbXBvbmVudCcpO2RpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO30pO3ZhciBzb3J0ZWROYW1lcz1zZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7dHJ5e3NldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJysnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJysndXNpbmcgaXQgc2hvdWxkIG1pZ3JhdGUgdG8gdGhlIG5ldyB2ZXJzaW9uLicrJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycrJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsc29ydGVkTmFtZXMpO31maW5hbGx5e3Jlc2V0Q3VycmVudEZpYmVyKCk7fX0pO307UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncz1mdW5jdGlvbigpe3BlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncz1bXTtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzPVtdO3BlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107cGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3M9W107cGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTtwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncz1bXTtwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmc9bmV3IE1hcCgpO307fXZhciBkaWRXYXJuQWJvdXRNYXBzO3ZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzO3ZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO3ZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7dmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZzt2YXIgd2FybkZvck1pc3NpbmdLZXk9ZnVuY3Rpb24oY2hpbGQscmV0dXJuRmliZXIpe307e2RpZFdhcm5BYm91dE1hcHM9ZmFsc2U7ZGlkV2FybkFib3V0R2VuZXJhdG9ycz1mYWxzZTtkaWRXYXJuQWJvdXRTdHJpbmdSZWZzPXt9Oy8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9vd25lckhhc0tleVVzZVdhcm5pbmc9e307b3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nPXt9O3dhcm5Gb3JNaXNzaW5nS2V5PWZ1bmN0aW9uKGNoaWxkLHJldHVybkZpYmVyKXtpZihjaGlsZD09PW51bGx8fHR5cGVvZiBjaGlsZCE9PSdvYmplY3QnKXtyZXR1cm47fWlmKCFjaGlsZC5fc3RvcmV8fGNoaWxkLl9zdG9yZS52YWxpZGF0ZWR8fGNoaWxkLmtleSE9bnVsbCl7cmV0dXJuO31pZih0eXBlb2YgY2hpbGQuX3N0b3JlIT09J29iamVjdCcpe3Rocm93IG5ldyBFcnJvcignUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31jaGlsZC5fc3RvcmUudmFsaWRhdGVkPXRydWU7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcil8fCdDb21wb25lbnQnO2lmKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSl7cmV0dXJuO31vd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV09dHJ1ZTtlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJysnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgJysnbW9yZSBpbmZvcm1hdGlvbi4nKTt9O31mdW5jdGlvbiBpc1JlYWN0Q2xhc3ModHlwZSl7cmV0dXJuIHR5cGUucHJvdG90eXBlJiZ0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O31mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50KXt2YXIgbWl4ZWRSZWY9ZWxlbWVudC5yZWY7aWYobWl4ZWRSZWYhPT1udWxsJiZ0eXBlb2YgbWl4ZWRSZWYhPT0nZnVuY3Rpb24nJiZ0eXBlb2YgbWl4ZWRSZWYhPT0nb2JqZWN0Jyl7ey8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4vLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuaWYoKHJldHVybkZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZXx8d2FybkFib3V0U3RyaW5nUmVmcykmJi8vIFdlIHdhcm4gaW4gUmVhY3RFbGVtZW50LmpzIGlmIG93bmVyIGFuZCBzZWxmIGFyZSBlcXVhbCBmb3Igc3RyaW5nIHJlZnNcbi8vIGJlY2F1c2UgdGhlc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uXG4vLyB1c2luZyBhIGNvZGVtb2QuIFRoZXJlZm9yZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YXJuIGFib3V0IHN0cmluZyByZWZzIGFnYWluLlxuIShlbGVtZW50Ll9vd25lciYmZWxlbWVudC5fc2VsZiYmZWxlbWVudC5fb3duZXIuc3RhdGVOb2RlIT09ZWxlbWVudC5fc2VsZikmJi8vIFdpbGwgYWxyZWFkeSB0aHJvdyB3aXRoIFwiRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSBzdHJpbmcgcmVmc1wiXG4hKGVsZW1lbnQuX293bmVyJiZlbGVtZW50Ll9vd25lci50YWchPT1DbGFzc0NvbXBvbmVudCkmJi8vIFdpbGwgYWxyZWFkeSB3YXJuIHdpdGggXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzXCJcbiEodHlwZW9mIGVsZW1lbnQudHlwZT09PSdmdW5jdGlvbicmJiFpc1JlYWN0Q2xhc3MoZWxlbWVudC50eXBlKSkmJi8vIFdpbGwgYWxyZWFkeSB0aHJvdyB3aXRoIFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoc29tZVN0cmluZ1JlZikgYnV0IG5vIG93bmVyIHdhcyBzZXRcIlxuZWxlbWVudC5fb3duZXIpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSl7e2Vycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgJysnd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFdlIHJlY29tbWVuZCB1c2luZyAnKyd1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnKydMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJyxjb21wb25lbnROYW1lLG1peGVkUmVmKTt9ZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXT10cnVlO319fWlmKGVsZW1lbnQuX293bmVyKXt2YXIgb3duZXI9ZWxlbWVudC5fb3duZXI7dmFyIGluc3Q7aWYob3duZXIpe3ZhciBvd25lckZpYmVyPW93bmVyO2lmKG93bmVyRmliZXIudGFnIT09Q2xhc3NDb21wb25lbnQpe3Rocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSBzdHJpbmcgcmVmcy4gJysnV2UgcmVjb21tZW5kIHVzaW5nIHVzZVJlZigpIGluc3RlYWQuICcrJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnKTt9aW5zdD1vd25lckZpYmVyLnN0YXRlTm9kZTt9aWYoIWluc3Qpe3Rocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIrbWl4ZWRSZWYrXCIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIFwiKydidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO30vLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0IHNvIEZsb3cga25vd3MgaXQgd29uJ3QgY2hhbmdlIGluIHRoZSBjbG9zdXJlXG52YXIgcmVzb2x2ZWRJbnN0PWluc3Q7e2NoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKG1peGVkUmVmLCdyZWYnKTt9dmFyIHN0cmluZ1JlZj0nJyttaXhlZFJlZjsvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbmlmKGN1cnJlbnQhPT1udWxsJiZjdXJyZW50LnJlZiE9PW51bGwmJnR5cGVvZiBjdXJyZW50LnJlZj09PSdmdW5jdGlvbicmJmN1cnJlbnQucmVmLl9zdHJpbmdSZWY9PT1zdHJpbmdSZWYpe3JldHVybiBjdXJyZW50LnJlZjt9dmFyIHJlZj1mdW5jdGlvbih2YWx1ZSl7dmFyIHJlZnM9cmVzb2x2ZWRJbnN0LnJlZnM7aWYodmFsdWU9PT1udWxsKXtkZWxldGUgcmVmc1tzdHJpbmdSZWZdO31lbHNle3JlZnNbc3RyaW5nUmVmXT12YWx1ZTt9fTtyZWYuX3N0cmluZ1JlZj1zdHJpbmdSZWY7cmV0dXJuIHJlZjt9ZWxzZXtpZih0eXBlb2YgbWl4ZWRSZWYhPT0nc3RyaW5nJyl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC4nKTt9aWYoIWVsZW1lbnQuX293bmVyKXt0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChcIittaXhlZFJlZitcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2ZcIisnIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nKycxLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGZ1bmN0aW9uIGNvbXBvbmVudFxcbicrXCIyLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kXFxuXCIrJzMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG4nKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO319fXJldHVybiBtaXhlZFJlZjt9ZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKXt2YXIgY2hpbGRTdHJpbmc9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTt0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiKyhjaGlsZFN0cmluZz09PSdbb2JqZWN0IE9iamVjdF0nPydvYmplY3Qgd2l0aCBrZXlzIHsnK09iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpKyd9JzpjaGlsZFN0cmluZykrXCIpLiBcIisnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnKydpbnN0ZWFkLicpO31mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpe3t2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKXx8J0NvbXBvbmVudCc7aWYob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKXtyZXR1cm47fW93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXT10cnVlO2Vycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJysneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcrJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO319ZnVuY3Rpb24gcmVzb2x2ZUxhenkobGF6eVR5cGUpe3ZhciBwYXlsb2FkPWxhenlUeXBlLl9wYXlsb2FkO3ZhciBpbml0PWxhenlUeXBlLl9pbml0O3JldHVybiBpbml0KHBheWxvYWQpO30vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpe2Z1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkVG9EZWxldGUpe2lmKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKXsvLyBOb29wLlxucmV0dXJuO312YXIgZGVsZXRpb25zPXJldHVybkZpYmVyLmRlbGV0aW9ucztpZihkZWxldGlvbnM9PT1udWxsKXtyZXR1cm5GaWJlci5kZWxldGlvbnM9W2NoaWxkVG9EZWxldGVdO3JldHVybkZpYmVyLmZsYWdzfD1DaGlsZERlbGV0aW9uO31lbHNle2RlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO319ZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQpe2lmKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKXsvLyBOb29wLlxucmV0dXJuIG51bGw7fS8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbi8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbnZhciBjaGlsZFRvRGVsZXRlPWN1cnJlbnRGaXJzdENoaWxkO3doaWxlKGNoaWxkVG9EZWxldGUhPT1udWxsKXtkZWxldGVDaGlsZChyZXR1cm5GaWJlcixjaGlsZFRvRGVsZXRlKTtjaGlsZFRvRGVsZXRlPWNoaWxkVG9EZWxldGUuc2libGluZzt9cmV0dXJuIG51bGw7fWZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkKXsvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4vLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4vLyBpbnN0ZWFkLlxudmFyIGV4aXN0aW5nQ2hpbGRyZW49bmV3IE1hcCgpO3ZhciBleGlzdGluZ0NoaWxkPWN1cnJlbnRGaXJzdENoaWxkO3doaWxlKGV4aXN0aW5nQ2hpbGQhPT1udWxsKXtpZihleGlzdGluZ0NoaWxkLmtleSE9PW51bGwpe2V4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LGV4aXN0aW5nQ2hpbGQpO31lbHNle2V4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsZXhpc3RpbmdDaGlsZCk7fWV4aXN0aW5nQ2hpbGQ9ZXhpc3RpbmdDaGlsZC5zaWJsaW5nO31yZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjt9ZnVuY3Rpb24gdXNlRmliZXIoZmliZXIscGVuZGluZ1Byb3BzKXsvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbnZhciBjbG9uZT1jcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlcixwZW5kaW5nUHJvcHMpO2Nsb25lLmluZGV4PTA7Y2xvbmUuc2libGluZz1udWxsO3JldHVybiBjbG9uZTt9ZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlcixsYXN0UGxhY2VkSW5kZXgsbmV3SW5kZXgpe25ld0ZpYmVyLmluZGV4PW5ld0luZGV4O2lmKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKXsvLyBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgdXNlSWQgYWxnb3JpdGhtIG5lZWRzIHRvIGtub3cgd2hpY2ggZmliZXJzIGFyZVxuLy8gcGFydCBvZiBhIGxpc3Qgb2YgY2hpbGRyZW4gKGFycmF5cywgaXRlcmF0b3JzKS5cbm5ld0ZpYmVyLmZsYWdzfD1Gb3JrZWQ7cmV0dXJuIGxhc3RQbGFjZWRJbmRleDt9dmFyIGN1cnJlbnQ9bmV3RmliZXIuYWx0ZXJuYXRlO2lmKGN1cnJlbnQhPT1udWxsKXt2YXIgb2xkSW5kZXg9Y3VycmVudC5pbmRleDtpZihvbGRJbmRleDxsYXN0UGxhY2VkSW5kZXgpey8vIFRoaXMgaXMgYSBtb3ZlLlxubmV3RmliZXIuZmxhZ3N8PVBsYWNlbWVudDtyZXR1cm4gbGFzdFBsYWNlZEluZGV4O31lbHNley8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbnJldHVybiBvbGRJbmRleDt9fWVsc2V7Ly8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG5uZXdGaWJlci5mbGFnc3w9UGxhY2VtZW50O3JldHVybiBsYXN0UGxhY2VkSW5kZXg7fX1mdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKXsvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbi8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbmlmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMmJm5ld0ZpYmVyLmFsdGVybmF0ZT09PW51bGwpe25ld0ZpYmVyLmZsYWdzfD1QbGFjZW1lbnQ7fXJldHVybiBuZXdGaWJlcjt9ZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsY3VycmVudCx0ZXh0Q29udGVudCxsYW5lcyl7aWYoY3VycmVudD09PW51bGx8fGN1cnJlbnQudGFnIT09SG9zdFRleHQpey8vIEluc2VydFxudmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZWxzZXsvLyBVcGRhdGVcbnZhciBleGlzdGluZz11c2VGaWJlcihjdXJyZW50LHRleHRDb250ZW50KTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGV4aXN0aW5nO319ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlcixjdXJyZW50LGVsZW1lbnQsbGFuZXMpe3ZhciBlbGVtZW50VHlwZT1lbGVtZW50LnR5cGU7aWYoZWxlbWVudFR5cGU9PT1SRUFDVF9GUkFHTUVOVF9UWVBFKXtyZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50LnByb3BzLmNoaWxkcmVuLGxhbmVzLGVsZW1lbnQua2V5KTt9aWYoY3VycmVudCE9PW51bGwpe2lmKGN1cnJlbnQuZWxlbWVudFR5cGU9PT1lbGVtZW50VHlwZXx8Ly8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG5pc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY3VycmVudCxlbGVtZW50KXx8Ly8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4vLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4vLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2Vcbi8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbnR5cGVvZiBlbGVtZW50VHlwZT09PSdvYmplY3QnJiZlbGVtZW50VHlwZSE9PW51bGwmJmVsZW1lbnRUeXBlLiQkdHlwZW9mPT09UkVBQ1RfTEFaWV9UWVBFJiZyZXNvbHZlTGF6eShlbGVtZW50VHlwZSk9PT1jdXJyZW50LnR5cGUpey8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbnZhciBleGlzdGluZz11c2VGaWJlcihjdXJyZW50LGVsZW1lbnQucHJvcHMpO2V4aXN0aW5nLnJlZj1jb2VyY2VSZWYocmV0dXJuRmliZXIsY3VycmVudCxlbGVtZW50KTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7e2V4aXN0aW5nLl9kZWJ1Z1NvdXJjZT1lbGVtZW50Ll9zb3VyY2U7ZXhpc3RpbmcuX2RlYnVnT3duZXI9ZWxlbWVudC5fb3duZXI7fXJldHVybiBleGlzdGluZzt9fS8vIEluc2VydFxudmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LHJldHVybkZpYmVyLm1vZGUsbGFuZXMpO2NyZWF0ZWQucmVmPWNvZXJjZVJlZihyZXR1cm5GaWJlcixjdXJyZW50LGVsZW1lbnQpO2NyZWF0ZWQucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBjcmVhdGVkO31mdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsY3VycmVudCxwb3J0YWwsbGFuZXMpe2lmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50LnRhZyE9PUhvc3RQb3J0YWx8fGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1wb3J0YWwuY29udGFpbmVySW5mb3x8Y3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1wb3J0YWwuaW1wbGVtZW50YXRpb24pey8vIEluc2VydFxudmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZWxzZXsvLyBVcGRhdGVcbnZhciBleGlzdGluZz11c2VGaWJlcihjdXJyZW50LHBvcnRhbC5jaGlsZHJlbnx8W10pO2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gZXhpc3Rpbmc7fX1mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlcixjdXJyZW50LGZyYWdtZW50LGxhbmVzLGtleSl7aWYoY3VycmVudD09PW51bGx8fGN1cnJlbnQudGFnIT09RnJhZ21lbnQpey8vIEluc2VydFxudmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQscmV0dXJuRmliZXIubW9kZSxsYW5lcyxrZXkpO2NyZWF0ZWQucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBjcmVhdGVkO31lbHNley8vIFVwZGF0ZVxudmFyIGV4aXN0aW5nPXVzZUZpYmVyKGN1cnJlbnQsZnJhZ21lbnQpO2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gZXhpc3Rpbmc7fX1mdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlcixuZXdDaGlsZCxsYW5lcyl7aWYodHlwZW9mIG5ld0NoaWxkPT09J3N0cmluZycmJm5ld0NoaWxkIT09Jyd8fHR5cGVvZiBuZXdDaGlsZD09PSdudW1iZXInKXsvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbi8vIG5vZGUuXG52YXIgY3JlYXRlZD1jcmVhdGVGaWJlckZyb21UZXh0KCcnK25ld0NoaWxkLHJldHVybkZpYmVyLm1vZGUsbGFuZXMpO2NyZWF0ZWQucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBjcmVhdGVkO31pZih0eXBlb2YgbmV3Q2hpbGQ9PT0nb2JqZWN0JyYmbmV3Q2hpbGQhPT1udWxsKXtzd2l0Y2gobmV3Q2hpbGQuJCR0eXBlb2Ype2Nhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOnt2YXIgX2NyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtfY3JlYXRlZC5yZWY9Y29lcmNlUmVmKHJldHVybkZpYmVyLG51bGwsbmV3Q2hpbGQpO19jcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gX2NyZWF0ZWQ7fWNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6e3ZhciBfY3JlYXRlZDI9Y3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLHJldHVybkZpYmVyLm1vZGUsbGFuZXMpO19jcmVhdGVkMi5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIF9jcmVhdGVkMjt9Y2FzZSBSRUFDVF9MQVpZX1RZUEU6e3ZhciBwYXlsb2FkPW5ld0NoaWxkLl9wYXlsb2FkO3ZhciBpbml0PW5ld0NoaWxkLl9pbml0O3JldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlcixpbml0KHBheWxvYWQpLGxhbmVzKTt9fWlmKGlzQXJyYXkobmV3Q2hpbGQpfHxnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSl7dmFyIF9jcmVhdGVkMz1jcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzLG51bGwpO19jcmVhdGVkMy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIF9jcmVhdGVkMzt9dGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKTt9e2lmKHR5cGVvZiBuZXdDaGlsZD09PSdmdW5jdGlvbicpe3dhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7fX1yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlcixvbGRGaWJlcixuZXdDaGlsZCxsYW5lcyl7Ly8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxudmFyIGtleT1vbGRGaWJlciE9PW51bGw/b2xkRmliZXIua2V5Om51bGw7aWYodHlwZW9mIG5ld0NoaWxkPT09J3N0cmluZycmJm5ld0NoaWxkIT09Jyd8fHR5cGVvZiBuZXdDaGlsZD09PSdudW1iZXInKXsvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbi8vIG5vZGUuXG5pZihrZXkhPT1udWxsKXtyZXR1cm4gbnVsbDt9cmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLG9sZEZpYmVyLCcnK25ld0NoaWxkLGxhbmVzKTt9aWYodHlwZW9mIG5ld0NoaWxkPT09J29iamVjdCcmJm5ld0NoaWxkIT09bnVsbCl7c3dpdGNoKG5ld0NoaWxkLiQkdHlwZW9mKXtjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTp7aWYobmV3Q2hpbGQua2V5PT09a2V5KXtyZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlcixvbGRGaWJlcixuZXdDaGlsZCxsYW5lcyk7fWVsc2V7cmV0dXJuIG51bGw7fX1jYXNlIFJFQUNUX1BPUlRBTF9UWVBFOntpZihuZXdDaGlsZC5rZXk9PT1rZXkpe3JldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsb2xkRmliZXIsbmV3Q2hpbGQsbGFuZXMpO31lbHNle3JldHVybiBudWxsO319Y2FzZSBSRUFDVF9MQVpZX1RZUEU6e3ZhciBwYXlsb2FkPW5ld0NoaWxkLl9wYXlsb2FkO3ZhciBpbml0PW5ld0NoaWxkLl9pbml0O3JldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLG9sZEZpYmVyLGluaXQocGF5bG9hZCksbGFuZXMpO319aWYoaXNBcnJheShuZXdDaGlsZCl8fGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKXtpZihrZXkhPT1udWxsKXtyZXR1cm4gbnVsbDt9cmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLG9sZEZpYmVyLG5ld0NoaWxkLGxhbmVzLG51bGwpO310aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsbmV3Q2hpbGQpO317aWYodHlwZW9mIG5ld0NoaWxkPT09J2Z1bmN0aW9uJyl7d2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTt9fXJldHVybiBudWxsO31mdW5jdGlvbiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4scmV0dXJuRmliZXIsbmV3SWR4LG5ld0NoaWxkLGxhbmVzKXtpZih0eXBlb2YgbmV3Q2hpbGQ9PT0nc3RyaW5nJyYmbmV3Q2hpbGQhPT0nJ3x8dHlwZW9mIG5ld0NoaWxkPT09J251bWJlcicpey8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3Jcbi8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxudmFyIG1hdGNoZWRGaWJlcj1leGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpfHxudWxsO3JldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlcixtYXRjaGVkRmliZXIsJycrbmV3Q2hpbGQsbGFuZXMpO31pZih0eXBlb2YgbmV3Q2hpbGQ9PT0nb2JqZWN0JyYmbmV3Q2hpbGQhPT1udWxsKXtzd2l0Y2gobmV3Q2hpbGQuJCR0eXBlb2Ype2Nhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOnt2YXIgX21hdGNoZWRGaWJlcj1leGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXk9PT1udWxsP25ld0lkeDpuZXdDaGlsZC5rZXkpfHxudWxsO3JldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLF9tYXRjaGVkRmliZXIsbmV3Q2hpbGQsbGFuZXMpO31jYXNlIFJFQUNUX1BPUlRBTF9UWVBFOnt2YXIgX21hdGNoZWRGaWJlcjI9ZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5PT09bnVsbD9uZXdJZHg6bmV3Q2hpbGQua2V5KXx8bnVsbDtyZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLF9tYXRjaGVkRmliZXIyLG5ld0NoaWxkLGxhbmVzKTt9Y2FzZSBSRUFDVF9MQVpZX1RZUEU6dmFyIHBheWxvYWQ9bmV3Q2hpbGQuX3BheWxvYWQ7dmFyIGluaXQ9bmV3Q2hpbGQuX2luaXQ7cmV0dXJuIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbixyZXR1cm5GaWJlcixuZXdJZHgsaW5pdChwYXlsb2FkKSxsYW5lcyk7fWlmKGlzQXJyYXkobmV3Q2hpbGQpfHxnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSl7dmFyIF9tYXRjaGVkRmliZXIzPWV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCl8fG51bGw7cmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLF9tYXRjaGVkRmliZXIzLG5ld0NoaWxkLGxhbmVzLG51bGwpO310aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsbmV3Q2hpbGQpO317aWYodHlwZW9mIG5ld0NoaWxkPT09J2Z1bmN0aW9uJyl7d2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTt9fXJldHVybiBudWxsO30vKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCxrbm93bktleXMscmV0dXJuRmliZXIpe3tpZih0eXBlb2YgY2hpbGQhPT0nb2JqZWN0J3x8Y2hpbGQ9PT1udWxsKXtyZXR1cm4ga25vd25LZXlzO31zd2l0Y2goY2hpbGQuJCR0eXBlb2Ype2Nhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOmNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6d2FybkZvck1pc3NpbmdLZXkoY2hpbGQscmV0dXJuRmliZXIpO3ZhciBrZXk9Y2hpbGQua2V5O2lmKHR5cGVvZiBrZXkhPT0nc3RyaW5nJyl7YnJlYWs7fWlmKGtub3duS2V5cz09PW51bGwpe2tub3duS2V5cz1uZXcgU2V0KCk7a25vd25LZXlzLmFkZChrZXkpO2JyZWFrO31pZigha25vd25LZXlzLmhhcyhrZXkpKXtrbm93bktleXMuYWRkKGtleSk7YnJlYWs7fWVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcrJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJysnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJysnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnKydjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4nLGtleSk7YnJlYWs7Y2FzZSBSRUFDVF9MQVpZX1RZUEU6dmFyIHBheWxvYWQ9Y2hpbGQuX3BheWxvYWQ7dmFyIGluaXQ9Y2hpbGQuX2luaXQ7d2Fybk9uSW52YWxpZEtleShpbml0KHBheWxvYWQpLGtub3duS2V5cyxyZXR1cm5GaWJlcik7YnJlYWs7fX1yZXR1cm4ga25vd25LZXlzO31mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkcmVuLGxhbmVzKXsvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2Vcbi8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4vLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuLy8gYWRkIGl0IGxhdGVyLlxuLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4vLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbi8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4vLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbi8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4vLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbi8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbi8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuey8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxudmFyIGtub3duS2V5cz1udWxsO2Zvcih2YXIgaT0wO2k8bmV3Q2hpbGRyZW4ubGVuZ3RoO2krKyl7dmFyIGNoaWxkPW5ld0NoaWxkcmVuW2ldO2tub3duS2V5cz13YXJuT25JbnZhbGlkS2V5KGNoaWxkLGtub3duS2V5cyxyZXR1cm5GaWJlcik7fX12YXIgcmVzdWx0aW5nRmlyc3RDaGlsZD1udWxsO3ZhciBwcmV2aW91c05ld0ZpYmVyPW51bGw7dmFyIG9sZEZpYmVyPWN1cnJlbnRGaXJzdENoaWxkO3ZhciBsYXN0UGxhY2VkSW5kZXg9MDt2YXIgbmV3SWR4PTA7dmFyIG5leHRPbGRGaWJlcj1udWxsO2Zvcig7b2xkRmliZXIhPT1udWxsJiZuZXdJZHg8bmV3Q2hpbGRyZW4ubGVuZ3RoO25ld0lkeCsrKXtpZihvbGRGaWJlci5pbmRleD5uZXdJZHgpe25leHRPbGRGaWJlcj1vbGRGaWJlcjtvbGRGaWJlcj1udWxsO31lbHNle25leHRPbGRGaWJlcj1vbGRGaWJlci5zaWJsaW5nO312YXIgbmV3RmliZXI9dXBkYXRlU2xvdChyZXR1cm5GaWJlcixvbGRGaWJlcixuZXdDaGlsZHJlbltuZXdJZHhdLGxhbmVzKTtpZihuZXdGaWJlcj09PW51bGwpey8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4vLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4vLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbi8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuaWYob2xkRmliZXI9PT1udWxsKXtvbGRGaWJlcj1uZXh0T2xkRmliZXI7fWJyZWFrO31pZihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXtpZihvbGRGaWJlciYmbmV3RmliZXIuYWx0ZXJuYXRlPT09bnVsbCl7Ly8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4vLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG5kZWxldGVDaGlsZChyZXR1cm5GaWJlcixvbGRGaWJlcik7fX1sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChuZXdGaWJlcixsYXN0UGxhY2VkSW5kZXgsbmV3SWR4KTtpZihwcmV2aW91c05ld0ZpYmVyPT09bnVsbCl7Ly8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxucmVzdWx0aW5nRmlyc3RDaGlsZD1uZXdGaWJlcjt9ZWxzZXsvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4vLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4vLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4vLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG5wcmV2aW91c05ld0ZpYmVyLnNpYmxpbmc9bmV3RmliZXI7fXByZXZpb3VzTmV3RmliZXI9bmV3RmliZXI7b2xkRmliZXI9bmV4dE9sZEZpYmVyO31pZihuZXdJZHg9PT1uZXdDaGlsZHJlbi5sZW5ndGgpey8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsb2xkRmliZXIpO2lmKGdldElzSHlkcmF0aW5nKCkpe3ZhciBudW1iZXJPZkZvcmtzPW5ld0lkeDtwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsbnVtYmVyT2ZGb3Jrcyk7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO31pZihvbGRGaWJlcj09PW51bGwpey8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbmZvcig7bmV3SWR4PG5ld0NoaWxkcmVuLmxlbmd0aDtuZXdJZHgrKyl7dmFyIF9uZXdGaWJlcj1jcmVhdGVDaGlsZChyZXR1cm5GaWJlcixuZXdDaGlsZHJlbltuZXdJZHhdLGxhbmVzKTtpZihfbmV3RmliZXI9PT1udWxsKXtjb250aW51ZTt9bGFzdFBsYWNlZEluZGV4PXBsYWNlQ2hpbGQoX25ld0ZpYmVyLGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXsvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG5yZXN1bHRpbmdGaXJzdENoaWxkPV9uZXdGaWJlcjt9ZWxzZXtwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmc9X25ld0ZpYmVyO31wcmV2aW91c05ld0ZpYmVyPV9uZXdGaWJlcjt9aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIF9udW1iZXJPZkZvcmtzPW5ld0lkeDtwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsX251bWJlck9mRm9ya3MpO31yZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDt9Ly8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG52YXIgZXhpc3RpbmdDaGlsZHJlbj1tYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixvbGRGaWJlcik7Ly8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuZm9yKDtuZXdJZHg8bmV3Q2hpbGRyZW4ubGVuZ3RoO25ld0lkeCsrKXt2YXIgX25ld0ZpYmVyMj11cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4scmV0dXJuRmliZXIsbmV3SWR4LG5ld0NoaWxkcmVuW25ld0lkeF0sbGFuZXMpO2lmKF9uZXdGaWJlcjIhPT1udWxsKXtpZihzaG91bGRUcmFja1NpZGVFZmZlY3RzKXtpZihfbmV3RmliZXIyLmFsdGVybmF0ZSE9PW51bGwpey8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbi8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbi8vIGxpc3QuXG5leGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXIyLmtleT09PW51bGw/bmV3SWR4Ol9uZXdGaWJlcjIua2V5KTt9fWxhc3RQbGFjZWRJbmRleD1wbGFjZUNoaWxkKF9uZXdGaWJlcjIsbGFzdFBsYWNlZEluZGV4LG5ld0lkeCk7aWYocHJldmlvdXNOZXdGaWJlcj09PW51bGwpe3Jlc3VsdGluZ0ZpcnN0Q2hpbGQ9X25ld0ZpYmVyMjt9ZWxzZXtwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmc9X25ld0ZpYmVyMjt9cHJldmlvdXNOZXdGaWJlcj1fbmV3RmliZXIyO319aWYoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7Ly8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbi8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKXtyZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsY2hpbGQpO30pO31pZihnZXRJc0h5ZHJhdGluZygpKXt2YXIgX251bWJlck9mRm9ya3MyPW5ld0lkeDtwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsX251bWJlck9mRm9ya3MyKTt9cmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7fWZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsbmV3Q2hpbGRyZW5JdGVyYWJsZSxsYW5lcyl7Ly8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4vLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG52YXIgaXRlcmF0b3JGbj1nZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO2lmKHR5cGVvZiBpdGVyYXRvckZuIT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKCdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gJysnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO317Ly8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG5pZih0eXBlb2YgU3ltYm9sPT09J2Z1bmN0aW9uJyYmLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xubmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddPT09J0dlbmVyYXRvcicpe2lmKCFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzKXtlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJysndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJysnWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlICcrJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcrJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTt9ZGlkV2FybkFib3V0R2VuZXJhdG9ycz10cnVlO30vLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbmlmKG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcz09PWl0ZXJhdG9yRm4pe2lmKCFkaWRXYXJuQWJvdXRNYXBzKXtlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnKydVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO31kaWRXYXJuQWJvdXRNYXBzPXRydWU7fS8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxudmFyIF9uZXdDaGlsZHJlbj1pdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7aWYoX25ld0NoaWxkcmVuKXt2YXIga25vd25LZXlzPW51bGw7dmFyIF9zdGVwPV9uZXdDaGlsZHJlbi5uZXh0KCk7Zm9yKDshX3N0ZXAuZG9uZTtfc3RlcD1fbmV3Q2hpbGRyZW4ubmV4dCgpKXt2YXIgY2hpbGQ9X3N0ZXAudmFsdWU7a25vd25LZXlzPXdhcm5PbkludmFsaWRLZXkoY2hpbGQsa25vd25LZXlzLHJldHVybkZpYmVyKTt9fX12YXIgbmV3Q2hpbGRyZW49aXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO2lmKG5ld0NoaWxkcmVuPT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKTt9dmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ9bnVsbDt2YXIgcHJldmlvdXNOZXdGaWJlcj1udWxsO3ZhciBvbGRGaWJlcj1jdXJyZW50Rmlyc3RDaGlsZDt2YXIgbGFzdFBsYWNlZEluZGV4PTA7dmFyIG5ld0lkeD0wO3ZhciBuZXh0T2xkRmliZXI9bnVsbDt2YXIgc3RlcD1uZXdDaGlsZHJlbi5uZXh0KCk7Zm9yKDtvbGRGaWJlciE9PW51bGwmJiFzdGVwLmRvbmU7bmV3SWR4Kyssc3RlcD1uZXdDaGlsZHJlbi5uZXh0KCkpe2lmKG9sZEZpYmVyLmluZGV4Pm5ld0lkeCl7bmV4dE9sZEZpYmVyPW9sZEZpYmVyO29sZEZpYmVyPW51bGw7fWVsc2V7bmV4dE9sZEZpYmVyPW9sZEZpYmVyLnNpYmxpbmc7fXZhciBuZXdGaWJlcj11cGRhdGVTbG90KHJldHVybkZpYmVyLG9sZEZpYmVyLHN0ZXAudmFsdWUsbGFuZXMpO2lmKG5ld0ZpYmVyPT09bnVsbCl7Ly8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3Ncbi8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbi8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG5pZihvbGRGaWJlcj09PW51bGwpe29sZEZpYmVyPW5leHRPbGRGaWJlcjt9YnJlYWs7fWlmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpe2lmKG9sZEZpYmVyJiZuZXdGaWJlci5hbHRlcm5hdGU9PT1udWxsKXsvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2Vcbi8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbmRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLG9sZEZpYmVyKTt9fWxhc3RQbGFjZWRJbmRleD1wbGFjZUNoaWxkKG5ld0ZpYmVyLGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXsvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG5yZXN1bHRpbmdGaXJzdENoaWxkPW5ld0ZpYmVyO31lbHNley8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbi8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbi8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3Rcbi8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbnByZXZpb3VzTmV3RmliZXIuc2libGluZz1uZXdGaWJlcjt9cHJldmlvdXNOZXdGaWJlcj1uZXdGaWJlcjtvbGRGaWJlcj1uZXh0T2xkRmliZXI7fWlmKHN0ZXAuZG9uZSl7Ly8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG5kZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixvbGRGaWJlcik7aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIG51bWJlck9mRm9ya3M9bmV3SWR4O3B1c2hUcmVlRm9yayhyZXR1cm5GaWJlcixudW1iZXJPZkZvcmtzKTt9cmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7fWlmKG9sZEZpYmVyPT09bnVsbCl7Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4vLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuZm9yKDshc3RlcC5kb25lO25ld0lkeCsrLHN0ZXA9bmV3Q2hpbGRyZW4ubmV4dCgpKXt2YXIgX25ld0ZpYmVyMz1jcmVhdGVDaGlsZChyZXR1cm5GaWJlcixzdGVwLnZhbHVlLGxhbmVzKTtpZihfbmV3RmliZXIzPT09bnVsbCl7Y29udGludWU7fWxhc3RQbGFjZWRJbmRleD1wbGFjZUNoaWxkKF9uZXdGaWJlcjMsbGFzdFBsYWNlZEluZGV4LG5ld0lkeCk7aWYocHJldmlvdXNOZXdGaWJlcj09PW51bGwpey8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbnJlc3VsdGluZ0ZpcnN0Q2hpbGQ9X25ld0ZpYmVyMzt9ZWxzZXtwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmc9X25ld0ZpYmVyMzt9cHJldmlvdXNOZXdGaWJlcj1fbmV3RmliZXIzO31pZihnZXRJc0h5ZHJhdGluZygpKXt2YXIgX251bWJlck9mRm9ya3MzPW5ld0lkeDtwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsX251bWJlck9mRm9ya3MzKTt9cmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7fS8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxudmFyIGV4aXN0aW5nQ2hpbGRyZW49bWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsb2xkRmliZXIpOy8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbmZvcig7IXN0ZXAuZG9uZTtuZXdJZHgrKyxzdGVwPW5ld0NoaWxkcmVuLm5leHQoKSl7dmFyIF9uZXdGaWJlcjQ9dXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLHJldHVybkZpYmVyLG5ld0lkeCxzdGVwLnZhbHVlLGxhbmVzKTtpZihfbmV3RmliZXI0IT09bnVsbCl7aWYoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyl7aWYoX25ld0ZpYmVyNC5hbHRlcm5hdGUhPT1udWxsKXsvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4vLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbi8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4vLyBsaXN0LlxuZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyNC5rZXk9PT1udWxsP25ld0lkeDpfbmV3RmliZXI0LmtleSk7fX1sYXN0UGxhY2VkSW5kZXg9cGxhY2VDaGlsZChfbmV3RmliZXI0LGxhc3RQbGFjZWRJbmRleCxuZXdJZHgpO2lmKHByZXZpb3VzTmV3RmliZXI9PT1udWxsKXtyZXN1bHRpbmdGaXJzdENoaWxkPV9uZXdGaWJlcjQ7fWVsc2V7cHJldmlvdXNOZXdGaWJlci5zaWJsaW5nPV9uZXdGaWJlcjQ7fXByZXZpb3VzTmV3RmliZXI9X25ld0ZpYmVyNDt9fWlmKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpey8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4vLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbmV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCl7cmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkKTt9KTt9aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIF9udW1iZXJPZkZvcmtzND1uZXdJZHg7cHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLF9udW1iZXJPZkZvcmtzNCk7fXJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO31mdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCx0ZXh0Q29udGVudCxsYW5lcyl7Ly8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4vLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG5pZihjdXJyZW50Rmlyc3RDaGlsZCE9PW51bGwmJmN1cnJlbnRGaXJzdENoaWxkLnRhZz09PUhvc3RUZXh0KXsvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4vLyB0aGUgcmVzdC5cbmRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO3ZhciBleGlzdGluZz11c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCx0ZXh0Q29udGVudCk7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBleGlzdGluZzt9Ly8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbi8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5kZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCk7dmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxlbGVtZW50LGxhbmVzKXt2YXIga2V5PWVsZW1lbnQua2V5O3ZhciBjaGlsZD1jdXJyZW50Rmlyc3RDaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpey8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4vLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbmlmKGNoaWxkLmtleT09PWtleSl7dmFyIGVsZW1lbnRUeXBlPWVsZW1lbnQudHlwZTtpZihlbGVtZW50VHlwZT09PVJFQUNUX0ZSQUdNRU5UX1RZUEUpe2lmKGNoaWxkLnRhZz09PUZyYWdtZW50KXtkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlcixjaGlsZC5zaWJsaW5nKTt2YXIgZXhpc3Rpbmc9dXNlRmliZXIoY2hpbGQsZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7ZXhpc3RpbmcucmV0dXJuPXJldHVybkZpYmVyO3tleGlzdGluZy5fZGVidWdTb3VyY2U9ZWxlbWVudC5fc291cmNlO2V4aXN0aW5nLl9kZWJ1Z093bmVyPWVsZW1lbnQuX293bmVyO31yZXR1cm4gZXhpc3Rpbmc7fX1lbHNle2lmKGNoaWxkLmVsZW1lbnRUeXBlPT09ZWxlbWVudFR5cGV8fC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLGVsZW1lbnQpfHwvLyBMYXp5IHR5cGVzIHNob3VsZCByZWNvbmNpbGUgdGhlaXIgcmVzb2x2ZWQgdHlwZS5cbi8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciB0aGUgSG90IFJlbG9hZGluZyBjaGVjayBhYm92ZSxcbi8vIGJlY2F1c2UgaG90IHJlbG9hZGluZyBoYXMgZGlmZmVyZW50IHNlbWFudGljcyB0aGFuIHByb2QgYmVjYXVzZVxuLy8gaXQgZG9lc24ndCByZXN1c3BlbmQuIFNvIHdlIGNhbid0IGxldCB0aGUgY2FsbCBiZWxvdyBzdXNwZW5kLlxudHlwZW9mIGVsZW1lbnRUeXBlPT09J29iamVjdCcmJmVsZW1lbnRUeXBlIT09bnVsbCYmZWxlbWVudFR5cGUuJCR0eXBlb2Y9PT1SRUFDVF9MQVpZX1RZUEUmJnJlc29sdmVMYXp5KGVsZW1lbnRUeXBlKT09PWNoaWxkLnR5cGUpe2RlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGNoaWxkLnNpYmxpbmcpO3ZhciBfZXhpc3Rpbmc9dXNlRmliZXIoY2hpbGQsZWxlbWVudC5wcm9wcyk7X2V4aXN0aW5nLnJlZj1jb2VyY2VSZWYocmV0dXJuRmliZXIsY2hpbGQsZWxlbWVudCk7X2V4aXN0aW5nLnJldHVybj1yZXR1cm5GaWJlcjt7X2V4aXN0aW5nLl9kZWJ1Z1NvdXJjZT1lbGVtZW50Ll9zb3VyY2U7X2V4aXN0aW5nLl9kZWJ1Z093bmVyPWVsZW1lbnQuX293bmVyO31yZXR1cm4gX2V4aXN0aW5nO319Ly8gRGlkbid0IG1hdGNoLlxuZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY2hpbGQpO2JyZWFrO31lbHNle2RlbGV0ZUNoaWxkKHJldHVybkZpYmVyLGNoaWxkKTt9Y2hpbGQ9Y2hpbGQuc2libGluZzt9aWYoZWxlbWVudC50eXBlPT09UkVBQ1RfRlJBR01FTlRfVFlQRSl7dmFyIGNyZWF0ZWQ9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbixyZXR1cm5GaWJlci5tb2RlLGxhbmVzLGVsZW1lbnQua2V5KTtjcmVhdGVkLnJldHVybj1yZXR1cm5GaWJlcjtyZXR1cm4gY3JlYXRlZDt9ZWxzZXt2YXIgX2NyZWF0ZWQ0PWNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCxyZXR1cm5GaWJlci5tb2RlLGxhbmVzKTtfY3JlYXRlZDQucmVmPWNvZXJjZVJlZihyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxlbGVtZW50KTtfY3JlYXRlZDQucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBfY3JlYXRlZDQ7fX1mdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQscG9ydGFsLGxhbmVzKXt2YXIga2V5PXBvcnRhbC5rZXk7dmFyIGNoaWxkPWN1cnJlbnRGaXJzdENoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7Ly8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbi8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuaWYoY2hpbGQua2V5PT09a2V5KXtpZihjaGlsZC50YWc9PT1Ib3N0UG9ydGFsJiZjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PXBvcnRhbC5jb250YWluZXJJbmZvJiZjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1wb3J0YWwuaW1wbGVtZW50YXRpb24pe2RlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGNoaWxkLnNpYmxpbmcpO3ZhciBleGlzdGluZz11c2VGaWJlcihjaGlsZCxwb3J0YWwuY2hpbGRyZW58fFtdKTtleGlzdGluZy5yZXR1cm49cmV0dXJuRmliZXI7cmV0dXJuIGV4aXN0aW5nO31lbHNle2RlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLGNoaWxkKTticmVhazt9fWVsc2V7ZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsY2hpbGQpO31jaGlsZD1jaGlsZC5zaWJsaW5nO312YXIgY3JlYXRlZD1jcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLHJldHVybkZpYmVyLm1vZGUsbGFuZXMpO2NyZWF0ZWQucmV0dXJuPXJldHVybkZpYmVyO3JldHVybiBjcmVhdGVkO30vLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4vLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4vLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkLGxhbmVzKXsvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWN1cnNpdmUuXG4vLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4vLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbnZhciBpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50PXR5cGVvZiBuZXdDaGlsZD09PSdvYmplY3QnJiZuZXdDaGlsZCE9PW51bGwmJm5ld0NoaWxkLnR5cGU9PT1SRUFDVF9GUkFHTUVOVF9UWVBFJiZuZXdDaGlsZC5rZXk9PT1udWxsO2lmKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpe25ld0NoaWxkPW5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO30vLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5pZih0eXBlb2YgbmV3Q2hpbGQ9PT0nb2JqZWN0JyYmbmV3Q2hpbGQhPT1udWxsKXtzd2l0Y2gobmV3Q2hpbGQuJCR0eXBlb2Ype2Nhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOnJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQsbmV3Q2hpbGQsbGFuZXMpKTtjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOnJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxuZXdDaGlsZCxsYW5lcykpO2Nhc2UgUkVBQ1RfTEFaWV9UWVBFOnZhciBwYXlsb2FkPW5ld0NoaWxkLl9wYXlsb2FkO3ZhciBpbml0PW5ld0NoaWxkLl9pbml0Oy8vIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgc3VwcG9zZWQgdG8gYmUgbm9uLXJlY3Vyc2l2ZS5cbnJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCxpbml0KHBheWxvYWQpLGxhbmVzKTt9aWYoaXNBcnJheShuZXdDaGlsZCkpe3JldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkLGxhbmVzKTt9aWYoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpe3JldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLGN1cnJlbnRGaXJzdENoaWxkLG5ld0NoaWxkLGxhbmVzKTt9dGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLG5ld0NoaWxkKTt9aWYodHlwZW9mIG5ld0NoaWxkPT09J3N0cmluZycmJm5ld0NoaWxkIT09Jyd8fHR5cGVvZiBuZXdDaGlsZD09PSdudW1iZXInKXtyZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlcixjdXJyZW50Rmlyc3RDaGlsZCwnJytuZXdDaGlsZCxsYW5lcykpO317aWYodHlwZW9mIG5ld0NoaWxkPT09J2Z1bmN0aW9uJyl7d2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTt9fS8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5yZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsY3VycmVudEZpcnN0Q2hpbGQpO31yZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7fXZhciByZWNvbmNpbGVDaGlsZEZpYmVycz1DaGlsZFJlY29uY2lsZXIodHJ1ZSk7dmFyIG1vdW50Q2hpbGRGaWJlcnM9Q2hpbGRSZWNvbmNpbGVyKGZhbHNlKTtmdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Mpe2lmKGN1cnJlbnQhPT1udWxsJiZ3b3JrSW5Qcm9ncmVzcy5jaGlsZCE9PWN1cnJlbnQuY2hpbGQpe3Rocm93IG5ldyBFcnJvcignUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpO31pZih3b3JrSW5Qcm9ncmVzcy5jaGlsZD09PW51bGwpe3JldHVybjt9dmFyIGN1cnJlbnRDaGlsZD13b3JrSW5Qcm9ncmVzcy5jaGlsZDt2YXIgbmV3Q2hpbGQ9Y3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO3dvcmtJblByb2dyZXNzLmNoaWxkPW5ld0NoaWxkO25ld0NoaWxkLnJldHVybj13b3JrSW5Qcm9ncmVzczt3aGlsZShjdXJyZW50Q2hpbGQuc2libGluZyE9PW51bGwpe2N1cnJlbnRDaGlsZD1jdXJyZW50Q2hpbGQuc2libGluZztuZXdDaGlsZD1uZXdDaGlsZC5zaWJsaW5nPWNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCxjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtuZXdDaGlsZC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7fW5ld0NoaWxkLnNpYmxpbmc9bnVsbDt9Ly8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsbGFuZXMpe3ZhciBjaGlsZD13b3JrSW5Qcm9ncmVzcy5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe3Jlc2V0V29ya0luUHJvZ3Jlc3MoY2hpbGQsbGFuZXMpO2NoaWxkPWNoaWxkLnNpYmxpbmc7fX12YXIgdmFsdWVDdXJzb3I9Y3JlYXRlQ3Vyc29yKG51bGwpO3ZhciByZW5kZXJlclNpZ2lsO3svLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbnJlbmRlcmVyU2lnaWw9e307fXZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcj1udWxsO3ZhciBsYXN0Q29udGV4dERlcGVuZGVuY3k9bnVsbDt2YXIgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PW51bGw7dmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVY9ZmFsc2U7ZnVuY3Rpb24gcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCl7Ly8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4vLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbmN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyPW51bGw7bGFzdENvbnRleHREZXBlbmRlbmN5PW51bGw7bGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PW51bGw7e2lzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVY9ZmFsc2U7fX1mdW5jdGlvbiBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCl7e2lzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVY9dHJ1ZTt9fWZ1bmN0aW9uIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpe3tpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWPWZhbHNlO319ZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsY29udGV4dCxuZXh0VmFsdWUpe3twdXNoKHZhbHVlQ3Vyc29yLGNvbnRleHQuX2N1cnJlbnRWYWx1ZSxwcm92aWRlckZpYmVyKTtjb250ZXh0Ll9jdXJyZW50VmFsdWU9bmV4dFZhbHVlO3tpZihjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIhPT11bmRlZmluZWQmJmNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciE9PW51bGwmJmNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciE9PXJlbmRlcmVyU2lnaWwpe2Vycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJysnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTt9Y29udGV4dC5fY3VycmVudFJlbmRlcmVyPXJlbmRlcmVyU2lnaWw7fX19ZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCxwcm92aWRlckZpYmVyKXt2YXIgY3VycmVudFZhbHVlPXZhbHVlQ3Vyc29yLmN1cnJlbnQ7cG9wKHZhbHVlQ3Vyc29yLHByb3ZpZGVyRmliZXIpO3t7Y29udGV4dC5fY3VycmVudFZhbHVlPWN1cnJlbnRWYWx1ZTt9fX1mdW5jdGlvbiBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudCxyZW5kZXJMYW5lcyxwcm9wYWdhdGlvblJvb3Qpey8vIFVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZyB0aGUgYWx0ZXJuYXRlcy5cbnZhciBub2RlPXBhcmVudDt3aGlsZShub2RlIT09bnVsbCl7dmFyIGFsdGVybmF0ZT1ub2RlLmFsdGVybmF0ZTtpZighaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcykpe25vZGUuY2hpbGRMYW5lcz1tZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcyk7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmNoaWxkTGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcyxyZW5kZXJMYW5lcyk7fX1lbHNlIGlmKGFsdGVybmF0ZSE9PW51bGwmJiFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMscmVuZGVyTGFuZXMpKXthbHRlcm5hdGUuY2hpbGRMYW5lcz1tZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLHJlbmRlckxhbmVzKTt9aWYobm9kZT09PXByb3BhZ2F0aW9uUm9vdCl7YnJlYWs7fW5vZGU9bm9kZS5yZXR1cm47fXtpZihub2RlIT09cHJvcGFnYXRpb25Sb290KXtlcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJvcGFnYXRpb24gcm9vdCB3aGVuIHNjaGVkdWxpbmcgY29udGV4dCB3b3JrLiAnKydUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319fWZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsY29udGV4dCxyZW5kZXJMYW5lcyl7e3Byb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIod29ya0luUHJvZ3Jlc3MsY29udGV4dCxyZW5kZXJMYW5lcyk7fX1mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLGNvbnRleHQscmVuZGVyTGFuZXMpe3ZhciBmaWJlcj13b3JrSW5Qcm9ncmVzcy5jaGlsZDtpZihmaWJlciE9PW51bGwpey8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuZmliZXIucmV0dXJuPXdvcmtJblByb2dyZXNzO313aGlsZShmaWJlciE9PW51bGwpe3ZhciBuZXh0RmliZXI9dm9pZCAwOy8vIFZpc2l0IHRoaXMgZmliZXIuXG52YXIgbGlzdD1maWJlci5kZXBlbmRlbmNpZXM7aWYobGlzdCE9PW51bGwpe25leHRGaWJlcj1maWJlci5jaGlsZDt2YXIgZGVwZW5kZW5jeT1saXN0LmZpcnN0Q29udGV4dDt3aGlsZShkZXBlbmRlbmN5IT09bnVsbCl7Ly8gQ2hlY2sgaWYgdGhlIGNvbnRleHQgbWF0Y2hlcy5cbmlmKGRlcGVuZGVuY3kuY29udGV4dD09PWNvbnRleHQpey8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbmlmKGZpYmVyLnRhZz09PUNsYXNzQ29tcG9uZW50KXsvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbnZhciBsYW5lPXBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxsYW5lKTt1cGRhdGUudGFnPUZvcmNlVXBkYXRlOy8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4vLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbi8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3Ncbi8vIHdvcnRoIGZpeGluZy5cbi8vIElubGluZWQgYGVucXVldWVVcGRhdGVgIHRvIHJlbW92ZSBpbnRlcmxlYXZlZCB1cGRhdGUgY2hlY2tcbnZhciB1cGRhdGVRdWV1ZT1maWJlci51cGRhdGVRdWV1ZTtpZih1cGRhdGVRdWV1ZT09PW51bGwpO2Vsc2V7dmFyIHNoYXJlZFF1ZXVlPXVwZGF0ZVF1ZXVlLnNoYXJlZDt2YXIgcGVuZGluZz1zaGFyZWRRdWV1ZS5wZW5kaW5nO2lmKHBlbmRpbmc9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7fWVsc2V7dXBkYXRlLm5leHQ9cGVuZGluZy5uZXh0O3BlbmRpbmcubmV4dD11cGRhdGU7fXNoYXJlZFF1ZXVlLnBlbmRpbmc9dXBkYXRlO319ZmliZXIubGFuZXM9bWVyZ2VMYW5lcyhmaWJlci5sYW5lcyxyZW5kZXJMYW5lcyk7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmxhbmVzPW1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLHJlbmRlckxhbmVzKTt9c2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4scmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MpOy8vIE1hcmsgdGhlIHVwZGF0ZWQgbGFuZXMgb24gdGhlIGxpc3QsIHRvby5cbmxpc3QubGFuZXM9bWVyZ2VMYW5lcyhsaXN0LmxhbmVzLHJlbmRlckxhbmVzKTsvLyBTaW5jZSB3ZSBhbHJlYWR5IGZvdW5kIGEgbWF0Y2gsIHdlIGNhbiBzdG9wIHRyYXZlcnNpbmcgdGhlXG4vLyBkZXBlbmRlbmN5IGxpc3QuXG5icmVhazt9ZGVwZW5kZW5jeT1kZXBlbmRlbmN5Lm5leHQ7fX1lbHNlIGlmKGZpYmVyLnRhZz09PUNvbnRleHRQcm92aWRlcil7Ly8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG5uZXh0RmliZXI9ZmliZXIudHlwZT09PXdvcmtJblByb2dyZXNzLnR5cGU/bnVsbDpmaWJlci5jaGlsZDt9ZWxzZSBpZihmaWJlci50YWc9PT1EZWh5ZHJhdGVkRnJhZ21lbnQpey8vIElmIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBpcyBpbiB0aGlzIHN1YnRyZWUsIHdlIGRvbid0IGtub3dcbi8vIGlmIGl0IHdpbGwgaGF2ZSBhbnkgY29udGV4dCBjb25zdW1lcnMgaW4gaXQuIFRoZSBiZXN0IHdlIGNhbiBkbyBpc1xuLy8gbWFyayBpdCBhcyBoYXZpbmcgdXBkYXRlcy5cbnZhciBwYXJlbnRTdXNwZW5zZT1maWJlci5yZXR1cm47aWYocGFyZW50U3VzcGVuc2U9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fXBhcmVudFN1c3BlbnNlLmxhbmVzPW1lcmdlTGFuZXMocGFyZW50U3VzcGVuc2UubGFuZXMscmVuZGVyTGFuZXMpO3ZhciBfYWx0ZXJuYXRlPXBhcmVudFN1c3BlbnNlLmFsdGVybmF0ZTtpZihfYWx0ZXJuYXRlIT09bnVsbCl7X2FsdGVybmF0ZS5sYW5lcz1tZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMscmVuZGVyTGFuZXMpO30vLyBUaGlzIGlzIGludGVudGlvbmFsbHkgcGFzc2luZyB0aGlzIGZpYmVyIGFzIHRoZSBwYXJlbnRcbi8vIGJlY2F1c2Ugd2Ugd2FudCB0byBzY2hlZHVsZSB0aGlzIGZpYmVyIGFzIGhhdmluZyB3b3JrXG4vLyBvbiBpdHMgY2hpbGRyZW4uIFdlJ2xsIHVzZSB0aGUgY2hpbGRMYW5lcyBvblxuLy8gdGhpcyBmaWJlciB0byBpbmRpY2F0ZSB0aGF0IGEgY29udGV4dCBoYXMgY2hhbmdlZC5cbnNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50U3VzcGVuc2UscmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MpO25leHRGaWJlcj1maWJlci5zaWJsaW5nO31lbHNley8vIFRyYXZlcnNlIGRvd24uXG5uZXh0RmliZXI9ZmliZXIuY2hpbGQ7fWlmKG5leHRGaWJlciE9PW51bGwpey8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxubmV4dEZpYmVyLnJldHVybj1maWJlcjt9ZWxzZXsvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxubmV4dEZpYmVyPWZpYmVyO3doaWxlKG5leHRGaWJlciE9PW51bGwpe2lmKG5leHRGaWJlcj09PXdvcmtJblByb2dyZXNzKXsvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbm5leHRGaWJlcj1udWxsO2JyZWFrO312YXIgc2libGluZz1uZXh0RmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7Ly8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbnNpYmxpbmcucmV0dXJuPW5leHRGaWJlci5yZXR1cm47bmV4dEZpYmVyPXNpYmxpbmc7YnJlYWs7fS8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxubmV4dEZpYmVyPW5leHRGaWJlci5yZXR1cm47fX1maWJlcj1uZXh0RmliZXI7fX1mdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7Y3VycmVudGx5UmVuZGVyaW5nRmliZXI9d29ya0luUHJvZ3Jlc3M7bGFzdENvbnRleHREZXBlbmRlbmN5PW51bGw7bGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PW51bGw7dmFyIGRlcGVuZGVuY2llcz13b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7aWYoZGVwZW5kZW5jaWVzIT09bnVsbCl7e3ZhciBmaXJzdENvbnRleHQ9ZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtpZihmaXJzdENvbnRleHQhPT1udWxsKXtpZihpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcyxyZW5kZXJMYW5lcykpey8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG5tYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO30vLyBSZXNldCB0aGUgd29yay1pbi1wcm9ncmVzcyBsaXN0XG5kZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0PW51bGw7fX19fWZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpe3svLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuLy8gVW5saWtlIHRoZSBjbGFzcyBjaGVjayBiZWxvdywgaXQncyBub3QgZW5mb3JjZWQgaW4gcHJvZHVjdGlvbiBmb3IgcGVyZi5cbmlmKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpe2Vycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnKydJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnKydJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJysnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTt9fXZhciB2YWx1ZT1jb250ZXh0Ll9jdXJyZW50VmFsdWU7aWYobGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0PT09Y29udGV4dCk7ZWxzZXt2YXIgY29udGV4dEl0ZW09e2NvbnRleHQ6Y29udGV4dCxtZW1vaXplZFZhbHVlOnZhbHVlLG5leHQ6bnVsbH07aWYobGFzdENvbnRleHREZXBlbmRlbmN5PT09bnVsbCl7aWYoY3VycmVudGx5UmVuZGVyaW5nRmliZXI9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcrJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcrJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnKydpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO30vLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5sYXN0Q29udGV4dERlcGVuZGVuY3k9Y29udGV4dEl0ZW07Y3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzPXtsYW5lczpOb0xhbmVzLGZpcnN0Q29udGV4dDpjb250ZXh0SXRlbX07fWVsc2V7Ly8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbmxhc3RDb250ZXh0RGVwZW5kZW5jeT1sYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dD1jb250ZXh0SXRlbTt9fXJldHVybiB2YWx1ZTt9Ly8gcmVuZGVyLiBXaGVuIHRoaXMgcmVuZGVyIGV4aXRzLCBlaXRoZXIgYmVjYXVzZSBpdCBmaW5pc2hlcyBvciBiZWNhdXNlIGl0IGlzXG4vLyBpbnRlcnJ1cHRlZCwgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbCBiZSB0cmFuc2ZlcnJlZCBvbnRvIHRoZSBtYWluIHBhcnRcbi8vIG9mIHRoZSBxdWV1ZS5cbnZhciBjb25jdXJyZW50UXVldWVzPW51bGw7ZnVuY3Rpb24gcHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSl7aWYoY29uY3VycmVudFF1ZXVlcz09PW51bGwpe2NvbmN1cnJlbnRRdWV1ZXM9W3F1ZXVlXTt9ZWxzZXtjb25jdXJyZW50UXVldWVzLnB1c2gocXVldWUpO319ZnVuY3Rpb24gZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpey8vIFRyYW5zZmVyIHRoZSBpbnRlcmxlYXZlZCB1cGRhdGVzIG9udG8gdGhlIG1haW4gcXVldWUuIEVhY2ggcXVldWUgaGFzIGFcbi8vIGBwZW5kaW5nYCBmaWVsZCBhbmQgYW4gYGludGVybGVhdmVkYCBmaWVsZC4gV2hlbiB0aGV5IGFyZSBub3QgbnVsbCwgdGhleVxuLy8gcG9pbnQgdG8gdGhlIGxhc3Qgbm9kZSBpbiBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0LiBXZSBuZWVkIHRvIGFwcGVuZCB0aGVcbi8vIGludGVybGVhdmVkIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgcGVuZGluZyBsaXN0IGJ5IGpvaW5pbmcgdGhlbSBpbnRvIGFcbi8vIHNpbmdsZSwgY2lyY3VsYXIgbGlzdC5cbmlmKGNvbmN1cnJlbnRRdWV1ZXMhPT1udWxsKXtmb3IodmFyIGk9MDtpPGNvbmN1cnJlbnRRdWV1ZXMubGVuZ3RoO2krKyl7dmFyIHF1ZXVlPWNvbmN1cnJlbnRRdWV1ZXNbaV07dmFyIGxhc3RJbnRlcmxlYXZlZFVwZGF0ZT1xdWV1ZS5pbnRlcmxlYXZlZDtpZihsYXN0SW50ZXJsZWF2ZWRVcGRhdGUhPT1udWxsKXtxdWV1ZS5pbnRlcmxlYXZlZD1udWxsO3ZhciBmaXJzdEludGVybGVhdmVkVXBkYXRlPWxhc3RJbnRlcmxlYXZlZFVwZGF0ZS5uZXh0O3ZhciBsYXN0UGVuZGluZ1VwZGF0ZT1xdWV1ZS5wZW5kaW5nO2lmKGxhc3RQZW5kaW5nVXBkYXRlIT09bnVsbCl7dmFyIGZpcnN0UGVuZGluZ1VwZGF0ZT1sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ9Zmlyc3RJbnRlcmxlYXZlZFVwZGF0ZTtsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dD1maXJzdFBlbmRpbmdVcGRhdGU7fXF1ZXVlLnBlbmRpbmc9bGFzdEludGVybGVhdmVkVXBkYXRlO319Y29uY3VycmVudFF1ZXVlcz1udWxsO319ZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLHF1ZXVlLHVwZGF0ZSxsYW5lKXt2YXIgaW50ZXJsZWF2ZWQ9cXVldWUuaW50ZXJsZWF2ZWQ7aWYoaW50ZXJsZWF2ZWQ9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7Ly8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbi8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxucHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSk7fWVsc2V7dXBkYXRlLm5leHQ9aW50ZXJsZWF2ZWQubmV4dDtpbnRlcmxlYXZlZC5uZXh0PXVwZGF0ZTt9cXVldWUuaW50ZXJsZWF2ZWQ9dXBkYXRlO3JldHVybiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlcixsYW5lKTt9ZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlQW5kRWFnZXJseUJhaWxvdXQoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpe3ZhciBpbnRlcmxlYXZlZD1xdWV1ZS5pbnRlcmxlYXZlZDtpZihpbnRlcmxlYXZlZD09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbnVwZGF0ZS5uZXh0PXVwZGF0ZTsvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlbmRlciwgdGhpcyBxdWV1ZSdzIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbFxuLy8gYmUgdHJhbnNmZXJyZWQgdG8gdGhlIHBlbmRpbmcgcXVldWUuXG5wdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlKHF1ZXVlKTt9ZWxzZXt1cGRhdGUubmV4dD1pbnRlcmxlYXZlZC5uZXh0O2ludGVybGVhdmVkLm5leHQ9dXBkYXRlO31xdWV1ZS5pbnRlcmxlYXZlZD11cGRhdGU7fWZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpe3ZhciBpbnRlcmxlYXZlZD1xdWV1ZS5pbnRlcmxlYXZlZDtpZihpbnRlcmxlYXZlZD09PW51bGwpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbnVwZGF0ZS5uZXh0PXVwZGF0ZTsvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlbmRlciwgdGhpcyBxdWV1ZSdzIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbFxuLy8gYmUgdHJhbnNmZXJyZWQgdG8gdGhlIHBlbmRpbmcgcXVldWUuXG5wdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlKHF1ZXVlKTt9ZWxzZXt1cGRhdGUubmV4dD1pbnRlcmxlYXZlZC5uZXh0O2ludGVybGVhdmVkLm5leHQ9dXBkYXRlO31xdWV1ZS5pbnRlcmxlYXZlZD11cGRhdGU7cmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLGxhbmUpO31mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsbGFuZSl7cmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLGxhbmUpO30vLyBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBiZSBkb25lIGZvciBiYWNrd2FyZHNcbi8vIGNvbXBhdGliaWxpdHkgYW5kIHNob3VsZCBhbHdheXMgYmUgYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nLlxudmFyIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdD1tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdDtmdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlcixsYW5lKXsvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG5zb3VyY2VGaWJlci5sYW5lcz1tZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLGxhbmUpO3ZhciBhbHRlcm5hdGU9c291cmNlRmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2FsdGVybmF0ZS5sYW5lcz1tZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcyxsYW5lKTt9e2lmKGFsdGVybmF0ZT09PW51bGwmJihzb3VyY2VGaWJlci5mbGFncyYoUGxhY2VtZW50fEh5ZHJhdGluZykpIT09Tm9GbGFncyl7d2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7fX0vLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIHRoZSBjaGlsZCBsYW5lcy5cbnZhciBub2RlPXNvdXJjZUZpYmVyO3ZhciBwYXJlbnQ9c291cmNlRmliZXIucmV0dXJuO3doaWxlKHBhcmVudCE9PW51bGwpe3BhcmVudC5jaGlsZExhbmVzPW1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsbGFuZSk7YWx0ZXJuYXRlPXBhcmVudC5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLmNoaWxkTGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcyxsYW5lKTt9ZWxzZXt7aWYoKHBhcmVudC5mbGFncyYoUGxhY2VtZW50fEh5ZHJhdGluZykpIT09Tm9GbGFncyl7d2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7fX19bm9kZT1wYXJlbnQ7cGFyZW50PXBhcmVudC5yZXR1cm47fWlmKG5vZGUudGFnPT09SG9zdFJvb3Qpe3ZhciByb290PW5vZGUuc3RhdGVOb2RlO3JldHVybiByb290O31lbHNle3JldHVybiBudWxsO319dmFyIFVwZGF0ZVN0YXRlPTA7dmFyIFJlcGxhY2VTdGF0ZT0xO3ZhciBGb3JjZVVwZGF0ZT0yO3ZhciBDYXB0dXJlVXBkYXRlPTM7Ly8gR2xvYmFsIHN0YXRlIHRoYXQgaXMgcmVzZXQgYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLlxuLy8gSXQgc2hvdWxkIG9ubHkgYmUgcmVhZCByaWdodCBhZnRlciBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLCB2aWFcbi8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cbnZhciBoYXNGb3JjZVVwZGF0ZT1mYWxzZTt2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZTt2YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO3tkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlPWZhbHNlO2N1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZT1udWxsO31mdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpe3ZhciBxdWV1ZT17YmFzZVN0YXRlOmZpYmVyLm1lbW9pemVkU3RhdGUsZmlyc3RCYXNlVXBkYXRlOm51bGwsbGFzdEJhc2VVcGRhdGU6bnVsbCxzaGFyZWQ6e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOk5vTGFuZXN9LGVmZmVjdHM6bnVsbH07ZmliZXIudXBkYXRlUXVldWU9cXVldWU7fWZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyl7Ly8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbnZhciBxdWV1ZT13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTt2YXIgY3VycmVudFF1ZXVlPWN1cnJlbnQudXBkYXRlUXVldWU7aWYocXVldWU9PT1jdXJyZW50UXVldWUpe3ZhciBjbG9uZT17YmFzZVN0YXRlOmN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUsbGFzdEJhc2VVcGRhdGU6Y3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLHNoYXJlZDpjdXJyZW50UXVldWUuc2hhcmVkLGVmZmVjdHM6Y3VycmVudFF1ZXVlLmVmZmVjdHN9O3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPWNsb25lO319ZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSxsYW5lKXt2YXIgdXBkYXRlPXtldmVudFRpbWU6ZXZlbnRUaW1lLGxhbmU6bGFuZSx0YWc6VXBkYXRlU3RhdGUscGF5bG9hZDpudWxsLGNhbGxiYWNrOm51bGwsbmV4dDpudWxsfTtyZXR1cm4gdXBkYXRlO31mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxsYW5lKXt2YXIgdXBkYXRlUXVldWU9ZmliZXIudXBkYXRlUXVldWU7aWYodXBkYXRlUXVldWU9PT1udWxsKXsvLyBPbmx5IG9jY3VycyBpZiB0aGUgZmliZXIgaGFzIGJlZW4gdW5tb3VudGVkLlxucmV0dXJuIG51bGw7fXZhciBzaGFyZWRRdWV1ZT11cGRhdGVRdWV1ZS5zaGFyZWQ7e2lmKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZT09PXNoYXJlZFF1ZXVlJiYhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSl7ZXJyb3IoJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJysnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnKyd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnKydjYWxsYmFjay4nKTtkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlPXRydWU7fX1pZihpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoKSl7Ly8gVGhpcyBpcyBhbiB1bnNhZmUgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gQWRkIGRpcmVjdGx5IHRvIHRoZSB1cGRhdGVcbi8vIHF1ZXVlIHNvIHdlIGNhbiBwcm9jZXNzIGl0IGltbWVkaWF0ZWx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIuXG52YXIgcGVuZGluZz1zaGFyZWRRdWV1ZS5wZW5kaW5nO2lmKHBlbmRpbmc9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG51cGRhdGUubmV4dD11cGRhdGU7fWVsc2V7dXBkYXRlLm5leHQ9cGVuZGluZy5uZXh0O3BlbmRpbmcubmV4dD11cGRhdGU7fXNoYXJlZFF1ZXVlLnBlbmRpbmc9dXBkYXRlOy8vIFVwZGF0ZSB0aGUgY2hpbGRMYW5lcyBldmVuIHRob3VnaCB3ZSdyZSBtb3N0IGxpa2VseSBhbHJlYWR5IHJlbmRlcmluZ1xuLy8gdGhpcyBmaWJlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gdGhlIGNhc2Ugd2hlcmUgeW91XG4vLyB1cGRhdGUgYSBkaWZmZXJlbnQgY29tcG9uZW50IGR1cmluZyByZW5kZXIgcGhhc2UgdGhhbiB0aGUgb25lIHRoYXQgaXNcbi8vIGN1cnJlbnRseSByZW5kZXJpbmdzIChhIHBhdHRlcm4gdGhhdCBpcyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcpLlxucmV0dXJuIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlcixsYW5lKTt9ZWxzZXtyZXR1cm4gZW5xdWV1ZUNvbmN1cnJlbnRDbGFzc1VwZGF0ZShmaWJlcixzaGFyZWRRdWV1ZSx1cGRhdGUsbGFuZSk7fX1mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsZmliZXIsbGFuZSl7dmFyIHVwZGF0ZVF1ZXVlPWZpYmVyLnVwZGF0ZVF1ZXVlO2lmKHVwZGF0ZVF1ZXVlPT09bnVsbCl7Ly8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbnJldHVybjt9dmFyIHNoYXJlZFF1ZXVlPXVwZGF0ZVF1ZXVlLnNoYXJlZDtpZihpc1RyYW5zaXRpb25MYW5lKGxhbmUpKXt2YXIgcXVldWVMYW5lcz1zaGFyZWRRdWV1ZS5sYW5lczsvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3Rcbi8vIGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoIHJlcHJlc2VudHNcbi8vIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2UgbWF5IGVudGFuZ2xlXG4vLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbi8vIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxucXVldWVMYW5lcz1pbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLHJvb3QucGVuZGluZ0xhbmVzKTsvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxudmFyIG5ld1F1ZXVlTGFuZXM9bWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLGxhbmUpO3NoYXJlZFF1ZXVlLmxhbmVzPW5ld1F1ZXVlTGFuZXM7Ly8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbi8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5tYXJrUm9vdEVudGFuZ2xlZChyb290LG5ld1F1ZXVlTGFuZXMpO319ZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLGNhcHR1cmVkVXBkYXRlKXsvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4vLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG52YXIgcXVldWU9d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7Ly8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cbnZhciBjdXJyZW50PXdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtpZihjdXJyZW50IT09bnVsbCl7dmFyIGN1cnJlbnRRdWV1ZT1jdXJyZW50LnVwZGF0ZVF1ZXVlO2lmKHF1ZXVlPT09Y3VycmVudFF1ZXVlKXsvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4vLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4vLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2Vcbi8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbnZhciBuZXdGaXJzdD1udWxsO3ZhciBuZXdMYXN0PW51bGw7dmFyIGZpcnN0QmFzZVVwZGF0ZT1xdWV1ZS5maXJzdEJhc2VVcGRhdGU7aWYoZmlyc3RCYXNlVXBkYXRlIT09bnVsbCl7Ly8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxudmFyIHVwZGF0ZT1maXJzdEJhc2VVcGRhdGU7ZG97dmFyIGNsb25lPXtldmVudFRpbWU6dXBkYXRlLmV2ZW50VGltZSxsYW5lOnVwZGF0ZS5sYW5lLHRhZzp1cGRhdGUudGFnLHBheWxvYWQ6dXBkYXRlLnBheWxvYWQsY2FsbGJhY2s6dXBkYXRlLmNhbGxiYWNrLG5leHQ6bnVsbH07aWYobmV3TGFzdD09PW51bGwpe25ld0ZpcnN0PW5ld0xhc3Q9Y2xvbmU7fWVsc2V7bmV3TGFzdC5uZXh0PWNsb25lO25ld0xhc3Q9Y2xvbmU7fXVwZGF0ZT11cGRhdGUubmV4dDt9d2hpbGUodXBkYXRlIT09bnVsbCk7Ly8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5pZihuZXdMYXN0PT09bnVsbCl7bmV3Rmlyc3Q9bmV3TGFzdD1jYXB0dXJlZFVwZGF0ZTt9ZWxzZXtuZXdMYXN0Lm5leHQ9Y2FwdHVyZWRVcGRhdGU7bmV3TGFzdD1jYXB0dXJlZFVwZGF0ZTt9fWVsc2V7Ly8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbm5ld0ZpcnN0PW5ld0xhc3Q9Y2FwdHVyZWRVcGRhdGU7fXF1ZXVlPXtiYXNlU3RhdGU6Y3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bmV3Rmlyc3QsbGFzdEJhc2VVcGRhdGU6bmV3TGFzdCxzaGFyZWQ6Y3VycmVudFF1ZXVlLnNoYXJlZCxlZmZlY3RzOmN1cnJlbnRRdWV1ZS5lZmZlY3RzfTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1xdWV1ZTtyZXR1cm47fX0vLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxudmFyIGxhc3RCYXNlVXBkYXRlPXF1ZXVlLmxhc3RCYXNlVXBkYXRlO2lmKGxhc3RCYXNlVXBkYXRlPT09bnVsbCl7cXVldWUuZmlyc3RCYXNlVXBkYXRlPWNhcHR1cmVkVXBkYXRlO31lbHNle2xhc3RCYXNlVXBkYXRlLm5leHQ9Y2FwdHVyZWRVcGRhdGU7fXF1ZXVlLmxhc3RCYXNlVXBkYXRlPWNhcHR1cmVkVXBkYXRlO31mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MscXVldWUsdXBkYXRlLHByZXZTdGF0ZSxuZXh0UHJvcHMsaW5zdGFuY2Upe3N3aXRjaCh1cGRhdGUudGFnKXtjYXNlIFJlcGxhY2VTdGF0ZTp7dmFyIHBheWxvYWQ9dXBkYXRlLnBheWxvYWQ7aWYodHlwZW9mIHBheWxvYWQ9PT0nZnVuY3Rpb24nKXsvLyBVcGRhdGVyIGZ1bmN0aW9uXG57ZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO312YXIgbmV4dFN0YXRlPXBheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7cGF5bG9hZC5jYWxsKGluc3RhbmNlLHByZXZTdGF0ZSxuZXh0UHJvcHMpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fWV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO31yZXR1cm4gbmV4dFN0YXRlO30vLyBTdGF0ZSBvYmplY3RcbnJldHVybiBwYXlsb2FkO31jYXNlIENhcHR1cmVVcGRhdGU6e3dvcmtJblByb2dyZXNzLmZsYWdzPXdvcmtJblByb2dyZXNzLmZsYWdzJn5TaG91bGRDYXB0dXJlfERpZENhcHR1cmU7fS8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5jYXNlIFVwZGF0ZVN0YXRlOnt2YXIgX3BheWxvYWQ9dXBkYXRlLnBheWxvYWQ7dmFyIHBhcnRpYWxTdGF0ZTtpZih0eXBlb2YgX3BheWxvYWQ9PT0nZnVuY3Rpb24nKXsvLyBVcGRhdGVyIGZ1bmN0aW9uXG57ZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO31wYXJ0aWFsU3RhdGU9X3BheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7X3BheWxvYWQuY2FsbChpbnN0YW5jZSxwcmV2U3RhdGUsbmV4dFByb3BzKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1leGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTt9fWVsc2V7Ly8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbnBhcnRpYWxTdGF0ZT1fcGF5bG9hZDt9aWYocGFydGlhbFN0YXRlPT09bnVsbHx8cGFydGlhbFN0YXRlPT09dW5kZWZpbmVkKXsvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxucmV0dXJuIHByZXZTdGF0ZTt9Ly8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbnJldHVybiBhc3NpZ24oe30scHJldlN0YXRlLHBhcnRpYWxTdGF0ZSk7fWNhc2UgRm9yY2VVcGRhdGU6e2hhc0ZvcmNlVXBkYXRlPXRydWU7cmV0dXJuIHByZXZTdGF0ZTt9fXJldHVybiBwcmV2U3RhdGU7fWZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyxwcm9wcyxpbnN0YW5jZSxyZW5kZXJMYW5lcyl7Ly8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxudmFyIHF1ZXVlPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO2hhc0ZvcmNlVXBkYXRlPWZhbHNlO3tjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU9cXVldWUuc2hhcmVkO312YXIgZmlyc3RCYXNlVXBkYXRlPXF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTt2YXIgbGFzdEJhc2VVcGRhdGU9cXVldWUubGFzdEJhc2VVcGRhdGU7Ly8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG52YXIgcGVuZGluZ1F1ZXVlPXF1ZXVlLnNoYXJlZC5wZW5kaW5nO2lmKHBlbmRpbmdRdWV1ZSE9PW51bGwpe3F1ZXVlLnNoYXJlZC5wZW5kaW5nPW51bGw7Ly8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuLy8gYW5kIGxhc3Qgc28gdGhhdCBpdCdzIG5vbi1jaXJjdWxhci5cbnZhciBsYXN0UGVuZGluZ1VwZGF0ZT1wZW5kaW5nUXVldWU7dmFyIGZpcnN0UGVuZGluZ1VwZGF0ZT1sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ9bnVsbDsvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcbmlmKGxhc3RCYXNlVXBkYXRlPT09bnVsbCl7Zmlyc3RCYXNlVXBkYXRlPWZpcnN0UGVuZGluZ1VwZGF0ZTt9ZWxzZXtsYXN0QmFzZVVwZGF0ZS5uZXh0PWZpcnN0UGVuZGluZ1VwZGF0ZTt9bGFzdEJhc2VVcGRhdGU9bGFzdFBlbmRpbmdVcGRhdGU7Ly8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4vLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbi8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG52YXIgY3VycmVudD13b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7aWYoY3VycmVudCE9PW51bGwpey8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbnZhciBjdXJyZW50UXVldWU9Y3VycmVudC51cGRhdGVRdWV1ZTt2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlPWN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtpZihjdXJyZW50TGFzdEJhc2VVcGRhdGUhPT1sYXN0QmFzZVVwZGF0ZSl7aWYoY3VycmVudExhc3RCYXNlVXBkYXRlPT09bnVsbCl7Y3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZT1maXJzdFBlbmRpbmdVcGRhdGU7fWVsc2V7Y3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQ9Zmlyc3RQZW5kaW5nVXBkYXRlO31jdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU9bGFzdFBlbmRpbmdVcGRhdGU7fX19Ly8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5pZihmaXJzdEJhc2VVcGRhdGUhPT1udWxsKXsvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG52YXIgbmV3U3RhdGU9cXVldWUuYmFzZVN0YXRlOy8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG4vLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cbnZhciBuZXdMYW5lcz1Ob0xhbmVzO3ZhciBuZXdCYXNlU3RhdGU9bnVsbDt2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlPW51bGw7dmFyIG5ld0xhc3RCYXNlVXBkYXRlPW51bGw7dmFyIHVwZGF0ZT1maXJzdEJhc2VVcGRhdGU7ZG97dmFyIHVwZGF0ZUxhbmU9dXBkYXRlLmxhbmU7dmFyIHVwZGF0ZUV2ZW50VGltZT11cGRhdGUuZXZlbnRUaW1lO2lmKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsdXBkYXRlTGFuZSkpey8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3Rcbi8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuLy8gdXBkYXRlL3N0YXRlLlxudmFyIGNsb25lPXtldmVudFRpbWU6dXBkYXRlRXZlbnRUaW1lLGxhbmU6dXBkYXRlTGFuZSx0YWc6dXBkYXRlLnRhZyxwYXlsb2FkOnVwZGF0ZS5wYXlsb2FkLGNhbGxiYWNrOnVwZGF0ZS5jYWxsYmFjayxuZXh0Om51bGx9O2lmKG5ld0xhc3RCYXNlVXBkYXRlPT09bnVsbCl7bmV3Rmlyc3RCYXNlVXBkYXRlPW5ld0xhc3RCYXNlVXBkYXRlPWNsb25lO25ld0Jhc2VTdGF0ZT1uZXdTdGF0ZTt9ZWxzZXtuZXdMYXN0QmFzZVVwZGF0ZT1uZXdMYXN0QmFzZVVwZGF0ZS5uZXh0PWNsb25lO30vLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5uZXdMYW5lcz1tZXJnZUxhbmVzKG5ld0xhbmVzLHVwZGF0ZUxhbmUpO31lbHNley8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuaWYobmV3TGFzdEJhc2VVcGRhdGUhPT1udWxsKXt2YXIgX2Nsb25lPXtldmVudFRpbWU6dXBkYXRlRXZlbnRUaW1lLC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4vLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4vLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG5sYW5lOk5vTGFuZSx0YWc6dXBkYXRlLnRhZyxwYXlsb2FkOnVwZGF0ZS5wYXlsb2FkLGNhbGxiYWNrOnVwZGF0ZS5jYWxsYmFjayxuZXh0Om51bGx9O25ld0xhc3RCYXNlVXBkYXRlPW5ld0xhc3RCYXNlVXBkYXRlLm5leHQ9X2Nsb25lO30vLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxubmV3U3RhdGU9Z2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLHF1ZXVlLHVwZGF0ZSxuZXdTdGF0ZSxwcm9wcyxpbnN0YW5jZSk7dmFyIGNhbGxiYWNrPXVwZGF0ZS5jYWxsYmFjaztpZihjYWxsYmFjayE9PW51bGwmJi8vIElmIHRoZSB1cGRhdGUgd2FzIGFscmVhZHkgY29tbWl0dGVkLCB3ZSBzaG91bGQgbm90IHF1ZXVlIGl0c1xuLy8gY2FsbGJhY2sgYWdhaW4uXG51cGRhdGUubGFuZSE9PU5vTGFuZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PUNhbGxiYWNrO3ZhciBlZmZlY3RzPXF1ZXVlLmVmZmVjdHM7aWYoZWZmZWN0cz09PW51bGwpe3F1ZXVlLmVmZmVjdHM9W3VwZGF0ZV07fWVsc2V7ZWZmZWN0cy5wdXNoKHVwZGF0ZSk7fX19dXBkYXRlPXVwZGF0ZS5uZXh0O2lmKHVwZGF0ZT09PW51bGwpe3BlbmRpbmdRdWV1ZT1xdWV1ZS5zaGFyZWQucGVuZGluZztpZihwZW5kaW5nUXVldWU9PT1udWxsKXticmVhazt9ZWxzZXsvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4vLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxudmFyIF9sYXN0UGVuZGluZ1VwZGF0ZT1wZW5kaW5nUXVldWU7Ly8gSW50ZW50aW9uYWxseSB1bnNvdW5kLiBQZW5kaW5nIHVwZGF0ZXMgZm9ybSBhIGNpcmN1bGFyIGxpc3QsIGJ1dCB3ZVxuLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG52YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZT1fbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtfbGFzdFBlbmRpbmdVcGRhdGUubmV4dD1udWxsO3VwZGF0ZT1fZmlyc3RQZW5kaW5nVXBkYXRlO3F1ZXVlLmxhc3RCYXNlVXBkYXRlPV9sYXN0UGVuZGluZ1VwZGF0ZTtxdWV1ZS5zaGFyZWQucGVuZGluZz1udWxsO319fXdoaWxlKHRydWUpO2lmKG5ld0xhc3RCYXNlVXBkYXRlPT09bnVsbCl7bmV3QmFzZVN0YXRlPW5ld1N0YXRlO31xdWV1ZS5iYXNlU3RhdGU9bmV3QmFzZVN0YXRlO3F1ZXVlLmZpcnN0QmFzZVVwZGF0ZT1uZXdGaXJzdEJhc2VVcGRhdGU7cXVldWUubGFzdEJhc2VVcGRhdGU9bmV3TGFzdEJhc2VVcGRhdGU7Ly8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcbi8vIGFyZSByZW1haW5pbmcuXG52YXIgbGFzdEludGVybGVhdmVkPXF1ZXVlLnNoYXJlZC5pbnRlcmxlYXZlZDtpZihsYXN0SW50ZXJsZWF2ZWQhPT1udWxsKXt2YXIgaW50ZXJsZWF2ZWQ9bGFzdEludGVybGVhdmVkO2Rve25ld0xhbmVzPW1lcmdlTGFuZXMobmV3TGFuZXMsaW50ZXJsZWF2ZWQubGFuZSk7aW50ZXJsZWF2ZWQ9aW50ZXJsZWF2ZWQubmV4dDt9d2hpbGUoaW50ZXJsZWF2ZWQhPT1sYXN0SW50ZXJsZWF2ZWQpO31lbHNlIGlmKGZpcnN0QmFzZVVwZGF0ZT09PW51bGwpey8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4vLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxucXVldWUuc2hhcmVkLmxhbmVzPU5vTGFuZXM7fS8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuLy8gVGhpcyBzaG91bGQgYmUgZmluZSBiZWNhdXNlIHRoZSBvbmx5IHR3byBvdGhlciB0aGluZ3MgdGhhdCBjb250cmlidXRlIHRvXG4vLyBleHBpcmF0aW9uIHRpbWUgYXJlIHByb3BzIGFuZCBjb250ZXh0LiBXZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgdGhlXG4vLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuLy8gZGVhbHQgd2l0aCB0aGUgcHJvcHMuIENvbnRleHQgaW4gY29tcG9uZW50cyB0aGF0IHNwZWNpZnlcbi8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB0cmlja3k7IGJ1dCB3ZSdsbCBoYXZlIHRvIGFjY291bnQgZm9yXG4vLyB0aGF0IHJlZ2FyZGxlc3MuXG5tYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1uZXdMYW5lczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO317Y3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlPW51bGw7fX1mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssY29udGV4dCl7aWYodHlwZW9mIGNhbGxiYWNrIT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCAnKyhcInJlY2VpdmVkOiBcIitjYWxsYmFjaykpO31jYWxsYmFjay5jYWxsKGNvbnRleHQpO31mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpe2hhc0ZvcmNlVXBkYXRlPWZhbHNlO31mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCl7cmV0dXJuIGhhc0ZvcmNlVXBkYXRlO31mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssZmluaXNoZWRRdWV1ZSxpbnN0YW5jZSl7Ly8gQ29tbWl0IHRoZSBlZmZlY3RzXG52YXIgZWZmZWN0cz1maW5pc2hlZFF1ZXVlLmVmZmVjdHM7ZmluaXNoZWRRdWV1ZS5lZmZlY3RzPW51bGw7aWYoZWZmZWN0cyE9PW51bGwpe2Zvcih2YXIgaT0wO2k8ZWZmZWN0cy5sZW5ndGg7aSsrKXt2YXIgZWZmZWN0PWVmZmVjdHNbaV07dmFyIGNhbGxiYWNrPWVmZmVjdC5jYWxsYmFjaztpZihjYWxsYmFjayE9PW51bGwpe2VmZmVjdC5jYWxsYmFjaz1udWxsO2NhbGxDYWxsYmFjayhjYWxsYmFjayxpbnN0YW5jZSk7fX19fXZhciBOT19DT05URVhUPXt9O3ZhciBjb250ZXh0U3RhY2tDdXJzb3IkMT1jcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7dmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yPWNyZWF0ZUN1cnNvcihOT19DT05URVhUKTt2YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3I9Y3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO2Z1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKXtpZihjPT09Tk9fQ09OVEVYVCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnKydpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXJldHVybiBjO31mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpe3ZhciByb290SW5zdGFuY2U9cmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO3JldHVybiByb290SW5zdGFuY2U7fWZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLG5leHRSb290SW5zdGFuY2Upey8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbnB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsbmV4dFJvb3RJbnN0YW5jZSxmaWJlcik7Ly8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxucHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvcixmaWJlcixmaWJlcik7Ly8gRmluYWxseSwgd2UgbmVlZCB0byBwdXNoIHRoZSBob3N0IGNvbnRleHQgdG8gdGhlIHN0YWNrLlxuLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2Vcbi8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG4vLyB3aGV0aGVyIGdldFJvb3RIb3N0Q29udGV4dCgpIHRocm93cyBzb21ld2hlcmUgaW4gcmVuZGVyZXIgY29kZSBvciBub3QuXG4vLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5wdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLE5PX0NPTlRFWFQsZmliZXIpO3ZhciBuZXh0Um9vdENvbnRleHQ9Z2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOy8vIE5vdyB0aGF0IHdlIGtub3cgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHRocm93LCByZXBsYWNlIGl0LlxucG9wKGNvbnRleHRTdGFja0N1cnNvciQxLGZpYmVyKTtwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLG5leHRSb290Q29udGV4dCxmaWJlcik7fWZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpe3BvcChjb250ZXh0U3RhY2tDdXJzb3IkMSxmaWJlcik7cG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLGZpYmVyKTtwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsZmliZXIpO31mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpe3ZhciBjb250ZXh0PXJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtyZXR1cm4gY29udGV4dDt9ZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKXt2YXIgcm9vdEluc3RhbmNlPXJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTt2YXIgY29udGV4dD1yZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7dmFyIG5leHRDb250ZXh0PWdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCxmaWJlci50eXBlKTsvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbmlmKGNvbnRleHQ9PT1uZXh0Q29udGV4dCl7cmV0dXJuO30vLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5wdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLGZpYmVyLGZpYmVyKTtwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLG5leHRDb250ZXh0LGZpYmVyKTt9ZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpey8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbi8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuaWYoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCE9PWZpYmVyKXtyZXR1cm47fXBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSxmaWJlcik7cG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLGZpYmVyKTt9dmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQ9MDsvLyBUaGUgU3VzcGVuc2UgQ29udGV4dCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhlIGxvd2VyIGJpdHMgaXNcbi8vIGluaGVyaXRlZCBkZWVwbHkgZG93biB0aGUgc3VidHJlZS4gVGhlIHVwcGVyIGJpdHMgb25seSBhZmZlY3Rcbi8vIHRoaXMgaW1tZWRpYXRlIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBnZXRzIHJlc2V0IGVhY2ggbmV3XG4vLyBib3VuZGFyeSBvciBzdXNwZW5zZSBsaXN0LlxudmFyIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrPTE7Ly8gU3VidHJlZSBGbGFnczpcbi8vIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2Ygb3VyIHBhcmVudCBTdXNwZW5zZVxuLy8gYm91bmRhcmllcyBpcyBub3QgY3VycmVudGx5IHNob3dpbmcgdmlzaWJsZSBtYWluIGNvbnRlbnQuXG4vLyBFaXRoZXIgYmVjYXVzZSBpdCBpcyBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBvciBpcyBub3QgbW91bnRlZCBhdCBhbGwuXG4vLyBXZSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGRlc2lyYWJsZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgYXRcbi8vIHRoZSBwYXJlbnQuIElmIG5vdCwgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIHRyaWdnZXIgdW5kZXNpcmFibGUgYm91bmRhcmllc1xuLy8gYW5kL29yIHN1c3BlbmQgdGhlIGNvbW1pdCB0byBhdm9pZCBoaWRpbmcgdGhlIHBhcmVudCBjb250ZW50LlxudmFyIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dD0xOy8vIFNoYWxsb3cgRmxhZ3M6XG4vLyBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgY2FuIGJlIHVzZWQgYnkgU3VzcGVuc2VMaXN0IHRvIGZvcmNlIG5ld2x5IGFkZGVkXG4vLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG52YXIgRm9yY2VTdXNwZW5zZUZhbGxiYWNrPTI7dmFyIHN1c3BlbnNlU3RhY2tDdXJzb3I9Y3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO2Z1bmN0aW9uIGhhc1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LGZsYWcpe3JldHVybihwYXJlbnRDb250ZXh0JmZsYWcpIT09MDt9ZnVuY3Rpb24gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCl7cmV0dXJuIHBhcmVudENvbnRleHQmU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7fWZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCxzaGFsbG93Q29udGV4dCl7cmV0dXJuIHBhcmVudENvbnRleHQmU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2t8c2hhbGxvd0NvbnRleHQ7fWZ1bmN0aW9uIGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCxzdWJ0cmVlQ29udGV4dCl7cmV0dXJuIHBhcmVudENvbnRleHR8c3VidHJlZUNvbnRleHQ7fWZ1bmN0aW9uIHB1c2hTdXNwZW5zZUNvbnRleHQoZmliZXIsbmV3Q29udGV4dCl7cHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLG5ld0NvbnRleHQsZmliZXIpO31mdW5jdGlvbiBwb3BTdXNwZW5zZUNvbnRleHQoZmliZXIpe3BvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLGZpYmVyKTt9ZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzLGhhc0ludmlzaWJsZVBhcmVudCl7Ly8gSWYgaXQgd2FzIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHRoYXQganVzdCBzdXNwZW5kZWQsIGNhcHR1cmUgYW5kIHJlbmRlciB0aGVcbi8vIGZhbGxiYWNrLiBPdGhlcndpc2UsIGRvbid0IGNhcHR1cmUgYW5kIGJ1YmJsZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbnZhciBuZXh0U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihuZXh0U3RhdGUhPT1udWxsKXtpZihuZXh0U3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpey8vIEEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbHdheXMgY2FwdHVyZXMuXG5yZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO312YXIgcHJvcHM9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczsvLyBSZWd1bGFyIGJvdW5kYXJpZXMgYWx3YXlzIGNhcHR1cmUuXG57cmV0dXJuIHRydWU7fS8vIElmIGl0J3MgYSBib3VuZGFyeSB3ZSBzaG91bGQgYXZvaWQsIHRoZW4gd2UgcHJlZmVyIHRvIGJ1YmJsZSB1cCB0byB0aGVcbn1mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KXt2YXIgbm9kZT1yb3c7d2hpbGUobm9kZSE9PW51bGwpe2lmKG5vZGUudGFnPT09U3VzcGVuc2VDb21wb25lbnQpe3ZhciBzdGF0ZT1ub2RlLm1lbW9pemVkU3RhdGU7aWYoc3RhdGUhPT1udWxsKXt2YXIgZGVoeWRyYXRlZD1zdGF0ZS5kZWh5ZHJhdGVkO2lmKGRlaHlkcmF0ZWQ9PT1udWxsfHxpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKGRlaHlkcmF0ZWQpfHxpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhkZWh5ZHJhdGVkKSl7cmV0dXJuIG5vZGU7fX19ZWxzZSBpZihub2RlLnRhZz09PVN1c3BlbnNlTGlzdENvbXBvbmVudCYmLy8gcmV2ZWFsT3JkZXIgdW5kZWZpbmVkIGNhbid0IGJlIHRydXN0ZWQgYmVjYXVzZSBpdCBkb24ndFxuLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG5ub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIhPT11bmRlZmluZWQpe3ZhciBkaWRTdXNwZW5kPShub2RlLmZsYWdzJkRpZENhcHR1cmUpIT09Tm9GbGFncztpZihkaWRTdXNwZW5kKXtyZXR1cm4gbm9kZTt9fWVsc2UgaWYobm9kZS5jaGlsZCE9PW51bGwpe25vZGUuY2hpbGQucmV0dXJuPW5vZGU7bm9kZT1ub2RlLmNoaWxkO2NvbnRpbnVlO31pZihub2RlPT09cm93KXtyZXR1cm4gbnVsbDt9d2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxub2RlLnJldHVybj09PXJvdyl7cmV0dXJuIG51bGw7fW5vZGU9bm9kZS5yZXR1cm47fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7fXJldHVybiBudWxsO312YXIgTm9GbGFncyQxPS8qICAgKi8wOy8vIFJlcHJlc2VudHMgd2hldGhlciBlZmZlY3Qgc2hvdWxkIGZpcmUuXG52YXIgSGFzRWZmZWN0PS8qICovMTsvLyBSZXByZXNlbnRzIHRoZSBwaGFzZSBpbiB3aGljaCB0aGUgZWZmZWN0IChub3QgdGhlIGNsZWFuLXVwKSBmaXJlcy5cbnZhciBJbnNlcnRpb249LyogICovMjt2YXIgTGF5b3V0PS8qICAgICovNDt2YXIgUGFzc2l2ZSQxPS8qICAgKi84Oy8vIGFuZCBzaG91bGQgYmUgcmVzZXQgYmVmb3JlIHN0YXJ0aW5nIGEgbmV3IHJlbmRlci5cbi8vIFRoaXMgdHJhY2tzIHdoaWNoIG11dGFibGUgc291cmNlcyBuZWVkIHRvIGJlIHJlc2V0IGFmdGVyIGEgcmVuZGVyLlxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcz1bXTtmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKXtmb3IodmFyIGk9MDtpPHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7aSsrKXt2YXIgbXV0YWJsZVNvdXJjZT13b3JrSW5Qcm9ncmVzc1NvdXJjZXNbaV07e211dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk9bnVsbDt9fXdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg9MDt9Ly8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHZlcnNpb24gdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZyBtYXRjaGVzIHRoZSBvbmVcbi8vIHRoYXQgaXMgZXZlbnR1YWxseSByZWFkIGR1cmluZyBoeWRyYXRpb24uXG4vLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LG11dGFibGVTb3VyY2Upe3ZhciBnZXRWZXJzaW9uPW11dGFibGVTb3VyY2UuX2dldFZlcnNpb247dmFyIHZlcnNpb249Z2V0VmVyc2lvbihtdXRhYmxlU291cmNlLl9zb3VyY2UpOy8vIFRPRE8gQ2xlYXIgdGhpcyBkYXRhIG9uY2UgYWxsIHBlbmRpbmcgaHlkcmF0aW9uIHdvcmsgaXMgZmluaXNoZWQuXG4vLyBSZXRhaW5pbmcgaXQgZm9yZXZlciBtYXkgaW50ZXJmZXJlIHdpdGggR0MuXG5pZihyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9PW51bGwpe3Jvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT1bbXV0YWJsZVNvdXJjZSx2ZXJzaW9uXTt9ZWxzZXtyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChtdXRhYmxlU291cmNlLHZlcnNpb24pO319dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7dmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudDt2YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q7e2RpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudD1uZXcgU2V0KCk7fS8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcz1Ob0xhbmVzOy8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMT1udWxsOy8vIEhvb2tzIGFyZSBzdG9yZWQgYXMgYSBsaW5rZWQgbGlzdCBvbiB0aGUgZmliZXIncyBtZW1vaXplZFN0YXRlIGZpZWxkLiBUaGVcbi8vIGN1cnJlbnQgaG9vayBsaXN0IGlzIHRoZSBsaXN0IHRoYXQgYmVsb25ncyB0byB0aGUgY3VycmVudCBmaWJlci4gVGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGhvb2sgbGlzdCBpcyBhIG5ldyBsaXN0IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG52YXIgY3VycmVudEhvb2s9bnVsbDt2YXIgd29ya0luUHJvZ3Jlc3NIb29rPW51bGw7Ly8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBhdCBhbnkgcG9pbnQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXNcbi8vIGRvZXMgbm90IGdldCByZXNldCBpZiB3ZSBkbyBhbm90aGVyIHJlbmRlciBwYXNzOyBvbmx5IHdoZW4gd2UncmUgY29tcGxldGVseVxuLy8gZmluaXNoZWQgZXZhbHVhdGluZyB0aGlzIGNvbXBvbmVudC4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gd2Uga25vd1xuLy8gd2hldGhlciB3ZSBuZWVkIHRvIGNsZWFyIHJlbmRlciBwaGFzZSB1cGRhdGVzIGFmdGVyIGEgdGhyb3cuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZT1mYWxzZTsvLyBXaGVyZSBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbmx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcy4gVGhpc1xuLy8gZ2V0cyByZXNldCBhZnRlciBlYWNoIGF0dGVtcHQuXG4vLyBUT0RPOiBNYXliZSB0aGVyZSdzIHNvbWUgd2F5IHRvIGNvbnNvbGlkYXRlIHRoaXMgd2l0aFxuLy8gYGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVgLiBPciB3aXRoIGBudW1iZXJPZlJlUmVuZGVyc2AuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzPWZhbHNlOy8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50LlxudmFyIGxvY2FsSWRDb3VudGVyPTA7Ly8gVXNlZCBmb3IgaWRzIHRoYXQgYXJlIGdlbmVyYXRlZCBjb21wbGV0ZWx5IGNsaWVudC1zaWRlIChpLmUuIG5vdCBkdXJpbmdcbi8vIGh5ZHJhdGlvbikuIFRoaXMgY291bnRlciBpcyBnbG9iYWwsIHNvIGNsaWVudCBpZHMgYXJlIG5vdCBzdGFibGUgYWNyb3NzXG4vLyByZW5kZXIgYXR0ZW1wdHMuXG52YXIgZ2xvYmFsQ2xpZW50SWRDb3VudGVyPTA7dmFyIFJFX1JFTkRFUl9MSU1JVD0yNTsvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcbnZhciBjdXJyZW50SG9va05hbWVJbkRldj1udWxsOy8vIEluIERFViwgdGhpcyBsaXN0IGVuc3VyZXMgdGhhdCBob29rcyBhcmUgY2FsbGVkIGluIHRoZSBzYW1lIG9yZGVyIGJldHdlZW4gcmVuZGVycy5cbi8vIFRoZSBsaXN0IHN0b3JlcyB0aGUgb3JkZXIgb2YgaG9va3MgdXNlZCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIChtb3VudCkuXG4vLyBTdWJzZXF1ZW50IHJlbmRlcnMgKHVwZGF0ZXMpIHJlZmVyZW5jZSB0aGlzIGxpc3QuXG52YXIgaG9va1R5cGVzRGV2PW51bGw7dmFyIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2PS0xOy8vIEluIERFViwgdGhpcyB0cmFja3Mgd2hldGhlciBjdXJyZW50bHkgcmVuZGVyaW5nIGNvbXBvbmVudCBuZWVkcyB0byBpZ25vcmVcbi8vIHRoZSBkZXBlbmRlbmNpZXMgZm9yIEhvb2tzIHRoYXQgbmVlZCB0aGVtIChlLmcuIHVzZUVmZmVjdCBvciB1c2VNZW1vKS5cbi8vIFdoZW4gdHJ1ZSwgc3VjaCBIb29rcyB3aWxsIGFsd2F5cyBiZSBcInJlbW91bnRlZFwiLiBPbmx5IHVzZWQgZHVyaW5nIGhvdCByZWxvYWQuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXM9ZmFsc2U7ZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKXt7dmFyIGhvb2tOYW1lPWN1cnJlbnRIb29rTmFtZUluRGV2O2lmKGhvb2tUeXBlc0Rldj09PW51bGwpe2hvb2tUeXBlc0Rldj1baG9va05hbWVdO31lbHNle2hvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTt9fX1mdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKXt7dmFyIGhvb2tOYW1lPWN1cnJlbnRIb29rTmFtZUluRGV2O2lmKGhvb2tUeXBlc0RldiE9PW51bGwpe2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2Kys7aWYoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSE9PWhvb2tOYW1lKXt3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihob29rTmFtZSk7fX19fWZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpe3tpZihkZXBzIT09dW5kZWZpbmVkJiZkZXBzIT09bnVsbCYmIWlzQXJyYXkoZGVwcykpey8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4vLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbmVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnKydzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicsY3VycmVudEhvb2tOYW1lSW5EZXYsdHlwZW9mIGRlcHMpO319fWZ1bmN0aW9uIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGN1cnJlbnRIb29rTmFtZSl7e3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7aWYoIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpe2RpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7aWYoaG9va1R5cGVzRGV2IT09bnVsbCl7dmFyIHRhYmxlPScnO3ZhciBzZWNvbmRDb2x1bW5TdGFydD0zMDtmb3IodmFyIGk9MDtpPD1ob29rVHlwZXNVcGRhdGVJbmRleERldjtpKyspe3ZhciBvbGRIb29rTmFtZT1ob29rVHlwZXNEZXZbaV07dmFyIG5ld0hvb2tOYW1lPWk9PT1ob29rVHlwZXNVcGRhdGVJbmRleERldj9jdXJyZW50SG9va05hbWU6b2xkSG9va05hbWU7dmFyIHJvdz1pKzErXCIuIFwiK29sZEhvb2tOYW1lOy8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbi8vIGxvbCBAIElFIG5vdCBzdXBwb3J0aW5nIFN0cmluZyNyZXBlYXRcbndoaWxlKHJvdy5sZW5ndGg8c2Vjb25kQ29sdW1uU3RhcnQpe3Jvdys9JyAnO31yb3crPW5ld0hvb2tOYW1lKydcXG4nO3RhYmxlKz1yb3c7fWVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJysnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJysnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4nKycgICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbicrJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicrJyVzJysnICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJyxjb21wb25lbnROYW1lLHRhYmxlKTt9fX19ZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCl7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJysnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJysnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJysnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicrJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nKydTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTt9ZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLHByZXZEZXBzKXt7aWYoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpey8vIE9ubHkgdHJ1ZSB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGJlaW5nIGhvdCByZWxvYWRlZC5cbnJldHVybiBmYWxzZTt9fWlmKHByZXZEZXBzPT09bnVsbCl7e2Vycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJysndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnKydpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLGN1cnJlbnRIb29rTmFtZUluRGV2KTt9cmV0dXJuIGZhbHNlO317Ly8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4vLyBwYXNzZWQgaW5saW5lLlxuaWYobmV4dERlcHMubGVuZ3RoIT09cHJldkRlcHMubGVuZ3RoKXtlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJysnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nKydQcmV2aW91czogJXNcXG4nKydJbmNvbWluZzogJXMnLGN1cnJlbnRIb29rTmFtZUluRGV2LFwiW1wiK3ByZXZEZXBzLmpvaW4oJywgJykrXCJdXCIsXCJbXCIrbmV4dERlcHMuam9pbignLCAnKStcIl1cIik7fX1mb3IodmFyIGk9MDtpPHByZXZEZXBzLmxlbmd0aCYmaTxuZXh0RGVwcy5sZW5ndGg7aSsrKXtpZihvYmplY3RJcyhuZXh0RGVwc1tpXSxwcmV2RGVwc1tpXSkpe2NvbnRpbnVlO31yZXR1cm4gZmFsc2U7fXJldHVybiB0cnVlO31mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscHJvcHMsc2Vjb25kQXJnLG5leHRSZW5kZXJMYW5lcyl7cmVuZGVyTGFuZXM9bmV4dFJlbmRlckxhbmVzO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE9d29ya0luUHJvZ3Jlc3M7e2hvb2tUeXBlc0Rldj1jdXJyZW50IT09bnVsbD9jdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlczpudWxsO2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2PS0xOy8vIFVzZWQgZm9yIGhvdCByZWxvYWRpbmc6XG5pZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcz1jdXJyZW50IT09bnVsbCYmY3VycmVudC50eXBlIT09d29ya0luUHJvZ3Jlc3MudHlwZTt9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPW51bGw7d29ya0luUHJvZ3Jlc3MubGFuZXM9Tm9MYW5lczsvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuLy8gY3VycmVudEhvb2sgPSBudWxsO1xuLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbi8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbi8vIGxvY2FsSWRDb3VudGVyID0gMDtcbi8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbi8vIEN1cnJlbnRseSB3ZSB3aWxsIGlkZW50aWZ5IHRoZSB1cGRhdGUgcmVuZGVyIGFzIGEgbW91bnQgYmVjYXVzZSBtZW1vaXplZFN0YXRlID09PSBudWxsLlxuLy8gVGhpcyBpcyB0cmlja3kgYmVjYXVzZSBpdCdzIHZhbGlkIGZvciBjZXJ0YWluIHR5cGVzIG9mIGNvbXBvbmVudHMgKGUuZy4gUmVhY3QubGF6eSlcbi8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4vLyBOb24tc3RhdGVmdWwgaG9va3MgKGUuZy4gY29udGV4dCkgZG9uJ3QgZ2V0IGFkZGVkIHRvIG1lbW9pemVkU3RhdGUsXG4vLyBzbyBtZW1vaXplZFN0YXRlIHdvdWxkIGJlIG51bGwgZHVyaW5nIHVwZGF0ZXMgYW5kIG1vdW50cy5cbntpZihjdXJyZW50IT09bnVsbCYmY3VycmVudC5tZW1vaXplZFN0YXRlIT09bnVsbCl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt9ZWxzZSBpZihob29rVHlwZXNEZXYhPT1udWxsKXsvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4vLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4vLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbi8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG5SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1Ib29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWO31lbHNle1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt9fXZhciBjaGlsZHJlbj1Db21wb25lbnQocHJvcHMsc2Vjb25kQXJnKTsvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlXG5pZihkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3Mpey8vIEtlZXAgcmVuZGVyaW5nIGluIGEgbG9vcCBmb3IgYXMgbG9uZyBhcyByZW5kZXIgcGhhc2UgdXBkYXRlcyBjb250aW51ZSB0b1xuLy8gYmUgc2NoZWR1bGVkLiBVc2UgYSBjb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnM9MDtkb3tkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3M9ZmFsc2U7bG9jYWxJZENvdW50ZXI9MDtpZihudW1iZXJPZlJlUmVuZGVycz49UkVfUkVOREVSX0xJTUlUKXt0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCAnKydhbiBpbmZpbml0ZSBsb29wLicpO31udW1iZXJPZlJlUmVuZGVycys9MTt7Ly8gRXZlbiB3aGVuIGhvdCByZWxvYWRpbmcsIGFsbG93IGRlcGVuZGVuY2llcyB0byBzdGFiaWxpemVcbi8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXM9ZmFsc2U7fS8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5jdXJyZW50SG9vaz1udWxsO3dvcmtJblByb2dyZXNzSG9vaz1udWxsO3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPW51bGw7ey8vIEFsc28gdmFsaWRhdGUgaG9vayBvcmRlciBmb3IgY2FzY2FkaW5nIHVwZGF0ZXMuXG5ob29rVHlwZXNVcGRhdGVJbmRleERldj0tMTt9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO2NoaWxkcmVuPUNvbXBvbmVudChwcm9wcyxzZWNvbmRBcmcpO313aGlsZShkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO30vLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4vLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1Db250ZXh0T25seURpc3BhdGNoZXI7e3dvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcz1ob29rVHlwZXNEZXY7fS8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuLy8gaG9va1R5cGVzRGV2IGNvdWxkIGNhdGNoIG1vcmUgY2FzZXMgKGUuZy4gY29udGV4dCkgYnV0IG9ubHkgaW4gREVWIGJ1bmRsZXMuXG52YXIgZGlkUmVuZGVyVG9vRmV3SG9va3M9Y3VycmVudEhvb2shPT1udWxsJiZjdXJyZW50SG9vay5uZXh0IT09bnVsbDtyZW5kZXJMYW5lcz1Ob0xhbmVzO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE9bnVsbDtjdXJyZW50SG9vaz1udWxsO3dvcmtJblByb2dyZXNzSG9vaz1udWxsO3tjdXJyZW50SG9va05hbWVJbkRldj1udWxsO2hvb2tUeXBlc0Rldj1udWxsO2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2PS0xOy8vIENvbmZpcm0gdGhhdCBhIHN0YXRpYyBmbGFnIHdhcyBub3QgYWRkZWQgb3IgcmVtb3ZlZCBzaW5jZSB0aGUgbGFzdFxuLy8gcmVuZGVyLiBJZiB0aGlzIGZpcmVzLCBpdCBzdWdnZXN0cyB0aGF0IHdlIGluY29ycmVjdGx5IHJlc2V0IHRoZSBzdGF0aWNcbi8vIGZsYWdzIGluIHNvbWUgb3RoZXIgcGFydCBvZiB0aGUgY29kZWJhc2UuIFRoaXMgaGFzIGhhcHBlbmVkIGJlZm9yZSwgZm9yXG4vLyBleGFtcGxlLCBpbiB0aGUgU3VzcGVuc2VMaXN0IGltcGxlbWVudGF0aW9uLlxuaWYoY3VycmVudCE9PW51bGwmJihjdXJyZW50LmZsYWdzJlN0YXRpY01hc2spIT09KHdvcmtJblByb2dyZXNzLmZsYWdzJlN0YXRpY01hc2spJiYvLyBEaXNhYmxlIHRoaXMgd2FybmluZyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBsZWdhY3kgU3VzcGVuc2UgaXMgd2VpcmRcbi8vIGFuZCBjcmVhdGVzIGZhbHNlIHBvc2l0aXZlcy4gVG8gbWFrZSB0aGlzIHdvcmsgaW4gbGVnYWN5IG1vZGUsIHdlJ2Rcbi8vIG5lZWQgdG8gbWFyayBmaWJlcnMgdGhhdCBjb21taXQgaW4gYW4gaW5jb21wbGV0ZSBzdGF0ZSwgc29tZWhvdy4gRm9yXG4vLyBub3cgSSdsbCBkaXNhYmxlIHRoZSB3YXJuaW5nIHRoYXQgbW9zdCBvZiB0aGUgYnVncyB0aGF0IHdvdWxkIHRyaWdnZXJcbi8vIGl0IGFyZSBlaXRoZXIgZXhjbHVzaXZlIHRvIGNvbmN1cnJlbnQgbW9kZSBvciBleGlzdCBpbiBib3RoLlxuKGN1cnJlbnQubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUpe2Vycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSAnKydub3RpZnkgdGhlIFJlYWN0IHRlYW0uJyk7fX1kaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlPWZhbHNlOy8vIFRoaXMgaXMgcmVzZXQgYnkgY2hlY2tEaWRSZW5kZXJJZEhvb2tcbi8vIGxvY2FsSWRDb3VudGVyID0gMDtcbmlmKGRpZFJlbmRlclRvb0Zld0hvb2tzKXt0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsICcrJ2Vhcmx5IHJldHVybiBzdGF0ZW1lbnQuJyk7fXJldHVybiBjaGlsZHJlbjt9ZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKXsvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgcmVuZGVyV2l0aEhvb2tzIGNhbGwuXG4vLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIHJlbmRlcldpdGhIb29rczsgaXQncyBvbmx5IGFcbi8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxudmFyIGRpZFJlbmRlcklkSG9vaz1sb2NhbElkQ291bnRlciE9PTA7bG9jYWxJZENvdW50ZXI9MDtyZXR1cm4gZGlkUmVuZGVySWRIb29rO31mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxsYW5lcyl7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9Y3VycmVudC51cGRhdGVRdWV1ZTsvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG4vLyBjb21wbGV0ZSBwaGFzZSAoYnViYmxlUHJvcGVydGllcykuXG5pZigod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RFZmZlY3RzTW9kZSkhPT1Ob01vZGUpe3dvcmtJblByb2dyZXNzLmZsYWdzJj1+KE1vdW50UGFzc2l2ZURldnxNb3VudExheW91dERldnxQYXNzaXZlfFVwZGF0ZSk7fWVsc2V7d29ya0luUHJvZ3Jlc3MuZmxhZ3MmPX4oUGFzc2l2ZXxVcGRhdGUpO31jdXJyZW50LmxhbmVzPXJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsbGFuZXMpO31mdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpey8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbi8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cblJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUNvbnRleHRPbmx5RGlzcGF0Y2hlcjtpZihkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKXsvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbi8vIHBoYXNlLCB3aGljaCB3ZSBhcmUgbm93IGFib3J0aW5nLiBSZW1vdmUgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWVzIHNvXG4vLyB0aGV5IGRvIG5vdCBwZXJzaXN0IHRvIHRoZSBuZXh0IHJlbmRlci4gRG8gbm90IHJlbW92ZSB1cGRhdGVzIGZyb20gaG9va3Ncbi8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4vL1xuLy8gT25seSByZXNldCB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZSBpZiBpdCBoYXMgYSBjbG9uZS4gSWYgaXQgZG9lc1xuLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuLy8gc2NoZWR1bGVkIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSByZW5kZXIgcGhhc2UuXG52YXIgaG9vaz1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7d2hpbGUoaG9vayE9PW51bGwpe3ZhciBxdWV1ZT1ob29rLnF1ZXVlO2lmKHF1ZXVlIT09bnVsbCl7cXVldWUucGVuZGluZz1udWxsO31ob29rPWhvb2submV4dDt9ZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZT1mYWxzZTt9cmVuZGVyTGFuZXM9Tm9MYW5lcztjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxPW51bGw7Y3VycmVudEhvb2s9bnVsbDt3b3JrSW5Qcm9ncmVzc0hvb2s9bnVsbDt7aG9va1R5cGVzRGV2PW51bGw7aG9va1R5cGVzVXBkYXRlSW5kZXhEZXY9LTE7Y3VycmVudEhvb2tOYW1lSW5EZXY9bnVsbDtpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlPWZhbHNlO31kaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3M9ZmFsc2U7bG9jYWxJZENvdW50ZXI9MDt9ZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKXt2YXIgaG9vaz17bWVtb2l6ZWRTdGF0ZTpudWxsLGJhc2VTdGF0ZTpudWxsLGJhc2VRdWV1ZTpudWxsLHF1ZXVlOm51bGwsbmV4dDpudWxsfTtpZih3b3JrSW5Qcm9ncmVzc0hvb2s9PT1udWxsKXsvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG5jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU9d29ya0luUHJvZ3Jlc3NIb29rPWhvb2s7fWVsc2V7Ly8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbndvcmtJblByb2dyZXNzSG9vaz13b3JrSW5Qcm9ncmVzc0hvb2submV4dD1ob29rO31yZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO31mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKXsvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBmb3IgdXBkYXRlcyBhbmQgZm9yIHJlLXJlbmRlcnMgdHJpZ2dlcmVkIGJ5IGFcbi8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuLy8gY2xvbmUsIG9yIGEgd29yay1pbi1wcm9ncmVzcyBob29rIGZyb20gYSBwcmV2aW91cyByZW5kZXIgcGFzcyB0aGF0IHdlIGNhblxuLy8gdXNlIGFzIGEgYmFzZS4gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBiYXNlIGxpc3QsIHdlIG11c3Qgc3dpdGNoIHRvXG4vLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG52YXIgbmV4dEN1cnJlbnRIb29rO2lmKGN1cnJlbnRIb29rPT09bnVsbCl7dmFyIGN1cnJlbnQ9Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7aWYoY3VycmVudCE9PW51bGwpe25leHRDdXJyZW50SG9vaz1jdXJyZW50Lm1lbW9pemVkU3RhdGU7fWVsc2V7bmV4dEN1cnJlbnRIb29rPW51bGw7fX1lbHNle25leHRDdXJyZW50SG9vaz1jdXJyZW50SG9vay5uZXh0O312YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztpZih3b3JrSW5Qcm9ncmVzc0hvb2s9PT1udWxsKXtuZXh0V29ya0luUHJvZ3Jlc3NIb29rPWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTt9ZWxzZXtuZXh0V29ya0luUHJvZ3Jlc3NIb29rPXdvcmtJblByb2dyZXNzSG9vay5uZXh0O31pZihuZXh0V29ya0luUHJvZ3Jlc3NIb29rIT09bnVsbCl7Ly8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG53b3JrSW5Qcm9ncmVzc0hvb2s9bmV4dFdvcmtJblByb2dyZXNzSG9vaztuZXh0V29ya0luUHJvZ3Jlc3NIb29rPXdvcmtJblByb2dyZXNzSG9vay5uZXh0O2N1cnJlbnRIb29rPW5leHRDdXJyZW50SG9vazt9ZWxzZXsvLyBDbG9uZSBmcm9tIHRoZSBjdXJyZW50IGhvb2suXG5pZihuZXh0Q3VycmVudEhvb2s9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTt9Y3VycmVudEhvb2s9bmV4dEN1cnJlbnRIb29rO3ZhciBuZXdIb29rPXttZW1vaXplZFN0YXRlOmN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsYmFzZVN0YXRlOmN1cnJlbnRIb29rLmJhc2VTdGF0ZSxiYXNlUXVldWU6Y3VycmVudEhvb2suYmFzZVF1ZXVlLHF1ZXVlOmN1cnJlbnRIb29rLnF1ZXVlLG5leHQ6bnVsbH07aWYod29ya0luUHJvZ3Jlc3NIb29rPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdC5cbmN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZT13b3JrSW5Qcm9ncmVzc0hvb2s9bmV3SG9vazt9ZWxzZXsvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbndvcmtJblByb2dyZXNzSG9vaz13b3JrSW5Qcm9ncmVzc0hvb2submV4dD1uZXdIb29rO319cmV0dXJuIHdvcmtJblByb2dyZXNzSG9vazt9ZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpe3JldHVybntsYXN0RWZmZWN0Om51bGwsc3RvcmVzOm51bGx9O31mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSxhY3Rpb24pey8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG5yZXR1cm4gdHlwZW9mIGFjdGlvbj09PSdmdW5jdGlvbic/YWN0aW9uKHN0YXRlKTphY3Rpb247fWZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgaW5pdGlhbFN0YXRlO2lmKGluaXQhPT11bmRlZmluZWQpe2luaXRpYWxTdGF0ZT1pbml0KGluaXRpYWxBcmcpO31lbHNle2luaXRpYWxTdGF0ZT1pbml0aWFsQXJnO31ob29rLm1lbW9pemVkU3RhdGU9aG9vay5iYXNlU3RhdGU9aW5pdGlhbFN0YXRlO3ZhciBxdWV1ZT17cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6Tm9MYW5lcyxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6cmVkdWNlcixsYXN0UmVuZGVyZWRTdGF0ZTppbml0aWFsU3RhdGV9O2hvb2sucXVldWU9cXVldWU7dmFyIGRpc3BhdGNoPXF1ZXVlLmRpc3BhdGNoPWRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKG51bGwsY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxxdWV1ZSk7cmV0dXJuW2hvb2subWVtb2l6ZWRTdGF0ZSxkaXNwYXRjaF07fWZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBxdWV1ZT1ob29rLnF1ZXVlO2lmKHF1ZXVlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI9cmVkdWNlcjt2YXIgY3VycmVudD1jdXJyZW50SG9vazsvLyBUaGUgbGFzdCByZWJhc2UgdXBkYXRlIHRoYXQgaXMgTk9UIHBhcnQgb2YgdGhlIGJhc2Ugc3RhdGUuXG52YXIgYmFzZVF1ZXVlPWN1cnJlbnQuYmFzZVF1ZXVlOy8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cbnZhciBwZW5kaW5nUXVldWU9cXVldWUucGVuZGluZztpZihwZW5kaW5nUXVldWUhPT1udWxsKXsvLyBXZSBoYXZlIG5ldyB1cGRhdGVzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4vLyBXZSdsbCBhZGQgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cbmlmKGJhc2VRdWV1ZSE9PW51bGwpey8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbnZhciBiYXNlRmlyc3Q9YmFzZVF1ZXVlLm5leHQ7dmFyIHBlbmRpbmdGaXJzdD1wZW5kaW5nUXVldWUubmV4dDtiYXNlUXVldWUubmV4dD1wZW5kaW5nRmlyc3Q7cGVuZGluZ1F1ZXVlLm5leHQ9YmFzZUZpcnN0O317aWYoY3VycmVudC5iYXNlUXVldWUhPT1iYXNlUXVldWUpey8vIEludGVybmFsIGludmFyaWFudCB0aGF0IHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBmZWFzaWJseSBjb3VsZCBpblxuLy8gdGhlIGZ1dHVyZSBpZiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcsIG9yIHNvbWUgZm9ybSBvZiB0aGF0LlxuZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcrJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fX1jdXJyZW50LmJhc2VRdWV1ZT1iYXNlUXVldWU9cGVuZGluZ1F1ZXVlO3F1ZXVlLnBlbmRpbmc9bnVsbDt9aWYoYmFzZVF1ZXVlIT09bnVsbCl7Ly8gV2UgaGF2ZSBhIHF1ZXVlIHRvIHByb2Nlc3MuXG52YXIgZmlyc3Q9YmFzZVF1ZXVlLm5leHQ7dmFyIG5ld1N0YXRlPWN1cnJlbnQuYmFzZVN0YXRlO3ZhciBuZXdCYXNlU3RhdGU9bnVsbDt2YXIgbmV3QmFzZVF1ZXVlRmlyc3Q9bnVsbDt2YXIgbmV3QmFzZVF1ZXVlTGFzdD1udWxsO3ZhciB1cGRhdGU9Zmlyc3Q7ZG97dmFyIHVwZGF0ZUxhbmU9dXBkYXRlLmxhbmU7aWYoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcyx1cGRhdGVMYW5lKSl7Ly8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4vLyB1cGRhdGUvc3RhdGUuXG52YXIgY2xvbmU9e2xhbmU6dXBkYXRlTGFuZSxhY3Rpb246dXBkYXRlLmFjdGlvbixoYXNFYWdlclN0YXRlOnVwZGF0ZS5oYXNFYWdlclN0YXRlLGVhZ2VyU3RhdGU6dXBkYXRlLmVhZ2VyU3RhdGUsbmV4dDpudWxsfTtpZihuZXdCYXNlUXVldWVMYXN0PT09bnVsbCl7bmV3QmFzZVF1ZXVlRmlyc3Q9bmV3QmFzZVF1ZXVlTGFzdD1jbG9uZTtuZXdCYXNlU3RhdGU9bmV3U3RhdGU7fWVsc2V7bmV3QmFzZVF1ZXVlTGFzdD1uZXdCYXNlUXVldWVMYXN0Lm5leHQ9Y2xvbmU7fS8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbi8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4vLyByZW5kZXJMYW5lcyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cbmN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXM9bWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLHVwZGF0ZUxhbmUpO21hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7fWVsc2V7Ly8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5pZihuZXdCYXNlUXVldWVMYXN0IT09bnVsbCl7dmFyIF9jbG9uZT17Ly8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbi8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbi8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbmxhbmU6Tm9MYW5lLGFjdGlvbjp1cGRhdGUuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6dXBkYXRlLmhhc0VhZ2VyU3RhdGUsZWFnZXJTdGF0ZTp1cGRhdGUuZWFnZXJTdGF0ZSxuZXh0Om51bGx9O25ld0Jhc2VRdWV1ZUxhc3Q9bmV3QmFzZVF1ZXVlTGFzdC5uZXh0PV9jbG9uZTt9Ly8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cbmlmKHVwZGF0ZS5oYXNFYWdlclN0YXRlKXsvLyBJZiB0aGlzIHVwZGF0ZSBpcyBhIHN0YXRlIHVwZGF0ZSAobm90IGEgcmVkdWNlcikgYW5kIHdhcyBwcm9jZXNzZWQgZWFnZXJseSxcbi8vIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGVcbm5ld1N0YXRlPXVwZGF0ZS5lYWdlclN0YXRlO31lbHNle3ZhciBhY3Rpb249dXBkYXRlLmFjdGlvbjtuZXdTdGF0ZT1yZWR1Y2VyKG5ld1N0YXRlLGFjdGlvbik7fX11cGRhdGU9dXBkYXRlLm5leHQ7fXdoaWxlKHVwZGF0ZSE9PW51bGwmJnVwZGF0ZSE9PWZpcnN0KTtpZihuZXdCYXNlUXVldWVMYXN0PT09bnVsbCl7bmV3QmFzZVN0YXRlPW5ld1N0YXRlO31lbHNle25ld0Jhc2VRdWV1ZUxhc3QubmV4dD1uZXdCYXNlUXVldWVGaXJzdDt9Ly8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5pZighb2JqZWN0SXMobmV3U3RhdGUsaG9vay5tZW1vaXplZFN0YXRlKSl7bWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTt9aG9vay5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO2hvb2suYmFzZVN0YXRlPW5ld0Jhc2VTdGF0ZTtob29rLmJhc2VRdWV1ZT1uZXdCYXNlUXVldWVMYXN0O3F1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlPW5ld1N0YXRlO30vLyBJbnRlcmxlYXZlZCB1cGRhdGVzIGFyZSBzdG9yZWQgb24gYSBzZXBhcmF0ZSBxdWV1ZS4gV2UgYXJlbid0IGdvaW5nIHRvXG4vLyBwcm9jZXNzIHRoZW0gZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgd2UgZG8gbmVlZCB0byB0cmFjayB3aGljaCBsYW5lc1xuLy8gYXJlIHJlbWFpbmluZy5cbnZhciBsYXN0SW50ZXJsZWF2ZWQ9cXVldWUuaW50ZXJsZWF2ZWQ7aWYobGFzdEludGVybGVhdmVkIT09bnVsbCl7dmFyIGludGVybGVhdmVkPWxhc3RJbnRlcmxlYXZlZDtkb3t2YXIgaW50ZXJsZWF2ZWRMYW5lPWludGVybGVhdmVkLmxhbmU7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcz1tZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsaW50ZXJsZWF2ZWRMYW5lKTttYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGludGVybGVhdmVkTGFuZSk7aW50ZXJsZWF2ZWQ9aW50ZXJsZWF2ZWQubmV4dDt9d2hpbGUoaW50ZXJsZWF2ZWQhPT1sYXN0SW50ZXJsZWF2ZWQpO31lbHNlIGlmKGJhc2VRdWV1ZT09PW51bGwpey8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4vLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxucXVldWUubGFuZXM9Tm9MYW5lczt9dmFyIGRpc3BhdGNoPXF1ZXVlLmRpc3BhdGNoO3JldHVybltob29rLm1lbW9pemVkU3RhdGUsZGlzcGF0Y2hdO31mdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBxdWV1ZT1ob29rLnF1ZXVlO2lmKHF1ZXVlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fXF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI9cmVkdWNlcjsvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuLy8gd29yay1pbi1wcm9ncmVzcyBob29rLlxudmFyIGRpc3BhdGNoPXF1ZXVlLmRpc3BhdGNoO3ZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGU9cXVldWUucGVuZGluZzt2YXIgbmV3U3RhdGU9aG9vay5tZW1vaXplZFN0YXRlO2lmKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSE9PW51bGwpey8vIFRoZSBxdWV1ZSBkb2Vzbid0IHBlcnNpc3QgcGFzdCB0aGlzIHJlbmRlciBwYXNzLlxucXVldWUucGVuZGluZz1udWxsO3ZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlPWxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O3ZhciB1cGRhdGU9Zmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtkb3svLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbi8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbi8vIHJlbmRlcidzLlxudmFyIGFjdGlvbj11cGRhdGUuYWN0aW9uO25ld1N0YXRlPXJlZHVjZXIobmV3U3RhdGUsYWN0aW9uKTt1cGRhdGU9dXBkYXRlLm5leHQ7fXdoaWxlKHVwZGF0ZSE9PWZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpOy8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbi8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuaWYoIW9iamVjdElzKG5ld1N0YXRlLGhvb2subWVtb2l6ZWRTdGF0ZSkpe21hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7fWhvb2subWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTsvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bXVsYXRlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlcyB0b1xuLy8gdGhlIGJhc2Ugc3RhdGUgdW5sZXNzIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbi8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4vLyBkbyBmb3IgZ0RTRlAuIEkgY2FuJ3QgcmVtZW1iZXIgd2h5LlxuaWYoaG9vay5iYXNlUXVldWU9PT1udWxsKXtob29rLmJhc2VTdGF0ZT1uZXdTdGF0ZTt9cXVldWUubGFzdFJlbmRlcmVkU3RhdGU9bmV3U3RhdGU7fXJldHVybltuZXdTdGF0ZSxkaXNwYXRjaF07fWZ1bmN0aW9uIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXt7cmV0dXJuIHVuZGVmaW5lZDt9fWZ1bmN0aW9uIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7e3JldHVybiB1bmRlZmluZWQ7fX1mdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7dmFyIGZpYmVyPWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgbmV4dFNuYXBzaG90O3ZhciBpc0h5ZHJhdGluZz1nZXRJc0h5ZHJhdGluZygpO2lmKGlzSHlkcmF0aW5nKXtpZihnZXRTZXJ2ZXJTbmFwc2hvdD09PXVuZGVmaW5lZCl7dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJysnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuJyk7fW5leHRTbmFwc2hvdD1nZXRTZXJ2ZXJTbmFwc2hvdCgpO3tpZighZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Qpe2lmKG5leHRTbmFwc2hvdCE9PWdldFNlcnZlclNuYXBzaG90KCkpe2Vycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO2RpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90PXRydWU7fX19fWVsc2V7bmV4dFNuYXBzaG90PWdldFNuYXBzaG90KCk7e2lmKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCl7dmFyIGNhY2hlZFNuYXBzaG90PWdldFNuYXBzaG90KCk7aWYoIW9iamVjdElzKG5leHRTbmFwc2hvdCxjYWNoZWRTbmFwc2hvdCkpe2Vycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO2RpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90PXRydWU7fX19Ly8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4vLyBSaWdodCBiZWZvcmUgY29tbWl0dGluZywgd2Ugd2lsbCB3YWxrIHRoZSB0cmVlIGFuZCBjaGVjayBpZiBhbnkgb2YgdGhlXG4vLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuLy9cbi8vIFdlIHdvbid0IGRvIHRoaXMgaWYgd2UncmUgaHlkcmF0aW5nIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LCBiZWNhdXNlIGlmXG4vLyB0aGUgY29udGVudCBpcyBzdGFsZSwgaXQncyBhbHJlYWR5IHZpc2libGUgYW55d2F5LiBJbnN0ZWFkIHdlJ2xsIHBhdGNoXG4vLyBpdCB1cCBpbiBhIHBhc3NpdmUgZWZmZWN0LlxudmFyIHJvb3Q9Z2V0V29ya0luUHJvZ3Jlc3NSb290KCk7aWYocm9vdD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31pZighaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCxyZW5kZXJMYW5lcykpe3B1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsZ2V0U25hcHNob3QsbmV4dFNuYXBzaG90KTt9fS8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbi8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuaG9vay5tZW1vaXplZFN0YXRlPW5leHRTbmFwc2hvdDt2YXIgaW5zdD17dmFsdWU6bmV4dFNuYXBzaG90LGdldFNuYXBzaG90OmdldFNuYXBzaG90fTtob29rLnF1ZXVlPWluc3Q7Ly8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHN1YnNjcmliZSB0byB0aGUgc3RvcmUuXG5tb3VudEVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCxmaWJlcixpbnN0LHN1YnNjcmliZSksW3N1YnNjcmliZV0pOy8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byB1cGRhdGUgdGhlIG11dGFibGUgaW5zdGFuY2UgZmllbGRzLiBXZSB3aWxsIHVwZGF0ZVxuLy8gdGhpcyB3aGVuZXZlciBzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBvciB2YWx1ZSBjaGFuZ2VzLiBCZWNhdXNlIHRoZXJlJ3Mgbm9cbi8vIGNsZWFuLXVwIGZ1bmN0aW9uLCBhbmQgd2UgdHJhY2sgdGhlIGRlcHMgY29ycmVjdGx5LCB3ZSBjYW4gY2FsbCBwdXNoRWZmZWN0XG4vLyBkaXJlY3RseSwgd2l0aG91dCBzdG9yaW5nIGFueSBhZGRpdGlvbmFsIHN0YXRlLiBGb3IgdGhlIHNhbWUgcmVhc29uLCB3ZVxuLy8gZG9uJ3QgbmVlZCB0byBzZXQgYSBzdGF0aWMgZmxhZywgZWl0aGVyLlxuLy8gVE9ETzogV2UgY2FuIG1vdmUgdGhpcyB0byB0aGUgcGFzc2l2ZSBwaGFzZSBvbmNlIHdlIGFkZCBhIHByZS1jb21taXRcbi8vIGNvbnNpc3RlbmN5IGNoZWNrLiBTZWUgdGhlIG5leHQgY29tbWVudC5cbmZpYmVyLmZsYWdzfD1QYXNzaXZlO3B1c2hFZmZlY3QoSGFzRWZmZWN0fFBhc3NpdmUkMSx1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQobnVsbCxmaWJlcixpbnN0LG5leHRTbmFwc2hvdCxnZXRTbmFwc2hvdCksdW5kZWZpbmVkLG51bGwpO3JldHVybiBuZXh0U25hcHNob3Q7fWZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7dmFyIGZpYmVyPWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7Ly8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4vLyBhbHdheXMgc3luY2hyb25vdXMuXG52YXIgbmV4dFNuYXBzaG90PWdldFNuYXBzaG90KCk7e2lmKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCl7dmFyIGNhY2hlZFNuYXBzaG90PWdldFNuYXBzaG90KCk7aWYoIW9iamVjdElzKG5leHRTbmFwc2hvdCxjYWNoZWRTbmFwc2hvdCkpe2Vycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO2RpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90PXRydWU7fX19dmFyIHByZXZTbmFwc2hvdD1ob29rLm1lbW9pemVkU3RhdGU7dmFyIHNuYXBzaG90Q2hhbmdlZD0hb2JqZWN0SXMocHJldlNuYXBzaG90LG5leHRTbmFwc2hvdCk7aWYoc25hcHNob3RDaGFuZ2VkKXtob29rLm1lbW9pemVkU3RhdGU9bmV4dFNuYXBzaG90O21hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7fXZhciBpbnN0PWhvb2sucXVldWU7dXBkYXRlRWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLGZpYmVyLGluc3Qsc3Vic2NyaWJlKSxbc3Vic2NyaWJlXSk7Ly8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4vLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbi8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbi8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cbmlmKGluc3QuZ2V0U25hcHNob3QhPT1nZXRTbmFwc2hvdHx8c25hcHNob3RDaGFuZ2VkfHwvLyBDaGVjayBpZiB0aGUgc3VzYmNyaWJlIGZ1bmN0aW9uIGNoYW5nZWQuIFdlIGNhbiBzYXZlIHNvbWUgbWVtb3J5IGJ5XG4vLyBjaGVja2luZyB3aGV0aGVyIHdlIHNjaGVkdWxlZCBhIHN1YnNjcmlwdGlvbiBlZmZlY3QgYWJvdmUuXG53b3JrSW5Qcm9ncmVzc0hvb2shPT1udWxsJiZ3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcmSGFzRWZmZWN0KXtmaWJlci5mbGFnc3w9UGFzc2l2ZTtwdXNoRWZmZWN0KEhhc0VmZmVjdHxQYXNzaXZlJDEsdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsZmliZXIsaW5zdCxuZXh0U25hcHNob3QsZ2V0U25hcHNob3QpLHVuZGVmaW5lZCxudWxsKTsvLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cbi8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbi8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG52YXIgcm9vdD1nZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtpZihyb290PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWlmKCFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LHJlbmRlckxhbmVzKSl7cHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlcixnZXRTbmFwc2hvdCxuZXh0U25hcHNob3QpO319cmV0dXJuIG5leHRTbmFwc2hvdDt9ZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlcixnZXRTbmFwc2hvdCxyZW5kZXJlZFNuYXBzaG90KXtmaWJlci5mbGFnc3w9U3RvcmVDb25zaXN0ZW5jeTt2YXIgY2hlY2s9e2dldFNuYXBzaG90OmdldFNuYXBzaG90LHZhbHVlOnJlbmRlcmVkU25hcHNob3R9O3ZhciBjb21wb25lbnRVcGRhdGVRdWV1ZT1jdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO2lmKGNvbXBvbmVudFVwZGF0ZVF1ZXVlPT09bnVsbCl7Y29tcG9uZW50VXBkYXRlUXVldWU9Y3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU9Y29tcG9uZW50VXBkYXRlUXVldWU7Y29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzPVtjaGVja107fWVsc2V7dmFyIHN0b3Jlcz1jb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM7aWYoc3RvcmVzPT09bnVsbCl7Y29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzPVtjaGVja107fWVsc2V7c3RvcmVzLnB1c2goY2hlY2spO319fWZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsaW5zdCxuZXh0U25hcHNob3QsZ2V0U25hcHNob3Qpey8vIFRoZXNlIGFyZSB1cGRhdGVkIGluIHRoZSBwYXNzaXZlIHBoYXNlXG5pbnN0LnZhbHVlPW5leHRTbmFwc2hvdDtpbnN0LmdldFNuYXBzaG90PWdldFNuYXBzaG90Oy8vIFNvbWV0aGluZyBtYXkgaGF2ZSBiZWVuIG11dGF0ZWQgaW4gYmV0d2VlbiByZW5kZXIgYW5kIGNvbW1pdC4gVGhpcyBjb3VsZFxuLy8gaGF2ZSBiZWVuIGluIGFuIGV2ZW50IHRoYXQgZmlyZWQgYmVmb3JlIHRoZSBwYXNzaXZlIGVmZmVjdHMsIG9yIGl0IGNvdWxkXG4vLyBoYXZlIGJlZW4gaW4gYSBsYXlvdXQgZWZmZWN0LiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkIGhhdmUgdXNlZCB0aGUgb2xkXG4vLyBzbmFwc2hvIGFuZCBnZXRTbmFwc2hvdCB2YWx1ZXMgdG8gYmFpbCBvdXQuIFdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgdGltZS5cbmlmKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpey8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTt9fWZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsaW5zdCxzdWJzY3JpYmUpe3ZhciBoYW5kbGVTdG9yZUNoYW5nZT1mdW5jdGlvbigpey8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4vLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuaWYoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSl7Ly8gRm9yY2UgYSByZS1yZW5kZXIuXG5mb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO319Oy8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxucmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7fWZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCl7dmFyIGxhdGVzdEdldFNuYXBzaG90PWluc3QuZ2V0U25hcHNob3Q7dmFyIHByZXZWYWx1ZT1pbnN0LnZhbHVlO3RyeXt2YXIgbmV4dFZhbHVlPWxhdGVzdEdldFNuYXBzaG90KCk7cmV0dXJuIW9iamVjdElzKHByZXZWYWx1ZSxuZXh0VmFsdWUpO31jYXRjaChlcnJvcil7cmV0dXJuIHRydWU7fX1mdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpe3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fWZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO2lmKHR5cGVvZiBpbml0aWFsU3RhdGU9PT0nZnVuY3Rpb24nKXsvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuaW5pdGlhbFN0YXRlPWluaXRpYWxTdGF0ZSgpO31ob29rLm1lbW9pemVkU3RhdGU9aG9vay5iYXNlU3RhdGU9aW5pdGlhbFN0YXRlO3ZhciBxdWV1ZT17cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6Tm9MYW5lcyxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6YmFzaWNTdGF0ZVJlZHVjZXIsbGFzdFJlbmRlcmVkU3RhdGU6aW5pdGlhbFN0YXRlfTtob29rLnF1ZXVlPXF1ZXVlO3ZhciBkaXNwYXRjaD1xdWV1ZS5kaXNwYXRjaD1kaXNwYXRjaFNldFN0YXRlLmJpbmQobnVsbCxjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLHF1ZXVlKTtyZXR1cm5baG9vay5tZW1vaXplZFN0YXRlLGRpc3BhdGNoXTt9ZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKXtyZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7fWZ1bmN0aW9uIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKXtyZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTt9ZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsY3JlYXRlLGRlc3Ryb3ksZGVwcyl7dmFyIGVmZmVjdD17dGFnOnRhZyxjcmVhdGU6Y3JlYXRlLGRlc3Ryb3k6ZGVzdHJveSxkZXBzOmRlcHMsLy8gQ2lyY3VsYXJcbm5leHQ6bnVsbH07dmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlPWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7aWYoY29tcG9uZW50VXBkYXRlUXVldWU9PT1udWxsKXtjb21wb25lbnRVcGRhdGVRdWV1ZT1jcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZT1jb21wb25lbnRVcGRhdGVRdWV1ZTtjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0PWVmZmVjdC5uZXh0PWVmZmVjdDt9ZWxzZXt2YXIgbGFzdEVmZmVjdD1jb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0O2lmKGxhc3RFZmZlY3Q9PT1udWxsKXtjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0PWVmZmVjdC5uZXh0PWVmZmVjdDt9ZWxzZXt2YXIgZmlyc3RFZmZlY3Q9bGFzdEVmZmVjdC5uZXh0O2xhc3RFZmZlY3QubmV4dD1lZmZlY3Q7ZWZmZWN0Lm5leHQ9Zmlyc3RFZmZlY3Q7Y29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdD1lZmZlY3Q7fX1yZXR1cm4gZWZmZWN0O31mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7e3ZhciBfcmVmMj17Y3VycmVudDppbml0aWFsVmFsdWV9O2hvb2subWVtb2l6ZWRTdGF0ZT1fcmVmMjtyZXR1cm4gX3JlZjI7fX1mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKXt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtyZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO31mdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncyxob29rRmxhZ3MsY3JlYXRlLGRlcHMpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHREZXBzPWRlcHM9PT11bmRlZmluZWQ/bnVsbDpkZXBzO2N1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3N8PWZpYmVyRmxhZ3M7aG9vay5tZW1vaXplZFN0YXRlPXB1c2hFZmZlY3QoSGFzRWZmZWN0fGhvb2tGbGFncyxjcmVhdGUsdW5kZWZpbmVkLG5leHREZXBzKTt9ZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLGhvb2tGbGFncyxjcmVhdGUsZGVwcyl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHREZXBzPWRlcHM9PT11bmRlZmluZWQ/bnVsbDpkZXBzO3ZhciBkZXN0cm95PXVuZGVmaW5lZDtpZihjdXJyZW50SG9vayE9PW51bGwpe3ZhciBwcmV2RWZmZWN0PWN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7ZGVzdHJveT1wcmV2RWZmZWN0LmRlc3Ryb3k7aWYobmV4dERlcHMhPT1udWxsKXt2YXIgcHJldkRlcHM9cHJldkVmZmVjdC5kZXBzO2lmKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcyxwcmV2RGVwcykpe2hvb2subWVtb2l6ZWRTdGF0ZT1wdXNoRWZmZWN0KGhvb2tGbGFncyxjcmVhdGUsZGVzdHJveSxuZXh0RGVwcyk7cmV0dXJuO319fWN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3N8PWZpYmVyRmxhZ3M7aG9vay5tZW1vaXplZFN0YXRlPXB1c2hFZmZlY3QoSGFzRWZmZWN0fGhvb2tGbGFncyxjcmVhdGUsZGVzdHJveSxuZXh0RGVwcyk7fWZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSxkZXBzKXtpZigoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7cmV0dXJuIG1vdW50RWZmZWN0SW1wbChNb3VudFBhc3NpdmVEZXZ8UGFzc2l2ZXxQYXNzaXZlU3RhdGljLFBhc3NpdmUkMSxjcmVhdGUsZGVwcyk7fWVsc2V7cmV0dXJuIG1vdW50RWZmZWN0SW1wbChQYXNzaXZlfFBhc3NpdmVTdGF0aWMsUGFzc2l2ZSQxLGNyZWF0ZSxkZXBzKTt9fWZ1bmN0aW9uIHVwZGF0ZUVmZmVjdChjcmVhdGUsZGVwcyl7cmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoUGFzc2l2ZSxQYXNzaXZlJDEsY3JlYXRlLGRlcHMpO31mdW5jdGlvbiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyl7cmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsSW5zZXJ0aW9uLGNyZWF0ZSxkZXBzKTt9ZnVuY3Rpb24gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKXtyZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsSW5zZXJ0aW9uLGNyZWF0ZSxkZXBzKTt9ZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpe3ZhciBmaWJlckZsYWdzPVVwZGF0ZTt7ZmliZXJGbGFnc3w9TGF5b3V0U3RhdGljO31pZigoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7ZmliZXJGbGFnc3w9TW91bnRMYXlvdXREZXY7fXJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncyxMYXlvdXQsY3JlYXRlLGRlcHMpO31mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpe3JldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSxMYXlvdXQsY3JlYXRlLGRlcHMpO31mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSxyZWYpe2lmKHR5cGVvZiByZWY9PT0nZnVuY3Rpb24nKXt2YXIgcmVmQ2FsbGJhY2s9cmVmO3ZhciBfaW5zdD1jcmVhdGUoKTtyZWZDYWxsYmFjayhfaW5zdCk7cmV0dXJuIGZ1bmN0aW9uKCl7cmVmQ2FsbGJhY2sobnVsbCk7fTt9ZWxzZSBpZihyZWYhPT1udWxsJiZyZWYhPT11bmRlZmluZWQpe3ZhciByZWZPYmplY3Q9cmVmO3tpZighcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50Jykpe2Vycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgJysncmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywnYW4gb2JqZWN0IHdpdGgga2V5cyB7JytPYmplY3Qua2V5cyhyZWZPYmplY3QpLmpvaW4oJywgJykrJ30nKTt9fXZhciBfaW5zdDI9Y3JlYXRlKCk7cmVmT2JqZWN0LmN1cnJlbnQ9X2luc3QyO3JldHVybiBmdW5jdGlvbigpe3JlZk9iamVjdC5jdXJyZW50PW51bGw7fTt9fWZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpe3tpZih0eXBlb2YgY3JlYXRlIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnKyd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsY3JlYXRlIT09bnVsbD90eXBlb2YgY3JlYXRlOidudWxsJyk7fX0vLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xudmFyIGVmZmVjdERlcHM9ZGVwcyE9PW51bGwmJmRlcHMhPT11bmRlZmluZWQ/ZGVwcy5jb25jYXQoW3JlZl0pOm51bGw7dmFyIGZpYmVyRmxhZ3M9VXBkYXRlO3tmaWJlckZsYWdzfD1MYXlvdXRTdGF0aWM7fWlmKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUmU3RyaWN0RWZmZWN0c01vZGUpIT09Tm9Nb2RlKXtmaWJlckZsYWdzfD1Nb3VudExheW91dERldjt9cmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLExheW91dCxpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCxjcmVhdGUscmVmKSxlZmZlY3REZXBzKTt9ZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpe3tpZih0eXBlb2YgY3JlYXRlIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnKyd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsY3JlYXRlIT09bnVsbD90eXBlb2YgY3JlYXRlOidudWxsJyk7fX0vLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xudmFyIGVmZmVjdERlcHM9ZGVwcyE9PW51bGwmJmRlcHMhPT11bmRlZmluZWQ/ZGVwcy5jb25jYXQoW3JlZl0pOm51bGw7cmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLExheW91dCxpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCxjcmVhdGUscmVmKSxlZmZlY3REZXBzKTt9ZnVuY3Rpb24gbW91bnREZWJ1Z1ZhbHVlKHZhbHVlLGZvcm1hdHRlckZuKXsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbi8vIFRoZSByZWFjdC1kZWJ1Zy1ob29rcyBwYWNrYWdlIGluamVjdHMgaXRzIG93biBpbXBsZW1lbnRhdGlvblxuLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn12YXIgdXBkYXRlRGVidWdWYWx1ZT1tb3VudERlYnVnVmFsdWU7ZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjayxkZXBzKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0RGVwcz1kZXBzPT09dW5kZWZpbmVkP251bGw6ZGVwcztob29rLm1lbW9pemVkU3RhdGU9W2NhbGxiYWNrLG5leHREZXBzXTtyZXR1cm4gY2FsbGJhY2s7fWZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLGRlcHMpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciBuZXh0RGVwcz1kZXBzPT09dW5kZWZpbmVkP251bGw6ZGVwczt2YXIgcHJldlN0YXRlPWhvb2subWVtb2l6ZWRTdGF0ZTtpZihwcmV2U3RhdGUhPT1udWxsKXtpZihuZXh0RGVwcyE9PW51bGwpe3ZhciBwcmV2RGVwcz1wcmV2U3RhdGVbMV07aWYoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLHByZXZEZXBzKSl7cmV0dXJuIHByZXZTdGF0ZVswXTt9fX1ob29rLm1lbW9pemVkU3RhdGU9W2NhbGxiYWNrLG5leHREZXBzXTtyZXR1cm4gY2FsbGJhY2s7fWZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLGRlcHMpe3ZhciBob29rPW1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHREZXBzPWRlcHM9PT11bmRlZmluZWQ/bnVsbDpkZXBzO3ZhciBuZXh0VmFsdWU9bmV4dENyZWF0ZSgpO2hvb2subWVtb2l6ZWRTdGF0ZT1bbmV4dFZhbHVlLG5leHREZXBzXTtyZXR1cm4gbmV4dFZhbHVlO31mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsZGVwcyl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIG5leHREZXBzPWRlcHM9PT11bmRlZmluZWQ/bnVsbDpkZXBzO3ZhciBwcmV2U3RhdGU9aG9vay5tZW1vaXplZFN0YXRlO2lmKHByZXZTdGF0ZSE9PW51bGwpey8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG5pZihuZXh0RGVwcyE9PW51bGwpe3ZhciBwcmV2RGVwcz1wcmV2U3RhdGVbMV07aWYoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLHByZXZEZXBzKSl7cmV0dXJuIHByZXZTdGF0ZVswXTt9fX12YXIgbmV4dFZhbHVlPW5leHRDcmVhdGUoKTtob29rLm1lbW9pemVkU3RhdGU9W25leHRWYWx1ZSxuZXh0RGVwc107cmV0dXJuIG5leHRWYWx1ZTt9ZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKXt2YXIgaG9vaz1tb3VudFdvcmtJblByb2dyZXNzSG9vaygpO2hvb2subWVtb2l6ZWRTdGF0ZT12YWx1ZTtyZXR1cm4gdmFsdWU7fWZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpe3ZhciBob29rPXVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO3ZhciByZXNvbHZlZEN1cnJlbnRIb29rPWN1cnJlbnRIb29rO3ZhciBwcmV2VmFsdWU9cmVzb2x2ZWRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO3JldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLHByZXZWYWx1ZSx2YWx1ZSk7fWZ1bmN0aW9uIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7aWYoY3VycmVudEhvb2s9PT1udWxsKXsvLyBUaGlzIGlzIGEgcmVyZW5kZXIgZHVyaW5nIGEgbW91bnQuXG5ob29rLm1lbW9pemVkU3RhdGU9dmFsdWU7cmV0dXJuIHZhbHVlO31lbHNley8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYW4gdXBkYXRlLlxudmFyIHByZXZWYWx1ZT1jdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO3JldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLHByZXZWYWx1ZSx2YWx1ZSk7fX1mdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLHByZXZWYWx1ZSx2YWx1ZSl7dmFyIHNob3VsZERlZmVyVmFsdWU9IWluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKHJlbmRlckxhbmVzKTtpZihzaG91bGREZWZlclZhbHVlKXsvLyBUaGlzIGlzIGFuIHVyZ2VudCB1cGRhdGUuIElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwga2VlcCB1c2luZyB0aGVcbi8vIHByZXZpb3VzIHZhbHVlIGFuZCBzcGF3biBhIGRlZmVycmVkIHJlbmRlciB0byB1cGRhdGUgaXQgbGF0ZXIuXG5pZighb2JqZWN0SXModmFsdWUscHJldlZhbHVlKSl7Ly8gU2NoZWR1bGUgYSBkZWZlcnJlZCByZW5kZXJcbnZhciBkZWZlcnJlZExhbmU9Y2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTtjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzPW1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyxkZWZlcnJlZExhbmUpO21hcmtTa2lwcGVkVXBkYXRlTGFuZXMoZGVmZXJyZWRMYW5lKTsvLyBTZXQgdGhpcyB0byB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHJlbmRlcmVkIHZhbHVlIGlzIGluY29uc2lzdGVudFxuLy8gZnJvbSB0aGUgbGF0ZXN0IHZhbHVlLiBUaGUgbmFtZSBcImJhc2VTdGF0ZVwiIGRvZXNuJ3QgcmVhbGx5IG1hdGNoIGhvdyB3ZVxuLy8gdXNlIGl0IGJlY2F1c2Ugd2UncmUgcmV1c2luZyBhIHN0YXRlIGhvb2sgZmllbGQgaW5zdGVhZCBvZiBjcmVhdGluZyBhXG4vLyBuZXcgb25lLlxuaG9vay5iYXNlU3RhdGU9dHJ1ZTt9Ly8gUmV1c2UgdGhlIHByZXZpb3VzIHZhbHVlXG5yZXR1cm4gcHJldlZhbHVlO31lbHNley8vIFRoaXMgaXMgbm90IGFuIHVyZ2VudCB1cGRhdGUsIHNvIHdlIGNhbiB1c2UgdGhlIGxhdGVzdCB2YWx1ZSByZWdhcmRsZXNzXG4vLyBvZiB3aGF0IGl0IGlzLiBObyBuZWVkIHRvIGRlZmVyIGl0LlxuLy8gSG93ZXZlciwgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIHNwYXduZWQgcmVuZGVyLCB0aGVuIHdlIG5lZWQgdG8gbWFya1xuLy8gdGhpcyBhcyBhbiB1cGRhdGUgdG8gcHJldmVudCB0aGUgZmliZXIgZnJvbSBiYWlsaW5nIG91dC5cbi8vXG4vLyBgYmFzZVN0YXRlYCBpcyB0cnVlIHdoZW4gdGhlIGN1cnJlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIHJlbmRlcmVkXG4vLyB2YWx1ZS4gVGhlIG5hbWUgZG9lc24ndCByZWFsbHkgbWF0Y2ggaG93IHdlIHVzZSBpdCBiZWNhdXNlIHdlJ3JlIHJldXNpbmdcbi8vIGEgc3RhdGUgaG9vayBmaWVsZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZS5cbmlmKGhvb2suYmFzZVN0YXRlKXsvLyBGbGlwIHRoaXMgYmFjayB0byBmYWxzZS5cbmhvb2suYmFzZVN0YXRlPWZhbHNlO21hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7fWhvb2subWVtb2l6ZWRTdGF0ZT12YWx1ZTtyZXR1cm4gdmFsdWU7fX1mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2V0UGVuZGluZyxjYWxsYmFjayxvcHRpb25zKXt2YXIgcHJldmlvdXNQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoaGlnaGVyRXZlbnRQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5LENvbnRpbnVvdXNFdmVudFByaW9yaXR5KSk7c2V0UGVuZGluZyh0cnVlKTt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbj17fTt2YXIgY3VycmVudFRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO3tSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnM9bmV3IFNldCgpO310cnl7c2V0UGVuZGluZyhmYWxzZSk7Y2FsbGJhY2soKTt9ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uPXByZXZUcmFuc2l0aW9uO3tpZihwcmV2VHJhbnNpdGlvbj09PW51bGwmJmN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKXt2YXIgdXBkYXRlZEZpYmVyc0NvdW50PWN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7aWYodXBkYXRlZEZpYmVyc0NvdW50PjEwKXt3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcrJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcrJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTt9Y3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTt9fX19ZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCl7dmFyIF9tb3VudFN0YXRlPW1vdW50U3RhdGUoZmFsc2UpLGlzUGVuZGluZz1fbW91bnRTdGF0ZVswXSxzZXRQZW5kaW5nPV9tb3VudFN0YXRlWzFdOy8vIFRoZSBgc3RhcnRgIG1ldGhvZCBuZXZlciBjaGFuZ2VzLlxudmFyIHN0YXJ0PXN0YXJ0VHJhbnNpdGlvbi5iaW5kKG51bGwsc2V0UGVuZGluZyk7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtob29rLm1lbW9pemVkU3RhdGU9c3RhcnQ7cmV0dXJuW2lzUGVuZGluZyxzdGFydF07fWZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKXt2YXIgX3VwZGF0ZVN0YXRlPXVwZGF0ZVN0YXRlKCksaXNQZW5kaW5nPV91cGRhdGVTdGF0ZVswXTt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgc3RhcnQ9aG9vay5tZW1vaXplZFN0YXRlO3JldHVybltpc1BlbmRpbmcsc3RhcnRdO31mdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKXt2YXIgX3JlcmVuZGVyU3RhdGU9cmVyZW5kZXJTdGF0ZSgpLGlzUGVuZGluZz1fcmVyZW5kZXJTdGF0ZVswXTt2YXIgaG9vaz11cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgc3RhcnQ9aG9vay5tZW1vaXplZFN0YXRlO3JldHVybltpc1BlbmRpbmcsc3RhcnRdO312YXIgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZT1mYWxzZTtmdW5jdGlvbiBnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYoKXt7cmV0dXJuIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U7fX1mdW5jdGlvbiBtb3VudElkKCl7dmFyIGhvb2s9bW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTt2YXIgcm9vdD1nZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTsvLyBUT0RPOiBJbiBGaXp6LCBpZCBnZW5lcmF0aW9uIGlzIHNwZWNpZmljIHRvIGVhY2ggc2VydmVyIGNvbmZpZy4gTWF5YmUgd2Vcbi8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuLy8gdGhlcmUncyBubyBvdGhlciBwbGFjZSB0byBzdG9yZSB0aGUgcHJlZml4IGV4Y2VwdCBmb3IgYW4gaW50ZXJuYWwgZmllbGQgb25cbi8vIHRoZSBwdWJsaWMgY3JlYXRlUm9vdCBvYmplY3QsIHdoaWNoIHRoZSBmaWJlciB0cmVlIGRvZXMgbm90IGN1cnJlbnRseSBoYXZlXG4vLyBhIHJlZmVyZW5jZSB0by5cbnZhciBpZGVudGlmaWVyUHJlZml4PXJvb3QuaWRlbnRpZmllclByZWZpeDt2YXIgaWQ7aWYoZ2V0SXNIeWRyYXRpbmcoKSl7dmFyIHRyZWVJZD1nZXRUcmVlSWQoKTsvLyBVc2UgYSBjYXB0aWFsIFIgcHJlZml4IGZvciBzZXJ2ZXItZ2VuZXJhdGVkIGlkcy5cbmlkPSc6JytpZGVudGlmaWVyUHJlZml4KydSJyt0cmVlSWQ7Ly8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4vLyB0aGF0IHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdXNlSWQgaG9vayBhbW9uZyBhbGwgdGhlIHVzZUlkXG4vLyBob29rcyBmb3IgdGhpcyBmaWJlci5cbnZhciBsb2NhbElkPWxvY2FsSWRDb3VudGVyKys7aWYobG9jYWxJZD4wKXtpZCs9J0gnK2xvY2FsSWQudG9TdHJpbmcoMzIpO31pZCs9JzonO31lbHNley8vIFVzZSBhIGxvd2VyY2FzZSByIHByZWZpeCBmb3IgY2xpZW50LWdlbmVyYXRlZCBpZHMuXG52YXIgZ2xvYmFsQ2xpZW50SWQ9Z2xvYmFsQ2xpZW50SWRDb3VudGVyKys7aWQ9JzonK2lkZW50aWZpZXJQcmVmaXgrJ3InK2dsb2JhbENsaWVudElkLnRvU3RyaW5nKDMyKSsnOic7fWhvb2subWVtb2l6ZWRTdGF0ZT1pZDtyZXR1cm4gaWQ7fWZ1bmN0aW9uIHVwZGF0ZUlkKCl7dmFyIGhvb2s9dXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7dmFyIGlkPWhvb2subWVtb2l6ZWRTdGF0ZTtyZXR1cm4gaWQ7fWZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlcixxdWV1ZSxhY3Rpb24pe3tpZih0eXBlb2YgYXJndW1lbnRzWzNdPT09J2Z1bmN0aW9uJyl7ZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIisnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJysncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO319dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO3ZhciB1cGRhdGU9e2xhbmU6bGFuZSxhY3Rpb246YWN0aW9uLGhhc0VhZ2VyU3RhdGU6ZmFsc2UsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH07aWYoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpe2VucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSx1cGRhdGUpO31lbHNle3ZhciByb290PWVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlcixxdWV1ZSx1cGRhdGUsbGFuZSk7aWYocm9vdCE9PW51bGwpe3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCxxdWV1ZSxsYW5lKTt9fW1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLGxhbmUpO31mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLHF1ZXVlLGFjdGlvbil7e2lmKHR5cGVvZiBhcmd1bWVudHNbM109PT0nZnVuY3Rpb24nKXtlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiKydzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnKydyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7fX12YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT17bGFuZTpsYW5lLGFjdGlvbjphY3Rpb24saGFzRWFnZXJTdGF0ZTpmYWxzZSxlYWdlclN0YXRlOm51bGwsbmV4dDpudWxsfTtpZihpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSl7ZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLHVwZGF0ZSk7fWVsc2V7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoZmliZXIubGFuZXM9PT1Ob0xhbmVzJiYoYWx0ZXJuYXRlPT09bnVsbHx8YWx0ZXJuYXRlLmxhbmVzPT09Tm9MYW5lcykpey8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4vLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG52YXIgbGFzdFJlbmRlcmVkUmVkdWNlcj1xdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO2lmKGxhc3RSZW5kZXJlZFJlZHVjZXIhPT1udWxsKXt2YXIgcHJldkRpc3BhdGNoZXI7e3ByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO310cnl7dmFyIGN1cnJlbnRTdGF0ZT1xdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTt2YXIgZWFnZXJTdGF0ZT1sYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSxhY3Rpb24pOy8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG4vLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxudXBkYXRlLmhhc0VhZ2VyU3RhdGU9dHJ1ZTt1cGRhdGUuZWFnZXJTdGF0ZT1lYWdlclN0YXRlO2lmKG9iamVjdElzKGVhZ2VyU3RhdGUsY3VycmVudFN0YXRlKSl7Ly8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbi8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbi8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4vLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuLy8gVE9ETzogRG8gd2Ugc3RpbGwgbmVlZCB0byBlbnRhbmdsZSB0cmFuc2l0aW9ucyBpbiB0aGlzIGNhc2U/XG5lbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dChmaWJlcixxdWV1ZSx1cGRhdGUsbGFuZSk7cmV0dXJuO319Y2F0Y2goZXJyb3Ipey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxufWZpbmFsbHl7e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319fX12YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIscXVldWUsdXBkYXRlLGxhbmUpO2lmKHJvb3QhPT1udWxsKXt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixsYW5lLGV2ZW50VGltZSk7ZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QscXVldWUsbGFuZSk7fX1tYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlcixsYW5lKTt9ZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcil7dmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7cmV0dXJuIGZpYmVyPT09Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMXx8YWx0ZXJuYXRlIT09bnVsbCYmYWx0ZXJuYXRlPT09Y3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTt9ZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLHVwZGF0ZSl7Ly8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4vLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4vLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbmRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcz1kaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlPXRydWU7dmFyIHBlbmRpbmc9cXVldWUucGVuZGluZztpZihwZW5kaW5nPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxudXBkYXRlLm5leHQ9dXBkYXRlO31lbHNle3VwZGF0ZS5uZXh0PXBlbmRpbmcubmV4dDtwZW5kaW5nLm5leHQ9dXBkYXRlO31xdWV1ZS5wZW5kaW5nPXVwZGF0ZTt9Ly8gVE9ETzogTW92ZSB0byBSZWFjdEZpYmVyQ29uY3VycmVudFVwZGF0ZXM/XG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCxxdWV1ZSxsYW5lKXtpZihpc1RyYW5zaXRpb25MYW5lKGxhbmUpKXt2YXIgcXVldWVMYW5lcz1xdWV1ZS5sYW5lczsvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5XG4vLyBtdXN0IGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoXG4vLyByZXByZXNlbnRzIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2Vcbi8vIG1heSBlbnRhbmdsZSBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmXG4vLyB3ZSAqZG9uJ3QqIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxucXVldWVMYW5lcz1pbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLHJvb3QucGVuZGluZ0xhbmVzKTsvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxudmFyIG5ld1F1ZXVlTGFuZXM9bWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLGxhbmUpO3F1ZXVlLmxhbmVzPW5ld1F1ZXVlTGFuZXM7Ly8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbi8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5tYXJrUm9vdEVudGFuZ2xlZChyb290LG5ld1F1ZXVlTGFuZXMpO319ZnVuY3Rpb24gbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsbGFuZSxhY3Rpb24pe3ttYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsbGFuZSk7fX12YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyPXtyZWFkQ29udGV4dDpyZWFkQ29udGV4dCx1c2VDYWxsYmFjazp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlQ29udGV4dDp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlRWZmZWN0OnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VJbXBlcmF0aXZlSGFuZGxlOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VJbnNlcnRpb25FZmZlY3Q6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZUxheW91dEVmZmVjdDp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlTWVtbzp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlUmVkdWNlcjp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlUmVmOnRocm93SW52YWxpZEhvb2tFcnJvcix1c2VTdGF0ZTp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlRGVidWdWYWx1ZTp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlRGVmZXJyZWRWYWx1ZTp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlVHJhbnNpdGlvbjp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlTXV0YWJsZVNvdXJjZTp0aHJvd0ludmFsaWRIb29rRXJyb3IsdXNlU3luY0V4dGVybmFsU3RvcmU6dGhyb3dJbnZhbGlkSG9va0Vycm9yLHVzZUlkOnRocm93SW52YWxpZEhvb2tFcnJvcix1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07dmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVj1udWxsO3ZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWPW51bGw7dmFyIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY9bnVsbDt2YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWPW51bGw7dmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY9bnVsbDt2YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY9bnVsbDt2YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVj1udWxsO3t2YXIgd2FybkludmFsaWRDb250ZXh0QWNjZXNzPWZ1bmN0aW9uKCl7ZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcrJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcrJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnKydpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO307dmFyIHdhcm5JbnZhbGlkSG9va0FjY2Vzcz1mdW5jdGlvbigpe2Vycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcrJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJysnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTt9O0hvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzttb3VudEhvb2tUeXBlc0RldigpO2NoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO3JldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO21vdW50SG9va1R5cGVzRGV2KCk7Y2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7cmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7bW91bnRIb29rVHlwZXNEZXYoKTtjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtyZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO21vdW50SG9va1R5cGVzRGV2KCk7Y2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7cmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7bW91bnRIb29rVHlwZXNEZXYoKTtjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtyZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO21vdW50SG9va1R5cGVzRGV2KCk7Y2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudE1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzttb3VudEhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO21vdW50SG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTtIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudE1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjt0cnl7cmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudERlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO30sdXNlU3luY0V4dGVybmFsU3RvcmU6ZnVuY3Rpb24oc3Vic2NyaWJlLGdldFNuYXBzaG90LGdldFNlcnZlclNuYXBzaG90KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3luY0V4dGVybmFsU3RvcmUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTtIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWPXtyZWFkQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VDYWxsYmFjazpmdW5jdGlvbihjYWxsYmFjayxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ2FsbGJhY2snO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjayxkZXBzKTt9LHVzZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNvbnRleHQnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKHJlZixjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUltcGVyYXRpdmVIYW5kbGUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTGF5b3V0RWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZU1lbW86ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VNZW1vJzt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSxkZXBzKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVkdWNlcic7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVJlZigpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VUcmFuc2l0aW9uJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTtIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY9e3JlYWRDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe3JldHVybiByZWFkQ29udGV4dChjb250ZXh0KTt9LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGNhbGxiYWNrLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDYWxsYmFjayc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRWZmZWN0Jzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLGNyZWF0ZSxkZXBzKTt9LHVzZUluc2VydGlvbkVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUluc2VydGlvbkVmZmVjdCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VMYXlvdXRFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VMYXlvdXRFZmZlY3QnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO3RyeXtyZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO3RyeXtyZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlUmVmKCk7fSx1c2VTdGF0ZTpmdW5jdGlvbihpbml0aWFsU3RhdGUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTdGF0ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7dHJ5e3JldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7fSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKHZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVmZXJyZWRWYWx1ZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUlkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7d2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLGRlcHMpO30sdXNlQ29udGV4dDpmdW5jdGlvbihjb250ZXh0KXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlQ29udGV4dCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24ocmVmLGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW1wZXJhdGl2ZUhhbmRsZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZixjcmVhdGUsZGVwcyk7fSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbnNlcnRpb25FZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlTWVtbzpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU1lbW8nO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudE1lbW8oY3JlYXRlLGRlcHMpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZHVjZXI6ZnVuY3Rpb24ocmVkdWNlcixpbml0aWFsQXJnLGluaXQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWR1Y2VyJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO3RyeXtyZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsaW5pdGlhbEFyZyxpbml0KTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VSZWY6ZnVuY3Rpb24oaW5pdGlhbFZhbHVlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlUmVmJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTttb3VudEhvb2tUeXBlc0RldigpO3JldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7dHJ5e3JldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbih2YWx1ZSxmb3JtYXR0ZXJGbil7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlYnVnVmFsdWUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7fSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVRyYW5zaXRpb24nO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7bW91bnRIb29rVHlwZXNEZXYoKTtyZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3QpO30sdXNlSWQ6ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSWQnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO21vdW50SG9va1R5cGVzRGV2KCk7cmV0dXJuIG1vdW50SWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTtJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7d2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlcixpbml0aWFsQXJnLGluaXQpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZVJlZjpmdW5jdGlvbihpbml0aWFsVmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VSZWYnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVSZWYoKTt9LHVzZVN0YXRlOmZ1bmN0aW9uKGluaXRpYWxTdGF0ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN0YXRlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7dHJ5e3JldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO31maW5hbGx5e1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PXByZXZEaXNwYXRjaGVyO319LHVzZURlYnVnVmFsdWU6ZnVuY3Rpb24odmFsdWUsZm9ybWF0dGVyRm4pe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWJ1Z1ZhbHVlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO30sdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbih2YWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZURlZmVycmVkVmFsdWUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTt9LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oc291cmNlLGdldFNuYXBzaG90LHN1YnNjcmliZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZU11dGFibGVTb3VyY2UnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihzdWJzY3JpYmUsZ2V0U25hcHNob3QsZ2V0U2VydmVyU25hcHNob3Qpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSxnZXRTbmFwc2hvdCk7fSx1c2VJZDpmdW5jdGlvbigpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJZCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUlkKCk7fSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ZW5hYmxlTmV3UmVjb25jaWxlcn07SW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVj17cmVhZENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dCl7d2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7cmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO30sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oY2FsbGJhY2ssZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUNhbGxiYWNrJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssZGVwcyk7fSx1c2VDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHQpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VDb250ZXh0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7fSx1c2VFZmZlY3Q6ZnVuY3Rpb24oY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VFZmZlY3QnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3JldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLGRlcHMpO30sdXNlSW1wZXJhdGl2ZUhhbmRsZTpmdW5jdGlvbihyZWYsY3JlYXRlLGRlcHMpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VJbXBlcmF0aXZlSGFuZGxlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsY3JlYXRlLGRlcHMpO30sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlSW5zZXJ0aW9uRWZmZWN0Jzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSxkZXBzKTt9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihjcmVhdGUsZGVwcyl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUxheW91dEVmZmVjdCc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsZGVwcyk7fSx1c2VNZW1vOmZ1bmN0aW9uKGNyZWF0ZSxkZXBzKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTWVtbyc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7dmFyIHByZXZEaXNwYXRjaGVyPVJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50PUludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO3RyeXtyZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsZGVwcyk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVkdWNlcjpmdW5jdGlvbihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZHVjZXInO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLGluaXRpYWxBcmcsaW5pdCk7fWZpbmFsbHl7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ9cHJldkRpc3BhdGNoZXI7fX0sdXNlUmVmOmZ1bmN0aW9uKGluaXRpYWxWYWx1ZSl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVJlZic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZVJlZigpO30sdXNlU3RhdGU6ZnVuY3Rpb24oaW5pdGlhbFN0YXRlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlU3RhdGUnO3dhcm5JbnZhbGlkSG9va0FjY2VzcygpO3VwZGF0ZUhvb2tUeXBlc0RldigpO3ZhciBwcmV2RGlzcGF0Y2hlcj1SZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1JbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjt0cnl7cmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTt9ZmluYWxseXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudD1wcmV2RGlzcGF0Y2hlcjt9fSx1c2VEZWJ1Z1ZhbHVlOmZ1bmN0aW9uKHZhbHVlLGZvcm1hdHRlckZuKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlRGVidWdWYWx1ZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTt9LHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24odmFsdWUpe2N1cnJlbnRIb29rTmFtZUluRGV2PSd1c2VEZWZlcnJlZFZhbHVlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKTt9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlVHJhbnNpdGlvbic7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO30sdXNlTXV0YWJsZVNvdXJjZTpmdW5jdGlvbihzb3VyY2UsZ2V0U25hcHNob3Qsc3Vic2NyaWJlKXtjdXJyZW50SG9va05hbWVJbkRldj0ndXNlTXV0YWJsZVNvdXJjZSc7d2FybkludmFsaWRIb29rQWNjZXNzKCk7dXBkYXRlSG9va1R5cGVzRGV2KCk7cmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKHN1YnNjcmliZSxnZXRTbmFwc2hvdCxnZXRTZXJ2ZXJTbmFwc2hvdCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZVN5bmNFeHRlcm5hbFN0b3JlJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLGdldFNuYXBzaG90KTt9LHVzZUlkOmZ1bmN0aW9uKCl7Y3VycmVudEhvb2tOYW1lSW5EZXY9J3VzZUlkJzt3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTt1cGRhdGVIb29rVHlwZXNEZXYoKTtyZXR1cm4gdXBkYXRlSWQoKTt9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjplbmFibGVOZXdSZWNvbmNpbGVyfTt9dmFyIG5vdyQxPVNjaGVkdWxlci51bnN0YWJsZV9ub3c7dmFyIGNvbW1pdFRpbWU9MDt2YXIgbGF5b3V0RWZmZWN0U3RhcnRUaW1lPS0xO3ZhciBwcm9maWxlclN0YXJ0VGltZT0tMTt2YXIgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZT0tMTsvKipcbiAqIFRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQvY2FzY2FkaW5nIHVwZGF0ZSAoc2NoZWR1bGVkIGZyb20gYSBsYXlvdXQgZWZmZWN0KS5cbiAqXG4gKiBUaGUgb3ZlcmFsbCBzZXF1ZW5jZSBpczpcbiAqICAgMS4gcmVuZGVyXG4gKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcbiAqICAgMy4gY2hlY2sgZm9yIG5lc3RlZCB1cGRhdGVzXG4gKiAgIDQuIGZsdXNoIHBhc3NpdmUgZWZmZWN0cyAoYW5kIGNhbGwgYG9uUG9zdENvbW1pdGApXG4gKlxuICogTmVzdGVkIHVwZGF0ZXMgYXJlIGlkZW50aWZpZWQgaW4gc3RlcCAzIGFib3ZlLFxuICogYnV0IHN0ZXAgNCBzdGlsbCBhcHBsaWVzIHRvIHRoZSB3b3JrIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkLlxuICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuICogb25lIHRyYWNrcyB3aGV0aGVyIHRoZSB1cGNvbWluZyB1cGRhdGUgaXMgYSBuZXN0ZWQgdXBkYXRlLFxuICogYW5kIHRoZSBvdGhlciB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkIHVwZGF0ZS5cbiAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuICovdmFyIGN1cnJlbnRVcGRhdGVJc05lc3RlZD1mYWxzZTt2YXIgbmVzdGVkVXBkYXRlU2NoZWR1bGVkPWZhbHNlO2Z1bmN0aW9uIGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpe3JldHVybiBjdXJyZW50VXBkYXRlSXNOZXN0ZWQ7fWZ1bmN0aW9uIG1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKXt7bmVzdGVkVXBkYXRlU2NoZWR1bGVkPXRydWU7fX1mdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKXt7Y3VycmVudFVwZGF0ZUlzTmVzdGVkPWZhbHNlO25lc3RlZFVwZGF0ZVNjaGVkdWxlZD1mYWxzZTt9fWZ1bmN0aW9uIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCl7e2N1cnJlbnRVcGRhdGVJc05lc3RlZD1uZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7bmVzdGVkVXBkYXRlU2NoZWR1bGVkPWZhbHNlO319ZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpe3JldHVybiBjb21taXRUaW1lO31mdW5jdGlvbiByZWNvcmRDb21taXRUaW1lKCl7Y29tbWl0VGltZT1ub3ckMSgpO31mdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpe3Byb2ZpbGVyU3RhcnRUaW1lPW5vdyQxKCk7aWYoZmliZXIuYWN0dWFsU3RhcnRUaW1lPDApe2ZpYmVyLmFjdHVhbFN0YXJ0VGltZT1ub3ckMSgpO319ZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpe3Byb2ZpbGVyU3RhcnRUaW1lPS0xO31mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLG92ZXJyaWRlQmFzZVRpbWUpe2lmKHByb2ZpbGVyU3RhcnRUaW1lPj0wKXt2YXIgZWxhcHNlZFRpbWU9bm93JDEoKS1wcm9maWxlclN0YXJ0VGltZTtmaWJlci5hY3R1YWxEdXJhdGlvbis9ZWxhcHNlZFRpbWU7aWYob3ZlcnJpZGVCYXNlVGltZSl7ZmliZXIuc2VsZkJhc2VEdXJhdGlvbj1lbGFwc2VkVGltZTt9cHJvZmlsZXJTdGFydFRpbWU9LTE7fX1mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcil7aWYobGF5b3V0RWZmZWN0U3RhcnRUaW1lPj0wKXt2YXIgZWxhcHNlZFRpbWU9bm93JDEoKS1sYXlvdXRFZmZlY3RTdGFydFRpbWU7bGF5b3V0RWZmZWN0U3RhcnRUaW1lPS0xOy8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3Jcbi8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG52YXIgcGFyZW50RmliZXI9ZmliZXIucmV0dXJuO3doaWxlKHBhcmVudEZpYmVyIT09bnVsbCl7c3dpdGNoKHBhcmVudEZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp2YXIgcm9vdD1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7cm9vdC5lZmZlY3REdXJhdGlvbis9ZWxhcHNlZFRpbWU7cmV0dXJuO2Nhc2UgUHJvZmlsZXI6dmFyIHBhcmVudFN0YXRlTm9kZT1wYXJlbnRGaWJlci5zdGF0ZU5vZGU7cGFyZW50U3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uKz1lbGFwc2VkVGltZTtyZXR1cm47fXBhcmVudEZpYmVyPXBhcmVudEZpYmVyLnJldHVybjt9fX1mdW5jdGlvbiByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmliZXIpe2lmKHBhc3NpdmVFZmZlY3RTdGFydFRpbWU+PTApe3ZhciBlbGFwc2VkVGltZT1ub3ckMSgpLXBhc3NpdmVFZmZlY3RTdGFydFRpbWU7cGFzc2l2ZUVmZmVjdFN0YXJ0VGltZT0tMTsvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4vLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxudmFyIHBhcmVudEZpYmVyPWZpYmVyLnJldHVybjt3aGlsZShwYXJlbnRGaWJlciE9PW51bGwpe3N3aXRjaChwYXJlbnRGaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6dmFyIHJvb3Q9cGFyZW50RmliZXIuc3RhdGVOb2RlO2lmKHJvb3QhPT1udWxsKXtyb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbis9ZWxhcHNlZFRpbWU7fXJldHVybjtjYXNlIFByb2ZpbGVyOnZhciBwYXJlbnRTdGF0ZU5vZGU9cGFyZW50RmliZXIuc3RhdGVOb2RlO2lmKHBhcmVudFN0YXRlTm9kZSE9PW51bGwpey8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG4vLyBJbiB0aGlzIGNhc2UsIHRoZSByZXR1cm4gcG9pbnRlciBpcyBhbHNvIGNsZWFyZWQgb3V0LFxuLy8gc28gd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBvcnQgdGhlIHRpbWUgc3BlbnQgaW4gdGhpcyBQcm9maWxlcidzIHN1YnRyZWUuXG5wYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uKz1lbGFwc2VkVGltZTt9cmV0dXJuO31wYXJlbnRGaWJlcj1wYXJlbnRGaWJlci5yZXR1cm47fX19ZnVuY3Rpb24gc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpe2xheW91dEVmZmVjdFN0YXJ0VGltZT1ub3ckMSgpO31mdW5jdGlvbiBzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpe3Bhc3NpdmVFZmZlY3RTdGFydFRpbWU9bm93JDEoKTt9ZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcil7Ly8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuLy8gYWZ0ZXIgd2UgcmVyZW5kZXIuIFRoaXMgaXMgdXNlZCBhcyBhIGhlbHBlciBpbiBzcGVjaWFsIGNhc2VzXG4vLyB3aGVyZSB3ZSBzaG91bGQgY291bnQgdGhlIHdvcmsgb2YgbXVsdGlwbGUgcGFzc2VzLlxudmFyIGNoaWxkPWZpYmVyLmNoaWxkO3doaWxlKGNoaWxkKXtmaWJlci5hY3R1YWxEdXJhdGlvbis9Y2hpbGQuYWN0dWFsRHVyYXRpb247Y2hpbGQ9Y2hpbGQuc2libGluZzt9fWZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LGJhc2VQcm9wcyl7aWYoQ29tcG9uZW50JiZDb21wb25lbnQuZGVmYXVsdFByb3BzKXsvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHMuIFRha2VuIGZyb20gUmVhY3RFbGVtZW50XG52YXIgcHJvcHM9YXNzaWduKHt9LGJhc2VQcm9wcyk7dmFyIGRlZmF1bHRQcm9wcz1Db21wb25lbnQuZGVmYXVsdFByb3BzO2Zvcih2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKXtpZihwcm9wc1twcm9wTmFtZV09PT11bmRlZmluZWQpe3Byb3BzW3Byb3BOYW1lXT1kZWZhdWx0UHJvcHNbcHJvcE5hbWVdO319cmV0dXJuIHByb3BzO31yZXR1cm4gYmFzZVByb3BzO312YXIgZmFrZUludGVybmFsSW5zdGFuY2U9e307dmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDt2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO3ZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7dmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7dmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTt2YXIgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlO3ZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7dmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO3ZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlczt2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO3ZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDE7e2RpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudD1uZXcgU2V0KCk7ZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzPW5ldyBTZXQoKTtkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU9bmV3IFNldCgpO2RpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQkMT1uZXcgU2V0KCk7dmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjaz1uZXcgU2V0KCk7d2Fybk9uSW52YWxpZENhbGxiYWNrPWZ1bmN0aW9uKGNhbGxiYWNrLGNhbGxlck5hbWUpe2lmKGNhbGxiYWNrPT09bnVsbHx8dHlwZW9mIGNhbGxiYWNrPT09J2Z1bmN0aW9uJyl7cmV0dXJuO312YXIga2V5PWNhbGxlck5hbWUrJ18nK2NhbGxiYWNrO2lmKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpe2RpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcrJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLGNhbGxlck5hbWUsY2FsbGJhY2spO319O3dhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZT1mdW5jdGlvbih0eXBlLHBhcnRpYWxTdGF0ZSl7aWYocGFydGlhbFN0YXRlPT09dW5kZWZpbmVkKXt2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSl8fCdDb21wb25lbnQnO2lmKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKXtkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO2Vycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcrJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLGNvbXBvbmVudE5hbWUpO319fTsvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbi8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3Jcbi8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbi8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbi8vIGV4Y2VwdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwnX3Byb2Nlc3NDaGlsZENvbnRleHQnLHtlbnVtZXJhYmxlOmZhbHNlLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKCdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgJysnbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0ICcrJ2EgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nICcrXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIrJ3RvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoICcrJ3RvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7fX0pO09iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO31mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcyxjdG9yLGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxuZXh0UHJvcHMpe3ZhciBwcmV2U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt2YXIgcGFydGlhbFN0YXRlPWdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMscHJldlN0YXRlKTt7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7Ly8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbnBhcnRpYWxTdGF0ZT1nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLHByZXZTdGF0ZSk7fWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319d2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IscGFydGlhbFN0YXRlKTt9Ly8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbnZhciBtZW1vaXplZFN0YXRlPXBhcnRpYWxTdGF0ZT09PW51bGx8fHBhcnRpYWxTdGF0ZT09PXVuZGVmaW5lZD9wcmV2U3RhdGU6YXNzaWduKHt9LHByZXZTdGF0ZSxwYXJ0aWFsU3RhdGUpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bWVtb2l6ZWRTdGF0ZTsvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbi8vIGJhc2Ugc3RhdGUuXG5pZih3b3JrSW5Qcm9ncmVzcy5sYW5lcz09PU5vTGFuZXMpey8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xudmFyIHVwZGF0ZVF1ZXVlPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO3VwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1tZW1vaXplZFN0YXRlO319dmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlcj17aXNNb3VudGVkOmlzTW91bnRlZCxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oaW5zdCxwYXlsb2FkLGNhbGxiYWNrKXt2YXIgZmliZXI9Z2V0KGluc3QpO3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3ZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShldmVudFRpbWUsbGFuZSk7dXBkYXRlLnBheWxvYWQ9cGF5bG9hZDtpZihjYWxsYmFjayE9PXVuZGVmaW5lZCYmY2FsbGJhY2shPT1udWxsKXt7d2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCdzZXRTdGF0ZScpO311cGRhdGUuY2FsbGJhY2s9Y2FsbGJhY2s7fXZhciByb290PWVucXVldWVVcGRhdGUoZmliZXIsdXBkYXRlLGxhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixsYW5lLGV2ZW50VGltZSk7ZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LGZpYmVyLGxhbmUpO317bWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLGxhbmUpO319LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oaW5zdCxwYXlsb2FkLGNhbGxiYWNrKXt2YXIgZmliZXI9Z2V0KGluc3QpO3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3ZhciBsYW5lPXJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShldmVudFRpbWUsbGFuZSk7dXBkYXRlLnRhZz1SZXBsYWNlU3RhdGU7dXBkYXRlLnBheWxvYWQ9cGF5bG9hZDtpZihjYWxsYmFjayE9PXVuZGVmaW5lZCYmY2FsbGJhY2shPT1udWxsKXt7d2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCdyZXBsYWNlU3RhdGUnKTt9dXBkYXRlLmNhbGxiYWNrPWNhbGxiYWNrO312YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCxmaWJlcixsYW5lKTt9e21hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oaW5zdCxjYWxsYmFjayl7dmFyIGZpYmVyPWdldChpbnN0KTt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTt2YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpO3VwZGF0ZS50YWc9Rm9yY2VVcGRhdGU7aWYoY2FsbGJhY2shPT11bmRlZmluZWQmJmNhbGxiYWNrIT09bnVsbCl7e3dhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywnZm9yY2VVcGRhdGUnKTt9dXBkYXRlLmNhbGxiYWNrPWNhbGxiYWNrO312YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO2VudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCxmaWJlcixsYW5lKTt9e21hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlcixsYW5lKTt9fX07ZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsY3RvcixvbGRQcm9wcyxuZXdQcm9wcyxvbGRTdGF0ZSxuZXdTdGF0ZSxuZXh0Q29udGV4dCl7dmFyIGluc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpZih0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlPT09J2Z1bmN0aW9uJyl7dmFyIHNob3VsZFVwZGF0ZT1pbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsbmV3U3RhdGUsbmV4dENvbnRleHQpO3tpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO3RyeXsvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuc2hvdWxkVXBkYXRlPWluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcyxuZXdTdGF0ZSxuZXh0Q29udGV4dCk7fWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319aWYoc2hvdWxkVXBkYXRlPT09dW5kZWZpbmVkKXtlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJysnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50Jyk7fX1yZXR1cm4gc2hvdWxkVXBkYXRlO31pZihjdG9yLnByb3RvdHlwZSYmY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpe3JldHVybiFzaGFsbG93RXF1YWwob2xkUHJvcHMsbmV3UHJvcHMpfHwhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLG5ld1N0YXRlKTt9cmV0dXJuIHRydWU7fWZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzKXt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3t2YXIgbmFtZT1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3Rvcil8fCdDb21wb25lbnQnO3ZhciByZW5kZXJQcmVzZW50PWluc3RhbmNlLnJlbmRlcjtpZighcmVuZGVyUHJlc2VudCl7aWYoY3Rvci5wcm90b3R5cGUmJnR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXI9PT0nZnVuY3Rpb24nKXtlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJysnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JyxuYW1lKTt9ZWxzZXtlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJysnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsbmFtZSk7fX1pZihpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUmJiFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQmJiFpbnN0YW5jZS5zdGF0ZSl7ZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnKydUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcrJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsbmFtZSk7fWlmKGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyYmIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCl7ZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnKydUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcrJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJyxuYW1lKTt9aWYoaW5zdGFuY2UucHJvcFR5cGVzKXtlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJysncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsbmFtZSk7fWlmKGluc3RhbmNlLmNvbnRleHRUeXBlKXtlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnKydwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC4nLG5hbWUpO317aWYoY3Rvci5jaGlsZENvbnRleHRUeXBlcyYmIWRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQkMS5oYXMoY3RvcikmJi8vIFN0cmljdCBNb2RlIGhhcyBpdHMgb3duIHdhcm5pbmcgZm9yIGxlZ2FjeSBjb250ZXh0LCBzbyB3ZSBjYW4gc2tpcFxuLy8gdGhpcyBvbmUuXG4od29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKT09PU5vTW9kZSl7ZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCQxLmFkZChjdG9yKTtlcnJvcignJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCBpcyBubyBsb25nZXIgJysnc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlICcrJ1JlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkXFxuXFxuLicrJ0xlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsbmFtZSk7fWlmKGN0b3IuY29udGV4dFR5cGVzJiYhZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCQxLmhhcyhjdG9yKSYmLy8gU3RyaWN0IE1vZGUgaGFzIGl0cyBvd24gd2FybmluZyBmb3IgbGVnYWN5IGNvbnRleHQsIHNvIHdlIGNhbiBza2lwXG4vLyB0aGlzIG9uZS5cbih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpPT09Tm9Nb2RlKXtkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0JDEuYWRkKGN0b3IpO2Vycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkICcrJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlICcrJ1JlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLlxcblxcbicrJ0xlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsbmFtZSk7fWlmKGluc3RhbmNlLmNvbnRleHRUeXBlcyl7ZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcrJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLG5hbWUpO31pZihjdG9yLmNvbnRleHRUeXBlJiZjdG9yLmNvbnRleHRUeXBlcyYmIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKSl7ZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO2Vycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcrJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLG5hbWUpO319aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZT09PSdmdW5jdGlvbicpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcrJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcrJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnKydleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLG5hbWUpO31pZihjdG9yLnByb3RvdHlwZSYmY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQmJnR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUhPT0ndW5kZWZpbmVkJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcrJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJysnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3Rvcil8fCdBIHB1cmUgY29tcG9uZW50Jyk7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50PT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJysnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnKydEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJysnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcrJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnKyd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnKydydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcz09PSdmdW5jdGlvbicpe2Vycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcrJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHM9PT0nZnVuY3Rpb24nKXtlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnKydVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLG5hbWUpO312YXIgaGFzTXV0YXRlZFByb3BzPWluc3RhbmNlLnByb3BzIT09bmV3UHJvcHM7aWYoaW5zdGFuY2UucHJvcHMhPT11bmRlZmluZWQmJmhhc011dGF0ZWRQcm9wcyl7ZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcrXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixuYW1lLG5hbWUpO31pZihpbnN0YW5jZS5kZWZhdWx0UHJvcHMpe2Vycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJysnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJyxuYW1lLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nJiZ0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIT09J2Z1bmN0aW9uJyYmIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3Rvcikpe2RpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7ZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcrJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTt9aWYodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicpe2Vycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJysnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJyxuYW1lKTt9aWYodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj09PSdmdW5jdGlvbicpe2Vycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJysnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJyxuYW1lKTt9aWYodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXtlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJysnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJyxuYW1lKTt9dmFyIF9zdGF0ZT1pbnN0YW5jZS5zdGF0ZTtpZihfc3RhdGUmJih0eXBlb2YgX3N0YXRlIT09J29iamVjdCd8fGlzQXJyYXkoX3N0YXRlKSkpe2Vycm9yKCclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLG5hbWUpO31pZih0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0PT09J2Z1bmN0aW9uJyYmdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMhPT0nb2JqZWN0Jyl7ZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJysndXNlIGdldENoaWxkQ29udGV4dCgpLicsbmFtZSk7fX19ZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLGluc3RhbmNlKXtpbnN0YW5jZS51cGRhdGVyPWNsYXNzQ29tcG9uZW50VXBkYXRlcjt3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9aW5zdGFuY2U7Ly8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuc2V0KGluc3RhbmNlLHdvcmtJblByb2dyZXNzKTt7aW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZT1mYWtlSW50ZXJuYWxJbnN0YW5jZTt9fWZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsY3Rvcixwcm9wcyl7dmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyPWZhbHNlO3ZhciB1bm1hc2tlZENvbnRleHQ9ZW1wdHlDb250ZXh0T2JqZWN0O3ZhciBjb250ZXh0PWVtcHR5Q29udGV4dE9iamVjdDt2YXIgY29udGV4dFR5cGU9Y3Rvci5jb250ZXh0VHlwZTt7aWYoJ2NvbnRleHRUeXBlJ2luIGN0b3Ipe3ZhciBpc1ZhbGlkPS8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG5jb250ZXh0VHlwZT09PW51bGx8fGNvbnRleHRUeXBlIT09dW5kZWZpbmVkJiZjb250ZXh0VHlwZS4kJHR5cGVvZj09PVJFQUNUX0NPTlRFWFRfVFlQRSYmY29udGV4dFR5cGUuX2NvbnRleHQ9PT11bmRlZmluZWQ7Ly8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5pZighaXNWYWxpZCYmIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3Rvcikpe2RpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7dmFyIGFkZGVuZHVtPScnO2lmKGNvbnRleHRUeXBlPT09dW5kZWZpbmVkKXthZGRlbmR1bT0nIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcrJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcrJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcrJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO31lbHNlIGlmKHR5cGVvZiBjb250ZXh0VHlwZSE9PSdvYmplY3QnKXthZGRlbmR1bT0nIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcrdHlwZW9mIGNvbnRleHRUeXBlKycuJzt9ZWxzZSBpZihjb250ZXh0VHlwZS4kJHR5cGVvZj09PVJFQUNUX1BST1ZJREVSX1RZUEUpe2FkZGVuZHVtPScgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7fWVsc2UgaWYoY29udGV4dFR5cGUuX2NvbnRleHQhPT11bmRlZmluZWQpey8vIDxDb250ZXh0LkNvbnN1bWVyPlxuYWRkZW5kdW09JyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/Jzt9ZWxzZXthZGRlbmR1bT0nIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnK09iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpKyd9Lic7fWVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcrJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3Rvcil8fCdDb21wb25lbnQnLGFkZGVuZHVtKTt9fX1pZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtjb250ZXh0PXJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTt9ZWxzZXt1bm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLGN0b3IsdHJ1ZSk7dmFyIGNvbnRleHRUeXBlcz1jdG9yLmNvbnRleHRUeXBlcztpc0xlZ2FjeUNvbnRleHRDb25zdW1lcj1jb250ZXh0VHlwZXMhPT1udWxsJiZjb250ZXh0VHlwZXMhPT11bmRlZmluZWQ7Y29udGV4dD1pc0xlZ2FjeUNvbnRleHRDb25zdW1lcj9nZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCk6ZW1wdHlDb250ZXh0T2JqZWN0O312YXIgaW5zdGFuY2U9bmV3IGN0b3IocHJvcHMsY29udGV4dCk7Ly8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxue2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e2luc3RhbmNlPW5ldyBjdG9yKHByb3BzLGNvbnRleHQpOy8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG59ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX19dmFyIHN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9aW5zdGFuY2Uuc3RhdGUhPT1udWxsJiZpbnN0YW5jZS5zdGF0ZSE9PXVuZGVmaW5lZD9pbnN0YW5jZS5zdGF0ZTpudWxsO2Fkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7e2lmKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicmJnN0YXRlPT09bnVsbCl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnKyclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnKydhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJysnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsY29tcG9uZW50TmFtZSxpbnN0YW5jZS5zdGF0ZT09PW51bGw/J251bGwnOid1bmRlZmluZWQnLGNvbXBvbmVudE5hbWUpO319Ly8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4vLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5pZih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXt2YXIgZm91bmRXaWxsTW91bnROYW1lPW51bGw7dmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWU9bnVsbDt2YXIgZm91bmRXaWxsVXBkYXRlTmFtZT1udWxsO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nJiZpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe2ZvdW5kV2lsbE1vdW50TmFtZT0nY29tcG9uZW50V2lsbE1vdW50Jzt9ZWxzZSBpZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicpe2ZvdW5kV2lsbE1vdW50TmFtZT0nVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyYmaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIT09dHJ1ZSl7Zm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZT0nY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7fWVsc2UgaWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7Zm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZT0nVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO31pZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicmJmluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyE9PXRydWUpe2ZvdW5kV2lsbFVwZGF0ZU5hbWU9J2NvbXBvbmVudFdpbGxVcGRhdGUnO31lbHNlIGlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZT09PSdmdW5jdGlvbicpe2ZvdW5kV2lsbFVwZGF0ZU5hbWU9J1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJzt9aWYoZm91bmRXaWxsTW91bnROYW1lIT09bnVsbHx8Zm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSE9PW51bGx8fGZvdW5kV2lsbFVwZGF0ZU5hbWUhPT1udWxsKXt2YXIgX2NvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpfHwnQ29tcG9uZW50Jzt2YXIgbmV3QXBpTmFtZT10eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nPydnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSc6J2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO2lmKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpe2RpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJysnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicrJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLF9jb21wb25lbnROYW1lLG5ld0FwaU5hbWUsZm91bmRXaWxsTW91bnROYW1lIT09bnVsbD9cIlxcbiAgXCIrZm91bmRXaWxsTW91bnROYW1lOicnLGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUhPT1udWxsP1wiXFxuICBcIitmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lOicnLGZvdW5kV2lsbFVwZGF0ZU5hbWUhPT1udWxsP1wiXFxuICBcIitmb3VuZFdpbGxVcGRhdGVOYW1lOicnKTt9fX19Ly8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbmlmKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKXtjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsdW5tYXNrZWRDb250ZXh0LGNvbnRleHQpO31yZXR1cm4gaW5zdGFuY2U7fWZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsaW5zdGFuY2Upe3ZhciBvbGRTdGF0ZT1pbnN0YW5jZS5zdGF0ZTtpZih0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7fWlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50PT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO31pZihvbGRTdGF0ZSE9PWluc3RhbmNlLnN0YXRlKXt7ZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnK1wiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiKydjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcyl8fCdDb21wb25lbnQnKTt9Y2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsaW5zdGFuY2Uuc3RhdGUsbnVsbCk7fX1mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSxuZXdQcm9wcyxuZXh0Q29udGV4dCl7dmFyIG9sZFN0YXRlPWluc3RhbmNlLnN0YXRlO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcyxuZXh0Q29udGV4dCk7fWlmKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpe2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLG5leHRDb250ZXh0KTt9aWYoaW5zdGFuY2Uuc3RhdGUhPT1vbGRTdGF0ZSl7e3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpfHwnQ29tcG9uZW50JztpZighZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSl7ZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtlcnJvcignJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJytcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiKydjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsY29tcG9uZW50TmFtZSk7fX1jbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSxpbnN0YW5jZS5zdGF0ZSxudWxsKTt9fS8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzLHJlbmRlckxhbmVzKXt7Y2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLGN0b3IsbmV3UHJvcHMpO312YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2luc3RhbmNlLnByb3BzPW5ld1Byb3BzO2luc3RhbmNlLnN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aW5zdGFuY2UucmVmcz17fTtpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO3ZhciBjb250ZXh0VHlwZT1jdG9yLmNvbnRleHRUeXBlO2lmKHR5cGVvZiBjb250ZXh0VHlwZT09PSdvYmplY3QnJiZjb250ZXh0VHlwZSE9PW51bGwpe2luc3RhbmNlLmNvbnRleHQ9cmVhZENvbnRleHQoY29udGV4dFR5cGUpO31lbHNle3ZhciB1bm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLGN0b3IsdHJ1ZSk7aW5zdGFuY2UuY29udGV4dD1nZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHVubWFza2VkQ29udGV4dCk7fXtpZihpbnN0YW5jZS5zdGF0ZT09PW5ld1Byb3BzKXt2YXIgY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3Rvcil8fCdDb21wb25lbnQnO2lmKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpe2RpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJytcImJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIFwiKydJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsY29tcG9uZW50TmFtZSk7fX1pZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLGluc3RhbmNlKTt9e1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKHdvcmtJblByb2dyZXNzLGluc3RhbmNlKTt9fWluc3RhbmNlLnN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz1jdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztpZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJyl7YXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsY3RvcixnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsbmV3UHJvcHMpO2luc3RhbmNlLnN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7fS8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyE9PSdmdW5jdGlvbicmJnR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSE9PSdmdW5jdGlvbicmJih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKSl7Y2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcyxpbnN0YW5jZSk7Ly8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuLy8gcHJvY2VzcyB0aGVtIG5vdy5cbnByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyxuZXdQcm9wcyxpbnN0YW5jZSxyZW5kZXJMYW5lcyk7aW5zdGFuY2Uuc3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt9aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50PT09J2Z1bmN0aW9uJyl7dmFyIGZpYmVyRmxhZ3M9VXBkYXRlO3tmaWJlckZsYWdzfD1MYXlvdXRTdGF0aWM7fWlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7ZmliZXJGbGFnc3w9TW91bnRMYXlvdXREZXY7fXdvcmtJblByb2dyZXNzLmZsYWdzfD1maWJlckZsYWdzO319ZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLGN0b3IsbmV3UHJvcHMscmVuZGVyTGFuZXMpe3ZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7dmFyIG9sZFByb3BzPXdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7aW5zdGFuY2UucHJvcHM9b2xkUHJvcHM7dmFyIG9sZENvbnRleHQ9aW5zdGFuY2UuY29udGV4dDt2YXIgY29udGV4dFR5cGU9Y3Rvci5jb250ZXh0VHlwZTt2YXIgbmV4dENvbnRleHQ9ZW1wdHlDb250ZXh0T2JqZWN0O2lmKHR5cGVvZiBjb250ZXh0VHlwZT09PSdvYmplY3QnJiZjb250ZXh0VHlwZSE9PW51bGwpe25leHRDb250ZXh0PXJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTt9ZWxzZXt2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dD1nZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsY3Rvcix0cnVlKTtuZXh0Q29udGV4dD1nZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQpO312YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO3ZhciBoYXNOZXdMaWZlY3ljbGVzPXR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nOy8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbi8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4vLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4vLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuaWYoIWhhc05ld0xpZmVjeWNsZXMmJih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM9PT0nZnVuY3Rpb24nfHx0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09PSdmdW5jdGlvbicpKXtpZihvbGRQcm9wcyE9PW5ld1Byb3BzfHxvbGRDb250ZXh0IT09bmV4dENvbnRleHQpe2NhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLGluc3RhbmNlLG5ld1Byb3BzLG5leHRDb250ZXh0KTt9fXJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7dmFyIG9sZFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIG5ld1N0YXRlPWluc3RhbmNlLnN0YXRlPW9sZFN0YXRlO3Byb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyxuZXdQcm9wcyxpbnN0YW5jZSxyZW5kZXJMYW5lcyk7bmV3U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZihvbGRQcm9wcz09PW5ld1Byb3BzJiZvbGRTdGF0ZT09PW5ld1N0YXRlJiYhaGFzQ29udGV4dENoYW5nZWQoKSYmIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSl7Ly8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4vLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuaWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50PT09J2Z1bmN0aW9uJyl7dmFyIGZpYmVyRmxhZ3M9VXBkYXRlO3tmaWJlckZsYWdzfD1MYXlvdXRTdGF0aWM7fWlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7ZmliZXJGbGFnc3w9TW91bnRMYXlvdXREZXY7fXdvcmtJblByb2dyZXNzLmZsYWdzfD1maWJlckZsYWdzO31yZXR1cm4gZmFsc2U7fWlmKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nKXthcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcyxjdG9yLGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxuZXdQcm9wcyk7bmV3U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt9dmFyIHNob3VsZFVwZGF0ZT1jaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCl8fGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLGN0b3Isb2xkUHJvcHMsbmV3UHJvcHMsb2xkU3RhdGUsbmV3U3RhdGUsbmV4dENvbnRleHQpO2lmKHNob3VsZFVwZGF0ZSl7Ly8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4vLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuaWYoIWhhc05ld0xpZmVjeWNsZXMmJih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQ9PT0nZnVuY3Rpb24nKSl7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicpe2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO31pZih0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudD09PSdmdW5jdGlvbicpe2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTt9fWlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3ZhciBfZmliZXJGbGFncz1VcGRhdGU7e19maWJlckZsYWdzfD1MYXlvdXRTdGF0aWM7fWlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdEVmZmVjdHNNb2RlKSE9PU5vTW9kZSl7X2ZpYmVyRmxhZ3N8PU1vdW50TGF5b3V0RGV2O313b3JrSW5Qcm9ncmVzcy5mbGFnc3w9X2ZpYmVyRmxhZ3M7fX1lbHNley8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbmlmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudD09PSdmdW5jdGlvbicpe3ZhciBfZmliZXJGbGFnczI9VXBkYXRlO3tfZmliZXJGbGFnczJ8PUxheW91dFN0YXRpYzt9aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0RWZmZWN0c01vZGUpIT09Tm9Nb2RlKXtfZmliZXJGbGFnczJ8PU1vdW50TGF5b3V0RGV2O313b3JrSW5Qcm9ncmVzcy5mbGFnc3w9X2ZpYmVyRmxhZ3MyO30vLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4vLyBtZW1vaXplZCBzdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcz1uZXdQcm9wczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO30vLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4vLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbmluc3RhbmNlLnByb3BzPW5ld1Byb3BzO2luc3RhbmNlLnN0YXRlPW5ld1N0YXRlO2luc3RhbmNlLmNvbnRleHQ9bmV4dENvbnRleHQ7cmV0dXJuIHNob3VsZFVwZGF0ZTt9Ly8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxjdG9yLG5ld1Byb3BzLHJlbmRlckxhbmVzKXt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2Nsb25lVXBkYXRlUXVldWUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7dmFyIHVucmVzb2x2ZWRPbGRQcm9wcz13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO3ZhciBvbGRQcm9wcz13b3JrSW5Qcm9ncmVzcy50eXBlPT09d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU/dW5yZXNvbHZlZE9sZFByb3BzOnJlc29sdmVEZWZhdWx0UHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSx1bnJlc29sdmVkT2xkUHJvcHMpO2luc3RhbmNlLnByb3BzPW9sZFByb3BzO3ZhciB1bnJlc29sdmVkTmV3UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBvbGRDb250ZXh0PWluc3RhbmNlLmNvbnRleHQ7dmFyIGNvbnRleHRUeXBlPWN0b3IuY29udGV4dFR5cGU7dmFyIG5leHRDb250ZXh0PWVtcHR5Q29udGV4dE9iamVjdDtpZih0eXBlb2YgY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmY29udGV4dFR5cGUhPT1udWxsKXtuZXh0Q29udGV4dD1yZWFkQ29udGV4dChjb250ZXh0VHlwZSk7fWVsc2V7dmFyIG5leHRVbm1hc2tlZENvbnRleHQ9Z2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLGN0b3IsdHJ1ZSk7bmV4dENvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxuZXh0VW5tYXNrZWRDb250ZXh0KTt9dmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz1jdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczt2YXIgaGFzTmV3TGlmZWN5Y2xlcz10eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT09J2Z1bmN0aW9uJzsvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4vLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbi8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKCFoYXNOZXdMaWZlY3ljbGVzJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM9PT0nZnVuY3Rpb24nKSl7aWYodW5yZXNvbHZlZE9sZFByb3BzIT09dW5yZXNvbHZlZE5ld1Byb3BzfHxvbGRDb250ZXh0IT09bmV4dENvbnRleHQpe2NhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLGluc3RhbmNlLG5ld1Byb3BzLG5leHRDb250ZXh0KTt9fXJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7dmFyIG9sZFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIG5ld1N0YXRlPWluc3RhbmNlLnN0YXRlPW9sZFN0YXRlO3Byb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyxuZXdQcm9wcyxpbnN0YW5jZSxyZW5kZXJMYW5lcyk7bmV3U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtpZih1bnJlc29sdmVkT2xkUHJvcHM9PT11bnJlc29sdmVkTmV3UHJvcHMmJm9sZFN0YXRlPT09bmV3U3RhdGUmJiFoYXNDb250ZXh0Q2hhbmdlZCgpJiYhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpJiYhZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbil7Ly8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4vLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuaWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZT09PSdmdW5jdGlvbicpe2lmKHVucmVzb2x2ZWRPbGRQcm9wcyE9PWN1cnJlbnQubWVtb2l6ZWRQcm9wc3x8b2xkU3RhdGUhPT1jdXJyZW50Lm1lbW9pemVkU3RhdGUpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fX1pZih0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXtpZih1bnJlc29sdmVkT2xkUHJvcHMhPT1jdXJyZW50Lm1lbW9pemVkUHJvcHN8fG9sZFN0YXRlIT09Y3VycmVudC5tZW1vaXplZFN0YXRlKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U25hcHNob3Q7fX1yZXR1cm4gZmFsc2U7fWlmKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PT0nZnVuY3Rpb24nKXthcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcyxjdG9yLGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxuZXdQcm9wcyk7bmV3U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt9dmFyIHNob3VsZFVwZGF0ZT1jaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCl8fGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLGN0b3Isb2xkUHJvcHMsbmV3UHJvcHMsb2xkU3RhdGUsbmV3U3RhdGUsbmV4dENvbnRleHQpfHwvLyBUT0RPOiBJbiBzb21lIGNhc2VzLCB3ZSdsbCBlbmQgdXAgY2hlY2tpbmcgaWYgY29udGV4dCBoYXMgY2hhbmdlZCB0d2ljZSxcbi8vIGJvdGggYmVmb3JlIGFuZCBhZnRlciBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBoYXMgYmVlbiBjYWxsZWQuIE5vdCBpZGVhbCxcbi8vIGJ1dCBJJ20gbG9hdGggdG8gcmVmYWN0b3IgdGhpcyBmdW5jdGlvbi4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIG1lbW9pemVkXG4vLyBjb21wb25lbnRzIHNvIGl0J3Mgbm90IHRoYXQgY29tbW9uLlxuZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbjtpZihzaG91bGRVcGRhdGUpey8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbmlmKCFoYXNOZXdMaWZlY3ljbGVzJiYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJ3x8dHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGU9PT0nZnVuY3Rpb24nKSl7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGU9PT0nZnVuY3Rpb24nKXtpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLG5ld1N0YXRlLG5leHRDb250ZXh0KTt9aWYodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlPT09J2Z1bmN0aW9uJyl7aW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsbmV3U3RhdGUsbmV4dENvbnRleHQpO319aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZT09PSdmdW5jdGlvbicpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fWlmKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZT09PSdmdW5jdGlvbicpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1TbmFwc2hvdDt9fWVsc2V7Ly8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4vLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuaWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZT09PSdmdW5jdGlvbicpe2lmKHVucmVzb2x2ZWRPbGRQcm9wcyE9PWN1cnJlbnQubWVtb2l6ZWRQcm9wc3x8b2xkU3RhdGUhPT1jdXJyZW50Lm1lbW9pemVkU3RhdGUpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fX1pZih0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PT0nZnVuY3Rpb24nKXtpZih1bnJlc29sdmVkT2xkUHJvcHMhPT1jdXJyZW50Lm1lbW9pemVkUHJvcHN8fG9sZFN0YXRlIT09Y3VycmVudC5tZW1vaXplZFN0YXRlKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U25hcHNob3Q7fX0vLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4vLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcz1uZXdQcm9wczt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW5ld1N0YXRlO30vLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4vLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbmluc3RhbmNlLnByb3BzPW5ld1Byb3BzO2luc3RhbmNlLnN0YXRlPW5ld1N0YXRlO2luc3RhbmNlLmNvbnRleHQ9bmV4dENvbnRleHQ7cmV0dXJuIHNob3VsZFVwZGF0ZTt9ZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsc291cmNlKXsvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbi8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbnJldHVybnt2YWx1ZTp2YWx1ZSxzb3VyY2U6c291cmNlLHN0YWNrOmdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpLGRpZ2VzdDpudWxsfTt9ZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSxkaWdlc3Qsc3RhY2spe3JldHVybnt2YWx1ZTp2YWx1ZSxzb3VyY2U6bnVsbCxzdGFjazpzdGFjayE9bnVsbD9zdGFjazpudWxsLGRpZ2VzdDpkaWdlc3QhPW51bGw/ZGlnZXN0Om51bGx9O30vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSxlcnJvckluZm8pe3JldHVybiB0cnVlO31mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGJvdW5kYXJ5LGVycm9ySW5mbyl7dHJ5e3ZhciBsb2dFcnJvcj1zaG93RXJyb3JEaWFsb2coYm91bmRhcnksZXJyb3JJbmZvKTsvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuaWYobG9nRXJyb3I9PT1mYWxzZSl7cmV0dXJuO312YXIgZXJyb3I9ZXJyb3JJbmZvLnZhbHVlO2lmKHRydWUpe3ZhciBzb3VyY2U9ZXJyb3JJbmZvLnNvdXJjZTt2YXIgc3RhY2s9ZXJyb3JJbmZvLnN0YWNrO3ZhciBjb21wb25lbnRTdGFjaz1zdGFjayE9PW51bGw/c3RhY2s6Jyc7Ly8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbi8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5pZihlcnJvciE9bnVsbCYmZXJyb3IuX3N1cHByZXNzTG9nZ2luZyl7aWYoYm91bmRhcnkudGFnPT09Q2xhc3NDb21wb25lbnQpey8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4vLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbnJldHVybjt9Ly8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbi8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4vLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbmNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOy8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxufXZhciBjb21wb25lbnROYW1lPXNvdXJjZT9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHNvdXJjZSk6bnVsbDt2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2U9Y29tcG9uZW50TmFtZT9cIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiK2NvbXBvbmVudE5hbWUrXCI+IGNvbXBvbmVudDpcIjonVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6Jzt2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7aWYoYm91bmRhcnkudGFnPT09SG9zdFJvb3Qpe2Vycm9yQm91bmRhcnlNZXNzYWdlPSdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nKydWaXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJzt9ZWxzZXt2YXIgZXJyb3JCb3VuZGFyeU5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSl8fCdBbm9ueW1vdXMnO2Vycm9yQm91bmRhcnlNZXNzYWdlPVwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggXCIrKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIrZXJyb3JCb3VuZGFyeU5hbWUrXCIuXCIpO312YXIgY29tYmluZWRNZXNzYWdlPWNvbXBvbmVudE5hbWVNZXNzYWdlK1wiXFxuXCIrY29tcG9uZW50U3RhY2srXCJcXG5cXG5cIisoXCJcIitlcnJvckJvdW5kYXJ5TWVzc2FnZSk7Ly8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG5jb25zb2xlWydlcnJvciddKGNvbWJpbmVkTWVzc2FnZSk7Ly8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG59ZWxzZXsvLyBJbiBwcm9kdWN0aW9uLCB3ZSBwcmludCB0aGUgZXJyb3IgZGlyZWN0bHkuXG4vLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbi8vIFdlIHBhc3MgdGhlIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBtZXNzYWdlIHNvIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGxheXMgdGhlIGVycm9yIG5hdGl2ZWx5LlxuY29uc29sZVsnZXJyb3InXShlcnJvcik7Ly8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG59fWNhdGNoKGUpey8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4vLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbi8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9KTt9fXZhciBQb3NzaWJseVdlYWtNYXAkMT10eXBlb2YgV2Vha01hcD09PSdmdW5jdGlvbic/V2Vha01hcDpNYXA7ZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLGVycm9ySW5mbyxsYW5lKXt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxsYW5lKTsvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxudXBkYXRlLnRhZz1DYXB0dXJlVXBkYXRlOy8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbi8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbnVwZGF0ZS5wYXlsb2FkPXtlbGVtZW50Om51bGx9O3ZhciBlcnJvcj1lcnJvckluZm8udmFsdWU7dXBkYXRlLmNhbGxiYWNrPWZ1bmN0aW9uKCl7b25VbmNhdWdodEVycm9yKGVycm9yKTtsb2dDYXB0dXJlZEVycm9yKGZpYmVyLGVycm9ySW5mbyk7fTtyZXR1cm4gdXBkYXRlO31mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLGVycm9ySW5mbyxsYW5lKXt2YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCxsYW5lKTt1cGRhdGUudGFnPUNhcHR1cmVVcGRhdGU7dmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj1maWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtpZih0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yPT09J2Z1bmN0aW9uJyl7dmFyIGVycm9yJDE9ZXJyb3JJbmZvLnZhbHVlO3VwZGF0ZS5wYXlsb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvciQxKTt9O3VwZGF0ZS5jYWxsYmFjaz1mdW5jdGlvbigpe3ttYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7fWxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsZXJyb3JJbmZvKTt9O312YXIgaW5zdD1maWJlci5zdGF0ZU5vZGU7aWYoaW5zdCE9PW51bGwmJnR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoPT09J2Z1bmN0aW9uJyl7dXBkYXRlLmNhbGxiYWNrPWZ1bmN0aW9uIGNhbGxiYWNrKCl7e21hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTt9bG9nQ2FwdHVyZWRFcnJvcihmaWJlcixlcnJvckluZm8pO2lmKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IhPT0nZnVuY3Rpb24nKXsvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbi8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbi8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbi8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzXG4vLyBub3QgZGVmaW5lZC5cbm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7fXZhciBlcnJvciQxPWVycm9ySW5mby52YWx1ZTt2YXIgc3RhY2s9ZXJyb3JJbmZvLnN0YWNrO3RoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSx7Y29tcG9uZW50U3RhY2s6c3RhY2shPT1udWxsP3N0YWNrOicnfSk7e2lmKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IhPT0nZnVuY3Rpb24nKXsvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbi8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGlzIHNjaGVkdWxlZCB0aGVuIHRoZSBib3VuZGFyeSB3aWxsIHN3YWxsb3cgdGhlIGVycm9yLlxuaWYoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsU3luY0xhbmUpKXtlcnJvcignJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gJysnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKXx8J1Vua25vd24nKTt9fX19O31yZXR1cm4gdXBkYXRlO31mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCx3YWtlYWJsZSxsYW5lcyl7Ly8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuLy9cbi8vIFRoZSBkYXRhIG1pZ2h0IHJlc29sdmUgYmVmb3JlIHdlIGhhdmUgYSBjaGFuY2UgdG8gY29tbWl0IHRoZSBmYWxsYmFjay4gT3IsXG4vLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG4vLyBhdHRhY2ggYSBsaXN0ZW5lciBub3cuIFdoZW4gaXQgcmVzb2x2ZXMgKFwicGluZ3NcIiksIHdlIGNhbiBkZWNpZGUgd2hldGhlciB0b1xuLy8gdHJ5IHJlbmRlcmluZyB0aGUgdHJlZSBhZ2Fpbi5cbi8vXG4vLyBPbmx5IGF0dGFjaCBhIGxpc3RlbmVyIGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGZvciB0aGUgbGFuZXNcbi8vIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4vL1xuLy8gV2Ugb25seSBuZWVkIHRvIGRvIHRoaXMgaW4gY29uY3VycmVudCBtb2RlLiBMZWdhY3kgU3VzcGVuc2UgYWx3YXlzXG4vLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG52YXIgcGluZ0NhY2hlPXJvb3QucGluZ0NhY2hlO3ZhciB0aHJlYWRJRHM7aWYocGluZ0NhY2hlPT09bnVsbCl7cGluZ0NhY2hlPXJvb3QucGluZ0NhY2hlPW5ldyBQb3NzaWJseVdlYWtNYXAkMSgpO3RocmVhZElEcz1uZXcgU2V0KCk7cGluZ0NhY2hlLnNldCh3YWtlYWJsZSx0aHJlYWRJRHMpO31lbHNle3RocmVhZElEcz1waW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtpZih0aHJlYWRJRHM9PT11bmRlZmluZWQpe3RocmVhZElEcz1uZXcgU2V0KCk7cGluZ0NhY2hlLnNldCh3YWtlYWJsZSx0aHJlYWRJRHMpO319aWYoIXRocmVhZElEcy5oYXMobGFuZXMpKXsvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxudGhyZWFkSURzLmFkZChsYW5lcyk7dmFyIHBpbmc9cGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLHJvb3Qsd2FrZWFibGUsbGFuZXMpO3tpZihpc0RldlRvb2xzUHJlc2VudCl7Ly8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG5yZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsbGFuZXMpO319d2FrZWFibGUudGhlbihwaW5nLHBpbmcpO319ZnVuY3Rpb24gYXR0YWNoUmV0cnlMaXN0ZW5lcihzdXNwZW5zZUJvdW5kYXJ5LHJvb3Qsd2FrZWFibGUsbGFuZXMpey8vIFJldHJ5IGxpc3RlbmVyXG4vL1xuLy8gSWYgdGhlIGZhbGxiYWNrIGRvZXMgY29tbWl0LCB3ZSBuZWVkIHRvIGF0dGFjaCBhIGRpZmZlcmVudCB0eXBlIG9mXG4vLyBsaXN0ZW5lci4gVGhpcyBvbmUgc2NoZWR1bGVzIGFuIHVwZGF0ZSBvbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgdG8gdHVyblxuLy8gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cbi8vXG4vLyBTdGFzaCB0aGUgd2FrZWFibGUgb24gdGhlIGJvdW5kYXJ5IGZpYmVyIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGhlXG4vLyBjb21taXQgcGhhc2UuXG4vL1xuLy8gV2hlbiB0aGUgd2FrZWFibGUgcmVzb2x2ZXMsIHdlJ2xsIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBib3VuZGFyeVxuLy8gYWdhaW4gKFwicmV0cnlcIikuXG52YXIgd2FrZWFibGVzPXN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU7aWYod2FrZWFibGVzPT09bnVsbCl7dmFyIHVwZGF0ZVF1ZXVlPW5ldyBTZXQoKTt1cGRhdGVRdWV1ZS5hZGQod2FrZWFibGUpO3N1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU9dXBkYXRlUXVldWU7fWVsc2V7d2FrZWFibGVzLmFkZCh3YWtlYWJsZSk7fX1mdW5jdGlvbiByZXNldFN1c3BlbmRlZENvbXBvbmVudChzb3VyY2VGaWJlcixyb290UmVuZGVyTGFuZXMpey8vIEEgbGVnYWN5IG1vZGUgU3VzcGVuc2UgcXVpcmssIG9ubHkgcmVsZXZhbnQgdG8gaG9vayBjb21wb25lbnRzLlxudmFyIHRhZz1zb3VyY2VGaWJlci50YWc7aWYoKHNvdXJjZUZpYmVyLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlJiYodGFnPT09RnVuY3Rpb25Db21wb25lbnR8fHRhZz09PUZvcndhcmRSZWZ8fHRhZz09PVNpbXBsZU1lbW9Db21wb25lbnQpKXt2YXIgY3VycmVudFNvdXJjZT1zb3VyY2VGaWJlci5hbHRlcm5hdGU7aWYoY3VycmVudFNvdXJjZSl7c291cmNlRmliZXIudXBkYXRlUXVldWU9Y3VycmVudFNvdXJjZS51cGRhdGVRdWV1ZTtzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlPWN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtzb3VyY2VGaWJlci5sYW5lcz1jdXJyZW50U291cmNlLmxhbmVzO31lbHNle3NvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlPW51bGw7c291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZT1udWxsO319fWZ1bmN0aW9uIGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKXt2YXIgbm9kZT1yZXR1cm5GaWJlcjtkb3tpZihub2RlLnRhZz09PVN1c3BlbnNlQ29tcG9uZW50JiZzaG91bGRDYXB0dXJlU3VzcGVuc2Uobm9kZSkpe3JldHVybiBub2RlO30vLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuLy8gYm91bmRhcnkuXG5ub2RlPW5vZGUucmV0dXJuO313aGlsZShub2RlIT09bnVsbCk7cmV0dXJuIG51bGw7fWZ1bmN0aW9uIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LHJldHVybkZpYmVyLHNvdXJjZUZpYmVyLHJvb3Qscm9vdFJlbmRlckxhbmVzKXsvLyBUaGlzIG1hcmtzIGEgU3VzcGVuc2UgYm91bmRhcnkgc28gdGhhdCB3aGVuIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2ssXG4vLyBpdCBjYXB0dXJlcyB0aGUgc3VzcGVuZGVkIFwiZXhjZXB0aW9uXCIgYW5kIGRvZXMgYSBzZWNvbmQgKGZhbGxiYWNrKSBwYXNzLlxuaWYoKHN1c3BlbnNlQm91bmRhcnkubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpey8vIExlZ2FjeSBNb2RlIFN1c3BlbnNlXG4vL1xuLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIGluIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbi8vIHN1c3BlbmQgdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZFxuLy8gbnVsbCBhbmQga2VlcCByZW5kZXJpbmcuIFdoZW4gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IGNvbXBsZXRlcyxcbi8vIHdlJ2xsIGRvIGEgc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbmlmKHN1c3BlbnNlQm91bmRhcnk9PT1yZXR1cm5GaWJlcil7Ly8gU3BlY2lhbCBjYXNlIHdoZXJlIHdlIHN1c3BlbmRlZCB3aGlsZSByZWNvbmNpbGluZyB0aGUgY2hpbGRyZW4gb2Zcbi8vIGEgU3VzcGVuc2UgYm91bmRhcnkncyBpbm5lciBPZmZzY3JlZW4gd3JhcHBlciBmaWJlci4gVGhpcyBoYXBwZW5zXG4vLyB3aGVuIGEgUmVhY3QubGF6eSBjb21wb25lbnQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuLy8gU3VzcGVuc2UgYm91bmRhcnkuXG4vL1xuLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgaW1wbGVtZW50ZWQgYXMgbXVsdGlwbGUgZmliZXJzLCBidXQgdGhleVxuLy8gYXJlIGEgc2luZ2xlIGNvbmNlcHR1YWwgdW5pdC4gVGhlIGxlZ2FjeSBtb2RlIGJlaGF2aW9yIHdoZXJlIHdlXG4vLyBwcmV0ZW5kIHRoZSBzdXNwZW5kZWQgZmliZXIgY29tbWl0dGVkIGFzIGBudWxsYCB3b24ndCB3b3JrLFxuLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UgdGhlIFwic3VzcGVuZGVkXCIgZmliZXIgaXMgdGhlIGlubmVyXG4vLyBPZmZzY3JlZW4gd3JhcHBlci5cbi8vXG4vLyBCZWNhdXNlIHRoZSBjb250ZW50cyBvZiB0aGUgYm91bmRhcnkgaGF2ZW4ndCBzdGFydGVkIHJlbmRlcmluZ1xuLy8geWV0IChpLmUuIG5vdGhpbmcgaW4gdGhlIHRyZWUgaGFzIHBhcnRpYWxseSByZW5kZXJlZCkgd2UgY2FuXG4vLyBzd2l0Y2ggdG8gdGhlIHJlZ3VsYXIsIGNvbmN1cnJlbnQgbW9kZSBiZWhhdmlvcjogbWFyayB0aGVcbi8vIGJvdW5kYXJ5IHdpdGggU2hvdWxkQ2FwdHVyZSBhbmQgZW50ZXIgdGhlIHVud2luZCBwaGFzZS5cbnN1c3BlbnNlQm91bmRhcnkuZmxhZ3N8PVNob3VsZENhcHR1cmU7fWVsc2V7c3VzcGVuc2VCb3VuZGFyeS5mbGFnc3w9RGlkQ2FwdHVyZTtzb3VyY2VGaWJlci5mbGFnc3w9Rm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZTsvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4vLyBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yIGNhbGxiYWNrcy4gUmVtb3ZlXG4vLyBhbGwgbGlmZWN5Y2xlIGVmZmVjdCB0YWdzLlxuc291cmNlRmliZXIuZmxhZ3MmPX4oTGlmZWN5Y2xlRWZmZWN0TWFza3xJbmNvbXBsZXRlKTtpZihzb3VyY2VGaWJlci50YWc9PT1DbGFzc0NvbXBvbmVudCl7dmFyIGN1cnJlbnRTb3VyY2VGaWJlcj1zb3VyY2VGaWJlci5hbHRlcm5hdGU7aWYoY3VycmVudFNvdXJjZUZpYmVyPT09bnVsbCl7Ly8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbi8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbi8vIGNvbXBvbmVudFdpbGxVbm1vdW50IGlmIGl0IGlzIGRlbGV0ZWQuXG5zb3VyY2VGaWJlci50YWc9SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O31lbHNley8vIFdoZW4gd2UgdHJ5IHJlbmRlcmluZyBhZ2Fpbiwgd2Ugc2hvdWxkIG5vdCByZXVzZSB0aGUgY3VycmVudCBmaWJlcixcbi8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbi8vIHByZXZlbnQgYSBiYWlsIG91dC5cbnZhciB1cGRhdGU9Y3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLFN5bmNMYW5lKTt1cGRhdGUudGFnPUZvcmNlVXBkYXRlO2VucXVldWVVcGRhdGUoc291cmNlRmliZXIsdXBkYXRlLFN5bmNMYW5lKTt9fS8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbi8vIGluZGljYXRlIHRoYXQgaXQgc3RpbGwgaGFzIHBlbmRpbmcgd29yay5cbnNvdXJjZUZpYmVyLmxhbmVzPW1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsU3luY0xhbmUpO31yZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTt9Ly8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4vLyB3aXRoIHRoZSBub3JtYWwgc3VzcGVuZCBwYXRoLlxuLy9cbi8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuLy8gcmVuZGVyIHBhc3Mgd2lsbCBydW4gdG8gY29tcGxldGlvbiBvciByZXN0YXJ0IG9yIFwic3VzcGVuZFwiIHRoZSBjb21taXQuXG4vLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbi8vXG4vLyBUaGlzIGZpcnN0IHByaW5jaXBsZSBpcyB0aGF0IGlmIHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2hlbiB3ZSBjb21wbGV0ZVxuLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbi8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4vLyBiZWNhdXNlIHlvdSB0aGluayB5b3UgbWlnaHQgd2FudCB0byByZXN0YXJ0IGJlZm9yZSBjb21taXR0aW5nLiBIb3dldmVyLFxuLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbi8vXG4vLyBSZXN0YXJ0aW5nIHRvbyBhZ2dyZXNzaXZlbHkgaXMgYWxzbyBub3QgZ29vZCBiZWNhdXNlIGl0IHN0YXJ2ZXMgb3V0IGFueVxuLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuLy9cbi8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbi8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuLy9cbi8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbi8vIHRoYXQgd2UgY2FuIHNob3cgdGhlIGluaXRpYWwgbG9hZGluZyBzdGF0ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuLy9cbi8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4vLyBhIGZhbGxiYWNrLCB0aGVuIHdlIHNob3VsZCBhbHdheXMgc3VzcGVuZC9yZXN0YXJ0LiBUcmFuc2l0aW9ucyBhcHBseVxuLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4vL1xuLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgYW5kIGl0IGdldHMgXCJyZXRyaWVkXCIsIGFsbG93aW5nIHVzIHRvIHNob3dcbi8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbi8vIGFueXdoZXJlIGluIHRoZSB0cmVlLiBUaGlzIGVmZmVjdGl2ZWx5IHRocm90dGxlcyBwcm9ncmVzc2l2ZSBsb2FkaW5nIGludG8gYVxuLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbi8vXG4vLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuLy9cbi8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbi8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cbnN1c3BlbnNlQm91bmRhcnkuZmxhZ3N8PVNob3VsZENhcHR1cmU7Ly8gVE9ETzogSSB0aGluayB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIG5vdyB1c2UgYERpZENhcHR1cmVgIGluXG4vLyB0aGUgYmVnaW4gcGhhc2UgdG8gcHJldmVudCBhbiBlYXJseSBiYWlsb3V0Llxuc3VzcGVuc2VCb3VuZGFyeS5sYW5lcz1yb290UmVuZGVyTGFuZXM7cmV0dXJuIHN1c3BlbnNlQm91bmRhcnk7fWZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKHJvb3QscmV0dXJuRmliZXIsc291cmNlRmliZXIsdmFsdWUscm9vdFJlbmRlckxhbmVzKXsvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuXG5zb3VyY2VGaWJlci5mbGFnc3w9SW5jb21wbGV0ZTt7aWYoaXNEZXZUb29sc1ByZXNlbnQpey8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCByZXN0b3JlIHRoZSBvcmlnaW5hbCB1cGRhdGVyc1xucmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LHJvb3RSZW5kZXJMYW5lcyk7fX1pZih2YWx1ZSE9PW51bGwmJnR5cGVvZiB2YWx1ZT09PSdvYmplY3QnJiZ0eXBlb2YgdmFsdWUudGhlbj09PSdmdW5jdGlvbicpey8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG52YXIgd2FrZWFibGU9dmFsdWU7cmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO3tpZihnZXRJc0h5ZHJhdGluZygpJiZzb3VyY2VGaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKXttYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO319dmFyIHN1c3BlbnNlQm91bmRhcnk9Z2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpO2lmKHN1c3BlbnNlQm91bmRhcnkhPT1udWxsKXtzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzJj1+Rm9yY2VDbGllbnRSZW5kZXI7bWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnkscmV0dXJuRmliZXIsc291cmNlRmliZXIscm9vdCxyb290UmVuZGVyTGFuZXMpOy8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuaWYoc3VzcGVuc2VCb3VuZGFyeS5tb2RlJkNvbmN1cnJlbnRNb2RlKXthdHRhY2hQaW5nTGlzdGVuZXIocm9vdCx3YWtlYWJsZSxyb290UmVuZGVyTGFuZXMpO31hdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnkscm9vdCx3YWtlYWJsZSk7cmV0dXJuO31lbHNley8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gVW5sZXNzIHRoaXMgaXMgYSBzeW5jIHVwZGF0ZSwgdGhpcyBpcyBPSy5cbi8vIFdlIGNhbiBzdXNwZW5kIGFuZCB3YWl0IGZvciBtb3JlIGRhdGEgdG8gYXJyaXZlLlxuaWYoIWluY2x1ZGVzU3luY0xhbmUocm9vdFJlbmRlckxhbmVzKSl7Ly8gVGhpcyBpcyBub3QgYSBzeW5jIHVwZGF0ZS4gU3VzcGVuZC4gU2luY2Ugd2UncmUgbm90IGFjdGl2YXRpbmcgYVxuLy8gU3VzcGVuc2UgYm91bmRhcnksIHRoaXMgd2lsbCB1bndpbmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3Qgd2l0aG91dFxuLy8gcGVyZm9ybWluZyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciBhIGZhbGxiYWNrLiAoVGhpcyBpcyBhcmd1YWJseSBob3dcbi8vIHJlZnJlc2ggdHJhbnNpdGlvbnMgc2hvdWxkIHdvcmssIHRvbywgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIGNvbW1pdFxuLy8gdGhlIGZhbGxiYWNrcyBhbnl3YXkuKVxuLy9cbi8vIFRoaXMgY2FzZSBhbHNvIGFwcGxpZXMgdG8gaW5pdGlhbCBoeWRyYXRpb24uXG5hdHRhY2hQaW5nTGlzdGVuZXIocm9vdCx3YWtlYWJsZSxyb290UmVuZGVyTGFuZXMpO3JlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtyZXR1cm47fS8vIFRoaXMgaXMgYSBzeW5jL2Rpc2NyZXRlIHVwZGF0ZS4gV2UgdHJlYXQgdGhpcyBjYXNlIGxpa2UgYW4gZXJyb3Jcbi8vIGJlY2F1c2UgZGlzY3JldGUgcmVuZGVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIGNvbXBsZXRlIHRyZWVcbi8vIHN5bmNocm9ub3VzbHkgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgd2l0aCBleHRlcm5hbCBzdGF0ZS5cbnZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3I9bmV3IEVycm9yKCdBIGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVzcG9uZGluZyB0byBzeW5jaHJvbm91cyBpbnB1dC4gVGhpcyAnKyd3aWxsIGNhdXNlIHRoZSBVSSB0byBiZSByZXBsYWNlZCB3aXRoIGEgbG9hZGluZyBpbmRpY2F0b3IuIFRvICcrJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJysnd2l0aCBzdGFydFRyYW5zaXRpb24uJyk7Ly8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuLy8gVGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IHN1c3BlbnNlIGJvdW5kYXJ5LlxudmFsdWU9dW5jYXVnaHRTdXNwZW5zZUVycm9yO319ZWxzZXsvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvciwgbm90IGEgU3VzcGVuc2Ugd2FrZWFibGUuXG5pZihnZXRJc0h5ZHJhdGluZygpJiZzb3VyY2VGaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKXttYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO3ZhciBfc3VzcGVuc2VCb3VuZGFyeT1nZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcik7Ly8gSWYgdGhlIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIGh5ZHJhdGlvbiwgd2UgbWF5IGJlIGFibGUgdG8gcmVjb3ZlciBieVxuLy8gZGlzY2FyZGluZyB0aGUgZGVoeWRyYXRlZCBjb250ZW50IGFuZCBzd2l0Y2hpbmcgdG8gYSBjbGllbnQgcmVuZGVyLlxuLy8gSW5zdGVhZCBvZiBzdXJmYWNpbmcgdGhlIGVycm9yLCBmaW5kIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBhbmQgcmVuZGVyIGl0IGFnYWluIHdpdGhvdXQgaHlkcmF0aW9uLlxuaWYoX3N1c3BlbnNlQm91bmRhcnkhPT1udWxsKXtpZigoX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MmU2hvdWxkQ2FwdHVyZSk9PT1Ob0ZsYWdzKXsvLyBTZXQgYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgd2Ugc2hvdWxkIHRyeSByZW5kZXJpbmcgdGhlIG5vcm1hbFxuLy8gY2hpbGRyZW4gYWdhaW4sIG5vdCB0aGUgZmFsbGJhY2suXG5fc3VzcGVuc2VCb3VuZGFyeS5mbGFnc3w9Rm9yY2VDbGllbnRSZW5kZXI7fW1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSxyZXR1cm5GaWJlcixzb3VyY2VGaWJlcixyb290LHJvb3RSZW5kZXJMYW5lcyk7Ly8gRXZlbiB0aG91Z2ggdGhlIHVzZXIgbWF5IG5vdCBiZSBhZmZlY3RlZCBieSB0aGlzIGVycm9yLCB3ZSBzaG91bGRcbi8vIHN0aWxsIGxvZyBpdCBzbyBpdCBjYW4gYmUgZml4ZWQuXG5xdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLHNvdXJjZUZpYmVyKSk7cmV0dXJuO319fXZhbHVlPWNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLHNvdXJjZUZpYmVyKTtyZW5kZXJEaWRFcnJvcih2YWx1ZSk7Ly8gV2UgZGlkbid0IGZpbmQgYSBib3VuZGFyeSB0aGF0IGNvdWxkIGhhbmRsZSB0aGlzIHR5cGUgb2YgZXhjZXB0aW9uLiBTdGFydFxuLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4vLyBhcyBhbiBlcnJvci5cbnZhciB3b3JrSW5Qcm9ncmVzcz1yZXR1cm5GaWJlcjtkb3tzd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIEhvc3RSb290Ont2YXIgX2Vycm9ySW5mbz12YWx1ZTt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9U2hvdWxkQ2FwdHVyZTt2YXIgbGFuZT1waWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLmxhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsbGFuZSk7dmFyIHVwZGF0ZT1jcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsX2Vycm9ySW5mbyxsYW5lKTtlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsdXBkYXRlKTtyZXR1cm47fWNhc2UgQ2xhc3NDb21wb25lbnQ6Ly8gQ2FwdHVyZSBhbmQgcmV0cnlcbnZhciBlcnJvckluZm89dmFsdWU7dmFyIGN0b3I9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO2lmKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3MmJih0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9PT0nZnVuY3Rpb24nfHxpbnN0YW5jZSE9PW51bGwmJnR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaD09PSdmdW5jdGlvbicmJiFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpe3dvcmtJblByb2dyZXNzLmZsYWdzfD1TaG91bGRDYXB0dXJlO3ZhciBfbGFuZT1waWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLmxhbmVzPW1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsX2xhbmUpOy8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxudmFyIF91cGRhdGU9Y3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxlcnJvckluZm8sX2xhbmUpO2VucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyxfdXBkYXRlKTtyZXR1cm47fWJyZWFrO313b3JrSW5Qcm9ncmVzcz13b3JrSW5Qcm9ncmVzcy5yZXR1cm47fXdoaWxlKHdvcmtJblByb2dyZXNzIT09bnVsbCk7fWZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCl7e3JldHVybiBudWxsO30vLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgc3VzcGVuZHMuIEl0IHJldHVybnMgdGhlXG59dmFyIFJlYWN0Q3VycmVudE93bmVyJDE9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7dmFyIGRpZFJlY2VpdmVVcGRhdGU9ZmFsc2U7dmFyIGRpZFdhcm5BYm91dEJhZENsYXNzO3ZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50O3ZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7dmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQ7dmFyIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmczt2YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wczt2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXI7dmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zO3ZhciBkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50O3tkaWRXYXJuQWJvdXRCYWRDbGFzcz17fTtkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50PXt9O2RpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudD17fTtkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50PXt9O2RpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcz17fTtkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzPWZhbHNlO2RpZFdhcm5BYm91dFJldmVhbE9yZGVyPXt9O2RpZFdhcm5BYm91dFRhaWxPcHRpb25zPXt9O2RpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnQ9e307fWZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKXtpZihjdXJyZW50PT09bnVsbCl7Ly8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4vLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbi8vIHdlIHdpbGwgYWRkIHRoZW0gYWxsIHRvIHRoZSBjaGlsZCBiZWZvcmUgaXQgZ2V0cyByZW5kZXJlZC4gVGhhdCBtZWFuc1xuLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxud29ya0luUHJvZ3Jlc3MuY2hpbGQ9bW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxudWxsLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fWVsc2V7Ly8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbi8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4vLyB0aGUgY2xvbmUgYWxnb3JpdGhtIHRvIGNyZWF0ZSBhIGNvcHkgb2YgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuLlxuLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbi8vIGxldCdzIHRocm93IGl0IG91dC5cbndvcmtJblByb2dyZXNzLmNoaWxkPXJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLGN1cnJlbnQuY2hpbGQsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9fWZ1bmN0aW9uIGZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpey8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG4vLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4vLyBlZmZlY3Qgb2YgYWxsIGN1cnJlbnQgY2hpbGRyZW4gYmVpbmcgdW5tb3VudGVkOyBldmVuIGlmIHRoZSB0eXBlIGFuZCBrZXlcbi8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG4vL1xuLy8gVG8gZG8gdGhpcywgd2UncmUgZ29pbmcgdG8gZ28gdGhyb3VnaCB0aGUgcmVjb25jaWxlIGFsZ29yaXRobSB0d2ljZS4gSW5cbi8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcbi8vIHBhc3NpbmcgbnVsbC5cbndvcmtJblByb2dyZXNzLmNoaWxkPXJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLGN1cnJlbnQuY2hpbGQsbnVsbCxyZW5kZXJMYW5lcyk7Ly8gSW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBtb3VudCB0aGUgbmV3IGNoaWxkcmVuLiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0IHdlXG4vLyBwYXNzIG51bGwgaW4gcGxhY2Ugb2Ygd2hlcmUgd2UgdXN1YWxseSBwYXNzIHRoZSBjdXJyZW50IGNoaWxkIHNldC4gVGhpcyBoYXNcbi8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4vLyBpZGVudGl0aWVzIG1hdGNoLlxud29ya0luUHJvZ3Jlc3MuY2hpbGQ9cmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsbnVsbCxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO31mdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyl7Ly8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbi8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgc3VzcGVuZHMuXG4vLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG57aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIGlubmVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYoaW5uZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTt9fX12YXIgcmVuZGVyPUNvbXBvbmVudC5yZW5kZXI7dmFyIHJlZj13b3JrSW5Qcm9ncmVzcy5yZWY7Ly8gVGhlIHJlc3QgaXMgYSBmb3JrIG9mIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50XG52YXIgbmV4dENoaWxkcmVuO3ZhciBoYXNJZDtwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9e1JlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudD13b3JrSW5Qcm9ncmVzcztzZXRJc1JlbmRlcmluZyh0cnVlKTtuZXh0Q2hpbGRyZW49cmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyLG5leHRQcm9wcyxyZWYscmVuZGVyTGFuZXMpO2hhc0lkPWNoZWNrRGlkUmVuZGVySWRIb29rKCk7aWYod29ya0luUHJvZ3Jlc3MubW9kZSZTdHJpY3RMZWdhY3lNb2RlKXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTt0cnl7bmV4dENoaWxkcmVuPXJlbmRlcldpdGhIb29rcyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlcixuZXh0UHJvcHMscmVmLHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fXNldElzUmVuZGVyaW5nKGZhbHNlKTt9e21hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7fWlmKGN1cnJlbnQhPT1udWxsJiYhZGlkUmVjZWl2ZVVwZGF0ZSl7YmFpbG91dEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31pZihnZXRJc0h5ZHJhdGluZygpJiZoYXNJZCl7cHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7fS8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1QZXJmb3JtZWRXb3JrO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXtpZihjdXJyZW50PT09bnVsbCl7dmFyIHR5cGU9Q29tcG9uZW50LnR5cGU7aWYoaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSYmQ29tcG9uZW50LmNvbXBhcmU9PT1udWxsJiYvLyBTaW1wbGVNZW1vQ29tcG9uZW50IGNvZGVwYXRoIGRvZXNuJ3QgcmVzb2x2ZSBvdXRlciBwcm9wcyBlaXRoZXIuXG5Db21wb25lbnQuZGVmYXVsdFByb3BzPT09dW5kZWZpbmVkKXt2YXIgcmVzb2x2ZWRUeXBlPXR5cGU7e3Jlc29sdmVkVHlwZT1yZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7fS8vIElmIHRoaXMgaXMgYSBwbGFpbiBmdW5jdGlvbiBjb21wb25lbnQgd2l0aG91dCBkZWZhdWx0IHByb3BzLFxuLy8gYW5kIHdpdGggb25seSB0aGUgZGVmYXVsdCBzaGFsbG93IGNvbXBhcmlzb24sIHdlIHVwZ3JhZGUgaXRcbi8vIHRvIGEgU2ltcGxlTWVtb0NvbXBvbmVudCB0byBhbGxvdyBmYXN0IHBhdGggdXBkYXRlcy5cbndvcmtJblByb2dyZXNzLnRhZz1TaW1wbGVNZW1vQ29tcG9uZW50O3dvcmtJblByb2dyZXNzLnR5cGU9cmVzb2x2ZWRUeXBlO3t2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsdHlwZSk7fXJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVzb2x2ZWRUeXBlLG5leHRQcm9wcyxyZW5kZXJMYW5lcyk7fXt2YXIgaW5uZXJQcm9wVHlwZXM9dHlwZS5wcm9wVHlwZXM7aWYoaW5uZXJQcm9wVHlwZXMpey8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4vLyBXZSBjb3VsZCBtb3ZlIGl0IHRoZXJlLCBidXQgd2UnZCBzdGlsbCBuZWVkIHRoaXMgZm9yIGxhenkgY29kZSBwYXRoLlxuY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsbmV4dFByb3BzLC8vIFJlc29sdmVkIHByb3BzXG4ncHJvcCcsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpKTt9aWYoQ29tcG9uZW50LmRlZmF1bHRQcm9wcyE9PXVuZGVmaW5lZCl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpfHwnVW5rbm93bic7aWYoIWRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pe2Vycm9yKCclczogU3VwcG9ydCBmb3IgZGVmYXVsdFByb3BzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIG1lbW8gY29tcG9uZW50cyAnKydpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBVc2UgSmF2YVNjcmlwdCBkZWZhdWx0IHBhcmFtZXRlcnMgaW5zdGVhZC4nLGNvbXBvbmVudE5hbWUpO2RpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV09dHJ1ZTt9fX12YXIgY2hpbGQ9Y3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLG51bGwsbmV4dFByb3BzLHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLm1vZGUscmVuZGVyTGFuZXMpO2NoaWxkLnJlZj13b3JrSW5Qcm9ncmVzcy5yZWY7Y2hpbGQucmV0dXJuPXdvcmtJblByb2dyZXNzO3dvcmtJblByb2dyZXNzLmNoaWxkPWNoaWxkO3JldHVybiBjaGlsZDt9e3ZhciBfdHlwZT1Db21wb25lbnQudHlwZTt2YXIgX2lubmVyUHJvcFR5cGVzPV90eXBlLnByb3BUeXBlcztpZihfaW5uZXJQcm9wVHlwZXMpey8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4vLyBXZSBjb3VsZCBtb3ZlIGl0IHRoZXJlLCBidXQgd2UnZCBzdGlsbCBuZWVkIHRoaXMgZm9yIGxhenkgY29kZSBwYXRoLlxuY2hlY2tQcm9wVHlwZXMoX2lubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShfdHlwZSkpO319dmFyIGN1cnJlbnRDaGlsZD1jdXJyZW50LmNoaWxkOy8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0PWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQscmVuZGVyTGFuZXMpO2lmKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQpey8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4vLyB1bmxpa2UgY3VycmVudC5tZW1vaXplZFByb3BzIHdoaWNoIHdpbGwgYmUgdGhlIHVucmVzb2x2ZWQgb25lcy5cbnZhciBwcmV2UHJvcHM9Y3VycmVudENoaWxkLm1lbW9pemVkUHJvcHM7Ly8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cbnZhciBjb21wYXJlPUNvbXBvbmVudC5jb21wYXJlO2NvbXBhcmU9Y29tcGFyZSE9PW51bGw/Y29tcGFyZTpzaGFsbG93RXF1YWw7aWYoY29tcGFyZShwcmV2UHJvcHMsbmV4dFByb3BzKSYmY3VycmVudC5yZWY9PT13b3JrSW5Qcm9ncmVzcy5yZWYpe3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO319Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7dmFyIG5ld0NoaWxkPWNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCxuZXh0UHJvcHMpO25ld0NoaWxkLnJlZj13b3JrSW5Qcm9ncmVzcy5yZWY7bmV3Q2hpbGQucmV0dXJuPXdvcmtJblByb2dyZXNzO3dvcmtJblByb2dyZXNzLmNoaWxkPW5ld0NoaWxkO3JldHVybiBuZXdDaGlsZDt9ZnVuY3Rpb24gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpey8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4vLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4vLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG57aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIG91dGVyTWVtb1R5cGU9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7aWYob3V0ZXJNZW1vVHlwZS4kJHR5cGVvZj09PVJFQUNUX0xBWllfVFlQRSl7Ly8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuLy8gc28gbGV0J3MganVzdCBza2lwIG92ZXIgaXQgdG8gZmluZCBtZW1vKCkgb3V0ZXIgd3JhcHBlci5cbi8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG52YXIgbGF6eUNvbXBvbmVudD1vdXRlck1lbW9UeXBlO3ZhciBwYXlsb2FkPWxhenlDb21wb25lbnQuX3BheWxvYWQ7dmFyIGluaXQ9bGF6eUNvbXBvbmVudC5faW5pdDt0cnl7b3V0ZXJNZW1vVHlwZT1pbml0KHBheWxvYWQpO31jYXRjaCh4KXtvdXRlck1lbW9UeXBlPW51bGw7fS8vIElubmVyIHByb3BUeXBlcyB3aWxsIGJlIHZhbGlkYXRlZCBpbiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHBhdGguXG52YXIgb3V0ZXJQcm9wVHlwZXM9b3V0ZXJNZW1vVHlwZSYmb3V0ZXJNZW1vVHlwZS5wcm9wVHlwZXM7aWYob3V0ZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvdXRlck1lbW9UeXBlKSk7fX19fWlmKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJldlByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wcztpZihzaGFsbG93RXF1YWwocHJldlByb3BzLG5leHRQcm9wcykmJmN1cnJlbnQucmVmPT09d29ya0luUHJvZ3Jlc3MucmVmJiYvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG53b3JrSW5Qcm9ncmVzcy50eXBlPT09Y3VycmVudC50eXBlKXtkaWRSZWNlaXZlVXBkYXRlPWZhbHNlOy8vIFRoZSBwcm9wcyBhcmUgc2hhbGxvd2x5IGVxdWFsLiBSZXVzZSB0aGUgcHJldmlvdXMgcHJvcHMgb2JqZWN0LCBsaWtlIHdlXG4vLyB3b3VsZCBkdXJpbmcgYSBub3JtYWwgZmliZXIgYmFpbG91dC5cbi8vXG4vLyBXZSBkb24ndCBoYXZlIHN0cm9uZyBndWFyYW50ZWVzIHRoYXQgdGhlIHByb3BzIG9iamVjdCBpcyByZWZlcmVudGlhbGx5XG4vLyBlcXVhbCBkdXJpbmcgdXBkYXRlcyB3aGVyZSB3ZSBjYW4ndCBiYWlsIG91dCBhbnl3YXkg4oCUIGxpa2UgaWYgdGhlIHByb3BzXG4vLyBhcmUgc2hhbGxvd2x5IGVxdWFsLCBidXQgdGhlcmUncyBhIGxvY2FsIHN0YXRlIG9yIGNvbnRleHQgdXBkYXRlIGluIHRoZVxuLy8gc2FtZSBiYXRjaC5cbi8vXG4vLyBIb3dldmVyLCBhcyBhIHByaW5jaXBsZSwgd2Ugc2hvdWxkIGFpbSB0byBtYWtlIHRoZSBiZWhhdmlvciBjb25zaXN0ZW50XG4vLyBhY3Jvc3MgZGlmZmVyZW50IHdheXMgb2YgbWVtb2l6aW5nIGEgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgUmVhY3QubWVtb1xuLy8gaGFzIGEgZGlmZmVyZW50IGludGVybmFsIEZpYmVyIGxheW91dCBpZiB5b3UgcGFzcyBhIG5vcm1hbCBmdW5jdGlvblxuLy8gY29tcG9uZW50IChTaW1wbGVNZW1vQ29tcG9uZW50KSB2ZXJzdXMgaWYgeW91IHBhc3MgYSBkaWZmZXJlbnQgdHlwZVxuLy8gbGlrZSBmb3J3YXJkUmVmIChNZW1vQ29tcG9uZW50KS4gQnV0IHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuLy8gV3JhcHBpbmcgYSBjb21wb25lbnQgaW4gZm9yd2FyZFJlZiAob3IgUmVhY3QubGF6eSwgZXRjKSBzaG91bGRuJ3Rcbi8vIGFmZmVjdCB3aGV0aGVyIHRoZSBwcm9wcyBvYmplY3QgaXMgcmV1c2VkIGR1cmluZyBhIGJhaWxvdXQuXG53b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM9bmV4dFByb3BzPXByZXZQcm9wcztpZighY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCxyZW5kZXJMYW5lcykpey8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbi8vIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbGFuZXMgdGhhdCB3ZXJlbid0XG4vLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbi8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbi8vIGNvbXBvbmVudCAoaS5lLiB3aGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZSkuIEJ1dCBzaW5jZSBzaW5jZVxuLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4vLyBOT1RFOiBUaGlzIG9ubHkgYXBwbGllcyB0byBTaW1wbGVNZW1vQ29tcG9uZW50LCBub3QgTWVtb0NvbXBvbmVudCxcbi8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuLy8gY29udGFpbnMgaG9va3MuXG4vLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4vLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1jdXJyZW50LmxhbmVzO3JldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31lbHNlIGlmKChjdXJyZW50LmZsYWdzJkZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpIT09Tm9GbGFncyl7Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbmRpZFJlY2VpdmVVcGRhdGU9dHJ1ZTt9fX1yZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKTt9ZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBuZXh0Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBwcmV2U3RhdGU9Y3VycmVudCE9PW51bGw/Y3VycmVudC5tZW1vaXplZFN0YXRlOm51bGw7aWYobmV4dFByb3BzLm1vZGU9PT0naGlkZGVuJ3x8ZW5hYmxlTGVnYWN5SGlkZGVuKXsvLyBSZW5kZXJpbmcgYSBoaWRkZW4gdHJlZS5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7Ly8gSW4gbGVnYWN5IHN5bmMgbW9kZSwgZG9uJ3QgZGVmZXIgdGhlIHN1YnRyZWUuIFJlbmRlciBpdCBub3cuXG4vLyBUT0RPOiBDb25zaWRlciBob3cgT2Zmc2NyZWVuIHNob3VsZCB3b3JrIHdpdGggdHJhbnNpdGlvbnMgaW4gdGhlIGZ1dHVyZVxudmFyIG5leHRTdGF0ZT17YmFzZUxhbmVzOk5vTGFuZXMsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH07d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1uZXh0U3RhdGU7cHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9ZWxzZSBpZighaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyxPZmZzY3JlZW5MYW5lKSl7dmFyIHNwYXduZWRDYWNoZVBvb2w9bnVsbDsvLyBXZSdyZSBoaWRkZW4sIGFuZCB3ZSdyZSBub3QgcmVuZGVyaW5nIGF0IE9mZnNjcmVlbi4gV2Ugd2lsbCBiYWlsIG91dFxuLy8gYW5kIHJlc3VtZSB0aGlzIHRyZWUgbGF0ZXIuXG52YXIgbmV4dEJhc2VMYW5lcztpZihwcmV2U3RhdGUhPT1udWxsKXt2YXIgcHJldkJhc2VMYW5lcz1wcmV2U3RhdGUuYmFzZUxhbmVzO25leHRCYXNlTGFuZXM9bWVyZ2VMYW5lcyhwcmV2QmFzZUxhbmVzLHJlbmRlckxhbmVzKTt9ZWxzZXtuZXh0QmFzZUxhbmVzPXJlbmRlckxhbmVzO30vLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cbndvcmtJblByb2dyZXNzLmxhbmVzPXdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXM9bGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7dmFyIF9uZXh0U3RhdGU9e2Jhc2VMYW5lczpuZXh0QmFzZUxhbmVzLGNhY2hlUG9vbDpzcGF3bmVkQ2FjaGVQb29sLHRyYW5zaXRpb25zOm51bGx9O3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9X25leHRTdGF0ZTt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsOy8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxucHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLG5leHRCYXNlTGFuZXMpO3JldHVybiBudWxsO31lbHNley8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcbi8vIGNvbW1pdHRlZC4gTm93IHdlIHJlc3VtZSByZW5kZXJpbmcgdGhlIGhpZGRlbiB0cmVlLlxuLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxudmFyIF9uZXh0U3RhdGUyPXtiYXNlTGFuZXM6Tm9MYW5lcyxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPV9uZXh0U3RhdGUyOy8vIFB1c2ggdGhlIGxhbmVzIHRoYXQgd2VyZSBza2lwcGVkIHdoZW4gd2UgYmFpbGVkIG91dC5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXM9cHJldlN0YXRlIT09bnVsbD9wcmV2U3RhdGUuYmFzZUxhbmVzOnJlbmRlckxhbmVzO3B1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyxzdWJ0cmVlUmVuZGVyTGFuZXMpO319ZWxzZXsvLyBSZW5kZXJpbmcgYSB2aXNpYmxlIHRyZWUuXG52YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztpZihwcmV2U3RhdGUhPT1udWxsKXsvLyBXZSdyZSBnb2luZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLlxuX3N1YnRyZWVSZW5kZXJMYW5lcz1tZXJnZUxhbmVzKHByZXZTdGF0ZS5iYXNlTGFuZXMscmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt9ZWxzZXsvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbi8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5fc3VidHJlZVJlbmRlckxhbmVzPXJlbmRlckxhbmVzO31wdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsX3N1YnRyZWVSZW5kZXJMYW5lcyk7fXJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fS8vIE5vdGU6IFRoZXNlIGhhcHBlbiB0byBoYXZlIGlkZW50aWNhbCBiZWdpbiBwaGFzZXMsIGZvciBub3cuIFdlIHNob3VsZG4ndCBob2xkXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV4dENoaWxkcmVuPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXh0Q2hpbGRyZW49d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3t3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VXBkYXRlO3svLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4vLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxudmFyIHN0YXRlTm9kZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7c3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uPTA7c3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbj0wO319dmFyIG5leHRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIG5leHRDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LHdvcmtJblByb2dyZXNzKXt2YXIgcmVmPXdvcmtJblByb2dyZXNzLnJlZjtpZihjdXJyZW50PT09bnVsbCYmcmVmIT09bnVsbHx8Y3VycmVudCE9PW51bGwmJmN1cnJlbnQucmVmIT09cmVmKXsvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbndvcmtJblByb2dyZXNzLmZsYWdzfD1SZWY7e3dvcmtJblByb2dyZXNzLmZsYWdzfD1SZWZTdGF0aWM7fX19ZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXt7aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIGlubmVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYoaW5uZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTt9fX12YXIgY29udGV4dDt7dmFyIHVubWFza2VkQ29udGV4dD1nZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHRydWUpO2NvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpO312YXIgbmV4dENoaWxkcmVuO3ZhciBoYXNJZDtwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9e1JlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudD13b3JrSW5Qcm9ncmVzcztzZXRJc1JlbmRlcmluZyh0cnVlKTtuZXh0Q2hpbGRyZW49cmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxjb250ZXh0LHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e25leHRDaGlsZHJlbj1yZW5kZXJXaXRoSG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLGNvbnRleHQscmVuZGVyTGFuZXMpO2hhc0lkPWNoZWNrRGlkUmVuZGVySWRIb29rKCk7fWZpbmFsbHl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO319c2V0SXNSZW5kZXJpbmcoZmFsc2UpO317bWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTt9aWYoY3VycmVudCE9PW51bGwmJiFkaWRSZWNlaXZlVXBkYXRlKXtiYWlsb3V0SG9va3MoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7cmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fWlmKGdldElzSHlkcmF0aW5nKCkmJmhhc0lkKXtwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTt9Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9ZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXt7Ly8gVGhpcyBpcyB1c2VkIGJ5IERldlRvb2xzIHRvIGZvcmNlIGEgYm91bmRhcnkgdG8gZXJyb3IuXG5zd2l0Y2goc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKXtjYXNlIGZhbHNlOnt2YXIgX2luc3RhbmNlPXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTt2YXIgY3Rvcj13b3JrSW5Qcm9ncmVzcy50eXBlOy8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4vLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZG8gdGhpcz9cbnZhciB0ZW1wSW5zdGFuY2U9bmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxfaW5zdGFuY2UuY29udGV4dCk7dmFyIHN0YXRlPXRlbXBJbnN0YW5jZS5zdGF0ZTtfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLHN0YXRlLG51bGwpO2JyZWFrO31jYXNlIHRydWU6e3dvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO3dvcmtJblByb2dyZXNzLmZsYWdzfD1TaG91bGRDYXB0dXJlOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG52YXIgZXJyb3IkMT1uZXcgRXJyb3IoJ1NpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29scycpO3ZhciBsYW5lPXBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLGxhbmUpOy8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxudmFyIHVwZGF0ZT1jcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsd29ya0luUHJvZ3Jlc3MpLGxhbmUpO2VucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcyx1cGRhdGUpO2JyZWFrO319aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXsvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxudmFyIGlubmVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYoaW5uZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLG5leHRQcm9wcywvLyBSZXNvbHZlZCBwcm9wc1xuJ3Byb3AnLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTt9fX0vLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxudmFyIGhhc0NvbnRleHQ7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7aGFzQ29udGV4dD10cnVlO3B1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO31lbHNle2hhc0NvbnRleHQ9ZmFsc2U7fXByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt2YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO3ZhciBzaG91bGRVcGRhdGU7aWYoaW5zdGFuY2U9PT1udWxsKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpOy8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzKTttb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyxyZW5kZXJMYW5lcyk7c2hvdWxkVXBkYXRlPXRydWU7fWVsc2UgaWYoY3VycmVudD09PW51bGwpey8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuc2hvdWxkVXBkYXRlPXJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKTt9ZWxzZXtzaG91bGRVcGRhdGU9dXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO312YXIgbmV4dFVuaXRPZldvcms9ZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsc2hvdWxkVXBkYXRlLGhhc0NvbnRleHQscmVuZGVyTGFuZXMpO3t2YXIgaW5zdD13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7aWYoc2hvdWxkVXBkYXRlJiZpbnN0LnByb3BzIT09bmV4dFByb3BzKXtpZighZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyl7ZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnKydUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcyl8fCdhIGNvbXBvbmVudCcpO31kaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzPXRydWU7fX1yZXR1cm4gbmV4dFVuaXRPZldvcms7fWZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHNob3VsZFVwZGF0ZSxoYXNDb250ZXh0LHJlbmRlckxhbmVzKXsvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxubWFya1JlZihjdXJyZW50LHdvcmtJblByb2dyZXNzKTt2YXIgZGlkQ2FwdHVyZUVycm9yPSh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7aWYoIXNob3VsZFVwZGF0ZSYmIWRpZENhcHR1cmVFcnJvcil7Ly8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG5pZihoYXNDb250ZXh0KXtpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxmYWxzZSk7fXJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO312YXIgaW5zdGFuY2U9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOy8vIFJlcmVuZGVyXG5SZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7dmFyIG5leHRDaGlsZHJlbjtpZihkaWRDYXB0dXJlRXJyb3ImJnR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIT09J2Z1bmN0aW9uJyl7Ly8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXMgbm90IGRlZmluZWQsXG4vLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4vLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuLy8gdGhlIG5ldyBBUEkuXG4vLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG5uZXh0Q2hpbGRyZW49bnVsbDt7c3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTt9fWVsc2V7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9e3NldElzUmVuZGVyaW5nKHRydWUpO25leHRDaGlsZHJlbj1pbnN0YW5jZS5yZW5kZXIoKTtpZih3b3JrSW5Qcm9ncmVzcy5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO3RyeXtpbnN0YW5jZS5yZW5kZXIoKTt9ZmluYWxseXtzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7fX1zZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO319Ly8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxud29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBlcmZvcm1lZFdvcms7aWYoY3VycmVudCE9PW51bGwmJmRpZENhcHR1cmVFcnJvcil7Ly8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgd2l0aG91dCByZXVzaW5nIGFueSBvZlxuLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4vLyBub3JtYWwgY2hpbGRyZW4gZXZlbiBpZiB0aGVpciBpZGVudGl0aWVzIG1hdGNoLlxuZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fWVsc2V7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO30vLyBNZW1vaXplIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbi8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1pbnN0YW5jZS5zdGF0ZTsvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbmlmKGhhc0NvbnRleHQpe2ludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHRydWUpO31yZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3Mpe3ZhciByb290PXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtpZihyb290LnBlbmRpbmdDb250ZXh0KXtwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLHJvb3QucGVuZGluZ0NvbnRleHQscm9vdC5wZW5kaW5nQ29udGV4dCE9PXJvb3QuY29udGV4dCk7fWVsc2UgaWYocm9vdC5jb250ZXh0KXsvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxucHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyxyb290LmNvbnRleHQsZmFsc2UpO31wdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyxyb290LmNvbnRhaW5lckluZm8pO31mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXtwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtpZihjdXJyZW50PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fXZhciBuZXh0UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBwcmV2U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt2YXIgcHJldkNoaWxkcmVuPXByZXZTdGF0ZS5lbGVtZW50O2Nsb25lVXBkYXRlUXVldWUoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7cHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLG5leHRQcm9wcyxudWxsLHJlbmRlckxhbmVzKTt2YXIgbmV4dFN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7dmFyIHJvb3Q9d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOy8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbnZhciBuZXh0Q2hpbGRyZW49bmV4dFN0YXRlLmVsZW1lbnQ7aWYocHJldlN0YXRlLmlzRGVoeWRyYXRlZCl7Ly8gVGhpcyBpcyBhIGh5ZHJhdGlvbiByb290IHdob3NlIHNoZWxsIGhhcyBub3QgeWV0IGh5ZHJhdGVkLiBXZSBzaG91bGRcbi8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbi8vIEZsaXAgaXNEZWh5ZHJhdGVkIHRvIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2hlbiB0aGlzIHJlbmRlclxuLy8gZmluaXNoZXMsIHRoZSByb290IHdpbGwgbm8gbG9uZ2VyIGJlIGRlaHlkcmF0ZWQuXG52YXIgb3ZlcnJpZGVTdGF0ZT17ZWxlbWVudDpuZXh0Q2hpbGRyZW4saXNEZWh5ZHJhdGVkOmZhbHNlLGNhY2hlOm5leHRTdGF0ZS5jYWNoZSxwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOm5leHRTdGF0ZS5wZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzLHRyYW5zaXRpb25zOm5leHRTdGF0ZS50cmFuc2l0aW9uc307dmFyIHVwZGF0ZVF1ZXVlPXdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOy8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4vLyBoYXZlIHJlZHVjZXIgZnVuY3Rpb25zIHNvIGl0IGRvZXNuJ3QgbmVlZCByZWJhc2luZy5cbnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1vdmVycmlkZVN0YXRlO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9b3ZlcnJpZGVTdGF0ZTtpZih3b3JrSW5Qcm9ncmVzcy5mbGFncyZGb3JjZUNsaWVudFJlbmRlcil7Ly8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGEgcHJldmlvdXMgYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBzaGVsbCwgc28gd2Vcbi8vIGZvcmNlZCBhIGNsaWVudCByZW5kZXIuXG52YXIgcmVjb3ZlcmFibGVFcnJvcj1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJysnb2YgYSBTdXNwZW5zZSBib3VuZGFyeSwgdGhlIGVudGlyZSByb290IHdpbGwgc3dpdGNoIHRvICcrJ2NsaWVudCByZW5kZXJpbmcuJyksd29ya0luUHJvZ3Jlc3MpO3JldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyxyZWNvdmVyYWJsZUVycm9yKTt9ZWxzZSBpZihuZXh0Q2hpbGRyZW4hPT1wcmV2Q2hpbGRyZW4pe3ZhciBfcmVjb3ZlcmFibGVFcnJvcj1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSAnKydoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy4nKSx3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzLF9yZWNvdmVyYWJsZUVycm9yKTt9ZWxzZXsvLyBUaGUgb3V0ZXJtb3N0IHNoZWxsIGhhcyBub3QgaHlkcmF0ZWQgeWV0LiBTdGFydCBoeWRyYXRpbmcuXG5lbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTt2YXIgY2hpbGQ9bW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxudWxsLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9Y2hpbGQ7dmFyIG5vZGU9Y2hpbGQ7d2hpbGUobm9kZSl7Ly8gTWFyayBlYWNoIGNoaWxkIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4vLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbi8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5ub2RlLmZsYWdzPW5vZGUuZmxhZ3MmflBsYWNlbWVudHxIeWRyYXRpbmc7bm9kZT1ub2RlLnNpYmxpbmc7fX19ZWxzZXsvLyBSb290IGlzIG5vdCBkZWh5ZHJhdGVkLiBFaXRoZXIgdGhpcyBpcyBhIGNsaWVudC1vbmx5IHJvb3QsIG9yIGl0XG4vLyBhbHJlYWR5IGh5ZHJhdGVkLlxucmVzZXRIeWRyYXRpb25TdGF0ZSgpO2lmKG5leHRDaGlsZHJlbj09PXByZXZDaGlsZHJlbil7cmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fXJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTt9cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyxyZWNvdmVyYWJsZUVycm9yKXsvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbnJlc2V0SHlkcmF0aW9uU3RhdGUoKTtxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO3dvcmtJblByb2dyZXNzLmZsYWdzfD1Gb3JjZUNsaWVudFJlbmRlcjtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3B1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7aWYoY3VycmVudD09PW51bGwpe3RyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTt9dmFyIHR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczt2YXIgcHJldlByb3BzPWN1cnJlbnQhPT1udWxsP2N1cnJlbnQubWVtb2l6ZWRQcm9wczpudWxsO3ZhciBuZXh0Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBpc0RpcmVjdFRleHRDaGlsZD1zaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLG5leHRQcm9wcyk7aWYoaXNEaXJlY3RUZXh0Q2hpbGQpey8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4vLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4vLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbm5leHRDaGlsZHJlbj1udWxsO31lbHNlIGlmKHByZXZQcm9wcyE9PW51bGwmJnNob3VsZFNldFRleHRDb250ZW50KHR5cGUscHJldlByb3BzKSl7Ly8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbi8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9Q29udGVudFJlc2V0O31tYXJrUmVmKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dENoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Mpe2lmKGN1cnJlbnQ9PT1udWxsKXt0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7fS8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG5yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gbW91bnRMYXp5Q29tcG9uZW50KF9jdXJyZW50LHdvcmtJblByb2dyZXNzLGVsZW1lbnRUeXBlLHJlbmRlckxhbmVzKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LHdvcmtJblByb2dyZXNzKTt2YXIgcHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBsYXp5Q29tcG9uZW50PWVsZW1lbnRUeXBlO3ZhciBwYXlsb2FkPWxhenlDb21wb25lbnQuX3BheWxvYWQ7dmFyIGluaXQ9bGF6eUNvbXBvbmVudC5faW5pdDt2YXIgQ29tcG9uZW50PWluaXQocGF5bG9hZCk7Ly8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG53b3JrSW5Qcm9ncmVzcy50eXBlPUNvbXBvbmVudDt2YXIgcmVzb2x2ZWRUYWc9d29ya0luUHJvZ3Jlc3MudGFnPXJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7dmFyIHJlc29sdmVkUHJvcHM9cmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQscHJvcHMpO3ZhciBjaGlsZDtzd2l0Y2gocmVzb2x2ZWRUYWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6e3t2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50KTt3b3JrSW5Qcm9ncmVzcy50eXBlPUNvbXBvbmVudD1yZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTt9Y2hpbGQ9dXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscmVzb2x2ZWRQcm9wcyxyZW5kZXJMYW5lcyk7cmV0dXJuIGNoaWxkO31jYXNlIENsYXNzQ29tcG9uZW50Ont7d29ya0luUHJvZ3Jlc3MudHlwZT1Db21wb25lbnQ9cmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7fWNoaWxkPXVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHJlc29sdmVkUHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBjaGlsZDt9Y2FzZSBGb3J3YXJkUmVmOnt7d29ya0luUHJvZ3Jlc3MudHlwZT1Db21wb25lbnQ9cmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTt9Y2hpbGQ9dXBkYXRlRm9yd2FyZFJlZihudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZXNvbHZlZFByb3BzLHJlbmRlckxhbmVzKTtyZXR1cm4gY2hpbGQ7fWNhc2UgTWVtb0NvbXBvbmVudDp7e2lmKHdvcmtJblByb2dyZXNzLnR5cGUhPT13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSl7dmFyIG91dGVyUHJvcFR5cGVzPUNvbXBvbmVudC5wcm9wVHlwZXM7aWYob3V0ZXJQcm9wVHlwZXMpe2NoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLHJlc29sdmVkUHJvcHMsLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbidwcm9wJyxnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7fX19Y2hpbGQ9dXBkYXRlTWVtb0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudC50eXBlLHJlc29sdmVkUHJvcHMpLC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xucmVuZGVyTGFuZXMpO3JldHVybiBjaGlsZDt9fXZhciBoaW50PScnO3tpZihDb21wb25lbnQhPT1udWxsJiZ0eXBlb2YgQ29tcG9uZW50PT09J29iamVjdCcmJkNvbXBvbmVudC4kJHR5cGVvZj09PVJFQUNUX0xBWllfVFlQRSl7aGludD0nIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/Jzt9fS8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbi8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4vLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG50aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiK0NvbXBvbmVudCtcIi4gXCIrKFwiTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIraGludCkpO31mdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChfY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsbmV4dFByb3BzLHJlbmRlckxhbmVzKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LHdvcmtJblByb2dyZXNzKTsvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxud29ya0luUHJvZ3Jlc3MudGFnPUNsYXNzQ29tcG9uZW50Oy8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcbi8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4vLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4vLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG52YXIgaGFzQ29udGV4dDtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtoYXNDb250ZXh0PXRydWU7cHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7fWVsc2V7aGFzQ29udGV4dD1mYWxzZTt9cHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2NvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LG5leHRQcm9wcyk7bW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxuZXh0UHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCx0cnVlLGhhc0NvbnRleHQscmVuZGVyTGFuZXMpO31mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoX2N1cnJlbnQsd29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50LHJlbmRlckxhbmVzKXtyZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LHdvcmtJblByb2dyZXNzKTt2YXIgcHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBjb250ZXh0O3t2YXIgdW5tYXNrZWRDb250ZXh0PWdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQsZmFsc2UpO2NvbnRleHQ9Z2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyx1bm1hc2tlZENvbnRleHQpO31wcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7dmFyIHZhbHVlO3ZhciBoYXNJZDt7bWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO317aWYoQ29tcG9uZW50LnByb3RvdHlwZSYmdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyPT09J2Z1bmN0aW9uJyl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pe2Vycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIrJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLGNvbXBvbmVudE5hbWUsY29tcG9uZW50TmFtZSk7ZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV09dHJ1ZTt9fWlmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsbnVsbCk7fXNldElzUmVuZGVyaW5nKHRydWUpO1JlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudD13b3JrSW5Qcm9ncmVzczt2YWx1ZT1yZW5kZXJXaXRoSG9va3MobnVsbCx3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscHJvcHMsY29udGV4dCxyZW5kZXJMYW5lcyk7aGFzSWQ9Y2hlY2tEaWRSZW5kZXJJZEhvb2soKTtzZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO30vLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGVyZm9ybWVkV29yazt7Ly8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG5pZih0eXBlb2YgdmFsdWU9PT0nb2JqZWN0JyYmdmFsdWUhPT1udWxsJiZ0eXBlb2YgdmFsdWUucmVuZGVyPT09J2Z1bmN0aW9uJyYmdmFsdWUuJCR0eXBlb2Y9PT11bmRlZmluZWQpe3ZhciBfY29tcG9uZW50TmFtZT1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KXx8J1Vua25vd24nO2lmKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSl7ZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcrJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJytcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIrXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIisnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsX2NvbXBvbmVudE5hbWUsX2NvbXBvbmVudE5hbWUsX2NvbXBvbmVudE5hbWUpO2RpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdPXRydWU7fX19aWYoLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuLy8gRXZlbnR1YWxseSB3ZSdsbCBkZWxldGUgdGhpcyBicmFuY2ggYWx0b2dldGhlci5cbnR5cGVvZiB2YWx1ZT09PSdvYmplY3QnJiZ2YWx1ZSE9PW51bGwmJnR5cGVvZiB2YWx1ZS5yZW5kZXI9PT0nZnVuY3Rpb24nJiZ2YWx1ZS4kJHR5cGVvZj09PXVuZGVmaW5lZCl7e3ZhciBfY29tcG9uZW50TmFtZTI9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKXtlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJysnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnK1wiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIitcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiKydjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJyxfY29tcG9uZW50TmFtZTIsX2NvbXBvbmVudE5hbWUyLF9jb21wb25lbnROYW1lMik7ZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdPXRydWU7fX0vLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG53b3JrSW5Qcm9ncmVzcy50YWc9Q2xhc3NDb21wb25lbnQ7Ly8gVGhyb3cgb3V0IGFueSBob29rcyB0aGF0IHdlcmUgdXNlZC5cbndvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1udWxsOy8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4vLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4vLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG52YXIgaGFzQ29udGV4dD1mYWxzZTtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtoYXNDb250ZXh0PXRydWU7cHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7fWVsc2V7aGFzQ29udGV4dD1mYWxzZTt9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT12YWx1ZS5zdGF0ZSE9PW51bGwmJnZhbHVlLnN0YXRlIT09dW5kZWZpbmVkP3ZhbHVlLnN0YXRlOm51bGw7aW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTthZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsdmFsdWUpO21vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyxDb21wb25lbnQscHJvcHMscmVuZGVyTGFuZXMpO3JldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCx0cnVlLGhhc0NvbnRleHQscmVuZGVyTGFuZXMpO31lbHNley8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG53b3JrSW5Qcm9ncmVzcy50YWc9RnVuY3Rpb25Db21wb25lbnQ7e2lmKHdvcmtJblByb2dyZXNzLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7c2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7dHJ5e3ZhbHVlPXJlbmRlcldpdGhIb29rcyhudWxsLHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxwcm9wcyxjb250ZXh0LHJlbmRlckxhbmVzKTtoYXNJZD1jaGVja0RpZFJlbmRlcklkSG9vaygpO31maW5hbGx5e3NldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTt9fX1pZihnZXRJc0h5ZHJhdGluZygpJiZoYXNJZCl7cHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7fXJlY29uY2lsZUNoaWxkcmVuKG51bGwsd29ya0luUHJvZ3Jlc3MsdmFsdWUscmVuZGVyTGFuZXMpO3t2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsQ29tcG9uZW50KTt9cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO319ZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLENvbXBvbmVudCl7e2lmKENvbXBvbmVudCl7aWYoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKXtlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJyxDb21wb25lbnQuZGlzcGxheU5hbWV8fENvbXBvbmVudC5uYW1lfHwnQ29tcG9uZW50Jyk7fX1pZih3b3JrSW5Qcm9ncmVzcy5yZWYhPT1udWxsKXt2YXIgaW5mbz0nJzt2YXIgb3duZXJOYW1lPWdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7aWYob3duZXJOYW1lKXtpbmZvKz0nXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcrb3duZXJOYW1lKydgLic7fXZhciB3YXJuaW5nS2V5PW93bmVyTmFtZXx8Jyc7dmFyIGRlYnVnU291cmNlPXdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtpZihkZWJ1Z1NvdXJjZSl7d2FybmluZ0tleT1kZWJ1Z1NvdXJjZS5maWxlTmFtZSsnOicrZGVidWdTb3VyY2UubGluZU51bWJlcjt9aWYoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSl7ZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldPXRydWU7ZXJyb3IoJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcrJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcrJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJyxpbmZvKTt9fWlmKENvbXBvbmVudC5kZWZhdWx0UHJvcHMhPT11bmRlZmluZWQpe3ZhciBjb21wb25lbnROYW1lPWdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpfHwnVW5rbm93bic7aWYoIWRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pe2Vycm9yKCclczogU3VwcG9ydCBmb3IgZGVmYXVsdFByb3BzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGZ1bmN0aW9uIGNvbXBvbmVudHMgJysnaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVXNlIEphdmFTY3JpcHQgZGVmYXVsdCBwYXJhbWV0ZXJzIGluc3RlYWQuJyxjb21wb25lbnROYW1lKTtkaWRXYXJuQWJvdXREZWZhdWx0UHJvcHNPbkZ1bmN0aW9uQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdPXRydWU7fX1pZih0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcz09PSdmdW5jdGlvbicpe3ZhciBfY29tcG9uZW50TmFtZTM9Z2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCl8fCdVbmtub3duJztpZighZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKXtlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsX2NvbXBvbmVudE5hbWUzKTtkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM109dHJ1ZTt9fWlmKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGU9PT0nb2JqZWN0JyYmQ29tcG9uZW50LmNvbnRleHRUeXBlIT09bnVsbCl7dmFyIF9jb21wb25lbnROYW1lND1nZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KXx8J1Vua25vd24nO2lmKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSl7ZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsX2NvbXBvbmVudE5hbWU0KTtkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XT10cnVlO319fX12YXIgU1VTUEVOREVEX01BUktFUj17ZGVoeWRyYXRlZDpudWxsLHRyZWVDb250ZXh0Om51bGwscmV0cnlMYW5lOk5vTGFuZX07ZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKXtyZXR1cm57YmFzZUxhbmVzOnJlbmRlckxhbmVzLGNhY2hlUG9vbDpnZXRTdXNwZW5kZWRDYWNoZSgpLHRyYW5zaXRpb25zOm51bGx9O31mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSxyZW5kZXJMYW5lcyl7dmFyIGNhY2hlUG9vbD1udWxsO3JldHVybntiYXNlTGFuZXM6bWVyZ2VMYW5lcyhwcmV2T2Zmc2NyZWVuU3RhdGUuYmFzZUxhbmVzLHJlbmRlckxhbmVzKSxjYWNoZVBvb2w6Y2FjaGVQb29sLHRyYW5zaXRpb25zOnByZXZPZmZzY3JlZW5TdGF0ZS50cmFuc2l0aW9uc307fS8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5mdW5jdGlvbiBzaG91bGRSZW1haW5PbkZhbGxiYWNrKHN1c3BlbnNlQ29udGV4dCxjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXsvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbi8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG4vLyBGb3IgZXhhbXBsZSwgU3VzcGVuc2VMaXN0IGNvb3JkaW5hdGVzIHdoZW4gbmVzdGVkIGNvbnRlbnQgYXBwZWFycy5cbmlmKGN1cnJlbnQhPT1udWxsKXt2YXIgc3VzcGVuc2VTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7aWYoc3VzcGVuc2VTdGF0ZT09PW51bGwpey8vIEN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIERvbid0IGhpZGUgaXQsIGV2ZW4gaWYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4vLyBpcyB0cnVlLiBNb3JlIHByZWNpc2UgbmFtZSBtaWdodCBiZSBcIkZvcmNlUmVtYWluU3VzcGVuc2VGYWxsYmFja1wiLlxuLy8gTm90ZTogVGhpcyBpcyBhIGZhY3RvcmluZyBzbWVsbC4gQ2FuJ3QgcmVtYWluIG9uIGEgZmFsbGJhY2sgaWYgdGhlcmUnc1xuLy8gbm8gZmFsbGJhY2sgdG8gcmVtYWluIG9uLlxucmV0dXJuIGZhbHNlO319Ly8gTm90IGN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIENvbnN1bHQgdGhlIFN1c3BlbnNlIGNvbnRleHQuXG5yZXR1cm4gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCxGb3JjZVN1c3BlbnNlRmFsbGJhY2spO31mdW5jdGlvbiBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LHJlbmRlckxhbmVzKXsvLyBUT0RPOiBTaG91bGQgbm90IHJlbW92ZSByZW5kZXIgbGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCBkdXJpbmcgdGhpcyByZW5kZXJcbnJldHVybiByZW1vdmVMYW5lcyhjdXJyZW50LmNoaWxkTGFuZXMscmVuZGVyTGFuZXMpO31mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXt2YXIgbmV4dFByb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxue2lmKHNob3VsZFN1c3BlbmQod29ya0luUHJvZ3Jlc3MpKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTt9fXZhciBzdXNwZW5zZUNvbnRleHQ9c3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O3ZhciBzaG93RmFsbGJhY2s9ZmFsc2U7dmFyIGRpZFN1c3BlbmQ9KHdvcmtJblByb2dyZXNzLmZsYWdzJkRpZENhcHR1cmUpIT09Tm9GbGFncztpZihkaWRTdXNwZW5kfHxzaG91bGRSZW1haW5PbkZhbGxiYWNrKHN1c3BlbnNlQ29udGV4dCxjdXJyZW50KSl7Ly8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cbi8vIHJlbmRlcmluZyB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG5zaG93RmFsbGJhY2s9dHJ1ZTt3b3JrSW5Qcm9ncmVzcy5mbGFncyY9fkRpZENhcHR1cmU7fWVsc2V7Ly8gQXR0ZW1wdGluZyB0aGUgbWFpbiBjb250ZW50XG5pZihjdXJyZW50PT09bnVsbHx8Y3VycmVudC5tZW1vaXplZFN0YXRlIT09bnVsbCl7Ly8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbi8vIEF2b2lkZWQgYm91bmRhcmllcyBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2UgdGhleSBjYW5ub3QgaGFuZGxlIHByZWZlcnJlZCBmYWxsYmFjayBzdGF0ZXMuXG57c3VzcGVuc2VDb250ZXh0PWFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7fX19c3VzcGVuc2VDb250ZXh0PXNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7cHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5zZUNvbnRleHQpOy8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuLy8gYm91bmRhcnkncyBjaGlsZHJlbi4gVGhpcyBpbnZvbHZlcyBzb21lIGN1c3RvbSByZWNvbmNpbGlhdGlvbiBsb2dpYy4gVHdvXG4vLyBtYWluIHJlYXNvbnMgdGhpcyBpcyBzbyBjb21wbGljYXRlZC5cbi8vXG4vLyBGaXJzdCwgTGVnYWN5IE1vZGUgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGVcbi8vIHByaW1hcnkgdHJlZSB3aWxsIGNvbW1pdCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUsIHNvIHdoZW4gd2UgZG8gdGhlXG4vLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4vLyBoYWNrcyB0byBtYWtlIHRoYXQgbm90IHRvdGFsbHkgYnJlYWsuIExpa2UgdHJhbnNmZXJyaW5nIGVmZmVjdHMgYW5kXG4vLyBkZWxldGlvbnMgZnJvbSBoaWRkZW4gdHJlZS4gSW4gQ29uY3VycmVudCBNb2RlLCBpdCdzIG11Y2ggc2ltcGxlcixcbi8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbi8vIHN0YXRlLCBubyBlZmZlY3RzLiBTYW1lIGFzIHdoYXQgd2UgZG8gZm9yIE9mZnNjcmVlbiAoZXhjZXB0IHRoYXRcbi8vIE9mZnNjcmVlbiBkb2Vzbid0IGhhdmUgdGhlIGZpcnN0IHJlbmRlciBwYXNzKS5cbi8vXG4vLyBTZWNvbmQgaXMgaHlkcmF0aW9uLiBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgU3VzcGVuc2UgZmliZXIgaGFzIGEgc2xpZ2h0bHlcbi8vIGRpZmZlcmVudCBsYXlvdXQsIHdoZXJlIHRoZSBjaGlsZCBwb2ludHMgdG8gYSBkZWh5ZHJhdGVkIGZyYWdtZW50LCB3aGljaFxuLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuLy9cbi8vIFRoaXJkLCBldmVuIGlmIHlvdSBzZXQgYWxsIHRoYXQgYXNpZGUsIFN1c3BlbnNlIGlzIGxpa2UgZXJyb3IgYm91bmRhcmllcyBpblxuLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4vLyBhbmQgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHRyZWUuIExpa2UgYSB0cnkvY2F0Y2ggYmxvY2suIFNvIHdlIGhhdmUgdG8gdHJhY2tcbi8vIHdoaWNoIGJyYW5jaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nLiBJZGVhbGx5IHdlIHdvdWxkIG1vZGVsIHRoaXMgdXNpbmdcbi8vIGEgc3RhY2suXG5pZihjdXJyZW50PT09bnVsbCl7Ly8gSW5pdGlhbCBtb3VudFxuLy8gU3BlY2lhbCBwYXRoIGZvciBoeWRyYXRpb25cbi8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7Ly8gVGhpcyBjb3VsZCd2ZSBiZWVuIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQuXG52YXIgc3VzcGVuc2VTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKHN1c3BlbnNlU3RhdGUhPT1udWxsKXt2YXIgZGVoeWRyYXRlZD1zdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7aWYoZGVoeWRyYXRlZCE9PW51bGwpe3JldHVybiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcyxkZWh5ZHJhdGVkKTt9fXZhciBuZXh0UHJpbWFyeUNoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW49bmV4dFByb3BzLmZhbGxiYWNrO2lmKHNob3dGYWxsYmFjayl7dmFyIGZhbGxiYWNrRnJhZ21lbnQ9bW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsbmV4dFByaW1hcnlDaGlsZHJlbixuZXh0RmFsbGJhY2tDaGlsZHJlbixyZW5kZXJMYW5lcyk7dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PXdvcmtJblByb2dyZXNzLmNoaWxkO3ByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGU9bW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPVNVU1BFTkRFRF9NQVJLRVI7cmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7fWVsc2V7cmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsbmV4dFByaW1hcnlDaGlsZHJlbik7fX1lbHNley8vIFRoaXMgaXMgYW4gdXBkYXRlLlxuLy8gU3BlY2lhbCBwYXRoIGZvciBoeWRyYXRpb25cbnZhciBwcmV2U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO2lmKHByZXZTdGF0ZSE9PW51bGwpe3ZhciBfZGVoeWRyYXRlZD1wcmV2U3RhdGUuZGVoeWRyYXRlZDtpZihfZGVoeWRyYXRlZCE9PW51bGwpe3JldHVybiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxkaWRTdXNwZW5kLG5leHRQcm9wcyxfZGVoeWRyYXRlZCxwcmV2U3RhdGUscmVuZGVyTGFuZXMpO319aWYoc2hvd0ZhbGxiYWNrKXt2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuPW5leHRQcm9wcy5mYWxsYmFjazt2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW49bmV4dFByb3BzLmNoaWxkcmVuO3ZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ9dXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsX25leHRQcmltYXJ5Q2hpbGRyZW4sX25leHRGYWxsYmFja0NoaWxkcmVuLHJlbmRlckxhbmVzKTt2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mj13b3JrSW5Qcm9ncmVzcy5jaGlsZDt2YXIgcHJldk9mZnNjcmVlblN0YXRlPWN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLm1lbW9pemVkU3RhdGU9cHJldk9mZnNjcmVlblN0YXRlPT09bnVsbD9tb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpOnVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLHJlbmRlckxhbmVzKTtfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLmNoaWxkTGFuZXM9Z2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCxyZW5kZXJMYW5lcyk7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1TVVNQRU5ERURfTUFSS0VSO3JldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7fWVsc2V7dmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMj1uZXh0UHJvcHMuY2hpbGRyZW47dmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDM9dXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxfbmV4dFByaW1hcnlDaGlsZHJlbjIscmVuZGVyTGFuZXMpO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mzt9fX1mdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLHByaW1hcnlDaGlsZHJlbixyZW5kZXJMYW5lcyl7dmFyIG1vZGU9d29ya0luUHJvZ3Jlc3MubW9kZTt2YXIgcHJpbWFyeUNoaWxkUHJvcHM9e21vZGU6J3Zpc2libGUnLGNoaWxkcmVuOnByaW1hcnlDaGlsZHJlbn07dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PW1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcyxtb2RlKTtwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cHJpbWFyeUNoaWxkRnJhZ21lbnQ7cmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O31mdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4sZmFsbGJhY2tDaGlsZHJlbixyZW5kZXJMYW5lcyl7dmFyIG1vZGU9d29ya0luUHJvZ3Jlc3MubW9kZTt2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDt2YXIgcHJpbWFyeUNoaWxkUHJvcHM9e21vZGU6J2hpZGRlbicsY2hpbGRyZW46cHJpbWFyeUNoaWxkcmVufTt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7dmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtpZigobW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUmJnByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQhPT1udWxsKXsvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4vLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxucHJpbWFyeUNoaWxkRnJhZ21lbnQ9cHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzPU5vTGFuZXM7cHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzPXByaW1hcnlDaGlsZFByb3BzO2lmKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpey8vIFJlc2V0IHRoZSBkdXJhdGlvbnMgZnJvbSB0aGUgZmlyc3QgcGFzcyBzbyB0aGV5IGFyZW4ndCBpbmNsdWRlZCBpbiB0aGVcbi8vIGZpbmFsIGFtb3VudHMuIFRoaXMgc2VlbXMgY291bnRlcmludHVpdGl2ZSwgc2luY2Ugd2UncmUgaW50ZW50aW9uYWxseVxuLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2Vcbi8vIGRvIGluIENvbmN1cnJlbnQgTW9kZS5cbnByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbER1cmF0aW9uPTA7cHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lPS0xO3ByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb249MDtwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uPTA7fWZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLG1vZGUscmVuZGVyTGFuZXMsbnVsbCk7fWVsc2V7cHJpbWFyeUNoaWxkRnJhZ21lbnQ9bW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLG1vZGUpO2ZhbGxiYWNrQ2hpbGRGcmFnbWVudD1jcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLG1vZGUscmVuZGVyTGFuZXMsbnVsbCk7fXByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc9ZmFsbGJhY2tDaGlsZEZyYWdtZW50O3dvcmtJblByb2dyZXNzLmNoaWxkPXByaW1hcnlDaGlsZEZyYWdtZW50O3JldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7fWZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcyxtb2RlLHJlbmRlckxhbmVzKXsvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbmAgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZVxuLy8gdGhpcyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbnJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsbW9kZSxOb0xhbmVzLG51bGwpO31mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnQsb2Zmc2NyZWVuUHJvcHMpey8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlV29ya0luUHJvZ3Jlc3NgIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2UgdGhpc1xuLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG5yZXR1cm4gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCxvZmZzY3JlZW5Qcm9wcyk7fWZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuLHJlbmRlckxhbmVzKXt2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50PWN1cnJlbnQuY2hpbGQ7dmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PXVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LHttb2RlOid2aXNpYmxlJyxjaGlsZHJlbjpwcmltYXJ5Q2hpbGRyZW59KTtpZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe3ByaW1hcnlDaGlsZEZyYWdtZW50LmxhbmVzPXJlbmRlckxhbmVzO31wcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7cHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZz1udWxsO2lmKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQhPT1udWxsKXsvLyBEZWxldGUgdGhlIGZhbGxiYWNrIGNoaWxkIGZyYWdtZW50XG52YXIgZGVsZXRpb25zPXdvcmtJblByb2dyZXNzLmRlbGV0aW9ucztpZihkZWxldGlvbnM9PT1udWxsKXt3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM9W2N1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnRdO3dvcmtJblByb2dyZXNzLmZsYWdzfD1DaGlsZERlbGV0aW9uO31lbHNle2RlbGV0aW9ucy5wdXNoKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQpO319d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cHJpbWFyeUNoaWxkRnJhZ21lbnQ7cmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O31mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4sZmFsbGJhY2tDaGlsZHJlbixyZW5kZXJMYW5lcyl7dmFyIG1vZGU9d29ya0luUHJvZ3Jlc3MubW9kZTt2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50PWN1cnJlbnQuY2hpbGQ7dmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7dmFyIHByaW1hcnlDaGlsZFByb3BzPXttb2RlOidoaWRkZW4nLGNoaWxkcmVuOnByaW1hcnlDaGlsZHJlbn07dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O2lmKC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbi8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4obW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUmJi8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4vLyBhbHJlYWR5IGNsb25lZC4gSW4gbGVnYWN5IG1vZGUsIHRoZSBvbmx5IGNhc2Ugd2hlcmUgdGhpcyBpc24ndCB0cnVlIGlzXG4vLyB3aGVuIERldlRvb2xzIGZvcmNlcyB1cyB0byBkaXNwbGF5IGEgZmFsbGJhY2s7IHdlIHNraXAgdGhlIGZpcnN0IHJlbmRlclxuLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbi8vIE1vZGUsIFN1c3BlbnNlTGlzdCBjYW4gYWxzbyB0cmlnZ2VyIHRoaXMgc2NlbmFyaW8sIGJ1dCB0aGlzIGlzIGEgbGVnYWN5LVxuLy8gb25seSBjb2RlcGF0aC4pXG53b3JrSW5Qcm9ncmVzcy5jaGlsZCE9PWN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCl7dmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7cHJpbWFyeUNoaWxkRnJhZ21lbnQ9cHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzPU5vTGFuZXM7cHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzPXByaW1hcnlDaGlsZFByb3BzO2lmKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpey8vIFJlc2V0IHRoZSBkdXJhdGlvbnMgZnJvbSB0aGUgZmlyc3QgcGFzcyBzbyB0aGV5IGFyZW4ndCBpbmNsdWRlZCBpbiB0aGVcbi8vIGZpbmFsIGFtb3VudHMuIFRoaXMgc2VlbXMgY291bnRlcmludHVpdGl2ZSwgc2luY2Ugd2UncmUgaW50ZW50aW9uYWxseVxuLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2Vcbi8vIGRvIGluIENvbmN1cnJlbnQgTW9kZS5cbnByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbER1cmF0aW9uPTA7cHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lPS0xO3ByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb249Y3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247cHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbj1jdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjt9Ly8gVGhlIGZhbGxiYWNrIGZpYmVyIHdhcyBhZGRlZCBhcyBhIGRlbGV0aW9uIGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cbi8vIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIHJlbWFpbiBvbiB0aGUgZmFsbGJhY2ssIHdlIG5vIGxvbmdlciB3YW50XG4vLyB0byBkZWxldGUgaXQuXG53b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM9bnVsbDt9ZWxzZXtwcmltYXJ5Q2hpbGRGcmFnbWVudD11cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCxwcmltYXJ5Q2hpbGRQcm9wcyk7Ly8gU2luY2Ugd2UncmUgcmV1c2luZyBhIGN1cnJlbnQgdHJlZSwgd2UgbmVlZCB0byByZXVzZSB0aGUgZmxhZ3MsIHRvby5cbi8vIChXZSBkb24ndCBkbyB0aGlzIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGluIGxlZ2FjeSBtb2RlIHdlIGRvbid0IHJlLXVzZVxuLy8gdGhlIGN1cnJlbnQgdHJlZTsgc2VlIHByZXZpb3VzIGJyYW5jaC4pXG5wcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3M9Y3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncyZTdGF0aWNNYXNrO312YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O2lmKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQhPT1udWxsKXtmYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCxmYWxsYmFja0NoaWxkcmVuKTt9ZWxzZXtmYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbixtb2RlLHJlbmRlckxhbmVzLG51bGwpOy8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuLy8gbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cbmZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFnc3w9UGxhY2VtZW50O31mYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO3ByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybj13b3JrSW5Qcm9ncmVzcztwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nPWZhbGxiYWNrQ2hpbGRGcmFnbWVudDt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1wcmltYXJ5Q2hpbGRGcmFnbWVudDtyZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O31mdW5jdGlvbiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzLHJlY292ZXJhYmxlRXJyb3Ipey8vIEZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLiBCZWNhdXNlIHRoaXMgaGFzIHBlcmZvcm1hbmNlXG4vLyBpbXBsaWNhdGlvbnMsIGl0J3MgY29uc2lkZXJlZCBhIHJlY292ZXJhYmxlIGVycm9yLCBldmVuIHRob3VnaCB0aGUgdXNlclxuLy8gbGlrZWx5IHdvbid0IG9ic2VydmUgYW55dGhpbmcgd3Jvbmcgd2l0aCB0aGUgVUkuXG4vL1xuLy8gVGhlIGVycm9yIGlzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCB0byBlbmZvcmNlIHRoYXQgZXZlcnkgY2FsbGVyIHByb3ZpZGVcbi8vIGEgY3VzdG9tIG1lc3NhZ2UsIG9yIGV4cGxpY2l0bHkgb3B0IG91dCAoY3VycmVudGx5IHRoZSBvbmx5IHBhdGggdGhhdCBvcHRzXG4vLyBvdXQgaXMgbGVnYWN5IG1vZGU7IGV2ZXJ5IGNvbmN1cnJlbnQgcGF0aCBwcm92aWRlcyBhbiBlcnJvcikuXG5pZihyZWNvdmVyYWJsZUVycm9yIT09bnVsbCl7cXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTt9Ly8gVGhpcyB3aWxsIGFkZCB0aGUgb2xkIGZpYmVyIHRvIHRoZSBkZWxldGlvbiBsaXN0XG5yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxjdXJyZW50LmNoaWxkLG51bGwscmVuZGVyTGFuZXMpOy8vIFdlJ3JlIG5vdyBub3Qgc3VzcGVuZGVkIG5vciBkZWh5ZHJhdGVkLlxudmFyIG5leHRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIHByaW1hcnlDaGlsZHJlbj1uZXh0UHJvcHMuY2hpbGRyZW47dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PW1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuKTsvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbi8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5wcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFnc3w9UGxhY2VtZW50O3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7fWZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscHJpbWFyeUNoaWxkcmVuLGZhbGxiYWNrQ2hpbGRyZW4scmVuZGVyTGFuZXMpe3ZhciBmaWJlck1vZGU9d29ya0luUHJvZ3Jlc3MubW9kZTt2YXIgcHJpbWFyeUNoaWxkUHJvcHM9e21vZGU6J3Zpc2libGUnLGNoaWxkcmVuOnByaW1hcnlDaGlsZHJlbn07dmFyIHByaW1hcnlDaGlsZEZyYWdtZW50PW1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcyxmaWJlck1vZGUpO3ZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ9Y3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbixmaWJlck1vZGUscmVuZGVyTGFuZXMsbnVsbCk7Ly8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlXG4vLyBib3VuZGFyeSkgYWxyZWFkeSBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzfD1QbGFjZW1lbnQ7cHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuPXdvcmtJblByb2dyZXNzO2ZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm49d29ya0luUHJvZ3Jlc3M7cHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZz1mYWxsYmFja0NoaWxkRnJhZ21lbnQ7d29ya0luUHJvZ3Jlc3MuY2hpbGQ9cHJpbWFyeUNoaWxkRnJhZ21lbnQ7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlKXsvLyBXZSB3aWxsIGhhdmUgZHJvcHBlZCB0aGUgZWZmZWN0IGxpc3Qgd2hpY2ggY29udGFpbnMgdGhlXG4vLyBkZWxldGlvbi4gV2UgbmVlZCB0byByZWNvbmNpbGUgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGNoaWxkLlxucmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsY3VycmVudC5jaGlsZCxudWxsLHJlbmRlckxhbmVzKTt9cmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDt9ZnVuY3Rpb24gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3Msc3VzcGVuc2VJbnN0YW5jZSxyZW5kZXJMYW5lcyl7Ly8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgdGhlIGNvbnRlbnQgaW4gcGxhY2UgYW5kIHRyeSB0byBoeWRyYXRlIGl0IGxhdGVyLlxuaWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXt7ZXJyb3IoJ0Nhbm5vdCBoeWRyYXRlIFN1c3BlbnNlIGluIGxlZ2FjeSBtb2RlLiBTd2l0Y2ggZnJvbSAnKydSZWFjdERPTS5oeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lcikgdG8gJysnUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoY29udGFpbmVyLCA8QXBwIC8+KScrJy5yZW5kZXIoZWxlbWVudCkgb3IgcmVtb3ZlIHRoZSBTdXNwZW5zZSBjb21wb25lbnRzIGZyb20gJysndGhlIHNlcnZlciByZW5kZXJlZCBjb21wb25lbnRzLicpO313b3JrSW5Qcm9ncmVzcy5sYW5lcz1sYW5lVG9MYW5lcyhTeW5jTGFuZSk7fWVsc2UgaWYoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpey8vIFRoaXMgaXMgYSBjbGllbnQtb25seSBib3VuZGFyeS4gU2luY2Ugd2Ugd29uJ3QgZ2V0IGFueSBjb250ZW50IGZyb20gdGhlIHNlcnZlclxuLy8gZm9yIHRoaXMsIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhhdCBhdCBhIGhpZ2hlciBwcmlvcml0eSBiYXNlZCBvbiB3aGVuIGl0IHdvdWxkXG4vLyBoYXZlIHRpbWVkIG91dC4gSW4gdGhlb3J5IHdlIGNvdWxkIHJlbmRlciBpdCBpbiB0aGlzIHBhc3MgYnV0IGl0IHdvdWxkIGhhdmUgdGhlXG4vLyB3cm9uZyBwcmlvcml0eSBhc3NvY2lhdGVkIHdpdGggaXQgYW5kIHdpbGwgcHJldmVudCBoeWRyYXRpb24gb2YgcGFyZW50IHBhdGguXG4vLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB3b3JrIGxlZnQgb24gaXQgdG8gcmVuZGVyIGl0IGluIGEgc2VwYXJhdGUgY29tbWl0LlxuLy8gVE9ETyBUaGlzIHRpbWUgc2hvdWxkIGJlIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzcG9uc2UgdGhhdCBpc1xuLy8gYSBwYXJlbnQgdG8gdGhpcyBib3VuZGFyeSB3YXMgZGlzcGxheWVkLiBIb3dldmVyLCBzaW5jZSB3ZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZVxuLy8gYSBwcm90b2NvbCB0byB0cmFuc2ZlciB0aGF0IHRpbWUsIHdlJ2xsIGp1c3QgZXN0aW1hdGUgaXQgYnkgdXNpbmcgdGhlIGN1cnJlbnRcbi8vIHRpbWUuIFRoaXMgd2lsbCBtZWFuIHRoYXQgU3VzcGVuc2UgdGltZW91dHMgYXJlIHNsaWdodGx5IHNoaWZ0ZWQgdG8gbGF0ZXIgdGhhblxuLy8gdGhleSBzaG91bGQgYmUuXG4vLyBTY2hlZHVsZSBhIG5vcm1hbCBwcmkgdXBkYXRlIHRvIHJlbmRlciB0aGlzIGNvbnRlbnQuXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1sYW5lVG9MYW5lcyhEZWZhdWx0SHlkcmF0aW9uTGFuZSk7fWVsc2V7Ly8gV2UnbGwgY29udGludWUgaHlkcmF0aW5nIHRoZSByZXN0IGF0IG9mZnNjcmVlbiBwcmlvcml0eSBzaW5jZSB3ZSdsbCBhbHJlYWR5XG4vLyBiZSBzaG93aW5nIHRoZSByaWdodCBjb250ZW50IGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGlzIG5vIHJ1c2guXG53b3JrSW5Qcm9ncmVzcy5sYW5lcz1sYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTt9cmV0dXJuIG51bGw7fWZ1bmN0aW9uIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLGRpZFN1c3BlbmQsbmV4dFByb3BzLHN1c3BlbnNlSW5zdGFuY2Usc3VzcGVuc2VTdGF0ZSxyZW5kZXJMYW5lcyl7aWYoIWRpZFN1c3BlbmQpey8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBwYXNzLiBBdHRlbXB0IHRvIGh5ZHJhdGUuXG4vLyBXZSBzaG91bGQgbmV2ZXIgYmUgaHlkcmF0aW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCBpcyB0aGUgZmlyc3QgcGFzcyxcbi8vIGJ1dCBhZnRlciB3ZSd2ZSBhbHJlYWR5IGNvbW1pdHRlZCBvbmNlLlxud2FybklmSHlkcmF0aW5nKCk7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmQ29uY3VycmVudE1vZGUpPT09Tm9Nb2RlKXtyZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcywvLyBUT0RPOiBXaGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZSwgd2Ugc2hvdWxkIG1ha2UgdGhpcyBlcnJvciBhcmd1bWVudFxuLy8gcmVxdWlyZWQg4oCUIGV2ZXJ5IGNvbmN1cnJlbnQgbW9kZSBwYXRoIHRoYXQgY2F1c2VzIGh5ZHJhdGlvbiB0b1xuLy8gZGUtb3B0IHRvIGNsaWVudCByZW5kZXJpbmcgc2hvdWxkIGhhdmUgYW4gZXJyb3IgbWVzc2FnZS5cbm51bGwpO31pZihpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSl7Ly8gVGhpcyBib3VuZGFyeSBpcyBpbiBhIHBlcm1hbmVudCBmYWxsYmFjayBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSdsbCBuZXZlclxuLy8gZ2V0IGFuIHVwZGF0ZSBhbmQgd2UnbGwgbmV2ZXIgYmUgYWJsZSB0byBoeWRyYXRlIHRoZSBmaW5hbCBjb250ZW50LiBMZXQncyBqdXN0IHRyeSB0aGVcbi8vIGNsaWVudCBzaWRlIHJlbmRlciBpbnN0ZWFkLlxudmFyIGRpZ2VzdCxtZXNzYWdlLHN0YWNrO3t2YXIgX2dldFN1c3BlbnNlSW5zdGFuY2VGPWdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyhzdXNwZW5zZUluc3RhbmNlKTtkaWdlc3Q9X2dldFN1c3BlbnNlSW5zdGFuY2VGLmRpZ2VzdDttZXNzYWdlPV9nZXRTdXNwZW5zZUluc3RhbmNlRi5tZXNzYWdlO3N0YWNrPV9nZXRTdXNwZW5zZUluc3RhbmNlRi5zdGFjazt9dmFyIGVycm9yO2lmKG1lc3NhZ2Upey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5lcnJvcj1uZXcgRXJyb3IobWVzc2FnZSk7fWVsc2V7ZXJyb3I9bmV3IEVycm9yKCdUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5ICcrJ2R1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gJysnY2xpZW50IHJlbmRlcmluZy4nKTt9dmFyIGNhcHR1cmVkVmFsdWU9Y3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvcixkaWdlc3Qsc3RhY2spO3JldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzLGNhcHR1cmVkVmFsdWUpO30vLyBhbnkgY29udGV4dCBoYXMgY2hhbmdlZCwgd2UgbmVlZCB0byB0cmVhdCBpcyBhcyBpZiB0aGUgaW5wdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLlxudmFyIGhhc0NvbnRleHRDaGFuZ2VkPWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsY3VycmVudC5jaGlsZExhbmVzKTtpZihkaWRSZWNlaXZlVXBkYXRlfHxoYXNDb250ZXh0Q2hhbmdlZCl7Ly8gVGhpcyBib3VuZGFyeSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIG1lYW5zIHRoYXQgd2UgYXJlIG5vdyB1bmFibGUgdG9cbi8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxudmFyIHJvb3Q9Z2V0V29ya0luUHJvZ3Jlc3NSb290KCk7aWYocm9vdCE9PW51bGwpe3ZhciBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lPWdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCxyZW5kZXJMYW5lcyk7aWYoYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSE9PU5vTGFuZSYmYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSE9PXN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKXsvLyBJbnRlbnRpb25hbGx5IG11dGF0aW5nIHNpbmNlIHRoaXMgcmVuZGVyIHdpbGwgZ2V0IGludGVycnVwdGVkLiBUaGlzXG4vLyBpcyBvbmUgb2YgdGhlIHZlcnkgcmFyZSB0aW1lcyB3aGVyZSB3ZSBtdXRhdGUgdGhlIGN1cnJlbnQgdHJlZVxuLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG5zdXNwZW5zZVN0YXRlLnJldHJ5TGFuZT1hdHRlbXB0SHlkcmF0aW9uQXRMYW5lOy8vIFRPRE86IElkZWFsbHkgdGhpcyB3b3VsZCBpbmhlcml0IHRoZSBldmVudCB0aW1lIG9mIHRoZSBjdXJyZW50IHJlbmRlclxudmFyIGV2ZW50VGltZT1Ob1RpbWVzdGFtcDtlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCxhdHRlbXB0SHlkcmF0aW9uQXRMYW5lKTtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxjdXJyZW50LGF0dGVtcHRIeWRyYXRpb25BdExhbmUsZXZlbnRUaW1lKTt9fS8vIElmIHdlIGhhdmUgc2NoZWR1bGVkIGhpZ2hlciBwcmkgd29yayBhYm92ZSwgdGhpcyB3aWxsIHByb2JhYmx5IGp1c3QgYWJvcnQgdGhlIHJlbmRlclxuLy8gc2luY2Ugd2Ugbm93IGhhdmUgaGlnaGVyIHByaW9yaXR5IHdvcmssIGJ1dCBpbiBjYXNlIGl0IGRvZXNuJ3QsIHdlIG5lZWQgdG8gcHJlcGFyZSB0b1xuLy8gcmVuZGVyIHNvbWV0aGluZywgaWYgd2UgdGltZSBvdXQuIEV2ZW4gaWYgdGhhdCByZXF1aXJlcyB1cyB0byBkZWxldGUgZXZlcnl0aGluZyBhbmRcbi8vIHNraXAgaHlkcmF0aW9uLlxuLy8gRGVsYXkgaGF2aW5nIHRvIGRvIHRoaXMgYXMgbG9uZyBhcyB0aGUgc3VzcGVuc2UgdGltZW91dCBhbGxvd3MgdXMuXG5yZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7dmFyIF9jYXB0dXJlZFZhbHVlPWNyZWF0ZUNhcHR1cmVkVmFsdWUobmV3IEVycm9yKCdUaGlzIFN1c3BlbnNlIGJvdW5kYXJ5IHJlY2VpdmVkIGFuIHVwZGF0ZSBiZWZvcmUgaXQgZmluaXNoZWQgJysnaHlkcmF0aW5nLiBUaGlzIGNhdXNlZCB0aGUgYm91bmRhcnkgdG8gc3dpdGNoIHRvIGNsaWVudCByZW5kZXJpbmcuICcrJ1RoZSB1c3VhbCB3YXkgdG8gZml4IHRoaXMgaXMgdG8gd3JhcCB0aGUgb3JpZ2luYWwgdXBkYXRlICcrJ2luIHN0YXJ0VHJhbnNpdGlvbi4nKSk7cmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMsX2NhcHR1cmVkVmFsdWUpO31lbHNlIGlmKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpey8vIFRoaXMgY29tcG9uZW50IGlzIHN0aWxsIHBlbmRpbmcgbW9yZSBkYXRhIGZyb20gdGhlIHNlcnZlciwgc28gd2UgY2FuJ3QgaHlkcmF0ZSBpdHNcbi8vIGNvbnRlbnQuIFdlIHRyZWF0IGl0IGFzIGlmIHRoaXMgY29tcG9uZW50IHN1c3BlbmRlZCBpdHNlbGYuIEl0IG1pZ2h0IHNlZW0gYXMgaWZcbi8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG4vLyBsb3Qgb2YgdW5uZWNlc3Nhcnkgd29yayBhbmQgaXMgdW5saWtlbHkgdG8gY29tcGxldGUgc2luY2UgaXQgb2Z0ZW4gd2lsbCBzdXNwZW5kXG4vLyBvbiBtaXNzaW5nIGRhdGEgYW55d2F5LiBBZGRpdGlvbmFsbHksIHRoZSBzZXJ2ZXIgbWlnaHQgYmUgYWJsZSB0byByZW5kZXIgbW9yZVxuLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG4vLyBvbiB0aGUgY2xpZW50IHRoYW4gaWYgd2UganVzdCBsZWF2ZSBpdCBhbG9uZS4gSWYgdGhlIHNlcnZlciB0aW1lcyBvdXQgb3IgZXJyb3JzXG4vLyB0aGVzZSBzaG91bGQgdXBkYXRlIHRoaXMgYm91bmRhcnkgdG8gdGhlIHBlcm1hbmVudCBGYWxsYmFjayBzdGF0ZSBpbnN0ZWFkLlxuLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlOy8vIExlYXZlIHRoZSBjaGlsZCBpbiBwbGFjZS4gSS5lLiB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudC5cbndvcmtJblByb2dyZXNzLmNoaWxkPWN1cnJlbnQuY2hpbGQ7Ly8gUmVnaXN0ZXIgYSBjYWxsYmFjayB0byByZXRyeSB0aGlzIGJvdW5kYXJ5IG9uY2UgdGhlIHNlcnZlciBoYXMgc2VudCB0aGUgcmVzdWx0LlxudmFyIHJldHJ5PXJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLGN1cnJlbnQpO3JlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KHN1c3BlbnNlSW5zdGFuY2UscmV0cnkpO3JldHVybiBudWxsO31lbHNley8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG5yZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3Msc3VzcGVuc2VJbnN0YW5jZSxzdXNwZW5zZVN0YXRlLnRyZWVDb250ZXh0KTt2YXIgcHJpbWFyeUNoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ9bW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcyxwcmltYXJ5Q2hpbGRyZW4pOy8vIE1hcmsgdGhlIGNoaWxkcmVuIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4vLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbi8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5wcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFnc3w9SHlkcmF0aW5nO3JldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDt9fWVsc2V7Ly8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlciBwYXNzLiBXZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBoeWRyYXRlZCwgYnV0XG4vLyBzb21ldGhpbmcgZWl0aGVyIHN1c3BlbmRlZCBvciBlcnJvcmVkLlxuaWYod29ya0luUHJvZ3Jlc3MuZmxhZ3MmRm9yY2VDbGllbnRSZW5kZXIpey8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBoeWRyYXRpb24uIFRyeSBhZ2FpbiB3aXRob3V0IGh5ZHJhdGluZy5cbndvcmtJblByb2dyZXNzLmZsYWdzJj1+Rm9yY2VDbGllbnRSZW5kZXI7dmFyIF9jYXB0dXJlZFZhbHVlMj1jcmVhdGVDYXB0dXJlZFZhbHVlKG5ldyBFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LiAnKydTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nLicpKTtyZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyxfY2FwdHVyZWRWYWx1ZTIpO31lbHNlIGlmKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUhPT1udWxsKXsvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFuZCB3ZSBzaG91bGQgc3RpbGwgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxud29ya0luUHJvZ3Jlc3MuY2hpbGQ9Y3VycmVudC5jaGlsZDsvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcbi8vIGJ1dCB0aGUgbm9ybWFsIHN1c3BlbnNlIHBhc3MgZG9lc24ndC5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO3JldHVybiBudWxsO31lbHNley8vIFN1c3BlbmRlZCBidXQgd2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG4vLyBUaGVyZWZvcmUgd2Ugbm93IGhhdmUgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbnZhciBuZXh0UHJpbWFyeUNoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW49bmV4dFByb3BzLmZhbGxiYWNrO3ZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ9bW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0UHJpbWFyeUNoaWxkcmVuLG5leHRGYWxsYmFja0NoaWxkcmVuLHJlbmRlckxhbmVzKTt2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ND13b3JrSW5Qcm9ncmVzcy5jaGlsZDtfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0Lm1lbW9pemVkU3RhdGU9bW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPVNVU1BFTkRFRF9NQVJLRVI7cmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDt9fX1mdW5jdGlvbiBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoZmliZXIscmVuZGVyTGFuZXMscHJvcGFnYXRpb25Sb290KXtmaWJlci5sYW5lcz1tZXJnZUxhbmVzKGZpYmVyLmxhbmVzLHJlbmRlckxhbmVzKTt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZihhbHRlcm5hdGUhPT1udWxsKXthbHRlcm5hdGUubGFuZXM9bWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMscmVuZGVyTGFuZXMpO31zY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybixyZW5kZXJMYW5lcyxwcm9wYWdhdGlvblJvb3QpO31mdW5jdGlvbiBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsZmlyc3RDaGlsZCxyZW5kZXJMYW5lcyl7Ly8gTWFyayBhbnkgU3VzcGVuc2UgYm91bmRhcmllcyB3aXRoIGZhbGxiYWNrcyBhcyBoYXZpbmcgd29yayB0byBkby5cbi8vIElmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGZvcmNlZCBpbnRvIGZhbGxiYWNrcywgdGhleSBtYXkgbm93IGJlIGFibGVcbi8vIHRvIHVuYmxvY2suXG52YXIgbm9kZT1maXJzdENoaWxkO3doaWxlKG5vZGUhPT1udWxsKXtpZihub2RlLnRhZz09PVN1c3BlbnNlQ29tcG9uZW50KXt2YXIgc3RhdGU9bm9kZS5tZW1vaXplZFN0YXRlO2lmKHN0YXRlIT09bnVsbCl7c2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUscmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MpO319ZWxzZSBpZihub2RlLnRhZz09PVN1c3BlbnNlTGlzdENvbXBvbmVudCl7Ly8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG4vLyB0byBzY2hlZHVsZSB3b3JrIG9uLiBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBvbiB0aGVcbi8vIGxpc3QgaXRzZWxmLlxuLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2Vcbi8vIHRoZSBsaXN0IHdpbGwgcHJvcGFnYXRlIHRoZSBjaGFuZ2Ugd2hlbiBpdCByZXJlbmRlcnMuXG5zY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSxyZW5kZXJMYW5lcyx3b3JrSW5Qcm9ncmVzcyk7fWVsc2UgaWYobm9kZS5jaGlsZCE9PW51bGwpe25vZGUuY2hpbGQucmV0dXJuPW5vZGU7bm9kZT1ub2RlLmNoaWxkO2NvbnRpbnVlO31pZihub2RlPT09d29ya0luUHJvZ3Jlc3Mpe3JldHVybjt9d2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxub2RlLnJldHVybj09PXdvcmtJblByb2dyZXNzKXtyZXR1cm47fW5vZGU9bm9kZS5yZXR1cm47fW5vZGUuc2libGluZy5yZXR1cm49bm9kZS5yZXR1cm47bm9kZT1ub2RlLnNpYmxpbmc7fX1mdW5jdGlvbiBmaW5kTGFzdENvbnRlbnRSb3coZmlyc3RDaGlsZCl7Ly8gVGhpcyBpcyBnb2luZyB0byBmaW5kIHRoZSBsYXN0IHJvdyBhbW9uZyB0aGVzZSBjaGlsZHJlbiB0aGF0IGlzIGFscmVhZHlcbi8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4vLyBuZXcuIElmIGEgcm93IGhhcyBtdWx0aXBsZSBTdXNwZW5zZSBib3VuZGFyaWVzLCBhbnkgb2YgdGhlbSBiZWluZyBpbiB0aGVcbi8vIGZhbGxiYWNrIHN0YXRlLCBjb3VudHMgYXMgdGhlIHdob2xlIHJvdyBiZWluZyBpbiBhIGZhbGxiYWNrIHN0YXRlLlxuLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuLy8gd2lsbCBzdGlsbCBiZSBjdXJyZW50IHNpbmNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlbSB5ZXQuIFRoZSBtb3VudGVkXG4vLyBvcmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBuZXcgb3JkZXIuIFdlIHVzZSB0aGUgbmV3IG9yZGVyLlxudmFyIHJvdz1maXJzdENoaWxkO3ZhciBsYXN0Q29udGVudFJvdz1udWxsO3doaWxlKHJvdyE9PW51bGwpe3ZhciBjdXJyZW50Um93PXJvdy5hbHRlcm5hdGU7Ly8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuaWYoY3VycmVudFJvdyE9PW51bGwmJmZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KT09PW51bGwpe2xhc3RDb250ZW50Um93PXJvdzt9cm93PXJvdy5zaWJsaW5nO31yZXR1cm4gbGFzdENvbnRlbnRSb3c7fWZ1bmN0aW9uIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpe3tpZihyZXZlYWxPcmRlciE9PXVuZGVmaW5lZCYmcmV2ZWFsT3JkZXIhPT0nZm9yd2FyZHMnJiZyZXZlYWxPcmRlciE9PSdiYWNrd2FyZHMnJiZyZXZlYWxPcmRlciE9PSd0b2dldGhlcicmJiFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pe2RpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXT10cnVlO2lmKHR5cGVvZiByZXZlYWxPcmRlcj09PSdzdHJpbmcnKXtzd2l0Y2gocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSl7Y2FzZSd0b2dldGhlcic6Y2FzZSdmb3J3YXJkcyc6Y2FzZSdiYWNrd2FyZHMnOntlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnKydVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicscmV2ZWFsT3JkZXIscmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7YnJlYWs7fWNhc2UnZm9yd2FyZCc6Y2FzZSdiYWNrd2FyZCc6e2Vycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcrJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJyxyZXZlYWxPcmRlcixyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTticmVhazt9ZGVmYXVsdDplcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnKydEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLHJldmVhbE9yZGVyKTticmVhazt9fWVsc2V7ZXJyb3IoJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJysnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JyxyZXZlYWxPcmRlcik7fX19fWZ1bmN0aW9uIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUscmV2ZWFsT3JkZXIpe3tpZih0YWlsTW9kZSE9PXVuZGVmaW5lZCYmIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSl7aWYodGFpbE1vZGUhPT0nY29sbGFwc2VkJyYmdGFpbE1vZGUhPT0naGlkZGVuJyl7ZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdPXRydWU7ZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gJysnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLHRhaWxNb2RlKTt9ZWxzZSBpZihyZXZlYWxPcmRlciE9PSdmb3J3YXJkcycmJnJldmVhbE9yZGVyIT09J2JhY2t3YXJkcycpe2RpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXT10cnVlO2Vycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJysnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcrJ0RpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLHRhaWxNb2RlKTt9fX19ZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsaW5kZXgpe3t2YXIgaXNBbkFycmF5PWlzQXJyYXkoY2hpbGRTbG90KTt2YXIgaXNJdGVyYWJsZT0haXNBbkFycmF5JiZ0eXBlb2YgZ2V0SXRlcmF0b3JGbihjaGlsZFNsb3QpPT09J2Z1bmN0aW9uJztpZihpc0FuQXJyYXl8fGlzSXRlcmFibGUpe3ZhciB0eXBlPWlzQW5BcnJheT8nYXJyYXknOidpdGVyYWJsZSc7ZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcrJ2FuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6ICcrJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gJysnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJysnPC9TdXNwZW5zZUxpc3Q+Jyx0eXBlLGluZGV4LHR5cGUpO3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO31mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKGNoaWxkcmVuLHJldmVhbE9yZGVyKXt7aWYoKHJldmVhbE9yZGVyPT09J2ZvcndhcmRzJ3x8cmV2ZWFsT3JkZXI9PT0nYmFja3dhcmRzJykmJmNoaWxkcmVuIT09dW5kZWZpbmVkJiZjaGlsZHJlbiE9PW51bGwmJmNoaWxkcmVuIT09ZmFsc2Upe2lmKGlzQXJyYXkoY2hpbGRyZW4pKXtmb3IodmFyIGk9MDtpPGNoaWxkcmVuLmxlbmd0aDtpKyspe2lmKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkcmVuW2ldLGkpKXtyZXR1cm47fX19ZWxzZXt2YXIgaXRlcmF0b3JGbj1nZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtpZih0eXBlb2YgaXRlcmF0b3JGbj09PSdmdW5jdGlvbicpe3ZhciBjaGlsZHJlbkl0ZXJhdG9yPWl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7aWYoY2hpbGRyZW5JdGVyYXRvcil7dmFyIHN0ZXA9Y2hpbGRyZW5JdGVyYXRvci5uZXh0KCk7dmFyIF9pPTA7Zm9yKDshc3RlcC5kb25lO3N0ZXA9Y2hpbGRyZW5JdGVyYXRvci5uZXh0KCkpe2lmKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsX2kpKXtyZXR1cm47fV9pKys7fX19ZWxzZXtlcnJvcignQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gJysnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcrJ0RpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycscmV2ZWFsT3JkZXIpO319fX19ZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLGlzQmFja3dhcmRzLHRhaWwsbGFzdENvbnRlbnRSb3csdGFpbE1vZGUpe3ZhciByZW5kZXJTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKHJlbmRlclN0YXRlPT09bnVsbCl7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT17aXNCYWNrd2FyZHM6aXNCYWNrd2FyZHMscmVuZGVyaW5nOm51bGwscmVuZGVyaW5nU3RhcnRUaW1lOjAsbGFzdDpsYXN0Q29udGVudFJvdyx0YWlsOnRhaWwsdGFpbE1vZGU6dGFpbE1vZGV9O31lbHNley8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbnJlbmRlclN0YXRlLmlzQmFja3dhcmRzPWlzQmFja3dhcmRzO3JlbmRlclN0YXRlLnJlbmRlcmluZz1udWxsO3JlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZT0wO3JlbmRlclN0YXRlLmxhc3Q9bGFzdENvbnRlbnRSb3c7cmVuZGVyU3RhdGUudGFpbD10YWlsO3JlbmRlclN0YXRlLnRhaWxNb2RlPXRhaWxNb2RlO319Ly8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7dmFyIG5leHRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIHJldmVhbE9yZGVyPW5leHRQcm9wcy5yZXZlYWxPcmRlcjt2YXIgdGFpbE1vZGU9bmV4dFByb3BzLnRhaWw7dmFyIG5ld0NoaWxkcmVuPW5leHRQcm9wcy5jaGlsZHJlbjt2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKTt2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLHJldmVhbE9yZGVyKTt2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKG5ld0NoaWxkcmVuLHJldmVhbE9yZGVyKTtyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5ld0NoaWxkcmVuLHJlbmRlckxhbmVzKTt2YXIgc3VzcGVuc2VDb250ZXh0PXN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDt2YXIgc2hvdWxkRm9yY2VGYWxsYmFjaz1oYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7aWYoc2hvdWxkRm9yY2VGYWxsYmFjayl7c3VzcGVuc2VDb250ZXh0PXNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7fWVsc2V7dmFyIGRpZFN1c3BlbmRCZWZvcmU9Y3VycmVudCE9PW51bGwmJihjdXJyZW50LmZsYWdzJkRpZENhcHR1cmUpIT09Tm9GbGFncztpZihkaWRTdXNwZW5kQmVmb3JlKXsvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbi8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbi8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG5wcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3Msd29ya0luUHJvZ3Jlc3MuY2hpbGQscmVuZGVyTGFuZXMpO31zdXNwZW5zZUNvbnRleHQ9c2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTt9cHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5zZUNvbnRleHQpO2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7Ly8gSW4gbGVnYWN5IG1vZGUsIFN1c3BlbnNlTGlzdCBkb2Vzbid0IHdvcmsgc28gd2UganVzdFxuLy8gdXNlIG1ha2UgaXQgYSBub29wIGJ5IHRyZWF0aW5nIGl0IGFzIHRoZSBkZWZhdWx0IHJldmVhbE9yZGVyLlxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO31lbHNle3N3aXRjaChyZXZlYWxPcmRlcil7Y2FzZSdmb3J3YXJkcyc6e3ZhciBsYXN0Q29udGVudFJvdz1maW5kTGFzdENvbnRlbnRSb3cod29ya0luUHJvZ3Jlc3MuY2hpbGQpO3ZhciB0YWlsO2lmKGxhc3RDb250ZW50Um93PT09bnVsbCl7Ly8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbi8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG50YWlsPXdvcmtJblByb2dyZXNzLmNoaWxkO3dvcmtJblByb2dyZXNzLmNoaWxkPW51bGw7fWVsc2V7Ly8gRGlzY29ubmVjdCB0aGUgdGFpbCByb3dzIGFmdGVyIHRoZSBjb250ZW50IHJvdy5cbi8vIFdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgbGF0ZXIuXG50YWlsPWxhc3RDb250ZW50Um93LnNpYmxpbmc7bGFzdENvbnRlbnRSb3cuc2libGluZz1udWxsO31pbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsZmFsc2UsLy8gaXNCYWNrd2FyZHNcbnRhaWwsbGFzdENvbnRlbnRSb3csdGFpbE1vZGUpO2JyZWFrO31jYXNlJ2JhY2t3YXJkcyc6ey8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuLy8gQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBnb2luZyB0byByZXZlcnNlIHRoZSBsaXN0IG9mIGV2ZXJ5dGhpbmdcbi8vIHdlIHBhc3MgaW4gdGhlIG1lYW50aW1lLiBUaGF0J3MgZ29pbmcgdG8gYmUgb3VyIHRhaWwgaW4gcmV2ZXJzZVxuLy8gb3JkZXIuXG52YXIgX3RhaWw9bnVsbDt2YXIgcm93PXdvcmtJblByb2dyZXNzLmNoaWxkO3dvcmtJblByb2dyZXNzLmNoaWxkPW51bGw7d2hpbGUocm93IT09bnVsbCl7dmFyIGN1cnJlbnRSb3c9cm93LmFsdGVybmF0ZTsvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5pZihjdXJyZW50Um93IT09bnVsbCYmZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpPT09bnVsbCl7Ly8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1yb3c7YnJlYWs7fXZhciBuZXh0Um93PXJvdy5zaWJsaW5nO3Jvdy5zaWJsaW5nPV90YWlsO190YWlsPXJvdztyb3c9bmV4dFJvdzt9Ly8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLHRydWUsLy8gaXNCYWNrd2FyZHNcbl90YWlsLG51bGwsLy8gbGFzdFxudGFpbE1vZGUpO2JyZWFrO31jYXNlJ3RvZ2V0aGVyJzp7aW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLGZhbHNlLC8vIGlzQmFja3dhcmRzXG5udWxsLC8vIHRhaWxcbm51bGwsLy8gbGFzdFxudW5kZWZpbmVkKTticmVhazt9ZGVmYXVsdDp7Ly8gVGhlIGRlZmF1bHQgcmV2ZWFsIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG5vdCBoYXZpbmdcbi8vIGEgYm91bmRhcnkuXG53b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7fX19cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7cHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3Msd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3ZhciBuZXh0Q2hpbGRyZW49d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO2lmKGN1cnJlbnQ9PT1udWxsKXsvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbi8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4vLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbi8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcyxudWxsLG5leHRDaGlsZHJlbixyZW5kZXJMYW5lcyk7fWVsc2V7cmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0Q2hpbGRyZW4scmVuZGVyTGFuZXMpO31yZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fXZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcj1mYWxzZTtmdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7dmFyIHByb3ZpZGVyVHlwZT13b3JrSW5Qcm9ncmVzcy50eXBlO3ZhciBjb250ZXh0PXByb3ZpZGVyVHlwZS5fY29udGV4dDt2YXIgbmV3UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBvbGRQcm9wcz13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO3ZhciBuZXdWYWx1ZT1uZXdQcm9wcy52YWx1ZTt7aWYoISgndmFsdWUnaW4gbmV3UHJvcHMpKXtpZighaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpe2hhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyPXRydWU7ZXJyb3IoJ1RoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD8nKTt9fXZhciBwcm92aWRlclByb3BUeXBlcz13b3JrSW5Qcm9ncmVzcy50eXBlLnByb3BUeXBlcztpZihwcm92aWRlclByb3BUeXBlcyl7Y2hlY2tQcm9wVHlwZXMocHJvdmlkZXJQcm9wVHlwZXMsbmV3UHJvcHMsJ3Byb3AnLCdDb250ZXh0LlByb3ZpZGVyJyk7fX1wdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsY29udGV4dCxuZXdWYWx1ZSk7e2lmKG9sZFByb3BzIT09bnVsbCl7dmFyIG9sZFZhbHVlPW9sZFByb3BzLnZhbHVlO2lmKG9iamVjdElzKG9sZFZhbHVlLG5ld1ZhbHVlKSl7Ly8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbmlmKG9sZFByb3BzLmNoaWxkcmVuPT09bmV3UHJvcHMuY2hpbGRyZW4mJiFoYXNDb250ZXh0Q2hhbmdlZCgpKXtyZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9fWVsc2V7Ly8gVGhlIGNvbnRleHQgdmFsdWUgY2hhbmdlZC4gU2VhcmNoIGZvciBtYXRjaGluZyBjb25zdW1lcnMgYW5kIHNjaGVkdWxlXG4vLyB0aGVtIHRvIHVwZGF0ZS5cbnByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsY29udGV4dCxyZW5kZXJMYW5lcyk7fX19dmFyIG5ld0NoaWxkcmVuPW5ld1Byb3BzLmNoaWxkcmVuO3JlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV3Q2hpbGRyZW4scmVuZGVyTGFuZXMpO3JldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDt9dmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcj1mYWxzZTtmdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7dmFyIGNvbnRleHQ9d29ya0luUHJvZ3Jlc3MudHlwZTsvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbi8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4vLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0Rcbi8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4vLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4vLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG57aWYoY29udGV4dC5fY29udGV4dD09PXVuZGVmaW5lZCl7Ly8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4vLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4vLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG5pZihjb250ZXh0IT09Y29udGV4dC5Db25zdW1lcil7aWYoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcil7aGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyPXRydWU7ZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcrJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7fX19ZWxzZXtjb250ZXh0PWNvbnRleHQuX2NvbnRleHQ7fX12YXIgbmV3UHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciByZW5kZXI9bmV3UHJvcHMuY2hpbGRyZW47e2lmKHR5cGVvZiByZW5kZXIhPT0nZnVuY3Rpb24nKXtlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcrXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiKyd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJysnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTt9fXByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt2YXIgbmV3VmFsdWU9cmVhZENvbnRleHQoY29udGV4dCk7e21hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTt9dmFyIG5ld0NoaWxkcmVuO3tSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ9d29ya0luUHJvZ3Jlc3M7c2V0SXNSZW5kZXJpbmcodHJ1ZSk7bmV3Q2hpbGRyZW49cmVuZGVyKG5ld1ZhbHVlKTtzZXRJc1JlbmRlcmluZyhmYWxzZSk7fXttYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO30vLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGVyZm9ybWVkV29yaztyZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG5ld0NoaWxkcmVuLHJlbmRlckxhbmVzKTtyZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7fWZ1bmN0aW9uIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCl7ZGlkUmVjZWl2ZVVwZGF0ZT10cnVlO31mdW5jdGlvbiByZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Mpe2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7aWYoY3VycmVudCE9PW51bGwpey8vIEEgbGF6eSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbi8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2Vcbi8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuY3VycmVudC5hbHRlcm5hdGU9bnVsbDt3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU9bnVsbDsvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9UGxhY2VtZW50O319fWZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7aWYoY3VycmVudCE9PW51bGwpey8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xud29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzPWN1cnJlbnQuZGVwZW5kZW5jaWVzO317Ly8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG5zdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZygpO31tYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsvLyBDaGVjayBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBhbnkgcGVuZGluZyB3b3JrLlxuaWYoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpey8vIFRoZSBjaGlsZHJlbiBkb24ndCBoYXZlIGFueSB3b3JrIGVpdGhlci4gV2UgY2FuIHNraXAgdGhlbS5cbi8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4vLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxue3JldHVybiBudWxsO319Ly8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbmNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31mdW5jdGlvbiByZW1vdW50RmliZXIoY3VycmVudCxvbGRXb3JrSW5Qcm9ncmVzcyxuZXdXb3JrSW5Qcm9ncmVzcyl7e3ZhciByZXR1cm5GaWJlcj1vbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47aWYocmV0dXJuRmliZXI9PT1udWxsKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xudGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTt9Ly8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cbi8vIEl0IHdpbGwgZ2V0IGRlbGV0ZWQuXG5jdXJyZW50LmFsdGVybmF0ZT1udWxsO29sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZT1udWxsOy8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxubmV3V29ya0luUHJvZ3Jlc3MuaW5kZXg9b2xkV29ya0luUHJvZ3Jlc3MuaW5kZXg7bmV3V29ya0luUHJvZ3Jlc3Muc2libGluZz1vbGRXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nO25ld1dvcmtJblByb2dyZXNzLnJldHVybj1vbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47bmV3V29ya0luUHJvZ3Jlc3MucmVmPW9sZFdvcmtJblByb2dyZXNzLnJlZjsvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuaWYob2xkV29ya0luUHJvZ3Jlc3M9PT1yZXR1cm5GaWJlci5jaGlsZCl7cmV0dXJuRmliZXIuY2hpbGQ9bmV3V29ya0luUHJvZ3Jlc3M7fWVsc2V7dmFyIHByZXZTaWJsaW5nPXJldHVybkZpYmVyLmNoaWxkO2lmKHByZXZTaWJsaW5nPT09bnVsbCl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbnRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTt9d2hpbGUocHJldlNpYmxpbmcuc2libGluZyE9PW9sZFdvcmtJblByb2dyZXNzKXtwcmV2U2libGluZz1wcmV2U2libGluZy5zaWJsaW5nO2lmKHByZXZTaWJsaW5nPT09bnVsbCl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbnRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJldmlvdXMgc2libGluZy4nKTt9fXByZXZTaWJsaW5nLnNpYmxpbmc9bmV3V29ya0luUHJvZ3Jlc3M7fS8vIERlbGV0ZSB0aGUgb2xkIGZpYmVyIGFuZCBwbGFjZSB0aGUgbmV3IG9uZS5cbi8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxudmFyIGRlbGV0aW9ucz1yZXR1cm5GaWJlci5kZWxldGlvbnM7aWYoZGVsZXRpb25zPT09bnVsbCl7cmV0dXJuRmliZXIuZGVsZXRpb25zPVtjdXJyZW50XTtyZXR1cm5GaWJlci5mbGFnc3w9Q2hpbGREZWxldGlvbjt9ZWxzZXtkZWxldGlvbnMucHVzaChjdXJyZW50KTt9bmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVBsYWNlbWVudDsvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxucmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO319ZnVuY3Rpb24gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCxyZW5kZXJMYW5lcyl7Ly8gQmVmb3JlIHBlcmZvcm1pbmcgYW4gZWFybHkgYmFpbG91dCwgd2UgbXVzdCBjaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZ1xuLy8gdXBkYXRlcyBvciBjb250ZXh0LlxudmFyIHVwZGF0ZUxhbmVzPWN1cnJlbnQubGFuZXM7aWYoaW5jbHVkZXNTb21lTGFuZSh1cGRhdGVMYW5lcyxyZW5kZXJMYW5lcykpe3JldHVybiB0cnVlO30vLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxucmV0dXJuIGZhbHNlO31mdW5jdGlvbiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXsvLyBUaGlzIGZpYmVyIGRvZXMgbm90IGhhdmUgYW55IHBlbmRpbmcgd29yay4gQmFpbG91dCB3aXRob3V0IGVudGVyaW5nXG4vLyB0aGUgYmVnaW4gcGhhc2UuIFRoZXJlJ3Mgc3RpbGwgc29tZSBib29ra2VlcGluZyB3ZSB0aGF0IG5lZWRzIHRvIGJlIGRvbmVcbi8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuc3dpdGNoKHdvcmtJblByb2dyZXNzLnRhZyl7Y2FzZSBIb3N0Um9vdDpwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTt2YXIgcm9vdD13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7cmVzZXRIeWRyYXRpb25TdGF0ZSgpO2JyZWFrO2Nhc2UgSG9zdENvbXBvbmVudDpwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO2JyZWFrO2Nhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBDb21wb25lbnQ9d29ya0luUHJvZ3Jlc3MudHlwZTtpZihpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKXtwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTt9YnJlYWs7fWNhc2UgSG9zdFBvcnRhbDpwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyx3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7YnJlYWs7Y2FzZSBDb250ZXh0UHJvdmlkZXI6e3ZhciBuZXdWYWx1ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO3ZhciBjb250ZXh0PXdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7cHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLGNvbnRleHQsbmV3VmFsdWUpO2JyZWFrO31jYXNlIFByb2ZpbGVyOnsvLyBQcm9maWxlciBzaG91bGQgb25seSBjYWxsIG9uUmVuZGVyIHdoZW4gb25lIG9mIGl0cyBkZXNjZW5kYW50cyBhY3R1YWxseSByZW5kZXJlZC5cbnZhciBoYXNDaGlsZFdvcms9aW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyx3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtpZihoYXNDaGlsZFdvcmspe3dvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fXsvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4vLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxudmFyIHN0YXRlTm9kZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7c3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uPTA7c3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbj0wO319YnJlYWs7Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7dmFyIHN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYoc3RhdGUhPT1udWxsKXtpZihzdGF0ZS5kZWh5ZHJhdGVkIT09bnVsbCl7cHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4vLyBiZWVuIHVuc3VzcGVuZGVkIGl0IGhhcyBjb21taXR0ZWQgYXMgYSByZXNvbHZlZCBTdXNwZW5zZSBjb21wb25lbnQuXG4vLyBJZiBpdCBuZWVkcyB0byBiZSByZXRyaWVkLCBpdCBzaG91bGQgaGF2ZSB3b3JrIHNjaGVkdWxlZCBvbiBpdC5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlOy8vIFdlIHNob3VsZCBuZXZlciByZW5kZXIgdGhlIGNoaWxkcmVuIG9mIGEgZGVoeWRyYXRlZCBib3VuZGFyeSB1bnRpbCB3ZVxuLy8gdXBncmFkZSBpdC4gV2UgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrLlxucmV0dXJuIG51bGw7fS8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbi8vIHdoZXRoZXIgdG8gcmV0cnkgdGhlIHByaW1hcnkgY2hpbGRyZW4sIG9yIHRvIHNraXAgb3ZlciBpdCBhbmRcbi8vIGdvIHN0cmFpZ2h0IHRvIHRoZSBmYWxsYmFjay4gQ2hlY2sgdGhlIHByaW9yaXR5IG9mIHRoZSBwcmltYXJ5XG4vLyBjaGlsZCBmcmFnbWVudC5cbnZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDt2YXIgcHJpbWFyeUNoaWxkTGFuZXM9cHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcztpZihpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLHByaW1hcnlDaGlsZExhbmVzKSl7Ly8gVGhlIHByaW1hcnkgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFVzZSB0aGUgbm9ybWFsIHBhdGhcbi8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxucmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31lbHNley8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuLy8gb24gaXRcbnB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7Ly8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuLy8gcHJpb3JpdHkuIEJhaWxvdXQuXG52YXIgY2hpbGQ9YmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtpZihjaGlsZCE9PW51bGwpey8vIFRoZSBmYWxsYmFjayBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gU2tpcCBvdmVyIHRoZVxuLy8gcHJpbWFyeSBjaGlsZHJlbiBhbmQgd29yayBvbiB0aGUgZmFsbGJhY2suXG5yZXR1cm4gY2hpbGQuc2libGluZzt9ZWxzZXsvLyBOb3RlOiBXZSBjYW4gcmV0dXJuIGBudWxsYCBoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSBjaGVja2VkXG4vLyB3aGV0aGVyIHRoZXJlIHdlcmUgbmVzdGVkIGNvbnRleHQgY29uc3VtZXJzLCB2aWEgdGhlIGNhbGwgdG9cbi8vIGBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrYCBhYm92ZS5cbnJldHVybiBudWxsO319fWVsc2V7cHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTt9YnJlYWs7fWNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50Ont2YXIgZGlkU3VzcGVuZEJlZm9yZT0oY3VycmVudC5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7dmFyIF9oYXNDaGlsZFdvcms9aW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcyx3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtpZihkaWRTdXNwZW5kQmVmb3JlKXtpZihfaGFzQ2hpbGRXb3JrKXsvLyBJZiBzb21ldGhpbmcgd2FzIGluIGZhbGxiYWNrIHN0YXRlIGxhc3QgdGltZSwgYW5kIHdlIGhhdmUgYWxsIHRoZVxuLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4vLyBTb21ldGhpbmcgbWlnaHQgZ2V0IHVuYmxvY2tlZCBieSBzdGF0ZSB1cGRhdGVzIG9yIHJldHJpZXMgaW4gdGhlXG4vLyB0cmVlIHdoaWNoIHdpbGwgYWZmZWN0IHRoZSB0YWlsLiBTbyB3ZSBuZWVkIHRvIHVzZSB0aGUgbm9ybWFsXG4vLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbnJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fS8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2Zcbi8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO30vLyBJZiBub3RoaW5nIHN1c3BlbmRlZCBiZWZvcmUgYW5kIHdlJ3JlIHJlbmRlcmluZyB0aGUgc2FtZSBjaGlsZHJlbixcbi8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuLy8gaW4gdGhlIFwidG9nZXRoZXJcIiBtb2RlLCBzbyB3ZSBjYW4gY29udGludWUgZnJvbSB0aGUgc3RhdGUgd2UgaGFkLlxudmFyIHJlbmRlclN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYocmVuZGVyU3RhdGUhPT1udWxsKXsvLyBSZXNldCB0byB0aGUgXCJ0b2dldGhlclwiIG1vZGUgaW4gY2FzZSB3ZSd2ZSBzdGFydGVkIGEgZGlmZmVyZW50XG4vLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbnJlbmRlclN0YXRlLnJlbmRlcmluZz1udWxsO3JlbmRlclN0YXRlLnRhaWw9bnVsbDtyZW5kZXJTdGF0ZS5sYXN0RWZmZWN0PW51bGw7fXB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtpZihfaGFzQ2hpbGRXb3JrKXticmVhazt9ZWxzZXsvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4vLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbi8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5yZXR1cm4gbnVsbDt9fWNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OmNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OnsvLyBOZWVkIHRvIGNoZWNrIGlmIHRoZSB0cmVlIHN0aWxsIG5lZWRzIHRvIGJlIGRlZmVycmVkLiBUaGlzIGlzXG4vLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4vLyBzbyB3ZSdsbCBqdXN0IGVudGVyIHRoYXQuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgd2UnbGwgYmFpbCBvdXRcbi8vIGF0IHRoZSBuZXh0IGxldmVsIGluc3RlYWQgb2YgdGhpcyBvbmUsIGJlY2F1c2UgdGhlIGNoaWxkIHByb3BzXG4vLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHJlZmFjdG9yIGBiZWdpbldvcmtgIHRvIHNwbGl0IHRoZSBiYWlsb3V0XG4vLyBwYXRoIGZyb20gdGhlIG5vcm1hbCBwYXRoLiBJJ20gdGVtcHRlZCB0byBkbyBhIGxhYmVsZWQgYnJlYWsgaGVyZVxuLy8gYnV0IEkgd29uJ3QgOilcbndvcmtJblByb2dyZXNzLmxhbmVzPU5vTGFuZXM7cmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTt9fXJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7e2lmKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCYmY3VycmVudCE9PW51bGwpey8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxucmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LHdvcmtJblByb2dyZXNzLGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh3b3JrSW5Qcm9ncmVzcy50eXBlLHdvcmtJblByb2dyZXNzLmtleSx3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXJ8fG51bGwsd29ya0luUHJvZ3Jlc3MubW9kZSx3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO319aWYoY3VycmVudCE9PW51bGwpe3ZhciBvbGRQcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7dmFyIG5ld1Byb3BzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztpZihvbGRQcm9wcyE9PW5ld1Byb3BzfHxoYXNDb250ZXh0Q2hhbmdlZCgpfHwvLyBGb3JjZSBhIHJlLXJlbmRlciBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZDpcbndvcmtJblByb2dyZXNzLnR5cGUhPT1jdXJyZW50LnR5cGUpey8vIElmIHByb3BzIG9yIGNvbnRleHQgY2hhbmdlZCwgbWFyayB0aGUgZmliZXIgYXMgaGF2aW5nIHBlcmZvcm1lZCB3b3JrLlxuLy8gVGhpcyBtYXkgYmUgdW5zZXQgaWYgdGhlIHByb3BzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIGVxdWFsIGxhdGVyIChtZW1vKS5cbmRpZFJlY2VpdmVVcGRhdGU9dHJ1ZTt9ZWxzZXsvLyBOZWl0aGVyIHByb3BzIG5vciBsZWdhY3kgY29udGV4dCBjaGFuZ2VzLiBDaGVjayBpZiB0aGVyZSdzIGEgcGVuZGluZ1xuLy8gdXBkYXRlIG9yIGNvbnRleHQgY2hhbmdlLlxudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dD1jaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LHJlbmRlckxhbmVzKTtpZighaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0JiYvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgcGFzcyBvZiBhbiBlcnJvciBvciBzdXNwZW5zZSBib3VuZGFyeSwgdGhlcmVcbi8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuKHdvcmtJblByb2dyZXNzLmZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFncyl7Ly8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbmRpZFJlY2VpdmVVcGRhdGU9ZmFsc2U7cmV0dXJuIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31pZigoY3VycmVudC5mbGFncyZGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSE9PU5vRmxhZ3Mpey8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG5kaWRSZWNlaXZlVXBkYXRlPXRydWU7fWVsc2V7Ly8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb24gdGhpcyBmaWJlciwgYnV0IHRoZXJlIGFyZSBubyBuZXcgcHJvcHNcbi8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4vLyBjb25zdW1lciBwcm9kdWNlcyBhIGNoYW5nZWQgdmFsdWUsIGl0IHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZS4gT3RoZXJ3aXNlLFxuLy8gdGhlIGNvbXBvbmVudCB3aWxsIGFzc3VtZSB0aGUgY2hpbGRyZW4gaGF2ZSBub3QgY2hhbmdlZCBhbmQgYmFpbCBvdXQuXG5kaWRSZWNlaXZlVXBkYXRlPWZhbHNlO319fWVsc2V7ZGlkUmVjZWl2ZVVwZGF0ZT1mYWxzZTtpZihnZXRJc0h5ZHJhdGluZygpJiZpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKSl7Ly8gQ2hlY2sgaWYgdGhpcyBjaGlsZCBiZWxvbmdzIHRvIGEgbGlzdCBvZiBtdWxpcGxlIGNoaWxkcmVuIGluXG4vLyBpdHMgcGFyZW50LlxuLy9cbi8vIEluIGEgdHJ1ZSBtdWx0aS10aHJlYWRlZCBpbXBsZW1lbnRhdGlvbiwgd2Ugd291bGQgcmVuZGVyIGNoaWxkcmVuIG9uXG4vLyBwYXJhbGxlbCB0aHJlYWRzLiBUaGlzIHdvdWxkIHJlcHJlc2VudCB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHJlbmRlclxuLy8gdGhyZWFkIGZvciB0aGlzIHN1YnRyZWUuXG4vL1xuLy8gV2Ugb25seSB1c2UgdGhpcyBmb3IgaWQgZ2VuZXJhdGlvbiBkdXJpbmcgaHlkcmF0aW9uLCB3aGljaCBpcyB3aHkgdGhlXG4vLyBsb2dpYyBpcyBsb2NhdGVkIGluIHRoaXMgc3BlY2lhbCBicmFuY2guXG52YXIgc2xvdEluZGV4PXdvcmtJblByb2dyZXNzLmluZGV4O3ZhciBudW1iZXJPZkZvcmtzPWdldEZvcmtzQXRMZXZlbCgpO3B1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsbnVtYmVyT2ZGb3JrcyxzbG90SW5kZXgpO319Ly8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY2xlYXIgcGVuZGluZyB1cGRhdGUgcHJpb3JpdHkuXG4vLyBUT0RPOiBUaGlzIGFzc3VtZXMgdGhhdCB3ZSdyZSBhYm91dCB0byBldmFsdWF0ZSB0aGUgY29tcG9uZW50IGFuZCBwcm9jZXNzXG4vLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuLy8gc29tZXRpbWVzIGJhaWxzIG91dCBsYXRlciBpbiB0aGUgYmVnaW4gcGhhc2UuIFRoaXMgaW5kaWNhdGVzIHRoYXQgd2Ugc2hvdWxkXG4vLyBtb3ZlIHRoaXMgYXNzaWdubWVudCBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIGFuZCBpbnRvIGVhY2ggYnJhbmNoLlxud29ya0luUHJvZ3Jlc3MubGFuZXM9Tm9MYW5lcztzd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6e3JldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyx3b3JrSW5Qcm9ncmVzcy50eXBlLHJlbmRlckxhbmVzKTt9Y2FzZSBMYXp5Q29tcG9uZW50Ont2YXIgZWxlbWVudFR5cGU9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7cmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLGVsZW1lbnRUeXBlLHJlbmRlckxhbmVzKTt9Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDp7dmFyIENvbXBvbmVudD13b3JrSW5Qcm9ncmVzcy50eXBlO3ZhciB1bnJlc29sdmVkUHJvcHM9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciByZXNvbHZlZFByb3BzPXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlPT09Q29tcG9uZW50P3VucmVzb2x2ZWRQcm9wczpyZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCx1bnJlc29sdmVkUHJvcHMpO3JldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLENvbXBvbmVudCxyZXNvbHZlZFByb3BzLHJlbmRlckxhbmVzKTt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIF9Db21wb25lbnQ9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgX3VucmVzb2x2ZWRQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIF9yZXNvbHZlZFByb3BzPXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlPT09X0NvbXBvbmVudD9fdW5yZXNvbHZlZFByb3BzOnJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudCxfdW5yZXNvbHZlZFByb3BzKTtyZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxfQ29tcG9uZW50LF9yZXNvbHZlZFByb3BzLHJlbmRlckxhbmVzKTt9Y2FzZSBIb3N0Um9vdDpyZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBIb3N0Q29tcG9uZW50OnJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgSG9zdFRleHQ6cmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO2Nhc2UgU3VzcGVuc2VDb21wb25lbnQ6cmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgSG9zdFBvcnRhbDpyZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgRm9yd2FyZFJlZjp7dmFyIHR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTt2YXIgX3VucmVzb2x2ZWRQcm9wczI9d29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO3ZhciBfcmVzb2x2ZWRQcm9wczI9d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU9PT10eXBlP191bnJlc29sdmVkUHJvcHMyOnJlc29sdmVEZWZhdWx0UHJvcHModHlwZSxfdW5yZXNvbHZlZFByb3BzMik7cmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyx0eXBlLF9yZXNvbHZlZFByb3BzMixyZW5kZXJMYW5lcyk7fWNhc2UgRnJhZ21lbnQ6cmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgTW9kZTpyZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIFByb2ZpbGVyOnJldHVybiB1cGRhdGVQcm9maWxlcihjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKTtjYXNlIENvbnRleHRQcm92aWRlcjpyZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO2Nhc2UgQ29udGV4dENvbnN1bWVyOnJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7Y2FzZSBNZW1vQ29tcG9uZW50Ont2YXIgX3R5cGUyPXdvcmtJblByb2dyZXNzLnR5cGU7dmFyIF91bnJlc29sdmVkUHJvcHMzPXdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsvLyBSZXNvbHZlIG91dGVyIHByb3BzIGZpcnN0LCB0aGVuIHJlc29sdmUgaW5uZXIgcHJvcHMuXG52YXIgX3Jlc29sdmVkUHJvcHMzPXJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLF91bnJlc29sdmVkUHJvcHMzKTt7aWYod29ya0luUHJvZ3Jlc3MudHlwZSE9PXdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKXt2YXIgb3V0ZXJQcm9wVHlwZXM9X3R5cGUyLnByb3BUeXBlcztpZihvdXRlclByb3BUeXBlcyl7Y2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsX3Jlc29sdmVkUHJvcHMzLC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4ncHJvcCcsZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlMikpO319fV9yZXNvbHZlZFByb3BzMz1yZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMi50eXBlLF9yZXNvbHZlZFByb3BzMyk7cmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxfdHlwZTIsX3Jlc29sdmVkUHJvcHMzLHJlbmRlckxhbmVzKTt9Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OntyZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLHdvcmtJblByb2dyZXNzLnR5cGUsd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLHJlbmRlckxhbmVzKTt9Y2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6e3ZhciBfQ29tcG9uZW50Mj13b3JrSW5Qcm9ncmVzcy50eXBlO3ZhciBfdW5yZXNvbHZlZFByb3BzND13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7dmFyIF9yZXNvbHZlZFByb3BzND13b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZT09PV9Db21wb25lbnQyP191bnJlc29sdmVkUHJvcHM0OnJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsX3VucmVzb2x2ZWRQcm9wczQpO3JldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LHdvcmtJblByb2dyZXNzLF9Db21wb25lbnQyLF9yZXNvbHZlZFByb3BzNCxyZW5kZXJMYW5lcyk7fWNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OntyZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpO31jYXNlIFNjb3BlQ29tcG9uZW50OnticmVhazt9Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6e3JldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyk7fX10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiK3dvcmtJblByb2dyZXNzLnRhZytcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIisnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31mdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKXsvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4vLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fWZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyl7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVJlZjt7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PVJlZlN0YXRpYzt9fXZhciBhcHBlbmRBbGxDaGlsZHJlbjt2YXIgdXBkYXRlSG9zdENvbnRhaW5lcjt2YXIgdXBkYXRlSG9zdENvbXBvbmVudCQxO3ZhciB1cGRhdGVIb3N0VGV4dCQxO3svLyBNdXRhdGlvbiBtb2RlXG5hcHBlbmRBbGxDaGlsZHJlbj1mdW5jdGlvbihwYXJlbnQsd29ya0luUHJvZ3Jlc3MsbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLGlzSGlkZGVuKXsvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbi8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbnZhciBub2RlPXdvcmtJblByb2dyZXNzLmNoaWxkO3doaWxlKG5vZGUhPT1udWxsKXtpZihub2RlLnRhZz09PUhvc3RDb21wb25lbnR8fG5vZGUudGFnPT09SG9zdFRleHQpe2FwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsbm9kZS5zdGF0ZU5vZGUpO31lbHNlIGlmKG5vZGUudGFnPT09SG9zdFBvcnRhbCk7ZWxzZSBpZihub2RlLmNoaWxkIT09bnVsbCl7bm9kZS5jaGlsZC5yZXR1cm49bm9kZTtub2RlPW5vZGUuY2hpbGQ7Y29udGludWU7fWlmKG5vZGU9PT13b3JrSW5Qcm9ncmVzcyl7cmV0dXJuO313aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fG5vZGUucmV0dXJuPT09d29ya0luUHJvZ3Jlc3Mpe3JldHVybjt9bm9kZT1ub2RlLnJldHVybjt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt9fTt1cGRhdGVIb3N0Q29udGFpbmVyPWZ1bmN0aW9uKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Mpey8vIE5vb3Bcbn07dXBkYXRlSG9zdENvbXBvbmVudCQxPWZ1bmN0aW9uKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsdHlwZSxuZXdQcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2Upey8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkIHRvXG4vLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxudmFyIG9sZFByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wcztpZihvbGRQcm9wcz09PW5ld1Byb3BzKXsvLyBJbiBtdXRhdGlvbiBtb2RlLCB0aGlzIGlzIHN1ZmZpY2llbnQgZm9yIGEgYmFpbG91dCBiZWNhdXNlXG4vLyB3ZSB3b24ndCB0b3VjaCB0aGlzIG5vZGUgZXZlbiBpZiBjaGlsZHJlbiBjaGFuZ2VkLlxucmV0dXJuO30vLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3Rcbi8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4vLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbnZhciBpbnN0YW5jZT13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7dmFyIGN1cnJlbnRIb3N0Q29udGV4dD1nZXRIb3N0Q29udGV4dCgpOy8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3Rcbi8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4vLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxudmFyIHVwZGF0ZVBheWxvYWQ9cHJlcGFyZVVwZGF0ZShpbnN0YW5jZSx0eXBlLG9sZFByb3BzLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSxjdXJyZW50SG9zdENvbnRleHQpOy8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50Llxud29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9dXBkYXRlUGF5bG9hZDsvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbi8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuaWYodXBkYXRlUGF5bG9hZCl7bWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7fX07dXBkYXRlSG9zdFRleHQkMT1mdW5jdGlvbihjdXJyZW50LHdvcmtJblByb2dyZXNzLG9sZFRleHQsbmV3VGV4dCl7Ly8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG5pZihvbGRUZXh0IT09bmV3VGV4dCl7bWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7fX07fWZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSxoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spe2lmKGdldElzSHlkcmF0aW5nKCkpey8vIElmIHdlJ3JlIGh5ZHJhdGluZywgd2Ugc2hvdWxkIGNvbnN1bWUgYXMgbWFueSBpdGVtcyBhcyB3ZSBjYW5cbi8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG5yZXR1cm47fXN3aXRjaChyZW5kZXJTdGF0ZS50YWlsTW9kZSl7Y2FzZSdoaWRkZW4nOnsvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4vLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4vLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbi8vIHRoZXJlIGFyZSBhbnkuXG52YXIgdGFpbE5vZGU9cmVuZGVyU3RhdGUudGFpbDt2YXIgbGFzdFRhaWxOb2RlPW51bGw7d2hpbGUodGFpbE5vZGUhPT1udWxsKXtpZih0YWlsTm9kZS5hbHRlcm5hdGUhPT1udWxsKXtsYXN0VGFpbE5vZGU9dGFpbE5vZGU7fXRhaWxOb2RlPXRhaWxOb2RlLnNpYmxpbmc7fS8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbi8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cbmlmKGxhc3RUYWlsTm9kZT09PW51bGwpey8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG5yZW5kZXJTdGF0ZS50YWlsPW51bGw7fWVsc2V7Ly8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4vLyBpbnNlcnRlZC5cbmxhc3RUYWlsTm9kZS5zaWJsaW5nPW51bGw7fWJyZWFrO31jYXNlJ2NvbGxhcHNlZCc6ey8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4vLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbi8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbi8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuLy8gdGhlcmUgYXJlIGFueS5cbnZhciBfdGFpbE5vZGU9cmVuZGVyU3RhdGUudGFpbDt2YXIgX2xhc3RUYWlsTm9kZT1udWxsO3doaWxlKF90YWlsTm9kZSE9PW51bGwpe2lmKF90YWlsTm9kZS5hbHRlcm5hdGUhPT1udWxsKXtfbGFzdFRhaWxOb2RlPV90YWlsTm9kZTt9X3RhaWxOb2RlPV90YWlsTm9kZS5zaWJsaW5nO30vLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4vLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5pZihfbGFzdFRhaWxOb2RlPT09bnVsbCl7Ly8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbmlmKCFoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2smJnJlbmRlclN0YXRlLnRhaWwhPT1udWxsKXsvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4vLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG5yZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmc9bnVsbDt9ZWxzZXtyZW5kZXJTdGF0ZS50YWlsPW51bGw7fX1lbHNley8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuLy8gaW5zZXJ0ZWQuXG5fbGFzdFRhaWxOb2RlLnNpYmxpbmc9bnVsbDt9YnJlYWs7fX19ZnVuY3Rpb24gYnViYmxlUHJvcGVydGllcyhjb21wbGV0ZWRXb3JrKXt2YXIgZGlkQmFpbG91dD1jb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSE9PW51bGwmJmNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkPT09Y29tcGxldGVkV29yay5jaGlsZDt2YXIgbmV3Q2hpbGRMYW5lcz1Ob0xhbmVzO3ZhciBzdWJ0cmVlRmxhZ3M9Tm9GbGFncztpZighZGlkQmFpbG91dCl7Ly8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG5pZigoY29tcGxldGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7Ly8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbi8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbnZhciBhY3R1YWxEdXJhdGlvbj1jb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO3ZhciB0cmVlQmFzZUR1cmF0aW9uPWNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjt2YXIgY2hpbGQ9Y29tcGxldGVkV29yay5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe25ld0NoaWxkTGFuZXM9bWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsY2hpbGQuY2hpbGRMYW5lcykpO3N1YnRyZWVGbGFnc3w9Y2hpbGQuc3VidHJlZUZsYWdzO3N1YnRyZWVGbGFnc3w9Y2hpbGQuZmxhZ3M7Ly8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuIFRoaXMgdmFsdWUgd2lsbFxuLy8gb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbi8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbi8vIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksIHRoZW5cbi8vIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXNcbi8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbi8vIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG5hY3R1YWxEdXJhdGlvbis9Y2hpbGQuYWN0dWFsRHVyYXRpb247dHJlZUJhc2VEdXJhdGlvbis9Y2hpbGQudHJlZUJhc2VEdXJhdGlvbjtjaGlsZD1jaGlsZC5zaWJsaW5nO31jb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uPWFjdHVhbER1cmF0aW9uO2NvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbj10cmVlQmFzZUR1cmF0aW9uO31lbHNle3ZhciBfY2hpbGQ9Y29tcGxldGVkV29yay5jaGlsZDt3aGlsZShfY2hpbGQhPT1udWxsKXtuZXdDaGlsZExhbmVzPW1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcyxtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcyxfY2hpbGQuY2hpbGRMYW5lcykpO3N1YnRyZWVGbGFnc3w9X2NoaWxkLnN1YnRyZWVGbGFncztzdWJ0cmVlRmxhZ3N8PV9jaGlsZC5mbGFnczsvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4vLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbi8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuX2NoaWxkLnJldHVybj1jb21wbGV0ZWRXb3JrO19jaGlsZD1fY2hpbGQuc2libGluZzt9fWNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzfD1zdWJ0cmVlRmxhZ3M7fWVsc2V7Ly8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG5pZigoY29tcGxldGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7Ly8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbi8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbnZhciBfdHJlZUJhc2VEdXJhdGlvbj1jb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247dmFyIF9jaGlsZDI9Y29tcGxldGVkV29yay5jaGlsZDt3aGlsZShfY2hpbGQyIT09bnVsbCl7bmV3Q2hpbGRMYW5lcz1tZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLF9jaGlsZDIuY2hpbGRMYW5lcykpOy8vIFwiU3RhdGljXCIgZmxhZ3Mgc2hhcmUgdGhlIGxpZmV0aW1lIG9mIHRoZSBmaWJlci9ob29rIHRoZXkgYmVsb25nIHRvLFxuLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbi8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4vLyBpZ25vcmUgdGhlbS5cbnN1YnRyZWVGbGFnc3w9X2NoaWxkMi5zdWJ0cmVlRmxhZ3MmU3RhdGljTWFzaztzdWJ0cmVlRmxhZ3N8PV9jaGlsZDIuZmxhZ3MmU3RhdGljTWFzaztfdHJlZUJhc2VEdXJhdGlvbis9X2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO19jaGlsZDI9X2NoaWxkMi5zaWJsaW5nO31jb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb249X3RyZWVCYXNlRHVyYXRpb247fWVsc2V7dmFyIF9jaGlsZDM9Y29tcGxldGVkV29yay5jaGlsZDt3aGlsZShfY2hpbGQzIT09bnVsbCl7bmV3Q2hpbGRMYW5lcz1tZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsbWVyZ2VMYW5lcyhfY2hpbGQzLmxhbmVzLF9jaGlsZDMuY2hpbGRMYW5lcykpOy8vIFwiU3RhdGljXCIgZmxhZ3Mgc2hhcmUgdGhlIGxpZmV0aW1lIG9mIHRoZSBmaWJlci9ob29rIHRoZXkgYmVsb25nIHRvLFxuLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbi8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4vLyBpZ25vcmUgdGhlbS5cbnN1YnRyZWVGbGFnc3w9X2NoaWxkMy5zdWJ0cmVlRmxhZ3MmU3RhdGljTWFzaztzdWJ0cmVlRmxhZ3N8PV9jaGlsZDMuZmxhZ3MmU3RhdGljTWFzazsvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4vLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbi8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuX2NoaWxkMy5yZXR1cm49Y29tcGxldGVkV29yaztfY2hpbGQzPV9jaGlsZDMuc2libGluZzt9fWNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzfD1zdWJ0cmVlRmxhZ3M7fWNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcz1uZXdDaGlsZExhbmVzO3JldHVybiBkaWRCYWlsb3V0O31mdW5jdGlvbiBjb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MsbmV4dFN0YXRlKXtpZihoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkmJih3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZSYmKHdvcmtJblByb2dyZXNzLmZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFncyl7d2FybklmVW5oeWRyYXRlZFRhaWxOb2Rlcyh3b3JrSW5Qcm9ncmVzcyk7cmVzZXRIeWRyYXRpb25TdGF0ZSgpO3dvcmtJblByb2dyZXNzLmZsYWdzfD1Gb3JjZUNsaWVudFJlbmRlcnxJbmNvbXBsZXRlfFNob3VsZENhcHR1cmU7cmV0dXJuIGZhbHNlO312YXIgd2FzSHlkcmF0ZWQ9cG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO2lmKG5leHRTdGF0ZSE9PW51bGwmJm5leHRTdGF0ZS5kZWh5ZHJhdGVkIT09bnVsbCl7Ly8gV2UgbWlnaHQgYmUgaW5zaWRlIGEgaHlkcmF0aW9uIHN0YXRlIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIHBpY2tpbmcgdXAgdGhpc1xuLy8gU3VzcGVuc2UgYm91bmRhcnksIGFuZCBhbHNvIGFmdGVyIHdlJ3ZlIHJlZW50ZXJlZCBpdCBmb3IgZnVydGhlciBoeWRyYXRpb24uXG5pZihjdXJyZW50PT09bnVsbCl7aWYoIXdhc0h5ZHJhdGVkKXt0aHJvdyBuZXcgRXJyb3IoJ0EgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgd2FzIGNvbXBsZXRlZCB3aXRob3V0IGEgaHlkcmF0ZWQgbm9kZS4gJysnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTt9cHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTt7aWYoKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXt2YXIgaXNUaW1lZE91dFN1c3BlbnNlPW5leHRTdGF0ZSE9PW51bGw7aWYoaXNUaW1lZE91dFN1c3BlbnNlKXsvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbnZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDtpZihwcmltYXJ5Q2hpbGRGcmFnbWVudCE9PW51bGwpey8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG53b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uLT1wcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO319fX1yZXR1cm4gZmFsc2U7fWVsc2V7Ly8gV2UgbWlnaHQgaGF2ZSByZWVudGVyZWQgdGhpcyBib3VuZGFyeSB0byBoeWRyYXRlIGl0LiBJZiBzbywgd2UgbmVlZCB0byByZXNldCB0aGUgaHlkcmF0aW9uXG4vLyBzdGF0ZSBzaW5jZSB3ZSdyZSBub3cgZXhpdGluZyBvdXQgb2YgaXQuIHBvcEh5ZHJhdGlvblN0YXRlIGRvZXNuJ3QgZG8gdGhhdCBmb3IgdXMuXG5yZXNldEh5ZHJhdGlvblN0YXRlKCk7aWYoKHdvcmtJblByb2dyZXNzLmZsYWdzJkRpZENhcHR1cmUpPT09Tm9GbGFncyl7Ly8gVGhpcyBib3VuZGFyeSBkaWQgbm90IHN1c3BlbmQgc28gaXQncyBub3cgaHlkcmF0ZWQgYW5kIHVuc3VzcGVuZGVkLlxud29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1udWxsO30vLyBJZiBub3RoaW5nIHN1c3BlbmRlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBlZmZlY3QgdG8gbWFyayB0aGlzIGJvdW5kYXJ5XG4vLyBhcyBoYXZpbmcgaHlkcmF0ZWQgc28gZXZlbnRzIGtub3cgdGhhdCB0aGV5J3JlIGZyZWUgdG8gYmUgaW52b2tlZC5cbi8vIEl0J3MgYWxzbyBhIHNpZ25hbCB0byByZXBsYXkgZXZlbnRzIGFuZCB0aGUgc3VzcGVuc2UgY2FsbGJhY2suXG4vLyBJZiBzb21ldGhpbmcgc3VzcGVuZGVkLCBzY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIHJldHJ5IGxpc3RlbmVycy5cbi8vIFNvIHdlIG1pZ2h0IGFzIHdlbGwgYWx3YXlzIG1hcmsgdGhpcy5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7e2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7dmFyIF9pc1RpbWVkT3V0U3VzcGVuc2U9bmV4dFN0YXRlIT09bnVsbDtpZihfaXNUaW1lZE91dFN1c3BlbnNlKXsvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbnZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ9d29ya0luUHJvZ3Jlc3MuY2hpbGQ7aWYoX3ByaW1hcnlDaGlsZEZyYWdtZW50IT09bnVsbCl7Ly8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbndvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24tPV9wcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO319fX1yZXR1cm4gZmFsc2U7fX1lbHNley8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgdGhpcyB0cmVlLiBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLFxuLy8gdGhlcmUgbWF5IGhhdmUgYmVlbiByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvblxuLy8gYXR0ZW1wdC4gSWYgc28sIGFkZCB0aGVtIHRvIGEgcXVldWUgc28gd2UgY2FuIGxvZyB0aGVtIGluIHRoZVxuLy8gY29tbWl0IHBoYXNlLlxudXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTsvLyBGYWxsIHRocm91Z2ggdG8gbm9ybWFsIFN1c3BlbnNlIHBhdGhcbnJldHVybiB0cnVlO319ZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpe3ZhciBuZXdQcm9wcz13b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7Ly8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4vLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbi8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbi8vIGZvciBoeWRyYXRpb24uXG5wb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7c3dpdGNoKHdvcmtJblByb2dyZXNzLnRhZyl7Y2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OmNhc2UgTGF6eUNvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBGcmFnbWVudDpjYXNlIE1vZGU6Y2FzZSBQcm9maWxlcjpjYXNlIENvbnRleHRDb25zdW1lcjpjYXNlIE1lbW9Db21wb25lbnQ6YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIENvbXBvbmVudD13b3JrSW5Qcm9ncmVzcy50eXBlO2lmKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpe3BvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO31idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBIb3N0Um9vdDp7dmFyIGZpYmVyUm9vdD13b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7cG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7cG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtyZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtpZihmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpe2ZpYmVyUm9vdC5jb250ZXh0PWZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ9bnVsbDt9aWYoY3VycmVudD09PW51bGx8fGN1cnJlbnQuY2hpbGQ9PT1udWxsKXsvLyBJZiB3ZSBoeWRyYXRlZCwgcG9wIHNvIHRoYXQgd2UgY2FuIGRlbGV0ZSBhbnkgcmVtYWluaW5nIGNoaWxkcmVuXG4vLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG52YXIgd2FzSHlkcmF0ZWQ9cG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO2lmKHdhc0h5ZHJhdGVkKXsvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3Jcbi8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxubWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7fWVsc2V7aWYoY3VycmVudCE9PW51bGwpe3ZhciBwcmV2U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO2lmKC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjbGllbnQgcm9vdFxuIXByZXZTdGF0ZS5pc0RlaHlkcmF0ZWR8fC8vIENoZWNrIGlmIHdlIHJldmVydGVkIHRvIGNsaWVudCByZW5kZXJpbmcgKGUuZy4gZHVlIHRvIGFuIGVycm9yKVxuKHdvcmtJblByb2dyZXNzLmZsYWdzJkZvcmNlQ2xpZW50UmVuZGVyKSE9PU5vRmxhZ3Mpey8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlXG4vLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcbi8vIGNvbnRhaW5lciB3aXRoIHByZXZpb3VzIGNoaWxkcmVuLiBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3Jcbi8vIHVwZGF0ZXMgdG9vLCBiZWNhdXNlIGN1cnJlbnQuY2hpbGQgd291bGQgb25seSBiZSBudWxsIGlmIHRoZVxuLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcbi8vIGJlIGVtcHR5KS5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1TbmFwc2hvdDsvLyBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLCB0aGVyZSBtYXkgaGF2ZSBiZWVuXG4vLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG4vLyB0aGVtIHRvIGEgcXVldWUgc28gd2UgY2FuIGxvZyB0aGVtIGluIHRoZSBjb21taXQgcGhhc2UuXG51cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpO319fX11cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3MpO2J1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIEhvc3RDb21wb25lbnQ6e3BvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTt2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlPWdldFJvb3RIb3N0Q29udGFpbmVyKCk7dmFyIHR5cGU9d29ya0luUHJvZ3Jlc3MudHlwZTtpZihjdXJyZW50IT09bnVsbCYmd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlIT1udWxsKXt1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyx0eXBlLG5ld1Byb3BzLHJvb3RDb250YWluZXJJbnN0YW5jZSk7aWYoY3VycmVudC5yZWYhPT13b3JrSW5Qcm9ncmVzcy5yZWYpe21hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7fX1lbHNle2lmKCFuZXdQcm9wcyl7aWYod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnKydjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO30vLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fXZhciBjdXJyZW50SG9zdENvbnRleHQ9Z2V0SG9zdENvbnRleHQoKTsvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbi8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbi8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSB3YW50IHRvIGFkZCB0aGVtIHRvcC0+ZG93biBvclxuLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxudmFyIF93YXNIeWRyYXRlZD1wb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7aWYoX3dhc0h5ZHJhdGVkKXsvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuLy8gdG8gY29uc29saWRhdGUuXG5pZihwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLHJvb3RDb250YWluZXJJbnN0YW5jZSxjdXJyZW50SG9zdENvbnRleHQpKXsvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbi8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbm1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO319ZWxzZXt2YXIgaW5zdGFuY2U9Y3JlYXRlSW5zdGFuY2UodHlwZSxuZXdQcm9wcyxyb290Q29udGFpbmVySW5zdGFuY2UsY3VycmVudEhvc3RDb250ZXh0LHdvcmtJblByb2dyZXNzKTthcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSx3b3JrSW5Qcm9ncmVzcyxmYWxzZSxmYWxzZSk7d29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlPWluc3RhbmNlOy8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbi8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4vLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cbmlmKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlLHR5cGUsbmV3UHJvcHMscm9vdENvbnRhaW5lckluc3RhbmNlKSl7bWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7fX1pZih3b3JrSW5Qcm9ncmVzcy5yZWYhPT1udWxsKXsvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbm1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7fX1idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBIb3N0VGV4dDp7dmFyIG5ld1RleHQ9bmV3UHJvcHM7aWYoY3VycmVudCYmd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlIT1udWxsKXt2YXIgb2xkVGV4dD1jdXJyZW50Lm1lbW9pemVkUHJvcHM7Ly8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbi8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG51cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsd29ya0luUHJvZ3Jlc3Msb2xkVGV4dCxuZXdUZXh0KTt9ZWxzZXtpZih0eXBlb2YgbmV3VGV4dCE9PSdzdHJpbmcnKXtpZih3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9PT1udWxsKXt0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcrJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fS8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG59dmFyIF9yb290Q29udGFpbmVySW5zdGFuY2U9Z2V0Um9vdEhvc3RDb250YWluZXIoKTt2YXIgX2N1cnJlbnRIb3N0Q29udGV4dD1nZXRIb3N0Q29udGV4dCgpO3ZhciBfd2FzSHlkcmF0ZWQyPXBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtpZihfd2FzSHlkcmF0ZWQyKXtpZihwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpe21hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO319ZWxzZXt3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9Y3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsX3Jvb3RDb250YWluZXJJbnN0YW5jZSxfY3VycmVudEhvc3RDb250ZXh0LHdvcmtJblByb2dyZXNzKTt9fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50Ontwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO3ZhciBuZXh0U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTsvLyBTcGVjaWFsIHBhdGggZm9yIGRlaHlkcmF0ZWQgYm91bmRhcmllcy4gV2UgbWF5IGV2ZW50dWFsbHkgbW92ZSB0aGlzXG4vLyB0byBpdHMgb3duIGZpYmVyIHR5cGUgc28gdGhhdCB3ZSBjYW4gYWRkIG90aGVyIGtpbmRzIG9mIGh5ZHJhdGlvblxuLy8gYm91bmRhcmllcyB0aGF0IGFyZW4ndCBhc3NvY2lhdGVkIHdpdGggYSBTdXNwZW5zZSB0cmVlLiBJbiBhbnRpY2lwYXRpb25cbi8vIG9mIHN1Y2ggYSByZWZhY3RvciwgYWxsIHRoZSBoeWRyYXRpb24gbG9naWMgaXMgY29udGFpbmVkIGluXG4vLyB0aGlzIGJyYW5jaC5cbmlmKGN1cnJlbnQ9PT1udWxsfHxjdXJyZW50Lm1lbW9pemVkU3RhdGUhPT1udWxsJiZjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpe3ZhciBmYWxsdGhyb3VnaFRvTm9ybWFsU3VzcGVuc2VQYXRoPWNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyxuZXh0U3RhdGUpO2lmKCFmYWxsdGhyb3VnaFRvTm9ybWFsU3VzcGVuc2VQYXRoKXtpZih3b3JrSW5Qcm9ncmVzcy5mbGFncyZTaG91bGRDYXB0dXJlKXsvLyBTcGVjaWFsIGNhc2UuIFRoZXJlIHdlcmUgcmVtYWluaW5nIHVuaHlkcmF0ZWQgbm9kZXMuIFdlIHRyZWF0XG4vLyB0aGlzIGFzIGEgbWlzbWF0Y2guIFJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlxucmV0dXJuIHdvcmtJblByb2dyZXNzO31lbHNley8vIERpZCBub3QgZmluaXNoIGh5ZHJhdGluZywgZWl0aGVyIGJlY2F1c2UgdGhpcyBpcyB0aGUgaW5pdGlhbFxuLy8gcmVuZGVyIG9yIGJlY2F1c2Ugc29tZXRoaW5nIHN1c3BlbmRlZC5cbnJldHVybiBudWxsO319Ly8gQ29udGludWUgd2l0aCB0aGUgbm9ybWFsIFN1c3BlbnNlIHBhdGguXG59aWYoKHdvcmtJblByb2dyZXNzLmZsYWdzJkRpZENhcHR1cmUpIT09Tm9GbGFncyl7Ly8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxud29ya0luUHJvZ3Jlc3MubGFuZXM9cmVuZGVyTGFuZXM7Ly8gRG8gbm90IHJlc2V0IHRoZSBlZmZlY3QgbGlzdC5cbmlmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7dHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7fS8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cbnJldHVybiB3b3JrSW5Qcm9ncmVzczt9dmFyIG5leHREaWRUaW1lb3V0PW5leHRTdGF0ZSE9PW51bGw7dmFyIHByZXZEaWRUaW1lb3V0PWN1cnJlbnQhPT1udWxsJiZjdXJyZW50Lm1lbW9pemVkU3RhdGUhPT1udWxsOy8vIGEgcGFzc2l2ZSBlZmZlY3QsIHdoaWNoIGlzIHdoZW4gd2UgcHJvY2VzcyB0aGUgdHJhbnNpdGlvbnNcbmlmKG5leHREaWRUaW1lb3V0IT09cHJldkRpZFRpbWVvdXQpey8vIGFuIGVmZmVjdCB0byB0b2dnbGUgdGhlIHN1YnRyZWUncyB2aXNpYmlsaXR5LiBXaGVuIHdlIHN3aXRjaCBmcm9tXG4vLyBmYWxsYmFjayAtPiBwcmltYXJ5LCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIHNjaGVkdWxlcyB0aGlzIGVmZmVjdFxuLy8gYXMgcGFydCBvZiBpdHMgbm9ybWFsIGNvbXBsZXRlIHBoYXNlLiBCdXQgd2hlbiB3ZSBzd2l0Y2ggZnJvbVxuLy8gcHJpbWFyeSAtPiBmYWxsYmFjaywgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBkb2VzIG5vdCBoYXZlIGEgY29tcGxldGVcbi8vIHBoYXNlLiBTbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIGl0cyBlZmZlY3QgaGVyZS5cbi8vXG4vLyBXZSBhbHNvIHVzZSB0aGlzIGZsYWcgdG8gY29ubmVjdC9kaXNjb25uZWN0IHRoZSBlZmZlY3RzLCBidXQgdGhlIHNhbWVcbi8vIGxvZ2ljIGFwcGxpZXM6IHdoZW4gcmUtY29ubmVjdGluZywgdGhlIE9mZnNjcmVlbiBmaWJlcidzIGNvbXBsZXRlXG4vLyBwaGFzZSB3aWxsIGhhbmRsZSBzY2hlZHVsaW5nIHRoZSBlZmZlY3QuIEl0J3Mgb25seSB3aGVuIHRoZSBmYWxsYmFja1xuLy8gaXMgYWN0aXZlIHRoYXQgd2UgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsLlxuaWYobmV4dERpZFRpbWVvdXQpe3ZhciBfb2Zmc2NyZWVuRmliZXIyPXdvcmtJblByb2dyZXNzLmNoaWxkO19vZmZzY3JlZW5GaWJlcjIuZmxhZ3N8PVZpc2liaWxpdHk7Ly8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4vLyBpbiB0aGUgY29uY3VycmVudCB0cmVlIGFscmVhZHkgc3VzcGVuZGVkIGR1cmluZyB0aGlzIHJlbmRlci5cbi8vIFRoaXMgaXMgYSBrbm93biBidWcuXG5pZigod29ya0luUHJvZ3Jlc3MubW9kZSZDb25jdXJyZW50TW9kZSkhPT1Ob01vZGUpey8vIFRPRE86IE1vdmUgdGhpcyBiYWNrIHRvIHRocm93RXhjZXB0aW9uIGJlY2F1c2UgdGhpcyBpcyB0b28gbGF0ZVxuLy8gaWYgdGhpcyBpcyBhIGxhcmdlIHRyZWUgd2hpY2ggaXMgY29tbW9uIGZvciBpbml0aWFsIGxvYWRzLiBXZVxuLy8gZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgcmVzdGFydCBhIHJlbmRlciBvciBub3QgdW50aWwgd2UgZ2V0XG4vLyB0aGlzIG1hcmtlciwgYW5kIHRoaXMgaXMgdG9vIGxhdGUuXG4vLyBJZiB0aGlzIHJlbmRlciBhbHJlYWR5IGhhZCBhIHBpbmcgb3IgbG93ZXIgcHJpIHVwZGF0ZXMsXG4vLyBhbmQgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSBrbm93IHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2Vcbi8vIHNob3VsZCBiZSBhYmxlIHRvIGltbWVkaWF0ZWx5IHJlc3RhcnQgZnJvbSB3aXRoaW4gdGhyb3dFeGNlcHRpb24uXG52YXIgaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0PWN1cnJlbnQ9PT1udWxsJiYod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayE9PXRydWV8fCFlbmFibGVTdXNwZW5zZUF2b2lkVGhpc0ZhbGxiYWNrKTtpZihoYXNJbnZpc2libGVDaGlsZENvbnRleHR8fGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KSl7Ly8gSWYgdGhpcyB3YXMgaW4gYW4gaW52aXNpYmxlIHRyZWUgb3IgYSBuZXcgcmVuZGVyLCB0aGVuIHNob3dpbmdcbi8vIHRoaXMgYm91bmRhcnkgaXMgb2suXG5yZW5kZXJEaWRTdXNwZW5kKCk7fWVsc2V7Ly8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbi8vIHN1c3BlbmQgZm9yIGxvbmdlciBpZiBwb3NzaWJsZS5cbnJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTt9fX19dmFyIHdha2VhYmxlcz13b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtpZih3YWtlYWJsZXMhPT1udWxsKXsvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIGEgcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuXG4vLyBUT0RPOiBNb3ZlIHRvIHBhc3NpdmUgcGhhc2VcbndvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3tpZigod29ya0luUHJvZ3Jlc3MubW9kZSZQcm9maWxlTW9kZSkhPT1Ob01vZGUpe2lmKG5leHREaWRUaW1lb3V0KXsvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbnZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudD13b3JrSW5Qcm9ncmVzcy5jaGlsZDtpZihwcmltYXJ5Q2hpbGRGcmFnbWVudCE9PW51bGwpey8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG53b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uLT1wcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO319fX1yZXR1cm4gbnVsbDt9Y2FzZSBIb3N0UG9ydGFsOnBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO3VwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCx3b3JrSW5Qcm9ncmVzcyk7aWYoY3VycmVudD09PW51bGwpe3ByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7fWJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO2Nhc2UgQ29udGV4dFByb3ZpZGVyOi8vIFBvcCBwcm92aWRlciBmaWJlclxudmFyIGNvbnRleHQ9d29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtwb3BQcm92aWRlcihjb250ZXh0LHdvcmtJblByb2dyZXNzKTtidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDtjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDp7Ly8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG4vLyBzZXF1ZW50aWFsIHRvIGVuc3VyZSB0aGlzIHN3aXRjaCBpcyBjb21waWxlZCB0byBhIGp1bXAgdGFibGUuXG52YXIgX0NvbXBvbmVudD13b3JrSW5Qcm9ncmVzcy50eXBlO2lmKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKXtwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTt9YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fWNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50Ontwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO3ZhciByZW5kZXJTdGF0ZT13b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO2lmKHJlbmRlclN0YXRlPT09bnVsbCl7Ly8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4vLyBXZSBkb24ndCBkbyBhbnl0aGluZyBpbiB0aGlzIG1vZGUuXG5idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9dmFyIGRpZFN1c3BlbmRBbHJlYWR5PSh3b3JrSW5Qcm9ncmVzcy5mbGFncyZEaWRDYXB0dXJlKSE9PU5vRmxhZ3M7dmFyIHJlbmRlcmVkVGFpbD1yZW5kZXJTdGF0ZS5yZW5kZXJpbmc7aWYocmVuZGVyZWRUYWlsPT09bnVsbCl7Ly8gV2UganVzdCByZW5kZXJlZCB0aGUgaGVhZC5cbmlmKCFkaWRTdXNwZW5kQWxyZWFkeSl7Ly8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4vLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbi8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4vLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3Jcbi8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4vLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbi8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbnZhciBjYW5ub3RCZVN1c3BlbmRlZD1yZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSYmKGN1cnJlbnQ9PT1udWxsfHwoY3VycmVudC5mbGFncyZEaWRDYXB0dXJlKT09PU5vRmxhZ3MpO2lmKCFjYW5ub3RCZVN1c3BlbmRlZCl7dmFyIHJvdz13b3JrSW5Qcm9ncmVzcy5jaGlsZDt3aGlsZShyb3chPT1udWxsKXt2YXIgc3VzcGVuZGVkPWZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO2lmKHN1c3BlbmRlZCE9PW51bGwpe2RpZFN1c3BlbmRBbHJlYWR5PXRydWU7d29ya0luUHJvZ3Jlc3MuZmxhZ3N8PURpZENhcHR1cmU7Y3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLGZhbHNlKTsvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4vLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbi8vIGl0cyB0aGVuYWJsZXMuIEluc3RlYWQsIHdlJ2xsIHRyYW5zZmVyIGl0cyB0aGVuYWJsZXMgdG8gdGhlXG4vLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4vLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4vLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4vLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4vLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxudmFyIG5ld1RoZW5hYmxlcz1zdXNwZW5kZWQudXBkYXRlUXVldWU7aWYobmV3VGhlbmFibGVzIT09bnVsbCl7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9bmV3VGhlbmFibGVzO3dvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fS8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3Ncbi8vIHRvIHN0YXkgaW4gcGxhY2UuXG4vLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cbndvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncz1Ob0ZsYWdzO3Jlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MscmVuZGVyTGFuZXMpOy8vIFNldCB1cCB0aGUgU3VzcGVuc2UgQ29udGV4dCB0byBmb3JjZSBzdXNwZW5zZSBhbmQgaW1tZWRpYXRlbHlcbi8vIHJlcmVuZGVyIHRoZSBjaGlsZHJlbi5cbnB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3Msc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7Ly8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxucmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO31yb3c9cm93LnNpYmxpbmc7fX1pZihyZW5kZXJTdGF0ZS50YWlsIT09bnVsbCYmbm93KCk+Z2V0UmVuZGVyVGFyZ2V0VGltZSgpKXsvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuLy8gbGVmdCBpbiB0aGUgdGFpbC4gV2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gcmVuZGVyXG4vLyB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG53b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTtkaWRTdXNwZW5kQWxyZWFkeT10cnVlO2N1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSxmYWxzZSk7Ly8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbi8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4vLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbi8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cbndvcmtJblByb2dyZXNzLmxhbmVzPVNvbWVSZXRyeUxhbmU7fX1lbHNle2N1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSxmYWxzZSk7fS8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxufWVsc2V7Ly8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG5pZighZGlkU3VzcGVuZEFscmVhZHkpe3ZhciBfc3VzcGVuZGVkPWZpbmRGaXJzdFN1c3BlbmRlZChyZW5kZXJlZFRhaWwpO2lmKF9zdXNwZW5kZWQhPT1udWxsKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9RGlkQ2FwdHVyZTtkaWRTdXNwZW5kQWxyZWFkeT10cnVlOy8vIEVuc3VyZSB3ZSB0cmFuc2ZlciB0aGUgdXBkYXRlIHF1ZXVlIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBkb2Vzbid0XG4vLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG52YXIgX25ld1RoZW5hYmxlcz1fc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO2lmKF9uZXdUaGVuYWJsZXMhPT1udWxsKXt3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZT1fbmV3VGhlbmFibGVzO3dvcmtJblByb2dyZXNzLmZsYWdzfD1VcGRhdGU7fWN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSx0cnVlKTsvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cbmlmKHJlbmRlclN0YXRlLnRhaWw9PT1udWxsJiZyZW5kZXJTdGF0ZS50YWlsTW9kZT09PSdoaWRkZW4nJiYhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSYmIWdldElzSHlkcmF0aW5nKCkvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuKXsvLyBXZSdyZSBkb25lLlxuYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7cmV0dXJuIG51bGw7fX1lbHNlIGlmKC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4vLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuLy8gZXhjZWVkIGl0Llxubm93KCkqMi1yZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWU+Z2V0UmVuZGVyVGFyZ2V0VGltZSgpJiZyZW5kZXJMYW5lcyE9PU9mZnNjcmVlbkxhbmUpey8vIFdlIGhhdmUgbm93IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGFuZCB3ZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlclxuLy8gYXR0ZW1wdHMgdG8gcmVuZGVyIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbi8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbndvcmtJblByb2dyZXNzLmZsYWdzfD1EaWRDYXB0dXJlO2RpZFN1c3BlbmRBbHJlYWR5PXRydWU7Y3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLGZhbHNlKTsvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4vLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4vLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbi8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4vLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4vLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxud29ya0luUHJvZ3Jlc3MubGFuZXM9U29tZVJldHJ5TGFuZTt9fWlmKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzKXsvLyBUaGUgZWZmZWN0IGxpc3Qgb2YgdGhlIGJhY2t3YXJkcyB0YWlsIHdpbGwgaGF2ZSBiZWVuIGFkZGVkXG4vLyB0byB0aGUgZW5kLiBUaGlzIGJyZWFrcyB0aGUgZ3VhcmFudGVlIHRoYXQgbGlmZS1jeWNsZXMgZmlyZSBpblxuLy8gc2libGluZyBvcmRlciBidXQgdGhhdCBpc24ndCBhIHN0cm9uZyBndWFyYW50ZWUgcHJvbWlzZWQgYnkgUmVhY3QuXG4vLyBFc3BlY2lhbGx5IHNpbmNlIHRoZXNlIG1pZ2h0IGFsc28ganVzdCBwb3AgaW4gZHVyaW5nIGZ1dHVyZSBjb21taXRzLlxuLy8gQXBwZW5kIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG5yZW5kZXJlZFRhaWwuc2libGluZz13b3JrSW5Qcm9ncmVzcy5jaGlsZDt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZW5kZXJlZFRhaWw7fWVsc2V7dmFyIHByZXZpb3VzU2libGluZz1yZW5kZXJTdGF0ZS5sYXN0O2lmKHByZXZpb3VzU2libGluZyE9PW51bGwpe3ByZXZpb3VzU2libGluZy5zaWJsaW5nPXJlbmRlcmVkVGFpbDt9ZWxzZXt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1yZW5kZXJlZFRhaWw7fXJlbmRlclN0YXRlLmxhc3Q9cmVuZGVyZWRUYWlsO319aWYocmVuZGVyU3RhdGUudGFpbCE9PW51bGwpey8vIFdlIHN0aWxsIGhhdmUgdGFpbCByb3dzIHRvIHJlbmRlci5cbi8vIFBvcCBhIHJvdy5cbnZhciBuZXh0PXJlbmRlclN0YXRlLnRhaWw7cmVuZGVyU3RhdGUucmVuZGVyaW5nPW5leHQ7cmVuZGVyU3RhdGUudGFpbD1uZXh0LnNpYmxpbmc7cmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lPW5vdygpO25leHQuc2libGluZz1udWxsOy8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4vLyBUT0RPOiBXZSBjYW4gcHJvYmFibHkganVzdCBhdm9pZCBwb3BwaW5nIGl0IGluc3RlYWQgYW5kIG9ubHlcbi8vIHNldHRpbmcgaXQgdGhlIGZpcnN0IHRpbWUgd2UgZ28gZnJvbSBub3Qgc3VzcGVuZGVkIHRvIHN1c3BlbmRlZC5cbnZhciBzdXNwZW5zZUNvbnRleHQ9c3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O2lmKGRpZFN1c3BlbmRBbHJlYWR5KXtzdXNwZW5zZUNvbnRleHQ9c2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTt9ZWxzZXtzdXNwZW5zZUNvbnRleHQ9c2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTt9cHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyxzdXNwZW5zZUNvbnRleHQpOy8vIERvIGEgcGFzcyBvdmVyIHRoZSBuZXh0IHJvdy5cbi8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cbnJldHVybiBuZXh0O31idWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDt9Y2FzZSBTY29wZUNvbXBvbmVudDp7YnJlYWs7fWNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OmNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50Ontwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7dmFyIF9uZXh0U3RhdGU9d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTt2YXIgbmV4dElzSGlkZGVuPV9uZXh0U3RhdGUhPT1udWxsO2lmKGN1cnJlbnQhPT1udWxsKXt2YXIgX3ByZXZTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7dmFyIHByZXZJc0hpZGRlbj1fcHJldlN0YXRlIT09bnVsbDtpZihwcmV2SXNIaWRkZW4hPT1uZXh0SXNIaWRkZW4mJi8vIExlZ2FjeUhpZGRlbiBkb2Vzbid0IGRvIGFueSBoaWRpbmcg4oCUIGl0IG9ubHkgcHJlLXJlbmRlcnMuXG4hZW5hYmxlTGVnYWN5SGlkZGVuKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VmlzaWJpbGl0eTt9fWlmKCFuZXh0SXNIaWRkZW58fCh3b3JrSW5Qcm9ncmVzcy5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSl7YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7fWVsc2V7Ly8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgZm9yIGhpZGRlbiBjaGlsZHJlbiB1bmxlc3Mgd2UncmUgcmVuZGVyaW5nXG4vLyBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuXG5pZihpbmNsdWRlc1NvbWVMYW5lKHN1YnRyZWVSZW5kZXJMYW5lcyxPZmZzY3JlZW5MYW5lKSl7YnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7ey8vIENoZWNrIGlmIHRoZXJlIHdhcyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlIGluIHRoZSBoaWRkZW4gc3VidHJlZS5cbi8vIElmIHNvLCB3ZSBuZWVkIHRvIGhpZGUgdGhvc2Ugbm9kZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSwgc29cbi8vIHNjaGVkdWxlIGEgdmlzaWJpbGl0eSBlZmZlY3QuXG5pZih3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MmKFBsYWNlbWVudHxVcGRhdGUpKXt3b3JrSW5Qcm9ncmVzcy5mbGFnc3w9VmlzaWJpbGl0eTt9fX19cmV0dXJuIG51bGw7fWNhc2UgQ2FjaGVDb21wb25lbnQ6e3JldHVybiBudWxsO31jYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6e3JldHVybiBudWxsO319dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIit3b3JrSW5Qcm9ncmVzcy50YWcrXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIrJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9ZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LHdvcmtJblByb2dyZXNzLHJlbmRlckxhbmVzKXsvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbi8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuLy8gZm9yIGh5ZHJhdGlvbi5cbnBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtzd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgQ29tcG9uZW50PXdvcmtJblByb2dyZXNzLnR5cGU7aWYoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSl7cG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7fXZhciBmbGFncz13b3JrSW5Qcm9ncmVzcy5mbGFncztpZihmbGFncyZTaG91bGRDYXB0dXJlKXt3b3JrSW5Qcm9ncmVzcy5mbGFncz1mbGFncyZ+U2hvdWxkQ2FwdHVyZXxEaWRDYXB0dXJlO2lmKCh3b3JrSW5Qcm9ncmVzcy5tb2RlJlByb2ZpbGVNb2RlKSE9PU5vTW9kZSl7dHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7fXJldHVybiB3b3JrSW5Qcm9ncmVzczt9cmV0dXJuIG51bGw7fWNhc2UgSG9zdFJvb3Q6e3ZhciByb290PXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO3Jlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO3ZhciBfZmxhZ3M9d29ya0luUHJvZ3Jlc3MuZmxhZ3M7aWYoKF9mbGFncyZTaG91bGRDYXB0dXJlKSE9PU5vRmxhZ3MmJihfZmxhZ3MmRGlkQ2FwdHVyZSk9PT1Ob0ZsYWdzKXsvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIHJlbmRlciB0aGF0IHdhc24ndCBjYXB0dXJlZCBieSBhIHN1c3BlbnNlXG4vLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbndvcmtJblByb2dyZXNzLmZsYWdzPV9mbGFncyZ+U2hvdWxkQ2FwdHVyZXxEaWRDYXB0dXJlO3JldHVybiB3b3JrSW5Qcm9ncmVzczt9Ly8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5yZXR1cm4gbnVsbDt9Y2FzZSBIb3N0Q29tcG9uZW50OnsvLyBUT0RPOiBwb3BIeWRyYXRpb25TdGF0ZVxucG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO31jYXNlIFN1c3BlbnNlQ29tcG9uZW50Ontwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO3ZhciBzdXNwZW5zZVN0YXRlPXdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7aWYoc3VzcGVuc2VTdGF0ZSE9PW51bGwmJnN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpe2lmKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZT09PW51bGwpe3Rocm93IG5ldyBFcnJvcignVGhyZXcgaW4gbmV3bHkgbW91bnRlZCBkZWh5ZHJhdGVkIGNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gJysnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO31yZXNldEh5ZHJhdGlvblN0YXRlKCk7fXZhciBfZmxhZ3MyPXdvcmtJblByb2dyZXNzLmZsYWdzO2lmKF9mbGFnczImU2hvdWxkQ2FwdHVyZSl7d29ya0luUHJvZ3Jlc3MuZmxhZ3M9X2ZsYWdzMiZ+U2hvdWxkQ2FwdHVyZXxEaWRDYXB0dXJlOy8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuaWYoKHdvcmtJblByb2dyZXNzLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXt0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTt9cmV0dXJuIHdvcmtJblByb2dyZXNzO31yZXR1cm4gbnVsbDt9Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6e3BvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7Ly8gU3VzcGVuc2VMaXN0IGRvZXNuJ3QgYWN0dWFsbHkgY2F0Y2ggYW55dGhpbmcuIEl0IHNob3VsZCd2ZSBiZWVuXG4vLyBjYXVnaHQgYnkgYSBuZXN0ZWQgYm91bmRhcnkuIElmIG5vdCwgaXQgc2hvdWxkIGJ1YmJsZSB0aHJvdWdoLlxucmV0dXJuIG51bGw7fWNhc2UgSG9zdFBvcnRhbDpwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDtjYXNlIENvbnRleHRQcm92aWRlcjp2YXIgY29udGV4dD13b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0O3BvcFByb3ZpZGVyKGNvbnRleHQsd29ya0luUHJvZ3Jlc3MpO3JldHVybiBudWxsO2Nhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OmNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OnBvcFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzKTtyZXR1cm4gbnVsbDtjYXNlIENhY2hlQ29tcG9uZW50OnJldHVybiBudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGw7fX1mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCxpbnRlcnJ1cHRlZFdvcmsscmVuZGVyTGFuZXMpey8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4vLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4vLyBmb3IgaHlkcmF0aW9uLlxucG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtzd2l0Y2goaW50ZXJydXB0ZWRXb3JrLnRhZyl7Y2FzZSBDbGFzc0NvbXBvbmVudDp7dmFyIGNoaWxkQ29udGV4dFR5cGVzPWludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO2lmKGNoaWxkQ29udGV4dFR5cGVzIT09bnVsbCYmY2hpbGRDb250ZXh0VHlwZXMhPT11bmRlZmluZWQpe3BvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTt9YnJlYWs7fWNhc2UgSG9zdFJvb3Q6e3ZhciByb290PWludGVycnVwdGVkV29yay5zdGF0ZU5vZGU7cG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO3BvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO3Jlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO2JyZWFrO31jYXNlIEhvc3RDb21wb25lbnQ6e3BvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7YnJlYWs7fWNhc2UgSG9zdFBvcnRhbDpwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7YnJlYWs7Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDpwb3BTdXNwZW5zZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTticmVhaztjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpwb3BTdXNwZW5zZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTticmVhaztjYXNlIENvbnRleHRQcm92aWRlcjp2YXIgY29udGV4dD1pbnRlcnJ1cHRlZFdvcmsudHlwZS5fY29udGV4dDtwb3BQcm92aWRlcihjb250ZXh0LGludGVycnVwdGVkV29yayk7YnJlYWs7Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6Y2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6cG9wUmVuZGVyTGFuZXMoaW50ZXJydXB0ZWRXb3JrKTticmVhazt9fXZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZT1udWxsO3tkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZT1uZXcgU2V0KCk7fS8vIFVzZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgdG8gdHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHN0YWNrLlxuLy8gQWxsb3dzIHVzIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHJldHVybiBwYXRoIHRvIGZpbmQgdGhlIG5lYXJlc3QgT2Zmc2NyZWVuIGFuY2VzdG9yLlxuLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlU3VzcGVuc2VMYXlvdXRFZmZlY3RTZW1hbnRpY3MgaXMgZW5hYmxlZC5cbnZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW49ZmFsc2U7dmFyIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49ZmFsc2U7dmFyIFBvc3NpYmx5V2Vha1NldD10eXBlb2YgV2Vha1NldD09PSdmdW5jdGlvbic/V2Vha1NldDpTZXQ7dmFyIG5leHRFZmZlY3Q9bnVsbDsvLyBVc2VkIGZvciBQcm9maWxpbmcgYnVpbGRzIHRvIHRyYWNrIHVwZGF0ZXJzLlxudmFyIGluUHJvZ3Jlc3NMYW5lcz1udWxsO3ZhciBpblByb2dyZXNzUm9vdD1udWxsO2Z1bmN0aW9uIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcil7Ly8gV3JhcHBpbmcgZWFjaCBzbWFsbCBwYXJ0IG9mIHRoZSBjb21taXQgcGhhc2UgaW50byBhIGd1YXJkZWRcbi8vIGNhbGxiYWNrIGlzIGEgYml0IHRvbyBzbG93IChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMTY2NikuXG4vLyBCdXQgd2UgcmVseSBvbiBpdCB0byBzdXJmYWNlIGVycm9ycyB0byBERVYgdG9vbHMgbGlrZSBvdmVybGF5c1xuLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjE3MTIpLlxuLy8gQXMgYSBjb21wcm9taXNlLCByZXRocm93IG9ubHkgY2F1Z2h0IGVycm9ycyBpbiBhIGd1YXJkLlxue2ludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLGZ1bmN0aW9uKCl7dGhyb3cgZXJyb3I7fSk7Y2xlYXJDYXVnaHRFcnJvcigpO319dmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcj1mdW5jdGlvbihjdXJyZW50LGluc3RhbmNlKXtpbnN0YW5jZS5wcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7aW5zdGFuY2Uuc3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO2lmKGN1cnJlbnQubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO319ZWxzZXtpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO319Oy8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKXt0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQsY3VycmVudCk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IpO319Ly8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsaW5zdGFuY2Upe3RyeXtjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIoY3VycmVudCxpbnN0YW5jZSk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IpO319Ly8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgbW91bnRpbmcuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGluc3RhbmNlKXt0cnl7aW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvcik7fX0vLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3Ipe3RyeXtjb21taXRBdHRhY2hSZWYoY3VycmVudCk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZXJyb3IpO319ZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcil7dmFyIHJlZj1jdXJyZW50LnJlZjtpZihyZWYhPT1udWxsKXtpZih0eXBlb2YgcmVmPT09J2Z1bmN0aW9uJyl7dmFyIHJldFZhbDt0cnl7aWYoZW5hYmxlUHJvZmlsZXJUaW1lciYmZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyYmY3VycmVudC5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO3JldFZhbD1yZWYobnVsbCk7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7fX1lbHNle3JldFZhbD1yZWYobnVsbCk7fX1jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yKTt9e2lmKHR5cGVvZiByZXRWYWw9PT0nZnVuY3Rpb24nKXtlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJysnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkpO319fWVsc2V7cmVmLmN1cnJlbnQ9bnVsbDt9fX1mdW5jdGlvbiBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVzdHJveSl7dHJ5e2Rlc3Ryb3koKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixlcnJvcik7fX12YXIgZm9jdXNlZEluc3RhbmNlSGFuZGxlPW51bGw7dmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cj1mYWxzZTtmdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCxmaXJzdENoaWxkKXtmb2N1c2VkSW5zdGFuY2VIYW5kbGU9cHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO25leHRFZmZlY3Q9Zmlyc3RDaGlsZDtjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKTsvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG52YXIgc2hvdWxkRmlyZT1zaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7c2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyPWZhbHNlO2ZvY3VzZWRJbnN0YW5jZUhhbmRsZT1udWxsO3JldHVybiBzaG91bGRGaXJlO31mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7Ly8gVGhpcyBwaGFzZSBpcyBvbmx5IHVzZWQgZm9yIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ci5cbnZhciBjaGlsZD1maWJlci5jaGlsZDtpZigoZmliZXIuc3VidHJlZUZsYWdzJkJlZm9yZU11dGF0aW9uTWFzaykhPT1Ob0ZsYWdzJiZjaGlsZCE9PW51bGwpe2NoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWNoaWxkO31lbHNle2NvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpO319fWZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDtzZXRDdXJyZW50RmliZXIoZmliZXIpO3RyeXtjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpYmVyKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fXJlc2V0Q3VycmVudEZpYmVyKCk7dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7c2libGluZy5yZXR1cm49ZmliZXIucmV0dXJuO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9ZmliZXIucmV0dXJuO319ZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspe3ZhciBjdXJyZW50PWZpbmlzaGVkV29yay5hbHRlcm5hdGU7dmFyIGZsYWdzPWZpbmlzaGVkV29yay5mbGFncztpZigoZmxhZ3MmU25hcHNob3QpIT09Tm9GbGFncyl7c2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7c3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e2lmKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJldlByb3BzPWN1cnJlbnQubWVtb2l6ZWRQcm9wczt2YXIgcHJldlN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTt2YXIgaW5zdGFuY2U9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4vLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbi8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbntpZihmaW5pc2hlZFdvcmsudHlwZT09PWZpbmlzaGVkV29yay5lbGVtZW50VHlwZSYmIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpe2lmKGluc3RhbmNlLnByb3BzIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpe2Vycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJysnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fWlmKGluc3RhbmNlLnN0YXRlIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpe2Vycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJysnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fX19dmFyIHNuYXBzaG90PWluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGZpbmlzaGVkV29yay5lbGVtZW50VHlwZT09PWZpbmlzaGVkV29yay50eXBlP3ByZXZQcm9wczpyZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLHByZXZQcm9wcykscHJldlN0YXRlKTt7dmFyIGRpZFdhcm5TZXQ9ZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7aWYoc25hcHNob3Q9PT11bmRlZmluZWQmJiFkaWRXYXJuU2V0LmhhcyhmaW5pc2hlZFdvcmsudHlwZSkpe2RpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtlcnJvcignJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgJysnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTt9fWluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPXNuYXBzaG90O31icmVhazt9Y2FzZSBIb3N0Um9vdDp7e3ZhciByb290PWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7Y2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTt9YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDpjYXNlIEhvc3RUZXh0OmNhc2UgSG9zdFBvcnRhbDpjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDovLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbmJyZWFrO2RlZmF1bHQ6e3Rocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJysnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fX1yZXNldEN1cnJlbnRGaWJlcigpO319ZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KGZsYWdzLGZpbmlzaGVkV29yayxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKXt2YXIgdXBkYXRlUXVldWU9ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO3ZhciBsYXN0RWZmZWN0PXVwZGF0ZVF1ZXVlIT09bnVsbD91cGRhdGVRdWV1ZS5sYXN0RWZmZWN0Om51bGw7aWYobGFzdEVmZmVjdCE9PW51bGwpe3ZhciBmaXJzdEVmZmVjdD1sYXN0RWZmZWN0Lm5leHQ7dmFyIGVmZmVjdD1maXJzdEVmZmVjdDtkb3tpZigoZWZmZWN0LnRhZyZmbGFncyk9PT1mbGFncyl7Ly8gVW5tb3VudFxudmFyIGRlc3Ryb3k9ZWZmZWN0LmRlc3Ryb3k7ZWZmZWN0LmRlc3Ryb3k9dW5kZWZpbmVkO2lmKGRlc3Ryb3khPT11bmRlZmluZWQpe3tpZigoZmxhZ3MmUGFzc2l2ZSQxKSE9PU5vRmxhZ3MkMSl7bWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO31lbHNlIGlmKChmbGFncyZMYXlvdXQpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTt9fXtpZigoZmxhZ3MmSW5zZXJ0aW9uKSE9PU5vRmxhZ3MkMSl7c2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO319c2FmZWx5Q2FsbERlc3Ryb3koZmluaXNoZWRXb3JrLG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVzdHJveSk7e2lmKChmbGFncyZJbnNlcnRpb24pIT09Tm9GbGFncyQxKXtzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO319e2lmKChmbGFncyZQYXNzaXZlJDEpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7fWVsc2UgaWYoKGZsYWdzJkxheW91dCkhPT1Ob0ZsYWdzJDEpe21hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO319fX1lZmZlY3Q9ZWZmZWN0Lm5leHQ7fXdoaWxlKGVmZmVjdCE9PWZpcnN0RWZmZWN0KTt9fWZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoZmxhZ3MsZmluaXNoZWRXb3JrKXt2YXIgdXBkYXRlUXVldWU9ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO3ZhciBsYXN0RWZmZWN0PXVwZGF0ZVF1ZXVlIT09bnVsbD91cGRhdGVRdWV1ZS5sYXN0RWZmZWN0Om51bGw7aWYobGFzdEVmZmVjdCE9PW51bGwpe3ZhciBmaXJzdEVmZmVjdD1sYXN0RWZmZWN0Lm5leHQ7dmFyIGVmZmVjdD1maXJzdEVmZmVjdDtkb3tpZigoZWZmZWN0LnRhZyZmbGFncyk9PT1mbGFncyl7e2lmKChmbGFncyZQYXNzaXZlJDEpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO31lbHNlIGlmKChmbGFncyZMYXlvdXQpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7fX0vLyBNb3VudFxudmFyIGNyZWF0ZT1lZmZlY3QuY3JlYXRlO3tpZigoZmxhZ3MmSW5zZXJ0aW9uKSE9PU5vRmxhZ3MkMSl7c2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO319ZWZmZWN0LmRlc3Ryb3k9Y3JlYXRlKCk7e2lmKChmbGFncyZJbnNlcnRpb24pIT09Tm9GbGFncyQxKXtzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO319e2lmKChmbGFncyZQYXNzaXZlJDEpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO31lbHNlIGlmKChmbGFncyZMYXlvdXQpIT09Tm9GbGFncyQxKXttYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7fX17dmFyIGRlc3Ryb3k9ZWZmZWN0LmRlc3Ryb3k7aWYoZGVzdHJveSE9PXVuZGVmaW5lZCYmdHlwZW9mIGRlc3Ryb3khPT0nZnVuY3Rpb24nKXt2YXIgaG9va05hbWU9dm9pZCAwO2lmKChlZmZlY3QudGFnJkxheW91dCkhPT1Ob0ZsYWdzKXtob29rTmFtZT0ndXNlTGF5b3V0RWZmZWN0Jzt9ZWxzZSBpZigoZWZmZWN0LnRhZyZJbnNlcnRpb24pIT09Tm9GbGFncyl7aG9va05hbWU9J3VzZUluc2VydGlvbkVmZmVjdCc7fWVsc2V7aG9va05hbWU9J3VzZUVmZmVjdCc7fXZhciBhZGRlbmR1bT12b2lkIDA7aWYoZGVzdHJveT09PW51bGwpe2FkZGVuZHVtPScgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJysndXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLic7fWVsc2UgaWYodHlwZW9mIGRlc3Ryb3kudGhlbj09PSdmdW5jdGlvbicpe2FkZGVuZHVtPSdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSAnK2hvb2tOYW1lKycoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcrJ0luc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgJysnYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuJytob29rTmFtZSsnKCgpID0+IHtcXG4nKycgIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcXG4nKycgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJysnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicrJyAgICAvLyAuLi5cXG4nKycgIH1cXG4nKycgIGZldGNoRGF0YSgpO1xcbicrXCJ9LCBbc29tZUlkXSk7IC8vIE9yIFtdIGlmIGVmZmVjdCBkb2Vzbid0IG5lZWQgcHJvcHMgb3Igc3RhdGVcXG5cXG5cIisnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJzt9ZWxzZXthZGRlbmR1bT0nIFlvdSByZXR1cm5lZDogJytkZXN0cm95O31lcnJvcignJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJysnd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXMnLGhvb2tOYW1lLGFkZGVuZHVtKTt9fX1lZmZlY3Q9ZWZmZWN0Lm5leHQ7fXdoaWxlKGVmZmVjdCE9PWZpcnN0RWZmZWN0KTt9fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMoZmluaXNoZWRSb290LGZpbmlzaGVkV29yayl7ey8vIE9ubHkgUHJvZmlsZXJzIHdpdGggd29yayBpbiB0aGVpciBzdWJ0cmVlIHdpbGwgaGF2ZSBhbiBVcGRhdGUgZWZmZWN0IHNjaGVkdWxlZC5cbmlmKChmaW5pc2hlZFdvcmsuZmxhZ3MmVXBkYXRlKSE9PU5vRmxhZ3Mpe3N3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIFByb2ZpbGVyOnt2YXIgcGFzc2l2ZUVmZmVjdER1cmF0aW9uPWZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uO3ZhciBfZmluaXNoZWRXb3JrJG1lbW9pemU9ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsaWQ9X2ZpbmlzaGVkV29yayRtZW1vaXplLmlkLG9uUG9zdENvbW1pdD1fZmluaXNoZWRXb3JrJG1lbW9pemUub25Qb3N0Q29tbWl0Oy8vIFRoaXMgdmFsdWUgd2lsbCBzdGlsbCByZWZsZWN0IHRoZSBwcmV2aW91cyBjb21taXQgcGhhc2UuXG4vLyBJdCBkb2VzIG5vdCBnZXQgcmVzZXQgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGNvbW1pdCBwaGFzZS5cbnZhciBjb21taXRUaW1lPWdldENvbW1pdFRpbWUoKTt2YXIgcGhhc2U9ZmluaXNoZWRXb3JrLmFsdGVybmF0ZT09PW51bGw/J21vdW50JzondXBkYXRlJzt7aWYoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpe3BoYXNlPSduZXN0ZWQtdXBkYXRlJzt9fWlmKHR5cGVvZiBvblBvc3RDb21taXQ9PT0nZnVuY3Rpb24nKXtvblBvc3RDb21taXQoaWQscGhhc2UscGFzc2l2ZUVmZmVjdER1cmF0aW9uLGNvbW1pdFRpbWUpO30vLyBCdWJibGUgdGltZXMgdG8gdGhlIG5leHQgbmVhcmVzdCBhbmNlc3RvciBQcm9maWxlci5cbi8vIEFmdGVyIHdlIHByb2Nlc3MgdGhhdCBQcm9maWxlciwgd2UnbGwgYnViYmxlIGZ1cnRoZXIgdXAuXG52YXIgcGFyZW50RmliZXI9ZmluaXNoZWRXb3JrLnJldHVybjtvdXRlcjp3aGlsZShwYXJlbnRGaWJlciE9PW51bGwpe3N3aXRjaChwYXJlbnRGaWJlci50YWcpe2Nhc2UgSG9zdFJvb3Q6dmFyIHJvb3Q9cGFyZW50RmliZXIuc3RhdGVOb2RlO3Jvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uKz1wYXNzaXZlRWZmZWN0RHVyYXRpb247YnJlYWsgb3V0ZXI7Y2FzZSBQcm9maWxlcjp2YXIgcGFyZW50U3RhdGVOb2RlPXBhcmVudEZpYmVyLnN0YXRlTm9kZTtwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uKz1wYXNzaXZlRWZmZWN0RHVyYXRpb247YnJlYWsgb3V0ZXI7fXBhcmVudEZpYmVyPXBhcmVudEZpYmVyLnJldHVybjt9YnJlYWs7fX19fX1mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCxjdXJyZW50LGZpbmlzaGVkV29yayxjb21taXR0ZWRMYW5lcyl7aWYoKGZpbmlzaGVkV29yay5mbGFncyZMYXlvdXRNYXNrKSE9PU5vRmxhZ3Mpe3N3aXRjaChmaW5pc2hlZFdvcmsudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXsvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbi8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4vLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcbi8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG5pZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dHxIYXNFZmZlY3QsZmluaXNoZWRXb3JrKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO319ZWxzZXtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dHxIYXNFZmZlY3QsZmluaXNoZWRXb3JrKTt9fWJyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgaW5zdGFuY2U9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtpZihmaW5pc2hlZFdvcmsuZmxhZ3MmVXBkYXRlKXtpZighb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbil7aWYoY3VycmVudD09PW51bGwpey8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbi8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxue2lmKGZpbmlzaGVkV29yay50eXBlPT09ZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlJiYhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyl7aWYoaW5zdGFuY2UucHJvcHMhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyl7ZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnKydjb21wb25lbnREaWRNb3VudC4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9aWYoaW5zdGFuY2Uuc3RhdGUhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSl7ZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnKydjb21wb25lbnREaWRNb3VudC4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9fX1pZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7fX1lbHNle2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7fX1lbHNle3ZhciBwcmV2UHJvcHM9ZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlPT09ZmluaXNoZWRXb3JrLnR5cGU/Y3VycmVudC5tZW1vaXplZFByb3BzOnJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsY3VycmVudC5tZW1vaXplZFByb3BzKTt2YXIgcHJldlN0YXRlPWN1cnJlbnQubWVtb2l6ZWRTdGF0ZTsvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4vLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbi8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbntpZihmaW5pc2hlZFdvcmsudHlwZT09PWZpbmlzaGVkV29yay5lbGVtZW50VHlwZSYmIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpe2lmKGluc3RhbmNlLnByb3BzIT09ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpe2Vycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJysnY29tcG9uZW50RGlkVXBkYXRlLiAnKydUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcrJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJysnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yayl8fCdpbnN0YW5jZScpO31pZihpbnN0YW5jZS5zdGF0ZSE9PWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKXtlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcrJ2NvbXBvbmVudERpZFVwZGF0ZS4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9fX1pZihmaW5pc2hlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLHByZXZTdGF0ZSxpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7fWZpbmFsbHl7cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9fWVsc2V7aW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyxwcmV2U3RhdGUsaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO319fX0vLyBUT0RPOiBJIHRoaW5rIHRoaXMgaXMgbm93IGFsd2F5cyBub24tbnVsbCBieSB0aGUgdGltZSBpdCByZWFjaGVzIHRoZVxuLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbnZhciB1cGRhdGVRdWV1ZT1maW5pc2hlZFdvcmsudXBkYXRlUXVldWU7aWYodXBkYXRlUXVldWUhPT1udWxsKXt7aWYoZmluaXNoZWRXb3JrLnR5cGU9PT1maW5pc2hlZFdvcmsuZWxlbWVudFR5cGUmJiFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKXtpZihpbnN0YW5jZS5wcm9wcyE9PWZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKXtlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcrJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJysnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnKydhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcrJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspfHwnaW5zdGFuY2UnKTt9aWYoaW5zdGFuY2Uuc3RhdGUhPT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSl7ZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnKydwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcrJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJysnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnKydQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKXx8J2luc3RhbmNlJyk7fX19Ly8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4vLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5jb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssdXBkYXRlUXVldWUsaW5zdGFuY2UpO31icmVhazt9Y2FzZSBIb3N0Um9vdDp7Ly8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbi8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG52YXIgX3VwZGF0ZVF1ZXVlPWZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtpZihfdXBkYXRlUXVldWUhPT1udWxsKXt2YXIgX2luc3RhbmNlPW51bGw7aWYoZmluaXNoZWRXb3JrLmNoaWxkIT09bnVsbCl7c3dpdGNoKGZpbmlzaGVkV29yay5jaGlsZC50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDpfaW5zdGFuY2U9Z2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7YnJlYWs7Y2FzZSBDbGFzc0NvbXBvbmVudDpfaW5zdGFuY2U9ZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTticmVhazt9fWNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yayxfdXBkYXRlUXVldWUsX2luc3RhbmNlKTt9YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7dmFyIF9pbnN0YW5jZTI9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbi8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4vLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4vLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbmlmKGN1cnJlbnQ9PT1udWxsJiZmaW5pc2hlZFdvcmsuZmxhZ3MmVXBkYXRlKXt2YXIgdHlwZT1maW5pc2hlZFdvcmsudHlwZTt2YXIgcHJvcHM9ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7Y29tbWl0TW91bnQoX2luc3RhbmNlMix0eXBlLHByb3BzKTt9YnJlYWs7fWNhc2UgSG9zdFRleHQ6ey8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG5icmVhazt9Y2FzZSBIb3N0UG9ydGFsOnsvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuYnJlYWs7fWNhc2UgUHJvZmlsZXI6e3t2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMj1maW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxvbkNvbW1pdD1fZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uQ29tbWl0LG9uUmVuZGVyPV9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25SZW5kZXI7dmFyIGVmZmVjdER1cmF0aW9uPWZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb247dmFyIGNvbW1pdFRpbWU9Z2V0Q29tbWl0VGltZSgpO3ZhciBwaGFzZT1jdXJyZW50PT09bnVsbD8nbW91bnQnOid1cGRhdGUnO3tpZihpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSl7cGhhc2U9J25lc3RlZC11cGRhdGUnO319aWYodHlwZW9mIG9uUmVuZGVyPT09J2Z1bmN0aW9uJyl7b25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQscGhhc2UsZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsY29tbWl0VGltZSk7fXtpZih0eXBlb2Ygb25Db21taXQ9PT0nZnVuY3Rpb24nKXtvbkNvbW1pdChmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCxwaGFzZSxlZmZlY3REdXJhdGlvbixjb21taXRUaW1lKTt9Ly8gU2NoZWR1bGUgYSBwYXNzaXZlIGVmZmVjdCBmb3IgdGhpcyBQcm9maWxlciB0byBjYWxsIG9uUG9zdENvbW1pdCBob29rcy5cbi8vIFRoaXMgZWZmZWN0IHNob3VsZCBiZSBzY2hlZHVsZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBvblBvc3RDb21taXQgY2FsbGJhY2sgZm9yIHRoaXMgUHJvZmlsZXIsXG4vLyBiZWNhdXNlIHRoZSBlZmZlY3QgaXMgYWxzbyB3aGVyZSB0aW1lcyBidWJibGUgdG8gcGFyZW50IFByb2ZpbGVycy5cbmVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpbmlzaGVkV29yayk7Ly8gUHJvcGFnYXRlIGxheW91dCBlZmZlY3QgZHVyYXRpb25zIHRvIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3IuXG4vLyBEbyBub3QgcmVzZXQgdGhlc2UgdmFsdWVzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBzbyBEZXZUb29scyBoYXMgYSBjaGFuY2UgdG8gcmVhZCB0aGVtIGZpcnN0LlxudmFyIHBhcmVudEZpYmVyPWZpbmlzaGVkV29yay5yZXR1cm47b3V0ZXI6d2hpbGUocGFyZW50RmliZXIhPT1udWxsKXtzd2l0Y2gocGFyZW50RmliZXIudGFnKXtjYXNlIEhvc3RSb290OnZhciByb290PXBhcmVudEZpYmVyLnN0YXRlTm9kZTtyb290LmVmZmVjdER1cmF0aW9uKz1lZmZlY3REdXJhdGlvbjticmVhayBvdXRlcjtjYXNlIFByb2ZpbGVyOnZhciBwYXJlbnRTdGF0ZU5vZGU9cGFyZW50RmliZXIuc3RhdGVOb2RlO3BhcmVudFN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbis9ZWZmZWN0RHVyYXRpb247YnJlYWsgb3V0ZXI7fXBhcmVudEZpYmVyPXBhcmVudEZpYmVyLnJldHVybjt9fX1icmVhazt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7Y29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LGZpbmlzaGVkV29yayk7YnJlYWs7fWNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OmNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OmNhc2UgU2NvcGVDb21wb25lbnQ6Y2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6Y2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6Y2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OnticmVhazt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcrJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319aWYoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pe3tpZihmaW5pc2hlZFdvcmsuZmxhZ3MmUmVmKXtjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKTt9fX19ZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlcihub2RlKXsvLyBUdXJuIG9uIGxheW91dCBlZmZlY3RzIGluIGEgdHJlZSB0aGF0IHByZXZpb3VzbHkgZGlzYXBwZWFyZWQuXG4vLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuc3dpdGNoKG5vZGUudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKG5vZGUubW9kZSZQcm9maWxlTW9kZSl7dHJ5e3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLG5vZGUucmV0dXJuKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihub2RlKTt9fWVsc2V7c2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSxub2RlLnJldHVybik7fWJyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgaW5zdGFuY2U9bm9kZS5zdGF0ZU5vZGU7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50PT09J2Z1bmN0aW9uJyl7c2FmZWx5Q2FsbENvbXBvbmVudERpZE1vdW50KG5vZGUsbm9kZS5yZXR1cm4saW5zdGFuY2UpO31zYWZlbHlBdHRhY2hSZWYobm9kZSxub2RlLnJldHVybik7YnJlYWs7fWNhc2UgSG9zdENvbXBvbmVudDp7c2FmZWx5QXR0YWNoUmVmKG5vZGUsbm9kZS5yZXR1cm4pO2JyZWFrO319fWZ1bmN0aW9uIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yayxpc0hpZGRlbil7Ly8gT25seSBoaWRlIG9yIHVuaGlkZSB0aGUgdG9wLW1vc3QgaG9zdCBub2Rlcy5cbnZhciBob3N0U3VidHJlZVJvb3Q9bnVsbDt7Ly8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxudmFyIG5vZGU9ZmluaXNoZWRXb3JrO3doaWxlKHRydWUpe2lmKG5vZGUudGFnPT09SG9zdENvbXBvbmVudCl7aWYoaG9zdFN1YnRyZWVSb290PT09bnVsbCl7aG9zdFN1YnRyZWVSb290PW5vZGU7dHJ5e3ZhciBpbnN0YW5jZT1ub2RlLnN0YXRlTm9kZTtpZihpc0hpZGRlbil7aGlkZUluc3RhbmNlKGluc3RhbmNlKTt9ZWxzZXt1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSxub2RlLm1lbW9pemVkUHJvcHMpO319Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fX1lbHNlIGlmKG5vZGUudGFnPT09SG9zdFRleHQpe2lmKGhvc3RTdWJ0cmVlUm9vdD09PW51bGwpe3RyeXt2YXIgX2luc3RhbmNlMz1ub2RlLnN0YXRlTm9kZTtpZihpc0hpZGRlbil7aGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UzKTt9ZWxzZXt1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyxub2RlLm1lbW9pemVkUHJvcHMpO319Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fX1lbHNlIGlmKChub2RlLnRhZz09PU9mZnNjcmVlbkNvbXBvbmVudHx8bm9kZS50YWc9PT1MZWdhY3lIaWRkZW5Db21wb25lbnQpJiZub2RlLm1lbW9pemVkU3RhdGUhPT1udWxsJiZub2RlIT09ZmluaXNoZWRXb3JrKTtlbHNlIGlmKG5vZGUuY2hpbGQhPT1udWxsKXtub2RlLmNoaWxkLnJldHVybj1ub2RlO25vZGU9bm9kZS5jaGlsZDtjb250aW51ZTt9aWYobm9kZT09PWZpbmlzaGVkV29yayl7cmV0dXJuO313aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fG5vZGUucmV0dXJuPT09ZmluaXNoZWRXb3JrKXtyZXR1cm47fWlmKGhvc3RTdWJ0cmVlUm9vdD09PW5vZGUpe2hvc3RTdWJ0cmVlUm9vdD1udWxsO31ub2RlPW5vZGUucmV0dXJuO31pZihob3N0U3VidHJlZVJvb3Q9PT1ub2RlKXtob3N0U3VidHJlZVJvb3Q9bnVsbDt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt9fX1mdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKXt2YXIgcmVmPWZpbmlzaGVkV29yay5yZWY7aWYocmVmIT09bnVsbCl7dmFyIGluc3RhbmNlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7dmFyIGluc3RhbmNlVG9Vc2U7c3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDppbnN0YW5jZVRvVXNlPWdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTticmVhaztkZWZhdWx0Omluc3RhbmNlVG9Vc2U9aW5zdGFuY2U7fS8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuaWYodHlwZW9mIHJlZj09PSdmdW5jdGlvbicpe3ZhciByZXRWYWw7aWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7cmV0VmFsPXJlZihpbnN0YW5jZVRvVXNlKTt9ZmluYWxseXtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO319ZWxzZXtyZXRWYWw9cmVmKGluc3RhbmNlVG9Vc2UpO317aWYodHlwZW9mIHJldFZhbD09PSdmdW5jdGlvbicpe2Vycm9yKCdVbmV4cGVjdGVkIHJldHVybiB2YWx1ZSBmcm9tIGEgY2FsbGJhY2sgcmVmIGluICVzLiAnKydBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTt9fX1lbHNle3tpZighcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50Jykpe2Vycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnKydVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7fX1yZWYuY3VycmVudD1pbnN0YW5jZVRvVXNlO319fWZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpey8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVyIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZXRlY3QgYW5kIHdhcm4gYWdhaW5zdCBzdGF0ZSB1cGRhdGVzIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXG4vLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuLy9cbi8vIElkZWFsbHksIHdlIHNob3VsZCBhbHNvIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4vLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4vLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC5cbi8vIFRoaXMgY2hpbGQgaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbi8vXG4vLyBOb3RlIHRoYXQgd2UgY2FuJ3QgY2xlYXIgY2hpbGQgb3Igc2libGluZyBwb2ludGVycyB5ZXQuXG4vLyBUaGV5J3JlIG5lZWRlZCBmb3IgcGFzc2l2ZSBlZmZlY3RzIGFuZCBmb3IgZmluZERPTU5vZGUuXG4vLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4vL1xuLy8gRG9uJ3QgcmVzZXQgdGhlIGFsdGVybmF0ZSB5ZXQsIGVpdGhlci4gV2UgbmVlZCB0aGF0IHNvIHdlIGNhbiBkZXRhY2ggdGhlXG4vLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuLy8gc3VmZmljaWVudCBmb3IgZmluZERPTU5vZGUgc2VtYW50aWNzLlxudmFyIGFsdGVybmF0ZT1maWJlci5hbHRlcm5hdGU7aWYoYWx0ZXJuYXRlIT09bnVsbCl7YWx0ZXJuYXRlLnJldHVybj1udWxsO31maWJlci5yZXR1cm49bnVsbDt9ZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpe3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlO2lmKGFsdGVybmF0ZSE9PW51bGwpe2ZpYmVyLmFsdGVybmF0ZT1udWxsO2RldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGFsdGVybmF0ZSk7fS8vIE5vdGU6IERlZmVuc2l2ZWx5IHVzaW5nIG5lZ2F0aW9uIGluc3RlYWQgb2YgPCBpbiBjYXNlXG4vLyBgZGVsZXRlZFRyZWVDbGVhblVwTGV2ZWxgIGlzIHVuZGVmaW5lZC5cbnsvLyBDbGVhciBjeWNsaWNhbCBGaWJlciBmaWVsZHMuIFRoaXMgbGV2ZWwgYWxvbmUgaXMgZGVzaWduZWQgdG8gcm91Z2hseVxuLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuLy8gYm91bmQgdG8gYSBzcGVjaWFsIFwiaW5zdGFuY2VcIiBvYmplY3QgaW5zdGVhZCBvZiBhIEZpYmVyLiBUaGUgSW5zdGFuY2Vcbi8vIG9iamVjdCB3aWxsIG5vdCBoYXZlIGFueSBvZiB0aGVzZSBmaWVsZHMuIEl0IHdpbGwgb25seSBiZSBjb25uZWN0ZWQgdG9cbi8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4vLyBzdWZmaWNpZW50IHRvIGZpeCBtZW1vcnkgaXNzdWVzLCB0aGF0IGJvZGVzIHdlbGwgZm9yIG91ciBwbGFucy5cbmZpYmVyLmNoaWxkPW51bGw7ZmliZXIuZGVsZXRpb25zPW51bGw7ZmliZXIuc2libGluZz1udWxsOy8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4vLyB0cmVlLCB3aGljaCBoYXMgaXRzIG93biBwb2ludGVycyB0byBjaGlsZHJlbiwgcGFyZW50cywgYW5kIHNpYmxpbmdzLlxuLy8gVGhlIG90aGVyIGhvc3Qgbm9kZXMgYWxzbyBwb2ludCBiYWNrIHRvIGZpYmVycywgc28gd2Ugc2hvdWxkIGRldGFjaCB0aGF0XG4vLyBvbmUsIHRvby5cbmlmKGZpYmVyLnRhZz09PUhvc3RDb21wb25lbnQpe3ZhciBob3N0SW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO2lmKGhvc3RJbnN0YW5jZSE9PW51bGwpe2RldGFjaERlbGV0ZWRJbnN0YW5jZShob3N0SW5zdGFuY2UpO319ZmliZXIuc3RhdGVOb2RlPW51bGw7Ly8gSSdtIGludGVudGlvbmFsbHkgbm90IGNsZWFyaW5nIHRoZSBgcmV0dXJuYCBmaWVsZCBpbiB0aGlzIGxldmVsLiBXZVxuLy8gYWxyZWFkeSBkaXNjb25uZWN0IHRoZSBgcmV0dXJuYCBwb2ludGVyIGF0IHRoZSByb290IG9mIHRoZSBkZWxldGVkXG4vLyBzdWJ0cmVlIChpbiBgZGV0YWNoRmliZXJNdXRhdGlvbmApLiBCZXNpZGVzLCBgcmV0dXJuYCBieSBpdHNlbGYgaXMgbm90XG4vLyBjeWNsaWNhbCDigJQgaXQncyBvbmx5IGN5Y2xpY2FsIHdoZW4gY29tYmluZWQgd2l0aCBgY2hpbGRgLCBgc2libGluZ2AsIGFuZFxuLy8gYGFsdGVybmF0ZWAuIEJ1dCB3ZSdsbCBjbGVhciBpdCBpbiB0aGUgbmV4dCBsZXZlbCBhbnl3YXksIGp1c3QgaW4gY2FzZS5cbntmaWJlci5fZGVidWdPd25lcj1udWxsO317Ly8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4vLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2Vcbi8vXG4vLyBUaGUgcHVycG9zZSBvZiB0aGlzIGJyYW5jaCBpcyB0byBiZSBzdXBlciBhZ2dyZXNzaXZlIHNvIHdlIGNhbiBtZWFzdXJlXG4vLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG4vLyBpbmRpY2F0ZSBhIFJlYWN0IGxlYWsgd2UgZG9uJ3Qga25vdyBhYm91dC5cbmZpYmVyLnJldHVybj1udWxsO2ZpYmVyLmRlcGVuZGVuY2llcz1udWxsO2ZpYmVyLm1lbW9pemVkUHJvcHM9bnVsbDtmaWJlci5tZW1vaXplZFN0YXRlPW51bGw7ZmliZXIucGVuZGluZ1Byb3BzPW51bGw7ZmliZXIuc3RhdGVOb2RlPW51bGw7Ly8gVE9ETzogTW92ZSB0byBgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXJgIGluc3RlYWQuXG5maWJlci51cGRhdGVRdWV1ZT1udWxsO319fWZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcil7dmFyIHBhcmVudD1maWJlci5yZXR1cm47d2hpbGUocGFyZW50IT09bnVsbCl7aWYoaXNIb3N0UGFyZW50KHBhcmVudCkpe3JldHVybiBwYXJlbnQ7fXBhcmVudD1wYXJlbnQucmV0dXJuO310aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcrJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9ZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKXtyZXR1cm4gZmliZXIudGFnPT09SG9zdENvbXBvbmVudHx8ZmliZXIudGFnPT09SG9zdFJvb3R8fGZpYmVyLnRhZz09PUhvc3RQb3J0YWw7fWZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKXsvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3Rcbi8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4vLyBUT0RPOiBGaW5kIGEgbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXMuXG52YXIgbm9kZT1maWJlcjtzaWJsaW5nczp3aGlsZSh0cnVlKXsvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG53aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fGlzSG9zdFBhcmVudChub2RlLnJldHVybikpey8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbi8vIGxhc3Qgc2libGluZy5cbnJldHVybiBudWxsO31ub2RlPW5vZGUucmV0dXJuO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO3doaWxlKG5vZGUudGFnIT09SG9zdENvbXBvbmVudCYmbm9kZS50YWchPT1Ib3N0VGV4dCYmbm9kZS50YWchPT1EZWh5ZHJhdGVkRnJhZ21lbnQpey8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbi8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbmlmKG5vZGUuZmxhZ3MmUGxhY2VtZW50KXsvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbmNvbnRpbnVlIHNpYmxpbmdzO30vLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbi8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5pZihub2RlLmNoaWxkPT09bnVsbHx8bm9kZS50YWc9PT1Ib3N0UG9ydGFsKXtjb250aW51ZSBzaWJsaW5nczt9ZWxzZXtub2RlLmNoaWxkLnJldHVybj1ub2RlO25vZGU9bm9kZS5jaGlsZDt9fS8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG5pZighKG5vZGUuZmxhZ3MmUGxhY2VtZW50KSl7Ly8gRm91bmQgaXQhXG5yZXR1cm4gbm9kZS5zdGF0ZU5vZGU7fX19ZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yayl7dmFyIHBhcmVudEZpYmVyPWdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspOy8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuc3dpdGNoKHBhcmVudEZpYmVyLnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ont2YXIgcGFyZW50PXBhcmVudEZpYmVyLnN0YXRlTm9kZTtpZihwYXJlbnRGaWJlci5mbGFncyZDb250ZW50UmVzZXQpey8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbnJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xucGFyZW50RmliZXIuZmxhZ3MmPX5Db250ZW50UmVzZXQ7fXZhciBiZWZvcmU9Z2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4vLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5pbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLGJlZm9yZSxwYXJlbnQpO2JyZWFrO31jYXNlIEhvc3RSb290OmNhc2UgSG9zdFBvcnRhbDp7dmFyIF9wYXJlbnQ9cGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87dmFyIF9iZWZvcmU9Z2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yayxfYmVmb3JlLF9wYXJlbnQpO2JyZWFrO30vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcbmRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJysnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319ZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLGJlZm9yZSxwYXJlbnQpe3ZhciB0YWc9bm9kZS50YWc7dmFyIGlzSG9zdD10YWc9PT1Ib3N0Q29tcG9uZW50fHx0YWc9PT1Ib3N0VGV4dDtpZihpc0hvc3Qpe3ZhciBzdGF0ZU5vZGU9bm9kZS5zdGF0ZU5vZGU7aWYoYmVmb3JlKXtpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsc3RhdGVOb2RlLGJlZm9yZSk7fWVsc2V7YXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsc3RhdGVOb2RlKTt9fWVsc2UgaWYodGFnPT09SG9zdFBvcnRhbCk7ZWxzZXt2YXIgY2hpbGQ9bm9kZS5jaGlsZDtpZihjaGlsZCE9PW51bGwpe2luc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsYmVmb3JlLHBhcmVudCk7dmFyIHNpYmxpbmc9Y2hpbGQuc2libGluZzt3aGlsZShzaWJsaW5nIT09bnVsbCl7aW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLGJlZm9yZSxwYXJlbnQpO3NpYmxpbmc9c2libGluZy5zaWJsaW5nO319fX1mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSxiZWZvcmUscGFyZW50KXt2YXIgdGFnPW5vZGUudGFnO3ZhciBpc0hvc3Q9dGFnPT09SG9zdENvbXBvbmVudHx8dGFnPT09SG9zdFRleHQ7aWYoaXNIb3N0KXt2YXIgc3RhdGVOb2RlPW5vZGUuc3RhdGVOb2RlO2lmKGJlZm9yZSl7aW5zZXJ0QmVmb3JlKHBhcmVudCxzdGF0ZU5vZGUsYmVmb3JlKTt9ZWxzZXthcHBlbmRDaGlsZChwYXJlbnQsc3RhdGVOb2RlKTt9fWVsc2UgaWYodGFnPT09SG9zdFBvcnRhbCk7ZWxzZXt2YXIgY2hpbGQ9bm9kZS5jaGlsZDtpZihjaGlsZCE9PW51bGwpe2luc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCxiZWZvcmUscGFyZW50KTt2YXIgc2libGluZz1jaGlsZC5zaWJsaW5nO3doaWxlKHNpYmxpbmchPT1udWxsKXtpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZyxiZWZvcmUscGFyZW50KTtzaWJsaW5nPXNpYmxpbmcuc2libGluZzt9fX19Ly8gVGhlc2UgYXJlIHRyYWNrZWQgb24gdGhlIHN0YWNrIGFzIHdlIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFcbi8vIGRlbGV0ZWQgc3VidHJlZS5cbi8vIFRPRE86IFVwZGF0ZSB0aGVzZSBkdXJpbmcgdGhlIHdob2xlIG11dGF0aW9uIHBoYXNlLCBub3QganVzdCBkdXJpbmdcbi8vIGEgZGVsZXRpb24uXG52YXIgaG9zdFBhcmVudD1udWxsO3ZhciBob3N0UGFyZW50SXNDb250YWluZXI9ZmFsc2U7ZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QscmV0dXJuRmliZXIsZGVsZXRlZEZpYmVyKXt7Ly8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgZGVsZXRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4vLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4vLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LCBkZXRhY2ggcmVmcywgY2xlYW5cbi8vIHVwIG1vdW50ZWQgbGF5b3V0IGVmZmVjdHMsIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50LlxuLy8gV2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGUgdG9wbW9zdCBob3N0IGNoaWxkIGluIGVhY2ggYnJhbmNoLiBCdXQgdGhlbiB3ZVxuLy8gc3RpbGwgbmVlZCB0byBrZWVwIHRyYXZlcnNpbmcgdG8gdW5tb3VudCBlZmZlY3RzLCByZWZzLCBhbmQgY1dVLiBUT0RPOiBXZVxuLy8gY291bGQgc3BsaXQgdGhpcyBpbnRvIHR3byBzZXBhcmF0ZSB0cmF2ZXJzYWxzIGZ1bmN0aW9ucywgd2hlcmUgdGhlIHNlY29uZFxuLy8gb25lIGRvZXNuJ3QgaW5jbHVkZSBhbnkgcmVtb3ZlQ2hpbGQgbG9naWMuIFRoaXMgaXMgbWF5YmUgdGhlIHNhbWVcbi8vIGZ1bmN0aW9uIGFzIFwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0c1wiIChvciB3aGF0ZXZlciB0aGF0IHR1cm5zIGludG8gYWZ0ZXJcbi8vIHRoZSBsYXlvdXQgcGhhc2UgaXMgcmVmYWN0b3JlZCB0byB1c2UgcmVjdXJzaW9uKS5cbi8vIEJlZm9yZSBzdGFydGluZywgZmluZCB0aGUgbmVhcmVzdCBob3N0IHBhcmVudCBvbiB0aGUgc3RhY2sgc28gd2Uga25vd1xuLy8gd2hpY2ggaW5zdGFuY2UvY29udGFpbmVyIHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gZnJvbS5cbi8vIFRPRE86IEluc3RlYWQgb2Ygc2VhcmNoaW5nIHVwIHRoZSBmaWJlciByZXR1cm4gcGF0aCBvbiBldmVyeSBkZWxldGlvbiwgd2Vcbi8vIGNhbiB0cmFjayB0aGUgbmVhcmVzdCBob3N0IGNvbXBvbmVudCBvbiB0aGUgSlMgc3RhY2sgYXMgd2UgdHJhdmVyc2UgdGhlXG4vLyB0cmVlIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGlzIHdvdWxkIG1ha2UgaW5zZXJ0aW9ucyBmYXN0ZXIsIHRvby5cbnZhciBwYXJlbnQ9cmV0dXJuRmliZXI7ZmluZFBhcmVudDp3aGlsZShwYXJlbnQhPT1udWxsKXtzd2l0Y2gocGFyZW50LnRhZyl7Y2FzZSBIb3N0Q29tcG9uZW50Ontob3N0UGFyZW50PXBhcmVudC5zdGF0ZU5vZGU7aG9zdFBhcmVudElzQ29udGFpbmVyPWZhbHNlO2JyZWFrIGZpbmRQYXJlbnQ7fWNhc2UgSG9zdFJvb3Q6e2hvc3RQYXJlbnQ9cGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2hvc3RQYXJlbnRJc0NvbnRhaW5lcj10cnVlO2JyZWFrIGZpbmRQYXJlbnQ7fWNhc2UgSG9zdFBvcnRhbDp7aG9zdFBhcmVudD1wYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aG9zdFBhcmVudElzQ29udGFpbmVyPXRydWU7YnJlYWsgZmluZFBhcmVudDt9fXBhcmVudD1wYXJlbnQucmV0dXJuO31pZihob3N0UGFyZW50PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnKydhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7fWNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCxyZXR1cm5GaWJlcixkZWxldGVkRmliZXIpO2hvc3RQYXJlbnQ9bnVsbDtob3N0UGFyZW50SXNDb250YWluZXI9ZmFsc2U7fWRldGFjaEZpYmVyTXV0YXRpb24oZGVsZXRlZEZpYmVyKTt9ZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixwYXJlbnQpey8vIFRPRE86IFVzZSBhIHN0YXRpYyBmbGFnIHRvIHNraXAgdHJlZXMgdGhhdCBkb24ndCBoYXZlIHVubW91bnQgZWZmZWN0c1xudmFyIGNoaWxkPXBhcmVudC5jaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe2NvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsY2hpbGQpO2NoaWxkPWNoaWxkLnNpYmxpbmc7fX1mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcil7b25Db21taXRVbm1vdW50KGRlbGV0ZWRGaWJlcik7Ly8gVGhlIGNhc2VzIGluIHRoaXMgb3V0ZXIgc3dpdGNoIG1vZGlmeSB0aGUgc3RhY2sgYmVmb3JlIHRoZXkgdHJhdmVyc2Vcbi8vIGludG8gdGhlaXIgc3VidHJlZS4gVGhlcmUgYXJlIHNpbXBsZXIgY2FzZXMgaW4gdGhlIGlubmVyIHN3aXRjaFxuLy8gdGhhdCBkb24ndCBtb2RpZnkgdGhlIHN0YWNrLlxuc3dpdGNoKGRlbGV0ZWRGaWJlci50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDp7aWYoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pe3NhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7fS8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoIHRvIG5leHQgYnJhbmNoXG59Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5jYXNlIEhvc3RUZXh0OnsvLyBXZSBvbmx5IG5lZWQgdG8gcmVtb3ZlIHRoZSBuZWFyZXN0IGhvc3QgY2hpbGQuIFNldCB0aGUgaG9zdCBwYXJlbnRcbi8vIHRvIGBudWxsYCBvbiB0aGUgc3RhY2sgdG8gaW5kaWNhdGUgdGhhdCBuZXN0ZWQgY2hpbGRyZW4gZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgcmVtb3ZlZC5cbnt2YXIgcHJldkhvc3RQYXJlbnQ9aG9zdFBhcmVudDt2YXIgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcj1ob3N0UGFyZW50SXNDb250YWluZXI7aG9zdFBhcmVudD1udWxsO3JlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtob3N0UGFyZW50PXByZXZIb3N0UGFyZW50O2hvc3RQYXJlbnRJc0NvbnRhaW5lcj1wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO2lmKGhvc3RQYXJlbnQhPT1udWxsKXsvLyBOb3cgdGhhdCBhbGwgdGhlIGNoaWxkIGVmZmVjdHMgaGF2ZSB1bm1vdW50ZWQsIHdlIGNhbiByZW1vdmUgdGhlXG4vLyBub2RlIGZyb20gdGhlIHRyZWUuXG5pZihob3N0UGFyZW50SXNDb250YWluZXIpe3JlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihob3N0UGFyZW50LGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO31lbHNle3JlbW92ZUNoaWxkKGhvc3RQYXJlbnQsZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7fX19cmV0dXJuO31jYXNlIERlaHlkcmF0ZWRGcmFnbWVudDp7Ly8gRGVsZXRlIHRoZSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBhbGwgb2YgaXRzIGNvbnRlbnQuXG57aWYoaG9zdFBhcmVudCE9PW51bGwpe2lmKGhvc3RQYXJlbnRJc0NvbnRhaW5lcil7Y2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihob3N0UGFyZW50LGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO31lbHNle2NsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO319fXJldHVybjt9Y2FzZSBIb3N0UG9ydGFsOnt7Ly8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG52YXIgX3ByZXZIb3N0UGFyZW50PWhvc3RQYXJlbnQ7dmFyIF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyPWhvc3RQYXJlbnRJc0NvbnRhaW5lcjtob3N0UGFyZW50PWRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztob3N0UGFyZW50SXNDb250YWluZXI9dHJ1ZTtyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlbGV0ZWRGaWJlcik7aG9zdFBhcmVudD1fcHJldkhvc3RQYXJlbnQ7aG9zdFBhcmVudElzQ29udGFpbmVyPV9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO31yZXR1cm47fWNhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgTWVtb0NvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXt2YXIgdXBkYXRlUXVldWU9ZGVsZXRlZEZpYmVyLnVwZGF0ZVF1ZXVlO2lmKHVwZGF0ZVF1ZXVlIT09bnVsbCl7dmFyIGxhc3RFZmZlY3Q9dXBkYXRlUXVldWUubGFzdEVmZmVjdDtpZihsYXN0RWZmZWN0IT09bnVsbCl7dmFyIGZpcnN0RWZmZWN0PWxhc3RFZmZlY3QubmV4dDt2YXIgZWZmZWN0PWZpcnN0RWZmZWN0O2Rve3ZhciBfZWZmZWN0PWVmZmVjdCxkZXN0cm95PV9lZmZlY3QuZGVzdHJveSx0YWc9X2VmZmVjdC50YWc7aWYoZGVzdHJveSE9PXVuZGVmaW5lZCl7aWYoKHRhZyZJbnNlcnRpb24pIT09Tm9GbGFncyQxKXtzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZXN0cm95KTt9ZWxzZSBpZigodGFnJkxheW91dCkhPT1Ob0ZsYWdzJDEpe3ttYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZGVsZXRlZEZpYmVyKTt9aWYoZGVsZXRlZEZpYmVyLm1vZGUmUHJvZmlsZU1vZGUpe3N0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZXN0cm95KTtyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihkZWxldGVkRmliZXIpO31lbHNle3NhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGRlc3Ryb3kpO317bWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7fX19ZWZmZWN0PWVmZmVjdC5uZXh0O313aGlsZShlZmZlY3QhPT1maXJzdEVmZmVjdCk7fX19cmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixkZWxldGVkRmliZXIpO3JldHVybjt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7aWYoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pe3NhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7dmFyIGluc3RhbmNlPWRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50PT09J2Z1bmN0aW9uJyl7c2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGRlbGV0ZWRGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGluc3RhbmNlKTt9fXJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtyZXR1cm47fWNhc2UgU2NvcGVDb21wb25lbnQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtyZXR1cm47fWNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OntpZigvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZWFkIGZsYWdcbmRlbGV0ZWRGaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKXsvLyBJZiB0aGlzIG9mZnNjcmVlbiBjb21wb25lbnQgaXMgaGlkZGVuLCB3ZSBhbHJlYWR5IHVubW91bnRlZCBpdC4gQmVmb3JlXG4vLyBkZWxldGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIHRoYXQgaXQncyBhbHJlYWR5IHVubW91bnRlZCBzbyB0aGF0IHdlXG4vLyBkb24ndCBhdHRlbXB0IHRvIHVubW91bnQgdGhlIGVmZmVjdHMgYWdhaW4uXG4vLyBUT0RPOiBJZiB0aGUgdHJlZSBpcyBoaWRkZW4sIGluIG1vc3QgY2FzZXMgd2Ugc2hvdWxkIGJlIGFibGUgdG8gc2tpcFxuLy8gb3ZlciB0aGUgbmVzdGVkIGNoaWxkcmVuIGVudGlyZWx5LiBBbiBleGNlcHRpb24gaXMgd2UgaGF2ZW4ndCB5ZXQgZm91bmRcbi8vIHRoZSB0b3Btb3N0IGhvc3Qgbm9kZSB0byBkZWxldGUsIHdoaWNoIHdlIGFscmVhZHkgdHJhY2sgb24gdGhlIHN0YWNrLlxuLy8gQnV0IHRoZSBvdGhlciBjYXNlIGlzIHBvcnRhbHMsIHdoaWNoIG5lZWQgdG8gYmUgZGV0YWNoZWQgbm8gbWF0dGVyIGhvd1xuLy8gZGVlcGx5IHRoZXkgYXJlIG5lc3RlZC4gV2Ugc2hvdWxkIHVzZSBhIHN1YnRyZWUgZmxhZyB0byB0cmFjayB3aGV0aGVyIGFcbi8vIHN1YnRyZWUgaW5jbHVkZXMgYSBuZXN0ZWQgcG9ydGFsLlxudmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1wcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbnx8ZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUhPT1udWxsO3JlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO31lbHNle3JlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTt9YnJlYWs7fWRlZmF1bHQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsZGVsZXRlZEZpYmVyKTtyZXR1cm47fX19ZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspey8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG52YXIgbmV3U3RhdGU9ZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7fWZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCxmaW5pc2hlZFdvcmspe3ZhciBuZXdTdGF0ZT1maW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtpZihuZXdTdGF0ZT09PW51bGwpe3ZhciBjdXJyZW50PWZpbmlzaGVkV29yay5hbHRlcm5hdGU7aWYoY3VycmVudCE9PW51bGwpe3ZhciBwcmV2U3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO2lmKHByZXZTdGF0ZSE9PW51bGwpe3ZhciBzdXNwZW5zZUluc3RhbmNlPXByZXZTdGF0ZS5kZWh5ZHJhdGVkO2lmKHN1c3BlbnNlSW5zdGFuY2UhPT1udWxsKXtjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7fX19fX1mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayl7Ly8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgdGhlbiBpdCB3aWxsIGhhdmUgYSBzZXQgb2Ygd2FrZWFibGVzLlxuLy8gRm9yIGVhY2ggd2FrZWFibGUsIGF0dGFjaCBhIGxpc3RlbmVyIHNvIHRoYXQgd2hlbiBpdCByZXNvbHZlcywgUmVhY3Rcbi8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbnZhciB3YWtlYWJsZXM9ZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO2lmKHdha2VhYmxlcyE9PW51bGwpe2ZpbmlzaGVkV29yay51cGRhdGVRdWV1ZT1udWxsO3ZhciByZXRyeUNhY2hlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7aWYocmV0cnlDYWNoZT09PW51bGwpe3JldHJ5Q2FjaGU9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZT1uZXcgUG9zc2libHlXZWFrU2V0KCk7fXdha2VhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHdha2VhYmxlKXsvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG52YXIgcmV0cnk9cmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLGZpbmlzaGVkV29yayx3YWtlYWJsZSk7aWYoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSl7cmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO3tpZihpc0RldlRvb2xzUHJlc2VudCl7aWYoaW5Qcm9ncmVzc0xhbmVzIT09bnVsbCYmaW5Qcm9ncmVzc1Jvb3QhPT1udWxsKXsvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgYXNzb2NpYXRlIHRoZSBvcmlnaW5hbCB1cGRhdGVycyB3aXRoIGl0LlxucmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCxpblByb2dyZXNzTGFuZXMpO31lbHNle3Rocm93IEVycm9yKCdFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7fX19d2FrZWFibGUudGhlbihyZXRyeSxyZXRyeSk7fX0pO319Ly8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmssY29tbWl0dGVkTGFuZXMpe2luUHJvZ3Jlc3NMYW5lcz1jb21taXR0ZWRMYW5lcztpblByb2dyZXNzUm9vdD1yb290O3NldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO2NvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLHJvb3QpO3NldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO2luUHJvZ3Jlc3NMYW5lcz1udWxsO2luUHJvZ3Jlc3NSb290PW51bGw7fWZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxwYXJlbnRGaWJlcixsYW5lcyl7Ly8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuLy8gYmVmb3JlIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhZSBmaXJlZC5cbnZhciBkZWxldGlvbnM9cGFyZW50RmliZXIuZGVsZXRpb25zO2lmKGRlbGV0aW9ucyE9PW51bGwpe2Zvcih2YXIgaT0wO2k8ZGVsZXRpb25zLmxlbmd0aDtpKyspe3ZhciBjaGlsZFRvRGVsZXRlPWRlbGV0aW9uc1tpXTt0cnl7Y29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QscGFyZW50RmliZXIsY2hpbGRUb0RlbGV0ZSk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLHBhcmVudEZpYmVyLGVycm9yKTt9fX12YXIgcHJldkRlYnVnRmliZXI9Z2V0Q3VycmVudEZpYmVyKCk7aWYocGFyZW50RmliZXIuc3VidHJlZUZsYWdzJk11dGF0aW9uTWFzayl7dmFyIGNoaWxkPXBhcmVudEZpYmVyLmNoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7c2V0Q3VycmVudEZpYmVyKGNoaWxkKTtjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGNoaWxkLHJvb3QpO2NoaWxkPWNoaWxkLnNpYmxpbmc7fX1zZXRDdXJyZW50RmliZXIocHJldkRlYnVnRmliZXIpO31mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yayxyb290LGxhbmVzKXt2YXIgY3VycmVudD1maW5pc2hlZFdvcmsuYWx0ZXJuYXRlO3ZhciBmbGFncz1maW5pc2hlZFdvcmsuZmxhZ3M7Ly8gVGhlIGVmZmVjdCBmbGFnIHNob3VsZCBiZSBjaGVja2VkICphZnRlciogd2UgcmVmaW5lIHRoZSB0eXBlIG9mIGZpYmVyLFxuLy8gYmVjYXVzZSB0aGUgZmliZXIgdGFnIGlzIG1vcmUgc3BlY2lmaWMuIEFuIGV4Y2VwdGlvbiBpcyBhbnkgZmxhZyByZWxhdGVkXG4vLyB0byByZWNvbmNpbGF0aW9uLCBiZWNhdXNlIHRob3NlIGNhbiBiZSBzZXQgb24gYWxsIGZpYmVyIHR5cGVzLlxuc3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgTWVtb0NvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlVwZGF0ZSl7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChJbnNlcnRpb258SGFzRWZmZWN0LGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuKTtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbnxIYXNFZmZlY3QsZmluaXNoZWRXb3JrKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9Ly8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4vLyBkZXN0cm95IGZ1bmN0aW9ucyBmb3IgYWxsIGZpYmVycyBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgY3JlYXRlIGZ1bmN0aW9ucy5cbi8vIFRoaXMgcHJldmVudHMgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbi8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbmlmKGZpbmlzaGVkV29yay5tb2RlJlByb2ZpbGVNb2RlKXt0cnl7c3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXR8SGFzRWZmZWN0LGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9cmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTt9ZWxzZXt0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dHxIYXNFZmZlY3QsZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4pO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319fXJldHVybjt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7aWYoZmxhZ3MmUmVmKXtpZihjdXJyZW50IT09bnVsbCl7c2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsY3VycmVudC5yZXR1cm4pO319cmV0dXJuO31jYXNlIEhvc3RDb21wb25lbnQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlJlZil7aWYoY3VycmVudCE9PW51bGwpe3NhZmVseURldGFjaFJlZihjdXJyZW50LGN1cnJlbnQucmV0dXJuKTt9fXsvLyBUT0RPOiBDb250ZW50UmVzZXQgZ2V0cyBjbGVhcmVkIGJ5IHRoZSBjaGlsZHJlbiBkdXJpbmcgdGhlIGNvbW1pdFxuLy8gcGhhc2UuIFRoaXMgaXMgYSByZWZhY3RvciBoYXphcmQgYmVjYXVzZSBpdCBtZWFucyB3ZSBtdXN0IHJlYWRcbi8vIGZsYWdzIHRoZSBmbGFncyBhZnRlciBgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzYCBoYXMgYWxyZWFkeSBydW47XG4vLyB0aGUgb3JkZXIgbWF0dGVycy4gV2Ugc2hvdWxkIHJlZmFjdG9yIHNvIHRoYXQgQ29udGVudFJlc2V0IGRvZXMgbm90XG4vLyByZWx5IG9uIG11dGF0aW5nIHRoZSBmbGFnIGR1cmluZyBjb21taXQuIExpa2UgYnkgc2V0dGluZyBhIGZsYWdcbi8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIGluc3RlYWQuXG5pZihmaW5pc2hlZFdvcmsuZmxhZ3MmQ29udGVudFJlc2V0KXt2YXIgaW5zdGFuY2U9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTt0cnl7cmVzZXRUZXh0Q29udGVudChpbnN0YW5jZSk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fX1pZihmbGFncyZVcGRhdGUpe3ZhciBfaW5zdGFuY2U0PWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7aWYoX2luc3RhbmNlNCE9bnVsbCl7Ly8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG52YXIgbmV3UHJvcHM9ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7Ly8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4vLyB0aGlzIGNhc2UuXG52YXIgb2xkUHJvcHM9Y3VycmVudCE9PW51bGw/Y3VycmVudC5tZW1vaXplZFByb3BzOm5ld1Byb3BzO3ZhciB0eXBlPWZpbmlzaGVkV29yay50eXBlOy8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbnZhciB1cGRhdGVQYXlsb2FkPWZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU9bnVsbDtpZih1cGRhdGVQYXlsb2FkIT09bnVsbCl7dHJ5e2NvbW1pdFVwZGF0ZShfaW5zdGFuY2U0LHVwZGF0ZVBheWxvYWQsdHlwZSxvbGRQcm9wcyxuZXdQcm9wcyxmaW5pc2hlZFdvcmspO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319fX19cmV0dXJuO31jYXNlIEhvc3RUZXh0OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZVcGRhdGUpe3tpZihmaW5pc2hlZFdvcmsuc3RhdGVOb2RlPT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnKydjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO312YXIgdGV4dEluc3RhbmNlPWZpbmlzaGVkV29yay5zdGF0ZU5vZGU7dmFyIG5ld1RleHQ9ZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7Ly8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4vLyB0aGlzIGNhc2UuXG52YXIgb2xkVGV4dD1jdXJyZW50IT09bnVsbD9jdXJyZW50Lm1lbW9pemVkUHJvcHM6bmV3VGV4dDt0cnl7Y29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2Usb2xkVGV4dCxuZXdUZXh0KTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuLGVycm9yKTt9fX1yZXR1cm47fWNhc2UgSG9zdFJvb3Q6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlVwZGF0ZSl7e2lmKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJldlJvb3RTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7aWYocHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpe3RyeXtjb21taXRIeWRyYXRlZENvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO319fX19cmV0dXJuO31jYXNlIEhvc3RQb3J0YWw6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO3JldHVybjt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7Y29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7dmFyIG9mZnNjcmVlbkZpYmVyPWZpbmlzaGVkV29yay5jaGlsZDtpZihvZmZzY3JlZW5GaWJlci5mbGFncyZWaXNpYmlsaXR5KXt2YXIgb2Zmc2NyZWVuSW5zdGFuY2U9b2Zmc2NyZWVuRmliZXIuc3RhdGVOb2RlO3ZhciBuZXdTdGF0ZT1vZmZzY3JlZW5GaWJlci5tZW1vaXplZFN0YXRlO3ZhciBpc0hpZGRlbj1uZXdTdGF0ZSE9PW51bGw7Ly8gVHJhY2sgdGhlIGN1cnJlbnQgc3RhdGUgb24gdGhlIE9mZnNjcmVlbiBpbnN0YW5jZSBzbyB3ZSBjYW5cbi8vIHJlYWQgaXQgZHVyaW5nIGFuIGV2ZW50XG5vZmZzY3JlZW5JbnN0YW5jZS5pc0hpZGRlbj1pc0hpZGRlbjtpZihpc0hpZGRlbil7dmFyIHdhc0hpZGRlbj1vZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUhPT1udWxsJiZvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSE9PW51bGw7aWYoIXdhc0hpZGRlbil7Ly8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG5tYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKTt9fX1pZihmbGFncyZVcGRhdGUpe3RyeXtjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yayk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssZmluaXNoZWRXb3JrLnJldHVybixlcnJvcik7fWF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTt9cmV0dXJuO31jYXNlIE9mZnNjcmVlbkNvbXBvbmVudDp7dmFyIF93YXNIaWRkZW49Y3VycmVudCE9PW51bGwmJmN1cnJlbnQubWVtb2l6ZWRTdGF0ZSE9PW51bGw7aWYoLy8gVE9ETzogUmVtb3ZlIHRoaXMgZGVhZCBmbGFnXG5maW5pc2hlZFdvcmsubW9kZSZDb25jdXJyZW50TW9kZSl7Ly8gQmVmb3JlIGNvbW1pdHRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayBvbiB0aGUgc3RhY2sgd2hldGhlciB0aGlzXG4vLyBvZmZzY3JlZW4gc3VidHJlZSB3YXMgYWxyZWFkeSBoaWRkZW4sIHNvIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVcbi8vIGVmZmVjdHMgYWdhaW4uXG52YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVufHxfd2FzSGlkZGVuO3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO29mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW49cHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47fWVsc2V7cmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LGZpbmlzaGVkV29yayk7fWNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO2lmKGZsYWdzJlZpc2liaWxpdHkpe3ZhciBfb2Zmc2NyZWVuSW5zdGFuY2U9ZmluaXNoZWRXb3JrLnN0YXRlTm9kZTt2YXIgX25ld1N0YXRlPWZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO3ZhciBfaXNIaWRkZW49X25ld1N0YXRlIT09bnVsbDt2YXIgb2Zmc2NyZWVuQm91bmRhcnk9ZmluaXNoZWRXb3JrOy8vIFRyYWNrIHRoZSBjdXJyZW50IHN0YXRlIG9uIHRoZSBPZmZzY3JlZW4gaW5zdGFuY2Ugc28gd2UgY2FuXG4vLyByZWFkIGl0IGR1cmluZyBhbiBldmVudFxuX29mZnNjcmVlbkluc3RhbmNlLmlzSGlkZGVuPV9pc0hpZGRlbjt7aWYoX2lzSGlkZGVuKXtpZighX3dhc0hpZGRlbil7aWYoKG9mZnNjcmVlbkJvdW5kYXJ5Lm1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlKXtuZXh0RWZmZWN0PW9mZnNjcmVlbkJvdW5kYXJ5O3ZhciBvZmZzY3JlZW5DaGlsZD1vZmZzY3JlZW5Cb3VuZGFyeS5jaGlsZDt3aGlsZShvZmZzY3JlZW5DaGlsZCE9PW51bGwpe25leHRFZmZlY3Q9b2Zmc2NyZWVuQ2hpbGQ7ZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihvZmZzY3JlZW5DaGlsZCk7b2Zmc2NyZWVuQ2hpbGQ9b2Zmc2NyZWVuQ2hpbGQuc2libGluZzt9fX19fXsvLyBUT0RPOiBUaGlzIG5lZWRzIHRvIHJ1biB3aGVuZXZlciB0aGVyZSdzIGFuIGluc2VydGlvbiBvciB1cGRhdGVcbi8vIGluc2lkZSBhIGhpZGRlbiBPZmZzY3JlZW4gdHJlZS5cbmhpZGVPclVuaGlkZUFsbENoaWxkcmVuKG9mZnNjcmVlbkJvdW5kYXJ5LF9pc0hpZGRlbik7fX1yZXR1cm47fWNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OntyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTtjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtpZihmbGFncyZVcGRhdGUpe2F0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTt9cmV0dXJuO31jYXNlIFNjb3BlQ29tcG9uZW50OntyZXR1cm47fWRlZmF1bHQ6e3JlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCxmaW5pc2hlZFdvcmspO2NvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO3JldHVybjt9fX1mdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKXsvLyBQbGFjZW1lbnQgZWZmZWN0cyAoaW5zZXJ0aW9ucywgcmVvcmRlcnMpIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyXG4vLyB0eXBlLiBUaGV5IG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLCBidXRcbi8vIGJlZm9yZSB0aGUgZWZmZWN0cyBvbiB0aGlzIGZpYmVyIGhhdmUgZmlyZWQuXG52YXIgZmxhZ3M9ZmluaXNoZWRXb3JrLmZsYWdzO2lmKGZsYWdzJlBsYWNlbWVudCl7dHJ5e2NvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4sZXJyb3IpO30vLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbi8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWQgZG9lc1xuLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5maW5pc2hlZFdvcmsuZmxhZ3MmPX5QbGFjZW1lbnQ7fWlmKGZsYWdzJkh5ZHJhdGluZyl7ZmluaXNoZWRXb3JrLmZsYWdzJj1+SHlkcmF0aW5nO319ZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmsscm9vdCxjb21taXR0ZWRMYW5lcyl7aW5Qcm9ncmVzc0xhbmVzPWNvbW1pdHRlZExhbmVzO2luUHJvZ3Jlc3NSb290PXJvb3Q7bmV4dEVmZmVjdD1maW5pc2hlZFdvcms7Y29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmsscm9vdCxjb21taXR0ZWRMYW5lcyk7aW5Qcm9ncmVzc0xhbmVzPW51bGw7aW5Qcm9ncmVzc1Jvb3Q9bnVsbDt9ZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzKXsvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG52YXIgaXNNb2Rlcm5Sb290PShzdWJ0cmVlUm9vdC5tb2RlJkNvbmN1cnJlbnRNb2RlKSE9PU5vTW9kZTt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7dmFyIGZpcnN0Q2hpbGQ9ZmliZXIuY2hpbGQ7aWYoZmliZXIudGFnPT09T2Zmc2NyZWVuQ29tcG9uZW50JiZpc01vZGVyblJvb3Qpey8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG52YXIgaXNIaWRkZW49ZmliZXIubWVtb2l6ZWRTdGF0ZSE9PW51bGw7dmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbj1pc0hpZGRlbnx8b2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO2lmKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbil7Ly8gVGhlIE9mZnNjcmVlbiB0cmVlIGlzIGhpZGRlbi4gU2tpcCBvdmVyIGl0cyBsYXlvdXQgZWZmZWN0cy5cbmNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzKTtjb250aW51ZTt9ZWxzZXsvLyBUT0RPIChPZmZzY3JlZW4pIEFsc28gY2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dE1hc2tcbnZhciBjdXJyZW50PWZpYmVyLmFsdGVybmF0ZTt2YXIgd2FzSGlkZGVuPWN1cnJlbnQhPT1udWxsJiZjdXJyZW50Lm1lbW9pemVkU3RhdGUhPT1udWxsO3ZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPXdhc0hpZGRlbnx8b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjt2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbj1vZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47dmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47Ly8gVHJhdmVyc2UgdGhlIE9mZnNjcmVlbiBzdWJ0cmVlIHdpdGggdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIGFzIHRoZSByb290Llxub2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuPW5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuPW5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47aWYob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiYmIXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKXsvLyBUaGlzIGlzIHRoZSByb290IG9mIGEgcmVhcHBlYXJpbmcgYm91bmRhcnkuIFR1cm4gaXRzIGxheW91dCBlZmZlY3RzXG4vLyBiYWNrIG9uLlxubmV4dEVmZmVjdD1maWJlcjtyZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oZmliZXIpO312YXIgY2hpbGQ9Zmlyc3RDaGlsZDt3aGlsZShjaGlsZCE9PW51bGwpe25leHRFZmZlY3Q9Y2hpbGQ7Y29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihjaGlsZCwvLyBOZXcgcm9vdDsgYnViYmxlIGJhY2sgdXAgdG8gaGVyZSBhbmQgc3RvcC5cbnJvb3QsY29tbWl0dGVkTGFuZXMpO2NoaWxkPWNoaWxkLnNpYmxpbmc7fS8vIFJlc3RvcmUgT2Zmc2NyZWVuIHN0YXRlIGFuZCByZXN1bWUgaW4gb3VyLXByb2dyZXNzIHRyYXZlcnNhbC5cbm5leHRFZmZlY3Q9ZmliZXI7b2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuPXByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47b2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbj1wcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyk7Y29udGludWU7fX1pZigoZmliZXIuc3VidHJlZUZsYWdzJkxheW91dE1hc2spIT09Tm9GbGFncyYmZmlyc3RDaGlsZCE9PW51bGwpe2ZpcnN0Q2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Zmlyc3RDaGlsZDt9ZWxzZXtjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyk7fX19ZnVuY3Rpb24gY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LHJvb3QsY29tbWl0dGVkTGFuZXMpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDtpZigoZmliZXIuZmxhZ3MmTGF5b3V0TWFzaykhPT1Ob0ZsYWdzKXt2YXIgY3VycmVudD1maWJlci5hbHRlcm5hdGU7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTt0cnl7Y29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LGN1cnJlbnQsZmliZXIsY29tbWl0dGVkTGFuZXMpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9cmVzZXRDdXJyZW50RmliZXIoKTt9aWYoZmliZXI9PT1zdWJ0cmVlUm9vdCl7bmV4dEVmZmVjdD1udWxsO3JldHVybjt9dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7c2libGluZy5yZXR1cm49ZmliZXIucmV0dXJuO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9ZmliZXIucmV0dXJuO319ZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3ZhciBmaXJzdENoaWxkPWZpYmVyLmNoaWxkOy8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcbnN3aXRjaChmaWJlci50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgTWVtb0NvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKGZpYmVyLm1vZGUmUHJvZmlsZU1vZGUpe3RyeXtzdGFydExheW91dEVmZmVjdFRpbWVyKCk7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCxmaWJlcixmaWJlci5yZXR1cm4pO31maW5hbGx5e3JlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpYmVyKTt9fWVsc2V7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCxmaWJlcixmaWJlci5yZXR1cm4pO31icmVhazt9Y2FzZSBDbGFzc0NvbXBvbmVudDp7Ly8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBSZWZTdGF0aWNcbnNhZmVseURldGFjaFJlZihmaWJlcixmaWJlci5yZXR1cm4pO3ZhciBpbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7aWYodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50PT09J2Z1bmN0aW9uJyl7c2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGZpYmVyLGZpYmVyLnJldHVybixpbnN0YW5jZSk7fWJyZWFrO31jYXNlIEhvc3RDb21wb25lbnQ6e3NhZmVseURldGFjaFJlZihmaWJlcixmaWJlci5yZXR1cm4pO2JyZWFrO31jYXNlIE9mZnNjcmVlbkNvbXBvbmVudDp7Ly8gQ2hlY2sgaWYgdGhpcyBpcyBhXG52YXIgaXNIaWRkZW49ZmliZXIubWVtb2l6ZWRTdGF0ZSE9PW51bGw7aWYoaXNIaWRkZW4pey8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBhbHJlYWR5IGhpZGRlbi4gRG9uJ3QgZGlzYXBwZWFyXG4vLyBpdHMgZWZmZWN0cy5cbmRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO2NvbnRpbnVlO31icmVhazt9fS8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuaWYoZmlyc3RDaGlsZCE9PW51bGwpe2ZpcnN0Q2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Zmlyc3RDaGlsZDt9ZWxzZXtkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTt9fX1mdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7aWYoZmliZXI9PT1zdWJ0cmVlUm9vdCl7bmV4dEVmZmVjdD1udWxsO3JldHVybjt9dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7c2libGluZy5yZXR1cm49ZmliZXIucmV0dXJuO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9ZmliZXIucmV0dXJuO319ZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290KXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7dmFyIGZpcnN0Q2hpbGQ9ZmliZXIuY2hpbGQ7aWYoZmliZXIudGFnPT09T2Zmc2NyZWVuQ29tcG9uZW50KXt2YXIgaXNIaWRkZW49ZmliZXIubWVtb2l6ZWRTdGF0ZSE9PW51bGw7aWYoaXNIaWRkZW4pey8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBzdGlsbCBoaWRkZW4uIERvbid0IHJlLWFwcGVhciBpdHMgZWZmZWN0cy5cbnJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7Y29udGludWU7fX0vLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRTdGF0aWNcbmlmKGZpcnN0Q2hpbGQhPT1udWxsKXsvLyBUaGlzIG5vZGUgbWF5IGhhdmUgYmVlbiByZXVzZWQgZnJvbSBhIHByZXZpb3VzIHJlbmRlciwgc28gd2UgY2FuJ3Rcbi8vIGFzc3VtZSBpdHMgcmV0dXJuIHBvaW50ZXIgaXMgY29ycmVjdC5cbmZpcnN0Q2hpbGQucmV0dXJuPWZpYmVyO25leHRFZmZlY3Q9Zmlyc3RDaGlsZDt9ZWxzZXtyZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO319fWZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0Oy8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG5zZXRDdXJyZW50RmliZXIoZmliZXIpO3RyeXtyZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyKGZpYmVyKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fXJlc2V0Q3VycmVudEZpYmVyKCk7aWYoZmliZXI9PT1zdWJ0cmVlUm9vdCl7bmV4dEVmZmVjdD1udWxsO3JldHVybjt9dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7Ly8gVGhpcyBub2RlIG1heSBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIsIHNvIHdlIGNhbid0XG4vLyBhc3N1bWUgaXRzIHJldHVybiBwb2ludGVyIGlzIGNvcnJlY3QuXG5zaWJsaW5nLnJldHVybj1maWJlci5yZXR1cm47bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1maWJlci5yZXR1cm47fX1mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrLGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKXtuZXh0RWZmZWN0PWZpbmlzaGVkV29yaztjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2JlZ2luKGZpbmlzaGVkV29yayxyb290LGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKTt9ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7dmFyIGZpcnN0Q2hpbGQ9ZmliZXIuY2hpbGQ7aWYoKGZpYmVyLnN1YnRyZWVGbGFncyZQYXNzaXZlTWFzaykhPT1Ob0ZsYWdzJiZmaXJzdENoaWxkIT09bnVsbCl7Zmlyc3RDaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1maXJzdENoaWxkO31lbHNle2NvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3Qscm9vdCxjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyk7fX19ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCxyb290LGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKXt3aGlsZShuZXh0RWZmZWN0IT09bnVsbCl7dmFyIGZpYmVyPW5leHRFZmZlY3Q7aWYoKGZpYmVyLmZsYWdzJlBhc3NpdmUpIT09Tm9GbGFncyl7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTt0cnl7Y29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihyb290LGZpYmVyLGNvbW1pdHRlZExhbmVzLGNvbW1pdHRlZFRyYW5zaXRpb25zKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fXJlc2V0Q3VycmVudEZpYmVyKCk7fWlmKGZpYmVyPT09c3VidHJlZVJvb3Qpe25leHRFZmZlY3Q9bnVsbDtyZXR1cm47fXZhciBzaWJsaW5nPWZpYmVyLnNpYmxpbmc7aWYoc2libGluZyE9PW51bGwpe3NpYmxpbmcucmV0dXJuPWZpYmVyLnJldHVybjtuZXh0RWZmZWN0PXNpYmxpbmc7cmV0dXJuO31uZXh0RWZmZWN0PWZpYmVyLnJldHVybjt9fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoZmluaXNoZWRSb290LGZpbmlzaGVkV29yayxjb21taXR0ZWRMYW5lcyxjb21taXR0ZWRUcmFuc2l0aW9ucyl7c3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3N0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7dHJ5e2NvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxfEhhc0VmZmVjdCxmaW5pc2hlZFdvcmspO31maW5hbGx5e3JlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO319ZWxzZXtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KFBhc3NpdmUkMXxIYXNFZmZlY3QsZmluaXNoZWRXb3JrKTt9YnJlYWs7fX19ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpcnN0Q2hpbGQpe25leHRFZmZlY3Q9Zmlyc3RDaGlsZDtjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfYmVnaW4oKTt9ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luKCl7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0O3ZhciBjaGlsZD1maWJlci5jaGlsZDtpZigobmV4dEVmZmVjdC5mbGFncyZDaGlsZERlbGV0aW9uKSE9PU5vRmxhZ3Mpe3ZhciBkZWxldGlvbnM9ZmliZXIuZGVsZXRpb25zO2lmKGRlbGV0aW9ucyE9PW51bGwpe2Zvcih2YXIgaT0wO2k8ZGVsZXRpb25zLmxlbmd0aDtpKyspe3ZhciBmaWJlclRvRGVsZXRlPWRlbGV0aW9uc1tpXTtuZXh0RWZmZWN0PWZpYmVyVG9EZWxldGU7Y29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihmaWJlclRvRGVsZXRlLGZpYmVyKTt9ey8vIEEgZmliZXIgd2FzIGRlbGV0ZWQgZnJvbSB0aGlzIHBhcmVudCBmaWJlciwgYnV0IGl0J3Mgc3RpbGwgcGFydCBvZlxuLy8gdGhlIHByZXZpb3VzIChhbHRlcm5hdGUpIHBhcmVudCBmaWJlcidzIGxpc3Qgb2YgY2hpbGRyZW4uIEJlY2F1c2Vcbi8vIGNoaWxkcmVuIGFyZSBhIGxpbmtlZCBsaXN0LCBhbiBlYXJsaWVyIHNpYmxpbmcgdGhhdCdzIHN0aWxsIGFsaXZlXG4vLyB3aWxsIGJlIGNvbm5lY3RlZCB0byB0aGUgZGVsZXRlZCBmaWJlciB2aWEgaXRzIGBhbHRlcm5hdGVgOlxuLy9cbi8vICAgbGl2ZSBmaWJlclxuLy8gICAtLWFsdGVybmF0ZS0tPiBwcmV2aW91cyBsaXZlIGZpYmVyXG4vLyAgIC0tc2libGluZy0tPiBkZWxldGVkIGZpYmVyXG4vL1xuLy8gV2UgY2FuJ3QgZGlzY29ubmVjdCBgYWx0ZXJuYXRlYCBvbiBub2RlcyB0aGF0IGhhdmVuJ3QgYmVlbiBkZWxldGVkXG4vLyB5ZXQsIGJ1dCB3ZSBjYW4gZGlzY29ubmVjdCB0aGUgYHNpYmxpbmdgIGFuZCBgY2hpbGRgIHBvaW50ZXJzLlxudmFyIHByZXZpb3VzRmliZXI9ZmliZXIuYWx0ZXJuYXRlO2lmKHByZXZpb3VzRmliZXIhPT1udWxsKXt2YXIgZGV0YWNoZWRDaGlsZD1wcmV2aW91c0ZpYmVyLmNoaWxkO2lmKGRldGFjaGVkQ2hpbGQhPT1udWxsKXtwcmV2aW91c0ZpYmVyLmNoaWxkPW51bGw7ZG97dmFyIGRldGFjaGVkU2libGluZz1kZXRhY2hlZENoaWxkLnNpYmxpbmc7ZGV0YWNoZWRDaGlsZC5zaWJsaW5nPW51bGw7ZGV0YWNoZWRDaGlsZD1kZXRhY2hlZFNpYmxpbmc7fXdoaWxlKGRldGFjaGVkQ2hpbGQhPT1udWxsKTt9fX1uZXh0RWZmZWN0PWZpYmVyO319aWYoKGZpYmVyLnN1YnRyZWVGbGFncyZQYXNzaXZlTWFzaykhPT1Ob0ZsYWdzJiZjaGlsZCE9PW51bGwpe2NoaWxkLnJldHVybj1maWJlcjtuZXh0RWZmZWN0PWNoaWxkO31lbHNle2NvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO319fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDtpZigoZmliZXIuZmxhZ3MmUGFzc2l2ZSkhPT1Ob0ZsYWdzKXtzZXRDdXJyZW50RmliZXIoZmliZXIpO2NvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7cmVzZXRDdXJyZW50RmliZXIoKTt9dmFyIHNpYmxpbmc9ZmliZXIuc2libGluZztpZihzaWJsaW5nIT09bnVsbCl7c2libGluZy5yZXR1cm49ZmliZXIucmV0dXJuO25leHRFZmZlY3Q9c2libGluZztyZXR1cm47fW5leHRFZmZlY3Q9ZmliZXIucmV0dXJuO319ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yayl7c3dpdGNoKGZpbmlzaGVkV29yay50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7aWYoZmluaXNoZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpe3N0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMXxIYXNFZmZlY3QsZmluaXNoZWRXb3JrLGZpbmlzaGVkV29yay5yZXR1cm4pO3JlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO31lbHNle2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDF8SGFzRWZmZWN0LGZpbmlzaGVkV29yayxmaW5pc2hlZFdvcmsucmV0dXJuKTt9YnJlYWs7fX19ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihkZWxldGVkU3VidHJlZVJvb3QsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcil7d2hpbGUobmV4dEVmZmVjdCE9PW51bGwpe3ZhciBmaWJlcj1uZXh0RWZmZWN0Oy8vIERlbGV0aW9uIGVmZmVjdHMgZmlyZSBpbiBwYXJlbnQgLT4gY2hpbGQgb3JkZXJcbi8vIFRPRE86IENoZWNrIGlmIGZpYmVyIGhhcyBhIFBhc3NpdmVTdGF0aWMgZmxhZ1xuc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcihmaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtyZXNldEN1cnJlbnRGaWJlcigpO3ZhciBjaGlsZD1maWJlci5jaGlsZDsvLyBUT0RPOiBPbmx5IHRyYXZlcnNlIHN1YnRyZWUgaWYgaXQgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnLiAoQnV0LCBpZiB3ZVxuLy8gZG8gdGhpcywgc3RpbGwgbmVlZCB0byBoYW5kbGUgYGRlbGV0ZWRUcmVlQ2xlYW5VcExldmVsYCBjb3JyZWN0bHkuKVxuaWYoY2hpbGQhPT1udWxsKXtjaGlsZC5yZXR1cm49ZmliZXI7bmV4dEVmZmVjdD1jaGlsZDt9ZWxzZXtjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCk7fX19ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3Qpe3doaWxlKG5leHRFZmZlY3QhPT1udWxsKXt2YXIgZmliZXI9bmV4dEVmZmVjdDt2YXIgc2libGluZz1maWJlci5zaWJsaW5nO3ZhciByZXR1cm5GaWJlcj1maWJlci5yZXR1cm47ey8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgZGVsZXRlZCB0cmVlIGFuZCBjbGVhbiB1cCBmaWJlciBmaWVsZHMuXG4vLyBUaGlzIGlzIG1vcmUgYWdncmVzc2l2ZSB0aGFuIGlkZWFsLCBhbmQgdGhlIGxvbmcgdGVybSBnb2FsIGlzIHRvIG9ubHlcbi8vIGhhdmUgdG8gZGV0YWNoIHRoZSBkZWxldGVkIHRyZWUgYXQgdGhlIHJvb3QuXG5kZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcik7aWYoZmliZXI9PT1kZWxldGVkU3VidHJlZVJvb3Qpe25leHRFZmZlY3Q9bnVsbDtyZXR1cm47fX1pZihzaWJsaW5nIT09bnVsbCl7c2libGluZy5yZXR1cm49cmV0dXJuRmliZXI7bmV4dEVmZmVjdD1zaWJsaW5nO3JldHVybjt9bmV4dEVmZmVjdD1yZXR1cm5GaWJlcjt9fWZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcil7c3dpdGNoKGN1cnJlbnQudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKGN1cnJlbnQubW9kZSZQcm9maWxlTW9kZSl7c3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxLGN1cnJlbnQsbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7cmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO31lbHNle2NvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsY3VycmVudCxuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTt9YnJlYWs7fX19Ly8gVE9ETzogUmV1c2UgcmVhcHBlYXJMYXlvdXRFZmZlY3RzIHRyYXZlcnNhbCBoZXJlP1xuZnVuY3Rpb24gaW52b2tlTGF5b3V0RWZmZWN0TW91bnRJbkRFVihmaWJlcil7ey8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG5zd2l0Y2goZmliZXIudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3RyeXtjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dHxIYXNFZmZlY3QsZmliZXIpO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9YnJlYWs7fWNhc2UgQ2xhc3NDb21wb25lbnQ6e3ZhciBpbnN0YW5jZT1maWJlci5zdGF0ZU5vZGU7dHJ5e2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7fWNhdGNoKGVycm9yKXtjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlcixmaWJlci5yZXR1cm4sZXJyb3IpO31icmVhazt9fX19ZnVuY3Rpb24gaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYoZmliZXIpe3svLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuc3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50Ont0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDF8SGFzRWZmZWN0LGZpYmVyKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fWJyZWFrO319fX1mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpe3svLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuc3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIEZvcndhcmRSZWY6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50Ont0cnl7Y29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dHxIYXNFZmZlY3QsZmliZXIsZmliZXIucmV0dXJuKTt9Y2F0Y2goZXJyb3Ipe2NhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLGZpYmVyLnJldHVybixlcnJvcik7fWJyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50Ont2YXIgaW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO2lmKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudD09PSdmdW5jdGlvbicpe3NhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChmaWJlcixmaWJlci5yZXR1cm4saW5zdGFuY2UpO31icmVhazt9fX19ZnVuY3Rpb24gaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFVihmaWJlcil7ey8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG5zd2l0Y2goZmliZXIudGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgRm9yd2FyZFJlZjpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e3RyeXtjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxfEhhc0VmZmVjdCxmaWJlcixmaWJlci5yZXR1cm4pO31jYXRjaChlcnJvcil7Y2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsZmliZXIucmV0dXJuLGVycm9yKTt9fX19fXZhciBDT01QT05FTlRfVFlQRT0wO3ZhciBIQVNfUFNFVURPX0NMQVNTX1RZUEU9MTt2YXIgUk9MRV9UWVBFPTI7dmFyIFRFU1RfTkFNRV9UWVBFPTM7dmFyIFRFWFRfVFlQRT00O2lmKHR5cGVvZiBTeW1ib2w9PT0nZnVuY3Rpb24nJiZTeW1ib2wuZm9yKXt2YXIgc3ltYm9sRm9yPVN5bWJvbC5mb3I7Q09NUE9ORU5UX1RZUEU9c3ltYm9sRm9yKCdzZWxlY3Rvci5jb21wb25lbnQnKTtIQVNfUFNFVURPX0NMQVNTX1RZUEU9c3ltYm9sRm9yKCdzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzJyk7Uk9MRV9UWVBFPXN5bWJvbEZvcignc2VsZWN0b3Iucm9sZScpO1RFU1RfTkFNRV9UWVBFPXN5bWJvbEZvcignc2VsZWN0b3IudGVzdF9pZCcpO1RFWFRfVFlQRT1zeW1ib2xGb3IoJ3NlbGVjdG9yLnRleHQnKTt9dmFyIGNvbW1pdEhvb2tzPVtdO2Z1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCl7e2NvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24oY29tbWl0SG9vayl7cmV0dXJuIGNvbW1pdEhvb2soKTt9KTt9fXZhciBSZWFjdEN1cnJlbnRBY3RRdWV1ZT1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTtmdW5jdGlvbiBpc0xlZ2FjeUFjdEVudmlyb25tZW50KGZpYmVyKXt7Ly8gTGVnYWN5IG1vZGUuIFdlIHByZXNlcnZlIHRoZSBiZWhhdmlvciBvZiBSZWFjdCAxNydzIGFjdC4gSXQgYXNzdW1lcyBhblxuLy8gYWN0IGVudmlyb25tZW50IHdoZW5ldmVyIGBqZXN0YCBpcyBkZWZpbmVkLCBidXQgeW91IGNhbiBzdGlsbCB0dXJuIG9mZlxuLy8gc3B1cmlvdXMgd2FybmluZ3MgYnkgc2V0dGluZyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZXhwbGljaXRseVxuLy8gdG8gZmFsc2UuXG52YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsPS8vICRGbG93RXhwZWN0ZWRFcnJvciDigJMgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGdsb2JhbFxudHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCE9PSd1bmRlZmluZWQnP0lTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVDp1bmRlZmluZWQ7Ly8gJEZsb3dFeHBlY3RlZEVycm9yIC0gRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgamVzdFxudmFyIGplc3RJc0RlZmluZWQ9dHlwZW9mIGplc3QhPT0ndW5kZWZpbmVkJztyZXR1cm4gamVzdElzRGVmaW5lZCYmaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIT09ZmFsc2U7fX1mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpe3t2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsPS8vICRGbG93RXhwZWN0ZWRFcnJvciDigJMgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGdsb2JhbFxudHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCE9PSd1bmRlZmluZWQnP0lTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVDp1bmRlZmluZWQ7aWYoIWlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCYmUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCE9PW51bGwpey8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG5lcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcrJ2FjdCguLi4pJyk7fXJldHVybiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw7fX12YXIgY2VpbD1NYXRoLmNlaWw7dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMj1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFJlYWN0Q3VycmVudE93bmVyJDI9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXIsUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMz1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxPVJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEFjdFF1ZXVlO3ZhciBOb0NvbnRleHQ9LyogICAgICAgICAgICAgKi8wO3ZhciBCYXRjaGVkQ29udGV4dD0vKiAgICAgICAgICAgICAgICovMTt2YXIgUmVuZGVyQ29udGV4dD0vKiAgICAgICAgICAgICAgICAqLzI7dmFyIENvbW1pdENvbnRleHQ9LyogICAgICAgICAgICAgICAgKi80O3ZhciBSb290SW5Qcm9ncmVzcz0wO3ZhciBSb290RmF0YWxFcnJvcmVkPTE7dmFyIFJvb3RFcnJvcmVkPTI7dmFyIFJvb3RTdXNwZW5kZWQ9Mzt2YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheT00O3ZhciBSb290Q29tcGxldGVkPTU7dmFyIFJvb3REaWROb3RDb21wbGV0ZT02Oy8vIERlc2NyaWJlcyB3aGVyZSB3ZSBhcmUgaW4gdGhlIFJlYWN0IGV4ZWN1dGlvbiBzdGFja1xudmFyIGV4ZWN1dGlvbkNvbnRleHQ9Tm9Db250ZXh0Oy8vIFRoZSByb290IHdlJ3JlIHdvcmtpbmcgb25cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3Q9bnVsbDsvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxudmFyIHdvcmtJblByb2dyZXNzPW51bGw7Ly8gVGhlIGxhbmVzIHdlJ3JlIHJlbmRlcmluZ1xudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzPU5vTGFuZXM7Ly8gU3RhY2sgdGhhdCBhbGxvd3MgY29tcG9uZW50cyB0byBjaGFuZ2UgdGhlIHJlbmRlciBsYW5lcyBmb3IgaXRzIHN1YnRyZWVcbi8vIFRoaXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCB3b3JraW5nIG9uIGF0IHRoZSByb290LiBUaGUgb25seVxuLy8gY2FzZSB3aGVyZSBpdCdzIGRpZmZlcmVudCBmcm9tIGB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc2AgaXMgd2hlbiB3ZVxuLy8gZW50ZXIgYSBzdWJ0cmVlIHRoYXQgaXMgaGlkZGVuIGFuZCBuZWVkcyB0byBiZSB1bmhpZGRlbjogU3VzcGVuc2UgYW5kXG4vLyBPZmZzY3JlZW4gY29tcG9uZW50LlxuLy9cbi8vIE1vc3QgdGhpbmdzIGluIHRoZSB3b3JrIGxvb3Agc2hvdWxkIGRlYWwgd2l0aCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcy5cbi8vIE1vc3QgdGhpbmdzIGluIGJlZ2luL2NvbXBsZXRlIHBoYXNlcyBzaG91bGQgZGVhbCB3aXRoIHN1YnRyZWVSZW5kZXJMYW5lcy5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXM9Tm9MYW5lczt2YXIgc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yPWNyZWF0ZUN1cnNvcihOb0xhbmVzKTsvLyBXaGV0aGVyIHRvIHJvb3QgY29tcGxldGVkLCBlcnJvcmVkLCBzdXNwZW5kZWQsIGV0Yy5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPVJvb3RJblByb2dyZXNzOy8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yPW51bGw7Ly8gXCJJbmNsdWRlZFwiIGxhbmVzIHJlZmVyIHRvIGxhbmVzIHRoYXQgd2VyZSB3b3JrZWQgb24gZHVyaW5nIHRoaXMgcmVuZGVyLiBJdCdzXG4vLyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBgcmVuZGVyTGFuZXNgIGJlY2F1c2UgYHJlbmRlckxhbmVzYCBjYW4gY2hhbmdlIGFzIHlvdVxuLy8gZW50ZXIgYW5kIGV4aXQgYW4gT2Zmc2NyZWVuIHRyZWUuIFRoaXMgdmFsdWUgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIGFsbCByZW5kZXJcbi8vIGxhbmVzIGZvciB0aGUgZW50aXJlIHJlbmRlciBwaGFzZS5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzPU5vTGFuZXM7Ly8gVGhlIHdvcmsgbGVmdCBvdmVyIGJ5IGNvbXBvbmVudHMgdGhhdCB3ZXJlIHZpc2l0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBPbmx5XG4vLyBpbmNsdWRlcyB1bnByb2Nlc3NlZCB1cGRhdGVzLCBub3Qgd29yayBpbiBiYWlsZWQgb3V0IGNoaWxkcmVuLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcz1Ob0xhbmVzOy8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzPU5vTGFuZXM7Ly8gTGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UgKCpub3QqIGFuIGludGVybGVhdmVkIGV2ZW50KS5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcz1Ob0xhbmVzOy8vIEVycm9ycyB0aGF0IGFyZSB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycz1udWxsOy8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzPW51bGw7Ly8gVGhlIG1vc3QgcmVjZW50IHRpbWUgd2UgY29tbWl0dGVkIGEgZmFsbGJhY2suIFRoaXMgbGV0cyB1cyBlbnN1cmUgYSB0cmFpblxuLy8gbW9kZWwgd2hlcmUgd2UgZG9uJ3QgY29tbWl0IG5ldyBsb2FkaW5nIHN0YXRlcyBpbiB0b28gcXVpY2sgc3VjY2Vzc2lvbi5cbnZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lPTA7dmFyIEZBTExCQUNLX1RIUk9UVExFX01TPTUwMDsvLyBUaGUgYWJzb2x1dGUgdGltZSBmb3Igd2hlbiB3ZSBzaG91bGQgc3RhcnQgZ2l2aW5nIHVwIG9uIHJlbmRlcmluZ1xuLy8gbW9yZSBhbmQgcHJlZmVyIENQVSBzdXNwZW5zZSBoZXVyaXN0aWNzIGluc3RlYWQuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZT1JbmZpbml0eTsvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG4vLyBzdXNwZW5zZSBoZXVyaXN0aWNzIGFuZCBvcHQgb3V0IG9mIHJlbmRlcmluZyBtb3JlIGNvbnRlbnQuXG52YXIgUkVOREVSX1RJTUVPVVRfTVM9NTAwO3ZhciB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zPW51bGw7ZnVuY3Rpb24gcmVzZXRSZW5kZXJUaW1lcigpe3dvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWU9bm93KCkrUkVOREVSX1RJTUVPVVRfTVM7fWZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKXtyZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZTt9dmFyIGhhc1VuY2F1Z2h0RXJyb3I9ZmFsc2U7dmFyIGZpcnN0VW5jYXVnaHRFcnJvcj1udWxsO3ZhciBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZD1udWxsOy8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlU2NoZWR1bGVkSG9vayBpcyB0cnVlO1xudmFyIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzPWZhbHNlO3ZhciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cz1udWxsO3ZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcz1Ob0xhbmVzO3ZhciBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cz1bXTt2YXIgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucz1udWxsOy8vIFVzZSB0aGVzZSB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgbmVzdGVkIHVwZGF0ZXNcbnZhciBORVNURURfVVBEQVRFX0xJTUlUPTUwO3ZhciBuZXN0ZWRVcGRhdGVDb3VudD0wO3ZhciByb290V2l0aE5lc3RlZFVwZGF0ZXM9bnVsbDt2YXIgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzPWZhbHNlO3ZhciBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzPWZhbHNlO3ZhciBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQ9NTA7dmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudD0wO3ZhciByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzPW51bGw7Ly8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cbnZhciBjdXJyZW50RXZlbnRUaW1lPU5vVGltZXN0YW1wO3ZhciBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZT1Ob0xhbmVzO3ZhciBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3Q9ZmFsc2U7ZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCl7cmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdDt9ZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpe2lmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKSE9PU5vQ29udGV4dCl7Ly8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG5yZXR1cm4gbm93KCk7fS8vIFdlJ3JlIG5vdCBpbnNpZGUgUmVhY3QsIHNvIHdlIG1heSBiZSBpbiB0aGUgbWlkZGxlIG9mIGEgYnJvd3NlciBldmVudC5cbmlmKGN1cnJlbnRFdmVudFRpbWUhPT1Ob1RpbWVzdGFtcCl7Ly8gVXNlIHRoZSBzYW1lIHN0YXJ0IHRpbWUgZm9yIGFsbCB1cGRhdGVzIHVudGlsIHdlIGVudGVyIFJlYWN0IGFnYWluLlxucmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7fS8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSBzaW5jZSBSZWFjdCB5aWVsZGVkLiBDb21wdXRlIGEgbmV3IHN0YXJ0IHRpbWUuXG5jdXJyZW50RXZlbnRUaW1lPW5vdygpO3JldHVybiBjdXJyZW50RXZlbnRUaW1lO31mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcil7Ly8gU3BlY2lhbCBjYXNlc1xudmFyIG1vZGU9ZmliZXIubW9kZTtpZigobW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe3JldHVybiBTeW5jTGFuZTt9ZWxzZSBpZigoZXhlY3V0aW9uQ29udGV4dCZSZW5kZXJDb250ZXh0KSE9PU5vQ29udGV4dCYmd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMhPT1Ob0xhbmVzKXsvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gVGhlc2UgYXJlIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZC4gVGhlXG4vLyBvbGQgYmVoYXZpb3IgaXMgdG8gZ2l2ZSB0aGlzIHRoZSBzYW1lIFwidGhyZWFkXCIgKGxhbmVzKSBhc1xuLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuLy8gdGhhdCBoYXBwZW5zIGxhdGVyIGluIHRoZSBzYW1lIHJlbmRlciwgaXQgd2lsbCBmbHVzaC4gSWRlYWxseSwgd2Ugd2FudCB0b1xuLy8gcmVtb3ZlIHRoZSBzcGVjaWFsIGNhc2UgYW5kIHRyZWF0IHRoZW0gYXMgaWYgdGhleSBjYW1lIGZyb20gYW5cbi8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuLy8gVGhpcyBiZWhhdmlvciBpcyBvbmx5IGEgZmFsbGJhY2suIFRoZSBmbGFnIG9ubHkgZXhpc3RzIHVudGlsIHdlIGNhbiByb2xsXG4vLyBvdXQgdGhlIHNldFN0YXRlIHdhcm5pbmcsIHNpbmNlIGV4aXN0aW5nIGNvZGUgbWlnaHQgYWNjaWRlbnRhbGx5IHJlbHkgb25cbi8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxucmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTt9dmFyIGlzVHJhbnNpdGlvbj1yZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSE9PU5vVHJhbnNpdGlvbjtpZihpc1RyYW5zaXRpb24pe2lmKFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiE9PW51bGwpe3ZhciB0cmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjtpZighdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyl7dHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycz1uZXcgU2V0KCk7fXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuYWRkKGZpYmVyKTt9Ly8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4vLyB1cGRhdGVzIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGhpbiB0aGUgc2FtZSBldmVudC4gVG8gZG8gdGhpcywgdGhlXG4vLyBpbnB1dHMgdG8gdGhlIGFsZ29yaXRobSBtdXN0IGJlIHRoZSBzYW1lLlxuLy9cbi8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuLy8gZXZlbnQuIFRoZW4gcmVzZXQgdGhlIGNhY2hlZCB2YWx1ZXMgb25jZSB3ZSBjYW4gYmUgc3VyZSB0aGUgZXZlbnQgaXNcbi8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cbmlmKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lPT09Tm9MYW5lKXsvLyBBbGwgdHJhbnNpdGlvbnMgd2l0aGluIHRoZSBzYW1lIGV2ZW50IGFyZSBhc3NpZ25lZCB0aGUgc2FtZSBsYW5lLlxuY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU9Y2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTt9cmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO30vLyBVcGRhdGVzIG9yaWdpbmF0aW5nIGluc2lkZSBjZXJ0YWluIFJlYWN0IG1ldGhvZHMsIGxpa2UgZmx1c2hTeW5jLCBoYXZlXG4vLyB0aGVpciBwcmlvcml0eSBzZXQgYnkgdHJhY2tpbmcgaXQgd2l0aCBhIGNvbnRleHQgdmFyaWFibGUuXG4vL1xuLy8gVGhlIG9wYXF1ZSB0eXBlIHJldHVybmVkIGJ5IHRoZSBob3N0IGNvbmZpZyBpcyBpbnRlcm5hbGx5IGEgbGFuZSwgc28gd2UgY2FuXG4vLyB1c2UgdGhhdCBkaXJlY3RseS5cbi8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cbnZhciB1cGRhdGVMYW5lPWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO2lmKHVwZGF0ZUxhbmUhPT1Ob0xhbmUpe3JldHVybiB1cGRhdGVMYW5lO30vLyBUaGlzIHVwZGF0ZSBvcmlnaW5hdGVkIG91dHNpZGUgUmVhY3QuIEFzayB0aGUgaG9zdCBlbnZpcm9ubWVudCBmb3IgYW5cbi8vIGFwcHJvcHJpYXRlIHByaW9yaXR5LCBiYXNlZCBvbiB0aGUgdHlwZSBvZiBldmVudC5cbi8vXG4vLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbi8vIHVzZSB0aGF0IGRpcmVjdGx5LlxuLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxudmFyIGV2ZW50TGFuZT1nZXRDdXJyZW50RXZlbnRQcmlvcml0eSgpO3JldHVybiBldmVudExhbmU7fWZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpey8vIFRoaXMgaXMgYSBmb3JrIG9mIGByZXF1ZXN0VXBkYXRlTGFuZWAgZGVzaWduZWQgc3BlY2lmaWNhbGx5IGZvciBTdXNwZW5zZVxuLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbi8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuLy8gU3BlY2lhbCBjYXNlc1xudmFyIG1vZGU9ZmliZXIubW9kZTtpZigobW9kZSZDb25jdXJyZW50TW9kZSk9PT1Ob01vZGUpe3JldHVybiBTeW5jTGFuZTt9cmV0dXJuIGNsYWltTmV4dFJldHJ5TGFuZSgpO31mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixsYW5lLGV2ZW50VGltZSl7Y2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7e2lmKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCl7ZXJyb3IoJ3VzZUluc2VydGlvbkVmZmVjdCBtdXN0IG5vdCBzY2hlZHVsZSB1cGRhdGVzLicpO319e2lmKGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyl7ZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cz10cnVlO319Ly8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxubWFya1Jvb3RVcGRhdGVkKHJvb3QsbGFuZSxldmVudFRpbWUpO2lmKChleGVjdXRpb25Db250ZXh0JlJlbmRlckNvbnRleHQpIT09Tm9MYW5lcyYmcm9vdD09PXdvcmtJblByb2dyZXNzUm9vdCl7Ly8gVGhpcyB1cGRhdGUgd2FzIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXMgaXMgYSBtaXN0YWtlXG4vLyBpZiB0aGUgdXBkYXRlIG9yaWdpbmF0ZXMgZnJvbSB1c2VyIHNwYWNlICh3aXRoIHRoZSBleGNlcHRpb24gb2YgbG9jYWxcbi8vIGhvb2sgdXBkYXRlcywgd2hpY2ggYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IHJlYWNoIHRoaXNcbi8vIGZ1bmN0aW9uKSwgYnV0IHRoZXJlIGFyZSBzb21lIGludGVybmFsIFJlYWN0IGZlYXR1cmVzIHRoYXQgdXNlIHRoaXMgYXNcbi8vIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgbGlrZSBzZWxlY3RpdmUgaHlkcmF0aW9uLlxud2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpOy8vIFRyYWNrIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlXG59ZWxzZXsvLyBUaGlzIGlzIGEgbm9ybWFsIHVwZGF0ZSwgc2NoZWR1bGVkIGZyb20gb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLiBGb3Jcbi8vIGV4YW1wbGUsIGR1cmluZyBhbiBpbnB1dCBldmVudC5cbntpZihpc0RldlRvb2xzUHJlc2VudCl7YWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsZmliZXIsbGFuZSk7fX13YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpO2lmKHJvb3Q9PT13b3JrSW5Qcm9ncmVzc1Jvb3Qpey8vIFJlY2VpdmVkIGFuIHVwZGF0ZSB0byBhIHRyZWUgdGhhdCdzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLiBNYXJrXG4vLyB0aGF0IHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCB1cGRhdGUgd29yayBvbiB0aGlzIHJvb3QuIFVubGVzcyB0aGVcbi8vIGBkZWZlclJlbmRlclBoYXNlVXBkYXRlVG9OZXh0QmF0Y2hgIGZsYWcgaXMgb2ZmIGFuZCB0aGlzIGlzIGEgcmVuZGVyXG4vLyBwaGFzZSB1cGRhdGUuIEluIHRoYXQgY2FzZSwgd2UgZG9uJ3QgdHJlYXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXMgaWZcbi8vIHRoZXkgd2VyZSBpbnRlcmxlYXZlZCwgZm9yIGJhY2t3YXJkcyBjb21wYXQgcmVhc29ucy5cbmlmKChleGVjdXRpb25Db250ZXh0JlJlbmRlckNvbnRleHQpPT09Tm9Db250ZXh0KXt3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLGxhbmUpO31pZih3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdFN1c3BlbmRlZFdpdGhEZWxheSl7Ly8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuLy8gZGVmaW5pdGVseSB3b24ndCBmaW5pc2guIFNpbmNlIHdlIGhhdmUgYSBuZXcgdXBkYXRlLCBsZXQncyBtYXJrIGl0IGFzXG4vLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbi8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbi8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGRvZXNuJ3Qgb3ZlcnJpZGUgcGluZ3MgdGhhdCBoYXBwZW4gd2hpbGUgd2UndmVcbi8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG5tYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO319ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsZXZlbnRUaW1lKTtpZihsYW5lPT09U3luY0xhbmUmJmV4ZWN1dGlvbkNvbnRleHQ9PT1Ob0NvbnRleHQmJihmaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKT09PU5vTW9kZSYmLy8gVHJlYXQgYGFjdGAgYXMgaWYgaXQncyBpbnNpZGUgYGJhdGNoZWRVcGRhdGVzYCwgZXZlbiBpbiBsZWdhY3kgbW9kZS5cbiFSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3kpey8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbi8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2Zcbi8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4vLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4vLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxucmVzZXRSZW5kZXJUaW1lcigpO2ZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTt9fX1mdW5jdGlvbiBzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCxsYW5lLGV2ZW50VGltZSl7Ly8gVGhpcyBpcyBhIHNwZWNpYWwgZm9yayBvZiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgdGhhdCBpcyBvbmx5IHVzZWQgdG9cbi8vIHNjaGVkdWxlIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBvZiBhIHJvb3QgdGhhdCBoYXMganVzdCBiZWVuIGNyZWF0ZWQuIE1vc3Rcbi8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4vL1xuLy8gVGhlIG1haW4gcmVhc29uIGZvciB0aGlzIHNlcGFyYXRlIHBhdGgsIHRob3VnaCwgaXMgdG8gZGlzdGluZ3Vpc2ggdGhlXG4vLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbi8vIChjcmVhdGVSb290IGluc3RlYWQgb2YgaHlkcmF0ZVJvb3QpLCBhbGwgdG9wLWxldmVsIHJlbmRlcnMgYXJlIG1vZGVsZWQgYXNcbi8vIHVwZGF0ZXMsIGJ1dCBoeWRyYXRpb24gcm9vdHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgbXVzdFxuLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbnZhciBjdXJyZW50PXJvb3QuY3VycmVudDtjdXJyZW50LmxhbmVzPWxhbmU7bWFya1Jvb3RVcGRhdGVkKHJvb3QsbGFuZSxldmVudFRpbWUpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGV2ZW50VGltZSk7fWZ1bmN0aW9uIGlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcil7Ly8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIE9ubHkgY2FsbGVkIGJ5IGNsYXNzIGNvbXBvbmVudHMsXG4vLyB3aGljaCBzcGVjaWFsIChkZXByZWNhdGVkKSBiZWhhdmlvciBmb3IgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlIHByb3BzLlxucmV0dXJuKC8vIFRPRE86IFJlbW92ZSBvdXRkYXRlZCBkZWZlclJlbmRlclBoYXNlVXBkYXRlVG9OZXh0QmF0Y2ggZXhwZXJpbWVudC4gV2Vcbi8vIGRlY2lkZWQgbm90IHRvIGVuYWJsZSBpdC5cbihleGVjdXRpb25Db250ZXh0JlJlbmRlckNvbnRleHQpIT09Tm9Db250ZXh0KTt9Ly8gVXNlIHRoaXMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSB0YXNrIGZvciBhIHJvb3QuIFRoZXJlJ3Mgb25seSBvbmUgdGFzayBwZXJcbi8vIHJvb3Q7IGlmIGEgdGFzayB3YXMgYWxyZWFkeSBzY2hlZHVsZWQsIHdlJ2xsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgcHJpb3JpdHlcbi8vIG9mIHRoZSBleGlzdGluZyB0YXNrIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmlvcml0eSBvZiB0aGUgbmV4dCBsZXZlbCB0aGF0IHRoZVxuLy8gcm9vdCBoYXMgd29yayBvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgdXBkYXRlLCBhbmQgcmlnaHQgYmVmb3JlXG4vLyBleGl0aW5nIGEgdGFzay5cbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGN1cnJlbnRUaW1lKXt2YXIgZXhpc3RpbmdDYWxsYmFja05vZGU9cm9vdC5jYWxsYmFja05vZGU7Ly8gQ2hlY2sgaWYgYW55IGxhbmVzIGFyZSBiZWluZyBzdGFydmVkIGJ5IG90aGVyIHdvcmsuIElmIHNvLCBtYXJrIHRoZW0gYXNcbi8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5tYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsY3VycmVudFRpbWUpOy8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG52YXIgbmV4dExhbmVzPWdldE5leHRMYW5lcyhyb290LHJvb3Q9PT13b3JrSW5Qcm9ncmVzc1Jvb3Q/d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM6Tm9MYW5lcyk7aWYobmV4dExhbmVzPT09Tm9MYW5lcyl7Ly8gU3BlY2lhbCBjYXNlOiBUaGVyZSdzIG5vdGhpbmcgdG8gd29yayBvbi5cbmlmKGV4aXN0aW5nQ2FsbGJhY2tOb2RlIT09bnVsbCl7Y2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7fXJvb3QuY2FsbGJhY2tOb2RlPW51bGw7cm9vdC5jYWxsYmFja1ByaW9yaXR5PU5vTGFuZTtyZXR1cm47fS8vIFdlIHVzZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBsYW5lIHRvIHJlcHJlc2VudCB0aGUgcHJpb3JpdHkgb2YgdGhlIGNhbGxiYWNrLlxudmFyIG5ld0NhbGxiYWNrUHJpb3JpdHk9Z2V0SGlnaGVzdFByaW9yaXR5TGFuZShuZXh0TGFuZXMpOy8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgdGFzay4gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgaXQuXG52YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5PXJvb3QuY2FsbGJhY2tQcmlvcml0eTtpZihleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHk9PT1uZXdDYWxsYmFja1ByaW9yaXR5JiYvLyBTcGVjaWFsIGNhc2UgcmVsYXRlZCB0byBgYWN0YC4gSWYgdGhlIGN1cnJlbnRseSBzY2hlZHVsZWQgdGFzayBpcyBhXG4vLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZWRcbi8vIG9uIHRoZSBgYWN0YCBxdWV1ZS5cbiEoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50IT09bnVsbCYmZXhpc3RpbmdDYWxsYmFja05vZGUhPT1mYWtlQWN0Q2FsbGJhY2tOb2RlKSl7ey8vIElmIHdlJ3JlIGdvaW5nIHRvIHJlLXVzZSBhbiBleGlzdGluZyB0YXNrLCBpdCBuZWVkcyB0byBleGlzdC5cbi8vIEFzc3VtZSB0aGF0IGRpc2NyZXRlIHVwZGF0ZSBtaWNyb3Rhc2tzIGFyZSBub24tY2FuY2VsbGFibGUgYW5kIG51bGwuXG4vLyBUT0RPOiBUZW1wb3JhcnkgdW50aWwgd2UgY29uZmlybSB0aGlzIHdhcm5pbmcgaXMgbm90IGZpcmVkLlxuaWYoZXhpc3RpbmdDYWxsYmFja05vZGU9PW51bGwmJmV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSE9PVN5bmNMYW5lKXtlcnJvcignRXhwZWN0ZWQgc2NoZWR1bGVkIGNhbGxiYWNrIHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO319Ly8gVGhlIHByaW9yaXR5IGhhc24ndCBjaGFuZ2VkLiBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIHRhc2suIEV4aXQuXG5yZXR1cm47fWlmKGV4aXN0aW5nQ2FsbGJhY2tOb2RlIT1udWxsKXsvLyBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ldyBvbmUgYmVsb3cuXG5jYW5jZWxDYWxsYmFjayQxKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTt9Ly8gU2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG52YXIgbmV3Q2FsbGJhY2tOb2RlO2lmKG5ld0NhbGxiYWNrUHJpb3JpdHk9PT1TeW5jTGFuZSl7Ly8gU3BlY2lhbCBjYXNlOiBTeW5jIFJlYWN0IGNhbGxiYWNrcyBhcmUgc2NoZWR1bGVkIG9uIGEgc3BlY2lhbFxuLy8gaW50ZXJuYWwgcXVldWVcbmlmKHJvb3QudGFnPT09TGVnYWN5Um9vdCl7aWYoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5pc0JhdGNoaW5nTGVnYWN5IT09bnVsbCl7UmVhY3RDdXJyZW50QWN0UXVldWUkMS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZT10cnVlO31zY2hlZHVsZUxlZ2FjeVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLHJvb3QpKTt9ZWxzZXtzY2hlZHVsZVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLHJvb3QpKTt9ey8vIEZsdXNoIHRoZSBxdWV1ZSBpbiBhIG1pY3JvdGFzay5cbmlmKFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCE9PW51bGwpey8vIEluc2lkZSBgYWN0YCwgdXNlIG91ciBpbnRlcm5hbCBgYWN0YCBxdWV1ZSBzbyB0aGF0IHRoZXNlIGdldCBmbHVzaGVkXG4vLyBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNjb3BlIGV2ZW4gd2hlbiB1c2luZyB0aGUgc3luYyB2ZXJzaW9uXG4vLyBvZiBgYWN0YC5cblJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudC5wdXNoKGZsdXNoU3luY0NhbGxiYWNrcyk7fWVsc2V7c2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24oKXsvLyBJbiBTYWZhcmksIGFwcGVuZGluZyBhbiBpZnJhbWUgZm9yY2VzIG1pY3JvdGFza3MgdG8gcnVuLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMjQ1OVxuLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuLy8gb3IgY29tbWl0IHNvIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdCB0aGF0LlxuaWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpPT09Tm9Db250ZXh0KXsvLyBOb3RlIHRoYXQgdGhpcyB3b3VsZCBzdGlsbCBwcmVtYXR1cmVseSBmbHVzaCB0aGUgY2FsbGJhY2tzXG4vLyBpZiB0aGlzIGhhcHBlbnMgb3V0c2lkZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlIChlLmcuIGluIGFuIGV2ZW50KS5cbmZsdXNoU3luY0NhbGxiYWNrcygpO319KTt9fW5ld0NhbGxiYWNrTm9kZT1udWxsO31lbHNle3ZhciBzY2hlZHVsZXJQcmlvcml0eUxldmVsO3N3aXRjaChsYW5lc1RvRXZlbnRQcmlvcml0eShuZXh0TGFuZXMpKXtjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eUxldmVsPUltbWVkaWF0ZVByaW9yaXR5O2JyZWFrO2Nhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6c2NoZWR1bGVyUHJpb3JpdHlMZXZlbD1Vc2VyQmxvY2tpbmdQcmlvcml0eTticmVhaztjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OnNjaGVkdWxlclByaW9yaXR5TGV2ZWw9Tm9ybWFsUHJpb3JpdHk7YnJlYWs7Y2FzZSBJZGxlRXZlbnRQcmlvcml0eTpzY2hlZHVsZXJQcmlvcml0eUxldmVsPUlkbGVQcmlvcml0eTticmVhaztkZWZhdWx0OnNjaGVkdWxlclByaW9yaXR5TGV2ZWw9Tm9ybWFsUHJpb3JpdHk7YnJlYWs7fW5ld0NhbGxiYWNrTm9kZT1zY2hlZHVsZUNhbGxiYWNrJDEoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCxwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLHJvb3QpKTt9cm9vdC5jYWxsYmFja1ByaW9yaXR5PW5ld0NhbGxiYWNrUHJpb3JpdHk7cm9vdC5jYWxsYmFja05vZGU9bmV3Q2FsbGJhY2tOb2RlO30vLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgZXZlcnkgY29uY3VycmVudCB0YXNrLCBpLmUuIGFueXRoaW5nIHRoYXRcbi8vIGdvZXMgdGhyb3VnaCBTY2hlZHVsZXIuXG5mdW5jdGlvbiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3Qocm9vdCxkaWRUaW1lb3V0KXt7cmVzZXROZXN0ZWRVcGRhdGVGbGFnKCk7fS8vIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gYSBSZWFjdCBldmVudCwgd2UgY2FuIGNsZWFyIHRoZSBjdXJyZW50XG4vLyBldmVudCB0aW1lLiBUaGUgbmV4dCB1cGRhdGUgd2lsbCBjb21wdXRlIGEgbmV3IGV2ZW50IHRpbWUuXG5jdXJyZW50RXZlbnRUaW1lPU5vVGltZXN0YW1wO2N1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lPU5vTGFuZXM7aWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpIT09Tm9Db250ZXh0KXt0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO30vLyBGbHVzaCBhbnkgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGRlY2lkaW5nIHdoaWNoIGxhbmVzIHRvIHdvcmsgb24sXG4vLyBpbiBjYXNlIHRoZXkgc2NoZWR1bGUgYWRkaXRpb25hbCB3b3JrLlxudmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlPXJvb3QuY2FsbGJhY2tOb2RlO3ZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzPWZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtpZihkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKXsvLyBTb21ldGhpbmcgaW4gdGhlIHBhc3NpdmUgZWZmZWN0IHBoYXNlIG1heSBoYXZlIGNhbmNlbGVkIHRoZSBjdXJyZW50IHRhc2suXG4vLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG5pZihyb290LmNhbGxiYWNrTm9kZSE9PW9yaWdpbmFsQ2FsbGJhY2tOb2RlKXsvLyBUaGUgY3VycmVudCB0YXNrIHdhcyBjYW5jZWxlZC4gRXhpdC4gV2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4vLyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBiZWNhdXNlIHRoZSBjaGVjayBhYm92ZSBpbXBsaWVzIGVpdGhlciB0aGF0XG4vLyB0aGVyZSdzIGEgbmV3IHRhc2ssIG9yIHRoYXQgdGhlcmUncyBubyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3QuXG5yZXR1cm4gbnVsbDt9fS8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCB1c2luZyB0aGUgZmllbGRzIHN0b3JlZFxuLy8gb24gdGhlIHJvb3QuXG52YXIgbGFuZXM9Z2V0TmV4dExhbmVzKHJvb3Qscm9vdD09PXdvcmtJblByb2dyZXNzUm9vdD93b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lczpOb0xhbmVzKTtpZihsYW5lcz09PU5vTGFuZXMpey8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxucmV0dXJuIG51bGw7fS8vIFdlIGRpc2FibGUgdGltZS1zbGljaW5nIGluIHNvbWUgY2FzZXM6IGlmIHRoZSB3b3JrIGhhcyBiZWVuIENQVS1ib3VuZFxuLy8gZm9yIHRvbyBsb25nIChcImV4cGlyZWRcIiB3b3JrLCB0byBwcmV2ZW50IHN0YXJ2YXRpb24pLCBvciB3ZSdyZSBpblxuLy8gc3luYy11cGRhdGVzLWJ5LWRlZmF1bHQgbW9kZS5cbi8vIFRPRE86IFdlIG9ubHkgY2hlY2sgYGRpZFRpbWVvdXRgIGRlZmVuc2l2ZWx5LCB0byBhY2NvdW50IGZvciBhIFNjaGVkdWxlclxuLy8gYnVnIHdlJ3JlIHN0aWxsIGludmVzdGlnYXRpbmcuIE9uY2UgdGhlIGJ1ZyBpbiBTY2hlZHVsZXIgaXMgZml4ZWQsXG4vLyB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIHRyYWNrIGV4cGlyYXRpb24gb3Vyc2VsdmVzLlxudmFyIHNob3VsZFRpbWVTbGljZT0haW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCxsYW5lcykmJiFpbmNsdWRlc0V4cGlyZWRMYW5lKHJvb3QsbGFuZXMpJiYhZGlkVGltZW91dDt2YXIgZXhpdFN0YXR1cz1zaG91bGRUaW1lU2xpY2U/cmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCxsYW5lcyk6cmVuZGVyUm9vdFN5bmMocm9vdCxsYW5lcyk7aWYoZXhpdFN0YXR1cyE9PVJvb3RJblByb2dyZXNzKXtpZihleGl0U3RhdHVzPT09Um9vdEVycm9yZWQpey8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbFxuLy8gcmVuZGVyIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsXG4vLyBpbmNsdWRlcyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXJcbi8vIHRoZSBzZWNvbmQgYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cbnZhciBlcnJvclJldHJ5TGFuZXM9Z2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7aWYoZXJyb3JSZXRyeUxhbmVzIT09Tm9MYW5lcyl7bGFuZXM9ZXJyb3JSZXRyeUxhbmVzO2V4aXRTdGF0dXM9cmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCxlcnJvclJldHJ5TGFuZXMpO319aWYoZXhpdFN0YXR1cz09PVJvb3RGYXRhbEVycm9yZWQpe3ZhciBmYXRhbEVycm9yPXdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7cHJlcGFyZUZyZXNoU3RhY2socm9vdCxOb0xhbmVzKTttYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsbGFuZXMpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTt0aHJvdyBmYXRhbEVycm9yO31pZihleGl0U3RhdHVzPT09Um9vdERpZE5vdENvbXBsZXRlKXsvLyBUaGUgcmVuZGVyIHVud291bmQgd2l0aG91dCBjb21wbGV0aW5nIHRoZSB0cmVlLiBUaGlzIGhhcHBlbnMgaW4gc3BlY2lhbFxuLy8gY2FzZXMgd2hlcmUgbmVlZCB0byBleGl0IHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHByb2R1Y2luZyBhXG4vLyBjb25zaXN0ZW50IHRyZWUgb3IgY29tbWl0dGluZy5cbi8vXG4vLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBkdXJpbmcgYSBjb25jdXJyZW50IHJlbmRlciwgbm90IGEgZGlzY3JldGUgb3Jcbi8vIHN5bmNocm9ub3VzIHVwZGF0ZS4gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBjaGVja2VkIGZvciB0aGlzIHdoZW4gd2Vcbi8vIHVud291bmQgdGhlIHN0YWNrLlxubWFya1Jvb3RTdXNwZW5kZWQkMShyb290LGxhbmVzKTt9ZWxzZXsvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cbi8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIG1heSBoYXZlIHlpZWxkZWQgdG8gYSBjb25jdXJyZW50IGV2ZW50LCBhbmQgaWYgc28sXG4vLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbi8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuLy8gdG8gdGhlIG1haW4gdGhyZWFkLCBpZiBpdCB3YXMgZmFzdCBlbm91Z2gsIG9yIGlmIGl0IGV4cGlyZWQuIFdlIGNvdWxkXG4vLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbnZhciByZW5kZXJXYXNDb25jdXJyZW50PSFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LGxhbmVzKTt2YXIgZmluaXNoZWRXb3JrPXJvb3QuY3VycmVudC5hbHRlcm5hdGU7aWYocmVuZGVyV2FzQ29uY3VycmVudCYmIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspKXsvLyBBIHN0b3JlIHdhcyBtdXRhdGVkIGluIGFuIGludGVybGVhdmVkIGV2ZW50LiBSZW5kZXIgYWdhaW4sXG4vLyBzeW5jaHJvbm91c2x5LCB0byBibG9jayBmdXJ0aGVyIG11dGF0aW9ucy5cbmV4aXRTdGF0dXM9cmVuZGVyUm9vdFN5bmMocm9vdCxsYW5lcyk7Ly8gV2UgbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBzb21ldGhpbmcgdGhyZXdcbmlmKGV4aXRTdGF0dXM9PT1Sb290RXJyb3JlZCl7dmFyIF9lcnJvclJldHJ5TGFuZXM9Z2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7aWYoX2Vycm9yUmV0cnlMYW5lcyE9PU5vTGFuZXMpe2xhbmVzPV9lcnJvclJldHJ5TGFuZXM7ZXhpdFN0YXR1cz1yZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LF9lcnJvclJldHJ5TGFuZXMpOy8vIFdlIGFzc3VtZSB0aGUgdHJlZSBpcyBub3cgY29uc2lzdGVudCBiZWNhdXNlIHdlIGRpZG4ndCB5aWVsZCB0byBhbnlcbi8vIGNvbmN1cnJlbnQgZXZlbnRzLlxufX1pZihleGl0U3RhdHVzPT09Um9vdEZhdGFsRXJyb3JlZCl7dmFyIF9mYXRhbEVycm9yPXdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7cHJlcGFyZUZyZXNoU3RhY2socm9vdCxOb0xhbmVzKTttYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsbGFuZXMpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTt0aHJvdyBfZmF0YWxFcnJvcjt9fS8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBUaGUgbmV4dCBzdGVwIGlzIGVpdGhlciB0byBjb21taXQgaXQsXG4vLyBvciwgaWYgc29tZXRoaW5nIHN1c3BlbmRlZCwgd2FpdCB0byBjb21taXQgaXQgYWZ0ZXIgYSB0aW1lb3V0Llxucm9vdC5maW5pc2hlZFdvcms9ZmluaXNoZWRXb3JrO3Jvb3QuZmluaXNoZWRMYW5lcz1sYW5lcztmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsZXhpdFN0YXR1cyxsYW5lcyk7fX1lbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7aWYocm9vdC5jYWxsYmFja05vZGU9PT1vcmlnaW5hbENhbGxiYWNrTm9kZSl7Ly8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4vLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxucmV0dXJuIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwscm9vdCk7fXJldHVybiBudWxsO31mdW5jdGlvbiByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LGVycm9yUmV0cnlMYW5lcyl7Ly8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbiwgZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGxcbi8vIGJhY2sgdG8gY2xpZW50IHNpZGUgcmVuZGVyLlxuLy8gQmVmb3JlIHJlbmRlcmluZyBhZ2Fpbiwgc2F2ZSB0aGUgZXJyb3JzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuXG52YXIgZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdD13b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO2lmKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpey8vIFRoZSBzaGVsbCBmYWlsZWQgdG8gaHlkcmF0ZS4gU2V0IGEgZmxhZyB0byBmb3JjZSBhIGNsaWVudCByZW5kZXJpbmdcbi8vIGR1cmluZyB0aGUgbmV4dCBhdHRlbXB0LiBUbyBkbyB0aGlzLCB3ZSBjYWxsIHByZXBhcmVGcmVzaFN0YWNrIG5vd1xuLy8gdG8gY3JlYXRlIHRoZSByb290IHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoaXMgaXMgYSBiaXQgd2VpcmQgaW4gdGVybXNcbi8vIG9mIGZhY3RvcmluZywgYmVjYXVzZSBpdCByZWxpZXMgb24gcmVuZGVyUm9vdFN5bmMgbm90IGNhbGxpbmdcbi8vIHByZXBhcmVGcmVzaFN0YWNrIGFnYWluIGluIHRoZSBjYWxsIGJlbG93LCB3aGljaCBoYXBwZW5zIGJlY2F1c2UgdGhlXG4vLyByb290IGFuZCBsYW5lcyBoYXZlbid0IGNoYW5nZWQuXG4vL1xuLy8gVE9ETzogSSB0aGluayB3aGF0IHdlIHNob3VsZCBkbyBpcyBzZXQgRm9yY2VDbGllbnRSZW5kZXIgaW5zaWRlXG4vLyB0aHJvd0V4Y2VwdGlvbiwgbGlrZSB3ZSBkbyBmb3IgbmVzdGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMuIFRoZSByZWFzb25cbi8vIGl0J3MgaGVyZSBpbnN0ZWFkIGlzIHNvIHdlIGNhbiBzd2l0Y2ggdG8gdGhlIHN5bmNocm9ub3VzIHdvcmsgbG9vcCwgdG9vLlxuLy8gU29tZXRoaW5nIHRvIGNvbnNpZGVyIGZvciBhIGZ1dHVyZSByZWZhY3Rvci5cbnZhciByb290V29ya0luUHJvZ3Jlc3M9cHJlcGFyZUZyZXNoU3RhY2socm9vdCxlcnJvclJldHJ5TGFuZXMpO3Jvb3RXb3JrSW5Qcm9ncmVzcy5mbGFnc3w9Rm9yY2VDbGllbnRSZW5kZXI7e2Vycm9ySHlkcmF0aW5nQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7fX12YXIgZXhpdFN0YXR1cz1yZW5kZXJSb290U3luYyhyb290LGVycm9yUmV0cnlMYW5lcyk7aWYoZXhpdFN0YXR1cyE9PVJvb3RFcnJvcmVkKXsvLyBTdWNjZXNzZnVsbHkgZmluaXNoZWQgcmVuZGVyaW5nIG9uIHJldHJ5XG4vLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuLy8gdGhlbSB0byB0aGUgY29sbGVjdGlvbiBvZiByZWNvdmVyYWJsZSBlcnJvcnMuIFdlJ2xsIGxvZyB0aGVtIGluIHRoZVxuLy8gY29tbWl0IHBoYXNlLlxudmFyIGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0PXdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO3dvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzPWVycm9yc0Zyb21GaXJzdEF0dGVtcHQ7Ly8gVGhlIGVycm9ycyBmcm9tIHRoZSBzZWNvbmQgYXR0ZW1wdCBzaG91bGQgYmUgcXVldWVkIGFmdGVyIHRoZSBlcnJvcnNcbi8vIGZyb20gdGhlIGZpcnN0IGF0dGVtcHQsIHRvIHByZXNlcnZlIHRoZSBjYXVzYWwgc2VxdWVuY2UuXG5pZihlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCE9PW51bGwpe3F1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQpO319cmV0dXJuIGV4aXRTdGF0dXM7fWZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKXtpZih3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycz09PW51bGwpe3dvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzPWVycm9yczt9ZWxzZXt3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLGVycm9ycyk7fX1mdW5jdGlvbiBmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsZXhpdFN0YXR1cyxsYW5lcyl7c3dpdGNoKGV4aXRTdGF0dXMpe2Nhc2UgUm9vdEluUHJvZ3Jlc3M6Y2FzZSBSb290RmF0YWxFcnJvcmVkOnt0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTt9Ly8gRmxvdyBrbm93cyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWlucyBpZiBJIGFkZCBhIGJyZWFrXG4vLyBzdGF0ZW1lbnQsIGJ1dCBlc2xpbnQgZG9lc24ndCBrbm93IGFib3V0IGludmFyaWFudCwgc28gaXQgY29tcGxhaW5zXG4vLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmNhc2UgUm9vdEVycm9yZWQ6ey8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuLy8gdGhpcyBwb2ludCwgaXQgZXJyb3JlZCBhZ2Fpbi4gQ29tbWl0IGl0LlxuY29tbWl0Um9vdChyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO2JyZWFrO31jYXNlIFJvb3RTdXNwZW5kZWQ6e21hcmtSb290U3VzcGVuZGVkJDEocm9vdCxsYW5lcyk7Ly8gV2UgaGF2ZSBhbiBhY2NlcHRhYmxlIGxvYWRpbmcgc3RhdGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB3ZVxuLy8gc2hvdWxkIGltbWVkaWF0ZWx5IGNvbW1pdCBpdCBvciB3YWl0IGEgYml0LlxuaWYoaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykmJi8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcbiFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSl7Ly8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4vLyByZXRyaWVzIHNvIHRoYXQgd2UgZG9uJ3Qgc2hvdyB0b28gbWFueSBsb2FkaW5nIHN0YXRlcyB0b28gcXVpY2tseS5cbnZhciBtc1VudGlsVGltZW91dD1nbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lK0ZBTExCQUNLX1RIUk9UVExFX01TLW5vdygpOy8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuaWYobXNVbnRpbFRpbWVvdXQ+MTApe3ZhciBuZXh0TGFuZXM9Z2V0TmV4dExhbmVzKHJvb3QsTm9MYW5lcyk7aWYobmV4dExhbmVzIT09Tm9MYW5lcyl7Ly8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuYnJlYWs7fXZhciBzdXNwZW5kZWRMYW5lcz1yb290LnN1c3BlbmRlZExhbmVzO2lmKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsbGFuZXMpKXsvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3Rcbi8vIHN1c3BlbmRlZCBsZXZlbC4gUGluZyB0aGUgbGFzdCBzdXNwZW5kZWQgbGV2ZWwgdG8gdHJ5XG4vLyByZW5kZXJpbmcgaXQgYWdhaW4uXG4vLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG52YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTttYXJrUm9vdFBpbmdlZChyb290LHN1c3BlbmRlZExhbmVzKTticmVhazt9Ly8gVGhlIHJlbmRlciBpcyBzdXNwZW5kZWQsIGl0IGhhc24ndCB0aW1lZCBvdXQsIGFuZCB0aGVyZSdzIG5vXG4vLyBsb3dlciBwcmlvcml0eSB3b3JrIHRvIGRvLiBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrXG4vLyBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cbnJvb3QudGltZW91dEhhbmRsZT1zY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwscm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKSxtc1VudGlsVGltZW91dCk7YnJlYWs7fX0vLyBUaGUgd29yayBleHBpcmVkLiBDb21taXQgaW1tZWRpYXRlbHkuXG5jb21taXRSb290KHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7YnJlYWs7fWNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTp7bWFya1Jvb3RTdXNwZW5kZWQkMShyb290LGxhbmVzKTtpZihpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpey8vIFRoaXMgaXMgYSB0cmFuc2l0aW9uLCBzbyB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IGNvbW1pdHRpbmcgYVxuLy8gcGxhY2Vob2xkZXIgYW5kIHdpdGhvdXQgc2NoZWR1bGluZyBhIHRpbWVvdXQuIERlbGF5IGluZGVmaW5pdGVseVxuLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG5icmVhazt9aWYoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKXsvLyBUaGlzIGlzIG5vdCBhIHRyYW5zaXRpb24sIGJ1dCB3ZSBkaWQgdHJpZ2dlciBhbiBhdm9pZGVkIHN0YXRlLlxuLy8gU2NoZWR1bGUgYSBwbGFjZWhvbGRlciB0byBkaXNwbGF5IGFmdGVyIGEgc2hvcnQgZGVsYXksIHVzaW5nIHRoZSBKdXN0XG4vLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4vLyBUT0RPOiBJcyB0aGUgSk5EIG9wdGltaXphdGlvbiB3b3J0aCB0aGUgYWRkZWQgY29tcGxleGl0eT8gSWYgdGhpcyBpc1xuLy8gdGhlIG9ubHkgcmVhc29uIHdlIHRyYWNrIHRoZSBldmVudCB0aW1lLCB0aGVuIHByb2JhYmx5IG5vdC5cbi8vIENvbnNpZGVyIHJlbW92aW5nLlxudmFyIG1vc3RSZWNlbnRFdmVudFRpbWU9Z2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LGxhbmVzKTt2YXIgZXZlbnRUaW1lTXM9bW9zdFJlY2VudEV2ZW50VGltZTt2YXIgdGltZUVsYXBzZWRNcz1ub3coKS1ldmVudFRpbWVNczt2YXIgX21zVW50aWxUaW1lb3V0PWpuZCh0aW1lRWxhcHNlZE1zKS10aW1lRWxhcHNlZE1zOy8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuaWYoX21zVW50aWxUaW1lb3V0PjEwKXsvLyBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGFcbi8vIHRvIGFycml2ZS5cbnJvb3QudGltZW91dEhhbmRsZT1zY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwscm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKSxfbXNVbnRpbFRpbWVvdXQpO2JyZWFrO319Ly8gQ29tbWl0IHRoZSBwbGFjZWhvbGRlci5cbmNvbW1pdFJvb3Qocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTticmVhazt9Y2FzZSBSb290Q29tcGxldGVkOnsvLyBUaGUgd29yayBjb21wbGV0ZWQuIFJlYWR5IHRvIGNvbW1pdC5cbmNvbW1pdFJvb3Qocm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyx3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTticmVhazt9ZGVmYXVsdDp7dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuJyk7fX19ZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yayl7Ly8gU2VhcmNoIHRoZSByZW5kZXJlZCB0cmVlIGZvciBleHRlcm5hbCBzdG9yZSByZWFkcywgYW5kIGNoZWNrIHdoZXRoZXIgdGhlXG4vLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbi8vIGxvb3AgaW5zdGVhZCBvZiByZWN1cnNpb24gc28gd2UgY2FuIGV4aXQgZWFybHkuXG52YXIgbm9kZT1maW5pc2hlZFdvcms7d2hpbGUodHJ1ZSl7aWYobm9kZS5mbGFncyZTdG9yZUNvbnNpc3RlbmN5KXt2YXIgdXBkYXRlUXVldWU9bm9kZS51cGRhdGVRdWV1ZTtpZih1cGRhdGVRdWV1ZSE9PW51bGwpe3ZhciBjaGVja3M9dXBkYXRlUXVldWUuc3RvcmVzO2lmKGNoZWNrcyE9PW51bGwpe2Zvcih2YXIgaT0wO2k8Y2hlY2tzLmxlbmd0aDtpKyspe3ZhciBjaGVjaz1jaGVja3NbaV07dmFyIGdldFNuYXBzaG90PWNoZWNrLmdldFNuYXBzaG90O3ZhciByZW5kZXJlZFZhbHVlPWNoZWNrLnZhbHVlO3RyeXtpZighb2JqZWN0SXMoZ2V0U25hcHNob3QoKSxyZW5kZXJlZFZhbHVlKSl7Ly8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxucmV0dXJuIGZhbHNlO319Y2F0Y2goZXJyb3Ipey8vIElmIGBnZXRTbmFwc2hvdGAgdGhyb3dzLCByZXR1cm4gYGZhbHNlYC4gVGhpcyB3aWxsIHNjaGVkdWxlXG4vLyBhIHJlLXJlbmRlciwgYW5kIHRoZSBlcnJvciB3aWxsIGJlIHJldGhyb3duIGR1cmluZyByZW5kZXIuXG5yZXR1cm4gZmFsc2U7fX19fX12YXIgY2hpbGQ9bm9kZS5jaGlsZDtpZihub2RlLnN1YnRyZWVGbGFncyZTdG9yZUNvbnNpc3RlbmN5JiZjaGlsZCE9PW51bGwpe2NoaWxkLnJldHVybj1ub2RlO25vZGU9Y2hpbGQ7Y29udGludWU7fWlmKG5vZGU9PT1maW5pc2hlZFdvcmspe3JldHVybiB0cnVlO313aGlsZShub2RlLnNpYmxpbmc9PT1udWxsKXtpZihub2RlLnJldHVybj09PW51bGx8fG5vZGUucmV0dXJuPT09ZmluaXNoZWRXb3JrKXtyZXR1cm4gdHJ1ZTt9bm9kZT1ub2RlLnJldHVybjt9bm9kZS5zaWJsaW5nLnJldHVybj1ub2RlLnJldHVybjtub2RlPW5vZGUuc2libGluZzt9Ly8gRmxvdyBkb2Vzbid0IGtub3cgdGhpcyBpcyB1bnJlYWNoYWJsZSwgYnV0IGVzbGludCBkb2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbnJldHVybiB0cnVlO31mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3Qsc3VzcGVuZGVkTGFuZXMpey8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbi8vIHJhcmVseSwgc2luY2Ugd2UgdHJ5IHRvIGF2b2lkIGl0KSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuLy8gVE9ETzogTG9sIG1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIGZhY3RvciB0aGlzIGJlc2lkZXMgdGhpc1xuLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbnN1c3BlbmRlZExhbmVzPXJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzKTtzdXNwZW5kZWRMYW5lcz1yZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcyx3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyk7bWFya1Jvb3RTdXNwZW5kZWQocm9vdCxzdXNwZW5kZWRMYW5lcyk7fS8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3Qpe3tzeW5jTmVzdGVkVXBkYXRlRmxhZygpO31pZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSkhPT1Ob0NvbnRleHQpe3Rocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7fWZsdXNoUGFzc2l2ZUVmZmVjdHMoKTt2YXIgbGFuZXM9Z2V0TmV4dExhbmVzKHJvb3QsTm9MYW5lcyk7aWYoIWluY2x1ZGVzU29tZUxhbmUobGFuZXMsU3luY0xhbmUpKXsvLyBUaGVyZSdzIG5vIHJlbWFpbmluZyBzeW5jIHdvcmsgbGVmdC5cbmVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTtyZXR1cm4gbnVsbDt9dmFyIGV4aXRTdGF0dXM9cmVuZGVyUm9vdFN5bmMocm9vdCxsYW5lcyk7aWYocm9vdC50YWchPT1MZWdhY3lSb290JiZleGl0U3RhdHVzPT09Um9vdEVycm9yZWQpey8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbCByZW5kZXJcbi8vIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsIGluY2x1ZGVzXG4vLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuLy8gYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cbnZhciBlcnJvclJldHJ5TGFuZXM9Z2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7aWYoZXJyb3JSZXRyeUxhbmVzIT09Tm9MYW5lcyl7bGFuZXM9ZXJyb3JSZXRyeUxhbmVzO2V4aXRTdGF0dXM9cmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCxlcnJvclJldHJ5TGFuZXMpO319aWYoZXhpdFN0YXR1cz09PVJvb3RGYXRhbEVycm9yZWQpe3ZhciBmYXRhbEVycm9yPXdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7cHJlcGFyZUZyZXNoU3RhY2socm9vdCxOb0xhbmVzKTttYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsbGFuZXMpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTt0aHJvdyBmYXRhbEVycm9yO31pZihleGl0U3RhdHVzPT09Um9vdERpZE5vdENvbXBsZXRlKXt0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTt9Ly8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxudmFyIGZpbmlzaGVkV29yaz1yb290LmN1cnJlbnQuYWx0ZXJuYXRlO3Jvb3QuZmluaXNoZWRXb3JrPWZpbmlzaGVkV29yaztyb290LmZpbmlzaGVkTGFuZXM9bGFuZXM7Y29tbWl0Um9vdChyb290LHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpOy8vIEJlZm9yZSBleGl0aW5nLCBtYWtlIHN1cmUgdGhlcmUncyBhIGNhbGxiYWNrIHNjaGVkdWxlZCBmb3IgdGhlIG5leHRcbi8vIHBlbmRpbmcgbGV2ZWwuXG5lbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCxub3coKSk7cmV0dXJuIG51bGw7fWZ1bmN0aW9uIGZsdXNoUm9vdChyb290LGxhbmVzKXtpZihsYW5lcyE9PU5vTGFuZXMpe21hcmtSb290RW50YW5nbGVkKHJvb3QsbWVyZ2VMYW5lcyhsYW5lcyxTeW5jTGFuZSkpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LG5vdygpKTtpZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSk9PT1Ob0NvbnRleHQpe3Jlc2V0UmVuZGVyVGltZXIoKTtmbHVzaFN5bmNDYWxsYmFja3MoKTt9fX1mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLGEpe3ZhciBwcmV2RXhlY3V0aW9uQ29udGV4dD1leGVjdXRpb25Db250ZXh0O2V4ZWN1dGlvbkNvbnRleHR8PUJhdGNoZWRDb250ZXh0O3RyeXtyZXR1cm4gZm4oYSk7fWZpbmFsbHl7ZXhlY3V0aW9uQ29udGV4dD1wcmV2RXhlY3V0aW9uQ29udGV4dDsvLyBJZiB0aGVyZSB3ZXJlIGxlZ2FjeSBzeW5jIHVwZGF0ZXMsIGZsdXNoIHRoZW0gYXQgdGhlIGVuZCBvZiB0aGUgb3V0ZXJcbi8vIG1vc3QgYmF0Y2hlZFVwZGF0ZXMtbGlrZSBtZXRob2QuXG5pZihleGVjdXRpb25Db250ZXh0PT09Tm9Db250ZXh0JiYvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuIVJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSl7cmVzZXRSZW5kZXJUaW1lcigpO2ZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTt9fX1mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMoZm4sYSxiLGMsZCl7dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjt0cnl7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPW51bGw7c2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7cmV0dXJuIGZuKGEsYixjLGQpO31maW5hbGx5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247aWYoZXhlY3V0aW9uQ29udGV4dD09PU5vQ29udGV4dCl7cmVzZXRSZW5kZXJUaW1lcigpO319fS8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4pey8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBmbHVzaCBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuLy8gbmV4dCBldmVudCwgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG9uZS5cbmlmKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIT09bnVsbCYmcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMudGFnPT09TGVnYWN5Um9vdCYmKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpPT09Tm9Db250ZXh0KXtmbHVzaFBhc3NpdmVFZmZlY3RzKCk7fXZhciBwcmV2RXhlY3V0aW9uQ29udGV4dD1leGVjdXRpb25Db250ZXh0O2V4ZWN1dGlvbkNvbnRleHR8PUJhdGNoZWRDb250ZXh0O3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247dmFyIHByZXZpb3VzUHJpb3JpdHk9Z2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7dHJ5e1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1udWxsO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO2lmKGZuKXtyZXR1cm4gZm4oKTt9ZWxzZXtyZXR1cm4gdW5kZWZpbmVkO319ZmluYWxseXtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uPXByZXZUcmFuc2l0aW9uO2V4ZWN1dGlvbkNvbnRleHQ9cHJldkV4ZWN1dGlvbkNvbnRleHQ7Ly8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGV2ZW4gaWYgYmF0Y2hlZFVwZGF0ZXMgaXMgaGlnaGVyIHVwXG4vLyB0aGUgc3RhY2suXG5pZigoZXhlY3V0aW9uQ29udGV4dCYoUmVuZGVyQ29udGV4dHxDb21taXRDb250ZXh0KSk9PT1Ob0NvbnRleHQpe2ZsdXNoU3luY0NhbGxiYWNrcygpO319fWZ1bmN0aW9uIGlzQWxyZWFkeVJlbmRlcmluZygpey8vIFVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvIHByaW50IGEgd2FybmluZyBpZiBjZXJ0YWluIEFQSXMgYXJlIGNhbGxlZCBmcm9tXG4vLyB0aGUgd3JvbmcgY29udGV4dC5cbnJldHVybihleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKSE9PU5vQ29udGV4dDt9ZnVuY3Rpb24gcHVzaFJlbmRlckxhbmVzKGZpYmVyLGxhbmVzKXtwdXNoKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvcixzdWJ0cmVlUmVuZGVyTGFuZXMsZmliZXIpO3N1YnRyZWVSZW5kZXJMYW5lcz1tZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcyxsYW5lcyk7d29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsbGFuZXMpO31mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcil7c3VidHJlZVJlbmRlckxhbmVzPXN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50O3BvcChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsZmliZXIpO31mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LGxhbmVzKXtyb290LmZpbmlzaGVkV29yaz1udWxsO3Jvb3QuZmluaXNoZWRMYW5lcz1Ob0xhbmVzO3ZhciB0aW1lb3V0SGFuZGxlPXJvb3QudGltZW91dEhhbmRsZTtpZih0aW1lb3V0SGFuZGxlIT09bm9UaW1lb3V0KXsvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbi8vIHN0YXRlLiBOb3cgdGhhdCB3ZSBoYXZlIGFkZGl0aW9uYWwgd29yaywgY2FuY2VsIHRoZSB0aW1lb3V0Llxucm9vdC50aW1lb3V0SGFuZGxlPW5vVGltZW91dDsvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTt9aWYod29ya0luUHJvZ3Jlc3MhPT1udWxsKXt2YXIgaW50ZXJydXB0ZWRXb3JrPXdvcmtJblByb2dyZXNzLnJldHVybjt3aGlsZShpbnRlcnJ1cHRlZFdvcmshPT1udWxsKXt2YXIgY3VycmVudD1pbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlO3Vud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LGludGVycnVwdGVkV29yayk7aW50ZXJydXB0ZWRXb3JrPWludGVycnVwdGVkV29yay5yZXR1cm47fX13b3JrSW5Qcm9ncmVzc1Jvb3Q9cm9vdDt2YXIgcm9vdFdvcmtJblByb2dyZXNzPWNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCxudWxsKTt3b3JrSW5Qcm9ncmVzcz1yb290V29ya0luUHJvZ3Jlc3M7d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM9c3VidHJlZVJlbmRlckxhbmVzPXdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXM9bGFuZXM7d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290SW5Qcm9ncmVzczt3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yPW51bGw7d29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzPU5vTGFuZXM7d29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM9Tm9MYW5lczt3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcz1Ob0xhbmVzO3dvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM9bnVsbDt3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycz1udWxsO2ZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTt7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO31yZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO31mdW5jdGlvbiBoYW5kbGVFcnJvcihyb290LHRocm93blZhbHVlKXtkb3t2YXIgZXJyb3JlZFdvcms9d29ya0luUHJvZ3Jlc3M7dHJ5ey8vIFJlc2V0IG1vZHVsZS1sZXZlbCBzdGF0ZSB0aGF0IHdhcyBzZXQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG5yZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtyZXNldEhvb2tzQWZ0ZXJUaHJvdygpO3Jlc2V0Q3VycmVudEZpYmVyKCk7Ly8gVE9ETzogSSBmb3VuZCBhbmQgYWRkZWQgdGhpcyBtaXNzaW5nIGxpbmUgd2hpbGUgaW52ZXN0aWdhdGluZyBhXG4vLyBzZXBhcmF0ZSBpc3N1ZS4gV3JpdGUgYSByZWdyZXNzaW9uIHRlc3QgdXNpbmcgc3RyaW5nIHJlZnMuXG5SZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQ9bnVsbDtpZihlcnJvcmVkV29yaz09PW51bGx8fGVycm9yZWRXb3JrLnJldHVybj09PW51bGwpey8vIEV4cGVjdGVkIHRvIGJlIHdvcmtpbmcgb24gYSBub24tcm9vdCBmaWJlci4gVGhpcyBpcyBhIGZhdGFsIGVycm9yXG4vLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gYW5jZXN0b3IgdGhhdCBjYW4gaGFuZGxlIGl0OyB0aGUgcm9vdCBpc1xuLy8gc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndCBjYXVnaHQgYnkgYW4gZXJyb3Jcbi8vIGJvdW5kYXJ5Llxud29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290RmF0YWxFcnJvcmVkO3dvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I9dGhyb3duVmFsdWU7Ly8gU2V0IGB3b3JrSW5Qcm9ncmVzc2AgdG8gbnVsbC4gVGhpcyByZXByZXNlbnRzIGFkdmFuY2luZyB0byB0aGUgbmV4dFxuLy8gc2libGluZywgb3IgdGhlIHBhcmVudCBpZiB0aGVyZSBhcmUgbm8gc2libGluZ3MuIEJ1dCBzaW5jZSB0aGUgcm9vdFxuLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuLy8gaGFuZGxlZCBieSBgY29tcGxldGVVbml0T2ZXb3JrYCBvciBgdW53aW5kV29ya2AsIGJ1dCBzaW5jZSB3ZSdyZVxuLy8gaW50ZW50aW9uYWxseSBub3QgY2FsbGluZyB0aG9zZSwgd2UgbmVlZCBzZXQgaXQgaGVyZS5cbi8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG53b3JrSW5Qcm9ncmVzcz1udWxsO3JldHVybjt9aWYoZW5hYmxlUHJvZmlsZXJUaW1lciYmZXJyb3JlZFdvcmsubW9kZSZQcm9maWxlTW9kZSl7Ly8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuLy8gYXZvaWRzIGluYWNjdXJhdGUgUHJvZmlsZXIgZHVyYXRpb25zIGluIHRoZSBjYXNlIG9mIGFcbi8vIHN1c3BlbmRlZCByZW5kZXIuXG5zdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLHRydWUpO31pZihlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIpe21hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7aWYodGhyb3duVmFsdWUhPT1udWxsJiZ0eXBlb2YgdGhyb3duVmFsdWU9PT0nb2JqZWN0JyYmdHlwZW9mIHRocm93blZhbHVlLnRoZW49PT0nZnVuY3Rpb24nKXt2YXIgd2FrZWFibGU9dGhyb3duVmFsdWU7bWFya0NvbXBvbmVudFN1c3BlbmRlZChlcnJvcmVkV29yayx3YWtlYWJsZSx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7fWVsc2V7bWFya0NvbXBvbmVudEVycm9yZWQoZXJyb3JlZFdvcmssdGhyb3duVmFsdWUsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO319dGhyb3dFeGNlcHRpb24ocm9vdCxlcnJvcmVkV29yay5yZXR1cm4sZXJyb3JlZFdvcmssdGhyb3duVmFsdWUsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO2NvbXBsZXRlVW5pdE9mV29yayhlcnJvcmVkV29yayk7fWNhdGNoKHlldEFub3RoZXJUaHJvd25WYWx1ZSl7Ly8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxudGhyb3duVmFsdWU9eWV0QW5vdGhlclRocm93blZhbHVlO2lmKHdvcmtJblByb2dyZXNzPT09ZXJyb3JlZFdvcmsmJmVycm9yZWRXb3JrIT09bnVsbCl7Ly8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3Npbmdcbi8vIHRoZSBlcnJvci4gQnViYmxlIGl0IHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuZXJyb3JlZFdvcms9ZXJyb3JlZFdvcmsucmV0dXJuO3dvcmtJblByb2dyZXNzPWVycm9yZWRXb3JrO31lbHNle2Vycm9yZWRXb3JrPXdvcmtJblByb2dyZXNzO31jb250aW51ZTt9Ly8gUmV0dXJuIHRvIHRoZSBub3JtYWwgd29yayBsb29wLlxucmV0dXJuO313aGlsZSh0cnVlKTt9ZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKXt2YXIgcHJldkRpc3BhdGNoZXI9UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQ7UmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQ9Q29udGV4dE9ubHlEaXNwYXRjaGVyO2lmKHByZXZEaXNwYXRjaGVyPT09bnVsbCl7Ly8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuLy8gSW5zdGVhZCB0aGUgZmlyc3QgcmVuZGVyZXIgd2lsbCBsYXppbHkgYXR0YWNoIG9uZSwgaW4gb3JkZXIgdG8gZ2l2ZVxuLy8gbmljZXIgZXJyb3IgbWVzc2FnZXMuXG5yZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO31lbHNle3JldHVybiBwcmV2RGlzcGF0Y2hlcjt9fWZ1bmN0aW9uIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpe1JlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50PXByZXZEaXNwYXRjaGVyO31mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKXtnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lPW5vdygpO31mdW5jdGlvbiBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGxhbmUpe3dvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcz1tZXJnZUxhbmVzKGxhbmUsd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKTt9ZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZCgpe2lmKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290SW5Qcm9ncmVzcyl7d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290U3VzcGVuZGVkO319ZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpe2lmKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290SW5Qcm9ncmVzc3x8d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RTdXNwZW5kZWR8fHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9PT1Sb290RXJyb3JlZCl7d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz1Sb290U3VzcGVuZGVkV2l0aERlbGF5O30vLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4vLyB0aGlzIHJlbmRlci5cbmlmKHdvcmtJblByb2dyZXNzUm9vdCE9PW51bGwmJihpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyl8fGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpKSl7Ly8gTWFyayB0aGUgY3VycmVudCByZW5kZXIgYXMgc3VzcGVuZGVkIHNvIHRoYXQgd2Ugc3dpdGNoIHRvIHdvcmtpbmcgb25cbi8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4vLyB0aGUgcmVuZGVyIHBoYXNlLlxuLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGFsd2F5cyBtYXJrIHRoZSByb290IGFzIHN1c3BlbmRlZCBpbW1lZGlhdGVseVxuLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbi8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuLy8gcGluZ2VkIG9yIHVwZGF0ZWQgd2hpbGUgd2Ugd2VyZSByZW5kZXJpbmcuXG5tYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7fX1mdW5jdGlvbiByZW5kZXJEaWRFcnJvcihlcnJvcil7aWYod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyE9PVJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpe3dvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdEVycm9yZWQ7fWlmKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM9PT1udWxsKXt3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzPVtlcnJvcl07fWVsc2V7d29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTt9fS8vIENhbGxlZCBkdXJpbmcgcmVuZGVyIHRvIGRldGVybWluZSBpZiBhbnl0aGluZyBoYXMgc3VzcGVuZGVkLlxuLy8gUmV0dXJucyBmYWxzZSBpZiB3ZSdyZSBub3Qgc3VyZS5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpey8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4vLyBzbyB0aG9zZSBhcmUgZmFsc2UuXG5yZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RJblByb2dyZXNzO31mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LGxhbmVzKXt2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQ9ZXhlY3V0aW9uQ29udGV4dDtleGVjdXRpb25Db250ZXh0fD1SZW5kZXJDb250ZXh0O3ZhciBwcmV2RGlzcGF0Y2hlcj1wdXNoRGlzcGF0Y2hlcigpOy8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cbmlmKHdvcmtJblByb2dyZXNzUm9vdCE9PXJvb3R8fHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIT09bGFuZXMpe3tpZihpc0RldlRvb2xzUHJlc2VudCl7dmFyIG1lbW9pemVkVXBkYXRlcnM9cm9vdC5tZW1vaXplZFVwZGF0ZXJzO2lmKG1lbW9pemVkVXBkYXRlcnMuc2l6ZT4wKXtyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3Qsd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO21lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTt9Ly8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4vLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuLy8gSXQncyBpbXBvcnRhbnQgdG8gbW92ZSB0aGVtIG5vdyBpbiBjYXNlIHRoZSB3b3JrIHNwYXducyBtb3JlIHdvcmsgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgdXBkYXRlcnMuXG4vLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxubW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsbGFuZXMpO319d29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucz1nZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7cHJlcGFyZUZyZXNoU3RhY2socm9vdCxsYW5lcyk7fXttYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7fWRve3RyeXt3b3JrTG9vcFN5bmMoKTticmVhazt9Y2F0Y2godGhyb3duVmFsdWUpe2hhbmRsZUVycm9yKHJvb3QsdGhyb3duVmFsdWUpO319d2hpbGUodHJ1ZSk7cmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7ZXhlY3V0aW9uQ29udGV4dD1wcmV2RXhlY3V0aW9uQ29udGV4dDtwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtpZih3b3JrSW5Qcm9ncmVzcyE9PW51bGwpey8vIFRoaXMgaXMgYSBzeW5jIHJlbmRlciwgc28gd2Ugc2hvdWxkIGhhdmUgZmluaXNoZWQgdGhlIHdob2xlIHRyZWUuXG50aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnKydidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO317bWFya1JlbmRlclN0b3BwZWQoKTt9Ly8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGVyZSdzIG5vIGluLXByb2dyZXNzIHJlbmRlci5cbndvcmtJblByb2dyZXNzUm9vdD1udWxsO3dvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzPU5vTGFuZXM7cmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7fS8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cbi8qKiBAbm9pbmxpbmUgKi9mdW5jdGlvbiB3b3JrTG9vcFN5bmMoKXsvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbndoaWxlKHdvcmtJblByb2dyZXNzIT09bnVsbCl7cGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO319ZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCxsYW5lcyl7dmFyIHByZXZFeGVjdXRpb25Db250ZXh0PWV4ZWN1dGlvbkNvbnRleHQ7ZXhlY3V0aW9uQ29udGV4dHw9UmVuZGVyQ29udGV4dDt2YXIgcHJldkRpc3BhdGNoZXI9cHVzaERpc3BhdGNoZXIoKTsvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcbi8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5pZih3b3JrSW5Qcm9ncmVzc1Jvb3QhPT1yb290fHx3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyE9PWxhbmVzKXt7aWYoaXNEZXZUb29sc1ByZXNlbnQpe3ZhciBtZW1vaXplZFVwZGF0ZXJzPXJvb3QubWVtb2l6ZWRVcGRhdGVycztpZihtZW1vaXplZFVwZGF0ZXJzLnNpemU+MCl7cmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTttZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7fS8vIEF0IHRoaXMgcG9pbnQsIG1vdmUgRmliZXJzIHRoYXQgc2NoZWR1bGVkIHRoZSB1cGNvbWluZyB3b3JrIGZyb20gdGhlIE1hcCB0byB0aGUgU2V0LlxuLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cbi8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuLy8gVGhhdCB3YXkgd2UgY2FuIGtlZXAgdGhlIGN1cnJlbnQgdXBkYXRlIGFuZCBmdXR1cmUgdXBkYXRlcyBzZXBhcmF0ZS5cbm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LGxhbmVzKTt9fXdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnM9Z2V0VHJhbnNpdGlvbnNGb3JMYW5lcygpO3Jlc2V0UmVuZGVyVGltZXIoKTtwcmVwYXJlRnJlc2hTdGFjayhyb290LGxhbmVzKTt9e21hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTt9ZG97dHJ5e3dvcmtMb29wQ29uY3VycmVudCgpO2JyZWFrO31jYXRjaCh0aHJvd25WYWx1ZSl7aGFuZGxlRXJyb3Iocm9vdCx0aHJvd25WYWx1ZSk7fX13aGlsZSh0cnVlKTtyZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtleGVjdXRpb25Db250ZXh0PXByZXZFeGVjdXRpb25Db250ZXh0O2lmKHdvcmtJblByb2dyZXNzIT09bnVsbCl7Ly8gU3RpbGwgd29yayByZW1haW5pbmcuXG57bWFya1JlbmRlcllpZWxkZWQoKTt9cmV0dXJuIFJvb3RJblByb2dyZXNzO31lbHNley8vIENvbXBsZXRlZCB0aGUgdHJlZS5cbnttYXJrUmVuZGVyU3RvcHBlZCgpO30vLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxud29ya0luUHJvZ3Jlc3NSb290PW51bGw7d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM9Tm9MYW5lczsvLyBSZXR1cm4gdGhlIGZpbmFsIGV4aXQgc3RhdHVzLlxucmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7fX0vKiogQG5vaW5saW5lICovZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCl7Ly8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG53aGlsZSh3b3JrSW5Qcm9ncmVzcyE9PW51bGwmJiFzaG91bGRZaWVsZCgpKXtwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7fX1mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKXsvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4vLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxudmFyIGN1cnJlbnQ9dW5pdE9mV29yay5hbHRlcm5hdGU7c2V0Q3VycmVudEZpYmVyKHVuaXRPZldvcmspO3ZhciBuZXh0O2lmKCh1bml0T2ZXb3JrLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXtzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7bmV4dD1iZWdpbldvcmskMShjdXJyZW50LHVuaXRPZldvcmssc3VidHJlZVJlbmRlckxhbmVzKTtzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHVuaXRPZldvcmssdHJ1ZSk7fWVsc2V7bmV4dD1iZWdpbldvcmskMShjdXJyZW50LHVuaXRPZldvcmssc3VidHJlZVJlbmRlckxhbmVzKTt9cmVzZXRDdXJyZW50RmliZXIoKTt1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHM9dW5pdE9mV29yay5wZW5kaW5nUHJvcHM7aWYobmV4dD09PW51bGwpey8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbmNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTt9ZWxzZXt3b3JrSW5Qcm9ncmVzcz1uZXh0O31SZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQ9bnVsbDt9ZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspey8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlIG5leHRcbi8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbnZhciBjb21wbGV0ZWRXb3JrPXVuaXRPZldvcms7ZG97Ly8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3Rcbi8vIG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpbiBwcm9ncmVzcy5cbnZhciBjdXJyZW50PWNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlO3ZhciByZXR1cm5GaWJlcj1jb21wbGV0ZWRXb3JrLnJldHVybjsvLyBDaGVjayBpZiB0aGUgd29yayBjb21wbGV0ZWQgb3IgaWYgc29tZXRoaW5nIHRocmV3LlxuaWYoKGNvbXBsZXRlZFdvcmsuZmxhZ3MmSW5jb21wbGV0ZSk9PT1Ob0ZsYWdzKXtzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7dmFyIG5leHQ9dm9pZCAwO2lmKChjb21wbGV0ZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpPT09Tm9Nb2RlKXtuZXh0PWNvbXBsZXRlV29yayhjdXJyZW50LGNvbXBsZXRlZFdvcmssc3VidHJlZVJlbmRlckxhbmVzKTt9ZWxzZXtzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7bmV4dD1jb21wbGV0ZVdvcmsoY3VycmVudCxjb21wbGV0ZWRXb3JrLHN1YnRyZWVSZW5kZXJMYW5lcyk7Ly8gVXBkYXRlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgZXJyb3IuXG5zdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssZmFsc2UpO31yZXNldEN1cnJlbnRGaWJlcigpO2lmKG5leHQhPT1udWxsKXsvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG53b3JrSW5Qcm9ncmVzcz1uZXh0O3JldHVybjt9fWVsc2V7Ly8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4vLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbnZhciBfbmV4dD11bndpbmRXb3JrKGN1cnJlbnQsY29tcGxldGVkV29yayk7Ly8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBsYW5lcy5cbmlmKF9uZXh0IT09bnVsbCl7Ly8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4vLyBiYWNrIGhlcmUgYWdhaW4uXG4vLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbl9uZXh0LmZsYWdzJj1Ib3N0RWZmZWN0TWFzazt3b3JrSW5Qcm9ncmVzcz1fbmV4dDtyZXR1cm47fWlmKChjb21wbGV0ZWRXb3JrLm1vZGUmUHJvZmlsZU1vZGUpIT09Tm9Nb2RlKXsvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbnN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yayxmYWxzZSk7Ly8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cbnZhciBhY3R1YWxEdXJhdGlvbj1jb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO3ZhciBjaGlsZD1jb21wbGV0ZWRXb3JrLmNoaWxkO3doaWxlKGNoaWxkIT09bnVsbCl7YWN0dWFsRHVyYXRpb24rPWNoaWxkLmFjdHVhbER1cmF0aW9uO2NoaWxkPWNoaWxkLnNpYmxpbmc7fWNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb249YWN0dWFsRHVyYXRpb247fWlmKHJldHVybkZpYmVyIT09bnVsbCl7Ly8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxucmV0dXJuRmliZXIuZmxhZ3N8PUluY29tcGxldGU7cmV0dXJuRmliZXIuc3VidHJlZUZsYWdzPU5vRmxhZ3M7cmV0dXJuRmliZXIuZGVsZXRpb25zPW51bGw7fWVsc2V7Ly8gV2UndmUgdW53b3VuZCBhbGwgdGhlIHdheSB0byB0aGUgcm9vdC5cbndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdERpZE5vdENvbXBsZXRlO3dvcmtJblByb2dyZXNzPW51bGw7cmV0dXJuO319dmFyIHNpYmxpbmdGaWJlcj1jb21wbGV0ZWRXb3JrLnNpYmxpbmc7aWYoc2libGluZ0ZpYmVyIT09bnVsbCl7Ly8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbndvcmtJblByb2dyZXNzPXNpYmxpbmdGaWJlcjtyZXR1cm47fS8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcbmNvbXBsZXRlZFdvcms9cmV0dXJuRmliZXI7Ly8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxud29ya0luUHJvZ3Jlc3M9Y29tcGxldGVkV29yazt9d2hpbGUoY29tcGxldGVkV29yayE9PW51bGwpOy8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG5pZih3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdEluUHJvZ3Jlc3Mpe3dvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM9Um9vdENvbXBsZXRlZDt9fWZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCxyZWNvdmVyYWJsZUVycm9ycyx0cmFuc2l0aW9ucyl7Ly8gVE9ETzogVGhpcyBubyBsb25nZXIgbWFrZXMgYW55IHNlbnNlLiBXZSBhbHJlYWR5IHdyYXAgdGhlIG11dGF0aW9uIGFuZFxuLy8gbGF5b3V0IHBoYXNlcy4gU2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlLlxudmFyIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3ZhciBwcmV2VHJhbnNpdGlvbj1SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247dHJ5e1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1udWxsO3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO2NvbW1pdFJvb3RJbXBsKHJvb3QscmVjb3ZlcmFibGVFcnJvcnMsdHJhbnNpdGlvbnMscHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO31maW5hbGx5e1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbj1wcmV2VHJhbnNpdGlvbjtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO31yZXR1cm4gbnVsbDt9ZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCxyZWNvdmVyYWJsZUVycm9ycyx0cmFuc2l0aW9ucyxyZW5kZXJQcmlvcml0eUxldmVsKXtkb3svLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbi8vIG1lYW5zIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCB3aWxsIHNvbWV0aW1lcyByZXN1bHQgaW4gYWRkaXRpb25hbFxuLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4vLyBUT0RPOiBNaWdodCBiZSBiZXR0ZXIgaWYgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIGRpZCBub3QgYXV0b21hdGljYWxseVxuLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG5mbHVzaFBhc3NpdmVFZmZlY3RzKCk7fXdoaWxlKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIT09bnVsbCk7Zmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7aWYoKGV4ZWN1dGlvbkNvbnRleHQmKFJlbmRlckNvbnRleHR8Q29tbWl0Q29udGV4dCkpIT09Tm9Db250ZXh0KXt0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO312YXIgZmluaXNoZWRXb3JrPXJvb3QuZmluaXNoZWRXb3JrO3ZhciBsYW5lcz1yb290LmZpbmlzaGVkTGFuZXM7e21hcmtDb21taXRTdGFydGVkKGxhbmVzKTt9aWYoZmluaXNoZWRXb3JrPT09bnVsbCl7e21hcmtDb21taXRTdG9wcGVkKCk7fXJldHVybiBudWxsO31lbHNle3tpZihsYW5lcz09PU5vTGFuZXMpe2Vycm9yKCdyb290LmZpbmlzaGVkTGFuZXMgc2hvdWxkIG5vdCBiZSBlbXB0eSBkdXJpbmcgYSBjb21taXQuIFRoaXMgaXMgYSAnKydidWcgaW4gUmVhY3QuJyk7fX19cm9vdC5maW5pc2hlZFdvcms9bnVsbDtyb290LmZpbmlzaGVkTGFuZXM9Tm9MYW5lcztpZihmaW5pc2hlZFdvcms9PT1yb290LmN1cnJlbnQpe3Rocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcrJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTt9Ly8gY29tbWl0Um9vdCBuZXZlciByZXR1cm5zIGEgY29udGludWF0aW9uOyBpdCBhbHdheXMgZmluaXNoZXMgc3luY2hyb25vdXNseS5cbi8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxucm9vdC5jYWxsYmFja05vZGU9bnVsbDtyb290LmNhbGxiYWNrUHJpb3JpdHk9Tm9MYW5lOy8vIFVwZGF0ZSB0aGUgZmlyc3QgYW5kIGxhc3QgcGVuZGluZyB0aW1lcyBvbiB0aGlzIHJvb3QuIFRoZSBuZXcgZmlyc3Rcbi8vIHBlbmRpbmcgdGltZSBpcyB3aGF0ZXZlciBpcyBsZWZ0IG9uIHRoZSByb290IGZpYmVyLlxudmFyIHJlbWFpbmluZ0xhbmVzPW1lcmdlTGFuZXMoZmluaXNoZWRXb3JrLmxhbmVzLGZpbmlzaGVkV29yay5jaGlsZExhbmVzKTttYXJrUm9vdEZpbmlzaGVkKHJvb3QscmVtYWluaW5nTGFuZXMpO2lmKHJvb3Q9PT13b3JrSW5Qcm9ncmVzc1Jvb3Qpey8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbndvcmtJblByb2dyZXNzUm9vdD1udWxsO3dvcmtJblByb2dyZXNzPW51bGw7d29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM9Tm9MYW5lczt9Ly8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbi8vIERvIHRoaXMgYXMgZWFybHkgYXMgcG9zc2libGUsIHNvIGl0IGlzIHF1ZXVlZCBiZWZvcmUgYW55dGhpbmcgZWxzZSB0aGF0XG4vLyBtaWdodCBnZXQgc2NoZWR1bGVkIGluIHRoZSBjb21taXQgcGhhc2UuIChTZWUgIzE2NzE0Lilcbi8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4vLyBUaGV5J3JlIHJlZHVuZGFudC5cbmlmKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzJlBhc3NpdmVNYXNrKSE9PU5vRmxhZ3N8fChmaW5pc2hlZFdvcmsuZmxhZ3MmUGFzc2l2ZU1hc2spIT09Tm9GbGFncyl7aWYoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKXtyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cz10cnVlOy8vIHRvIHN0b3JlIGl0IGluIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgdW50aWwgdGhleSBnZXQgcHJvY2Vzc2VkXG4vLyBXZSBuZWVkIHRvIHBhc3MgdGhpcyB0aHJvdWdoIGFzIGFuIGFyZ3VtZW50IHRvIGNvbW1pdFJvb3Rcbi8vIGJlY2F1c2Ugd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyBtaWdodCBoYXZlIGNoYW5nZWQgYmV0d2VlblxuLy8gdGhlIHByZXZpb3VzIHJlbmRlciBhbmQgY29tbWl0IGlmIHdlIHRocm90dGxlIHRoZSBjb21taXRcbi8vIHdpdGggc2V0VGltZW91dFxucGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucz10cmFuc2l0aW9ucztzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksZnVuY3Rpb24oKXtmbHVzaFBhc3NpdmVFZmZlY3RzKCk7Ly8gVGhpcyByZW5kZXIgdHJpZ2dlcmVkIHBhc3NpdmUgZWZmZWN0czogcmVsZWFzZSB0aGUgcm9vdCBjYWNoZSBwb29sXG4vLyAqYWZ0ZXIqIHBhc3NpdmUgZWZmZWN0cyBmaXJlIHRvIGF2b2lkIGZyZWVpbmcgYSBjYWNoZSBwb29sIHRoYXQgbWF5XG4vLyBiZSByZWZlcmVuY2VkIGJ5IGEgbm9kZSBpbiB0aGUgdHJlZSAoSG9zdFJvb3QsIENhY2hlIGJvdW5kYXJ5IGV0YylcbnJldHVybiBudWxsO30pO319Ly8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBlZmZlY3RzIGluIHRoZSB3aG9sZSB0cmVlLlxuLy8gVE9ETzogVGhpcyBpcyBsZWZ0IG92ZXIgZnJvbSB0aGUgZWZmZWN0IGxpc3QgaW1wbGVtZW50YXRpb24sIHdoZXJlIHdlIGhhZFxuLy8gdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYGZpcnN0RWZmZWN0YCB0byBzYXRpc2Z5IEZsb3cuIEkgdGhpbmsgdGhlXG4vLyBvbmx5IG90aGVyIHJlYXNvbiB0aGlzIG9wdGltaXphdGlvbiBleGlzdHMgaXMgYmVjYXVzZSBpdCBhZmZlY3RzIHByb2ZpbGluZy5cbi8vIFJlY29uc2lkZXIgd2hldGhlciB0aGlzIGlzIG5lY2Vzc2FyeS5cbnZhciBzdWJ0cmVlSGFzRWZmZWN0cz0oZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyYoQmVmb3JlTXV0YXRpb25NYXNrfE11dGF0aW9uTWFza3xMYXlvdXRNYXNrfFBhc3NpdmVNYXNrKSkhPT1Ob0ZsYWdzO3ZhciByb290SGFzRWZmZWN0PShmaW5pc2hlZFdvcmsuZmxhZ3MmKEJlZm9yZU11dGF0aW9uTWFza3xNdXRhdGlvbk1hc2t8TGF5b3V0TWFza3xQYXNzaXZlTWFzaykpIT09Tm9GbGFncztpZihzdWJ0cmVlSGFzRWZmZWN0c3x8cm9vdEhhc0VmZmVjdCl7dmFyIHByZXZUcmFuc2l0aW9uPVJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249bnVsbDt2YXIgcHJldmlvdXNQcmlvcml0eT1nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTt2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQ9ZXhlY3V0aW9uQ29udGV4dDtleGVjdXRpb25Db250ZXh0fD1Db21taXRDb250ZXh0Oy8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG5SZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQ9bnVsbDsvLyBUaGUgY29tbWl0IHBoYXNlIGlzIGJyb2tlbiBpbnRvIHNldmVyYWwgc3ViLXBoYXNlcy4gV2UgZG8gYSBzZXBhcmF0ZSBwYXNzXG4vLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuLy8gbGF5b3V0IGVmZmVjdHMsIGFuZCBzbyBvbi5cbi8vIFRoZSBmaXJzdCBwaGFzZSBhIFwiYmVmb3JlIG11dGF0aW9uXCIgcGhhc2UuIFdlIHVzZSB0aGlzIHBoYXNlIHRvIHJlYWQgdGhlXG4vLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbi8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGlzIGNhbGxlZC5cbnZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI9Y29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrKTt7Ly8gTWFyayB0aGUgY3VycmVudCBjb21taXQgdGltZSB0byBiZSBzaGFyZWQgYnkgYWxsIFByb2ZpbGVycyBpbiB0aGlzXG4vLyBiYXRjaC4gVGhpcyBlbmFibGVzIHRoZW0gdG8gYmUgZ3JvdXBlZCBsYXRlci5cbnJlY29yZENvbW1pdFRpbWUoKTt9Y29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsZmluaXNoZWRXb3JrLGxhbmVzKTtyZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7Ly8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbi8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuLy8gY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIGxheW91dCBwaGFzZSwgc28gdGhhdCB0aGUgZmluaXNoZWRcbi8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxucm9vdC5jdXJyZW50PWZpbmlzaGVkV29yazsvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG57bWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKTt9Y29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmsscm9vdCxsYW5lcyk7e21hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO30vLyBvcHBvcnR1bml0eSB0byBwYWludC5cbnJlcXVlc3RQYWludCgpO2V4ZWN1dGlvbkNvbnRleHQ9cHJldkV4ZWN1dGlvbkNvbnRleHQ7Ly8gUmVzZXQgdGhlIHByaW9yaXR5IHRvIHRoZSBwcmV2aW91cyBub24tc3luYyB2YWx1ZS5cbnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247fWVsc2V7Ly8gTm8gZWZmZWN0cy5cbnJvb3QuY3VycmVudD1maW5pc2hlZFdvcms7Ly8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbi8vIG5vIGVmZmVjdHMuXG4vLyBUT0RPOiBNYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byByZXBvcnQgdGhpcy5cbntyZWNvcmRDb21taXRUaW1lKCk7fX12YXIgcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cz1yb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztpZihyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyl7Ly8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4vLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxucm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7cm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM9cm9vdDtwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcz1sYW5lczt9ZWxzZXt7bmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50PTA7cm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcz1udWxsO319Ly8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5yZW1haW5pbmdMYW5lcz1yb290LnBlbmRpbmdMYW5lczsvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuLy8gVE9ETzogVGhpcyBpcyBwYXJ0IG9mIHRoZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGltcGxlbWVudGF0aW9uLiBJdHMgcHVycG9zZVxuLy8gaXMgdG8gZGV0ZWN0IHdoZXRoZXIgc29tZXRoaW5nIG1pZ2h0IGhhdmUgY2FsbGVkIHNldFN0YXRlIGluc2lkZVxuLy8gYGNvbXBvbmVudERpZENhdGNoYC4gVGhlIG1lY2hhbmlzbSBpcyBrbm93biB0byBiZSBmbGF3ZWQgYmVjYXVzZSBgc2V0U3RhdGVgXG4vLyBpbnNpZGUgYGNvbXBvbmVudERpZENhdGNoYCBpcyBpdHNlbGYgZmxhd2VkIOKAlCB0aGF0J3Mgd2h5IHdlIHJlY29tbWVuZFxuLy8gYGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcmAgaW5zdGVhZC4gSG93ZXZlciwgaXQgY291bGQgYmUgaW1wcm92ZWQgYnlcbi8vIGNoZWNraW5nIGlmIHJlbWFpbmluZ0xhbmVzIGluY2x1ZGVzIFN5bmMgd29yaywgaW5zdGVhZCBvZiB3aGV0aGVyIHRoZXJlJ3Ncbi8vIGFueSB3b3JrIHJlbWFpbmluZyBhdCBhbGwgKHdoaWNoIHdvdWxkIGFsc28gaW5jbHVkZSBzdHVmZiBsaWtlIFN1c3BlbnNlXG4vLyByZXRyaWVzIG9yIHRyYW5zaXRpb25zKS4gSXQncyBiZWVuIGxpa2UgdGhpcyBmb3IgYSB3aGlsZSwgdGhvdWdoLCBzbyBmaXhpbmdcbi8vIGl0IHByb2JhYmx5IGlzbid0IHRoYXQgdXJnZW50LlxuaWYocmVtYWluaW5nTGFuZXM9PT1Ob0xhbmVzKXsvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuLy8gZXJyb3IgYm91bmRhcmllcy5cbmxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkPW51bGw7fXtpZighcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyl7Y29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QuY3VycmVudCxmYWxzZSk7fX1vbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxyZW5kZXJQcmlvcml0eUxldmVsKTt7aWYoaXNEZXZUb29sc1ByZXNlbnQpe3Jvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO319e29uQ29tbWl0Um9vdCQxKCk7fS8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbi8vIGFkZGl0aW9uYWwgd29yayBvbiB0aGlzIHJvb3QgaXMgc2NoZWR1bGVkLlxuZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3Qsbm93KCkpO2lmKHJlY292ZXJhYmxlRXJyb3JzIT09bnVsbCl7Ly8gVGhlcmUgd2VyZSBlcnJvcnMgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgcmVjb3ZlcmVkIGZyb20gdGhlbSB3aXRob3V0XG4vLyBuZWVkaW5nIHRvIHN1cmZhY2UgaXQgdG8gdGhlIFVJLiBXZSBsb2cgdGhlbSBoZXJlLlxudmFyIG9uUmVjb3ZlcmFibGVFcnJvcj1yb290Lm9uUmVjb3ZlcmFibGVFcnJvcjtmb3IodmFyIGk9MDtpPHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDtpKyspe3ZhciByZWNvdmVyYWJsZUVycm9yPXJlY292ZXJhYmxlRXJyb3JzW2ldO3ZhciBjb21wb25lbnRTdGFjaz1yZWNvdmVyYWJsZUVycm9yLnN0YWNrO3ZhciBkaWdlc3Q9cmVjb3ZlcmFibGVFcnJvci5kaWdlc3Q7b25SZWNvdmVyYWJsZUVycm9yKHJlY292ZXJhYmxlRXJyb3IudmFsdWUse2NvbXBvbmVudFN0YWNrOmNvbXBvbmVudFN0YWNrLGRpZ2VzdDpkaWdlc3R9KTt9fWlmKGhhc1VuY2F1Z2h0RXJyb3Ipe2hhc1VuY2F1Z2h0RXJyb3I9ZmFsc2U7dmFyIGVycm9yJDE9Zmlyc3RVbmNhdWdodEVycm9yO2ZpcnN0VW5jYXVnaHRFcnJvcj1udWxsO3Rocm93IGVycm9yJDE7fS8vIElmIHRoZSBwYXNzaXZlIGVmZmVjdHMgYXJlIHRoZSByZXN1bHQgb2YgYSBkaXNjcmV0ZSByZW5kZXIsIGZsdXNoIHRoZW1cbi8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuLy8gaW1tZWRpYXRlbHkgb2JzZXJ2YWJsZS4gT3RoZXJ3aXNlLCB3ZSBhc3N1bWUgdGhhdCB0aGV5IGFyZSBub3Rcbi8vIG9yZGVyLWRlcGVuZGVudCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgb2JzZXJ2ZWQgYnkgZXh0ZXJuYWwgc3lzdGVtcywgc28gd2Vcbi8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuLy8gVE9ETzogV2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbm90IHNjaGVkdWxpbmcgdGhlIGNhbGxiYWNrIGVhcmxpZXIuIFNpbmNlIHdlXG4vLyBjdXJyZW50bHkgc2NoZWR1bGUgdGhlIGNhbGxiYWNrIGluIG11bHRpcGxlIHBsYWNlcywgd2lsbCB3YWl0IHVudGlsIHRob3NlXG4vLyBhcmUgY29uc29saWRhdGVkLlxuaWYoaW5jbHVkZXNTb21lTGFuZShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyxTeW5jTGFuZSkmJnJvb3QudGFnIT09TGVnYWN5Um9vdCl7Zmx1c2hQYXNzaXZlRWZmZWN0cygpO30vLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5yZW1haW5pbmdMYW5lcz1yb290LnBlbmRpbmdMYW5lcztpZihpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzLFN5bmNMYW5lKSl7e21hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKTt9Ly8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cbmlmKHJvb3Q9PT1yb290V2l0aE5lc3RlZFVwZGF0ZXMpe25lc3RlZFVwZGF0ZUNvdW50Kys7fWVsc2V7bmVzdGVkVXBkYXRlQ291bnQ9MDtyb290V2l0aE5lc3RlZFVwZGF0ZXM9cm9vdDt9fWVsc2V7bmVzdGVkVXBkYXRlQ291bnQ9MDt9Ly8gSWYgbGF5b3V0IHdvcmsgd2FzIHNjaGVkdWxlZCwgZmx1c2ggaXQgbm93LlxuZmx1c2hTeW5jQ2FsbGJhY2tzKCk7e21hcmtDb21taXRTdG9wcGVkKCk7fXJldHVybiBudWxsO31mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCl7Ly8gUmV0dXJucyB3aGV0aGVyIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQuXG4vLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcbi8vIHByb2JhYmx5IGp1c3QgY29tYmluZSB0aGUgdHdvIGZ1bmN0aW9ucy4gSSBiZWxpZXZlIHRoZXkgd2VyZSBvbmx5IHNlcGFyYXRlXG4vLyBpbiB0aGUgZmlyc3QgcGxhY2UgYmVjYXVzZSB3ZSB1c2VkIHRvIHdyYXAgaXQgd2l0aFxuLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG4vLyBwcmlvcml0eSB3aXRoaW4gUmVhY3QgaXRzZWxmLCBzbyB3ZSBjYW4gbXV0YXRlIHRoZSB2YXJpYWJsZSBkaXJlY3RseS5cbmlmKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIT09bnVsbCl7dmFyIHJlbmRlclByaW9yaXR5PWxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKTt2YXIgcHJpb3JpdHk9bG93ZXJFdmVudFByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5LHJlbmRlclByaW9yaXR5KTt2YXIgcHJldlRyYW5zaXRpb249UmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO3ZhciBwcmV2aW91c1ByaW9yaXR5PWdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO3RyeXtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249bnVsbDtzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJpb3JpdHkpO3JldHVybiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpO31maW5hbGx5e3NldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb249cHJldlRyYW5zaXRpb247Ly8gT25jZSBwYXNzaXZlIGVmZmVjdHMgaGF2ZSBydW4gZm9yIHRoZSB0cmVlIC0gZ2l2aW5nIGNvbXBvbmVudHMgYVxufX1yZXR1cm4gZmFsc2U7fWZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpYmVyKXt7cGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMucHVzaChmaWJlcik7aWYoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKXtyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cz10cnVlO3NjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSxmdW5jdGlvbigpe2ZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtyZXR1cm4gbnVsbDt9KTt9fX1mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpe2lmKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzPT09bnVsbCl7cmV0dXJuIGZhbHNlO30vLyBDYWNoZSBhbmQgY2xlYXIgdGhlIHRyYW5zaXRpb25zIGZsYWdcbnZhciB0cmFuc2l0aW9ucz1wZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO3BlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM9bnVsbDt2YXIgcm9vdD1yb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0czt2YXIgbGFuZXM9cGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7cm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM9bnVsbDsvLyBUT0RPOiBUaGlzIGlzIHNvbWV0aW1lcyBvdXQgb2Ygc3luYyB3aXRoIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLlxuLy8gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gSXQncyBub3QgY2F1c2luZyBhbnkga25vd24gaXNzdWVzIChwcm9iYWJseVxuLy8gYmVjYXVzZSBpdCdzIG9ubHkgdXNlZCBmb3IgcHJvZmlsaW5nKSwgYnV0IGl0J3MgYSByZWZhY3RvciBoYXphcmQuXG5wZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcz1Ob0xhbmVzO2lmKChleGVjdXRpb25Db250ZXh0JihSZW5kZXJDb250ZXh0fENvbW1pdENvbnRleHQpKSE9PU5vQ29udGV4dCl7dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLicpO317aXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzPXRydWU7ZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cz1mYWxzZTt9e21hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO312YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQ9ZXhlY3V0aW9uQ29udGV4dDtleGVjdXRpb25Db250ZXh0fD1Db21taXRDb250ZXh0O2NvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyhyb290LmN1cnJlbnQpO2NvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCxyb290LmN1cnJlbnQsbGFuZXMsdHJhbnNpdGlvbnMpOy8vIFRPRE86IE1vdmUgdG8gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c1xue3ZhciBwcm9maWxlckVmZmVjdHM9cGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHM7cGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHM9W107Zm9yKHZhciBpPTA7aTxwcm9maWxlckVmZmVjdHMubGVuZ3RoO2krKyl7dmFyIF9maWJlcj1wcm9maWxlckVmZmVjdHNbaV07Y29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhyb290LF9maWJlcik7fX17bWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO317Y29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QuY3VycmVudCx0cnVlKTt9ZXhlY3V0aW9uQ29udGV4dD1wcmV2RXhlY3V0aW9uQ29udGV4dDtmbHVzaFN5bmNDYWxsYmFja3MoKTt7Ly8gSWYgYWRkaXRpb25hbCBwYXNzaXZlIGVmZmVjdHMgd2VyZSBzY2hlZHVsZWQsIGluY3JlbWVudCBhIGNvdW50ZXIuIElmIHRoaXNcbi8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cbmlmKGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMpe2lmKHJvb3Q9PT1yb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzKXtuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrKzt9ZWxzZXtuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQ9MDtyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzPXJvb3Q7fX1lbHNle25lc3RlZFBhc3NpdmVVcGRhdGVDb3VudD0wO31pc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHM9ZmFsc2U7ZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cz1mYWxzZTt9Ly8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5vblBvc3RDb21taXRSb290KHJvb3QpO3t2YXIgc3RhdGVOb2RlPXJvb3QuY3VycmVudC5zdGF0ZU5vZGU7c3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uPTA7c3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbj0wO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSl7cmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIT09bnVsbCYmbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTt9ZnVuY3Rpb24gbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZChpbnN0YW5jZSl7aWYobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQ9PT1udWxsKXtsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZD1uZXcgU2V0KFtpbnN0YW5jZV0pO31lbHNle2xlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7fX1mdW5jdGlvbiBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3IoZXJyb3Ipe2lmKCFoYXNVbmNhdWdodEVycm9yKXtoYXNVbmNhdWdodEVycm9yPXRydWU7Zmlyc3RVbmNhdWdodEVycm9yPWVycm9yO319dmFyIG9uVW5jYXVnaHRFcnJvcj1wcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3I7ZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLHNvdXJjZUZpYmVyLGVycm9yKXt2YXIgZXJyb3JJbmZvPWNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLHNvdXJjZUZpYmVyKTt2YXIgdXBkYXRlPWNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIsZXJyb3JJbmZvLFN5bmNMYW5lKTt2YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKHJvb3RGaWJlcix1cGRhdGUsU3luY0xhbmUpO3ZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO2lmKHJvb3QhPT1udWxsKXttYXJrUm9vdFVwZGF0ZWQocm9vdCxTeW5jTGFuZSxldmVudFRpbWUpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGV2ZW50VGltZSk7fX1mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlcixuZWFyZXN0TW91bnRlZEFuY2VzdG9yLGVycm9yJDEpe3tyZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IkMSk7c2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTt9aWYoc291cmNlRmliZXIudGFnPT09SG9zdFJvb3Qpey8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3Rcbi8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbmNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLHNvdXJjZUZpYmVyLGVycm9yJDEpO3JldHVybjt9dmFyIGZpYmVyPW51bGw7e2ZpYmVyPW5lYXJlc3RNb3VudGVkQW5jZXN0b3I7fXdoaWxlKGZpYmVyIT09bnVsbCl7aWYoZmliZXIudGFnPT09SG9zdFJvb3Qpe2NhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KGZpYmVyLHNvdXJjZUZpYmVyLGVycm9yJDEpO3JldHVybjt9ZWxzZSBpZihmaWJlci50YWc9PT1DbGFzc0NvbXBvbmVudCl7dmFyIGN0b3I9ZmliZXIudHlwZTt2YXIgaW5zdGFuY2U9ZmliZXIuc3RhdGVOb2RlO2lmKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcj09PSdmdW5jdGlvbid8fHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaD09PSdmdW5jdGlvbicmJiFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSl7dmFyIGVycm9ySW5mbz1jcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLHNvdXJjZUZpYmVyKTt2YXIgdXBkYXRlPWNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsZXJyb3JJbmZvLFN5bmNMYW5lKTt2YXIgcm9vdD1lbnF1ZXVlVXBkYXRlKGZpYmVyLHVwZGF0ZSxTeW5jTGFuZSk7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7aWYocm9vdCE9PW51bGwpe21hcmtSb290VXBkYXRlZChyb290LFN5bmNMYW5lLGV2ZW50VGltZSk7ZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsZXZlbnRUaW1lKTt9cmV0dXJuO319ZmliZXI9ZmliZXIucmV0dXJuO317Ly8gVE9ETzogVW50aWwgd2UgcmUtbGFuZCBza2lwVW5tb3VudGVkQm91bmRhcmllcyAoc2VlICMyMDE0NyksIHRoaXMgd2FybmluZ1xuLy8gd2lsbCBmaXJlIGZvciBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGRlc3Ryb3kgZnVuY3Rpb25zIGluc2lkZSBkZWxldGVkXG4vLyB0cmVlcy4gV2hhdCBpdCBzaG91bGQgaW5zdGVhZCBkbyBpcyBwcm9wYWdhdGUgdGhlIGVycm9yIHRvIHRoZSBwYXJlbnQgb2Zcbi8vIHRoZSBkZWxldGVkIHRyZWUuIEluIHRoZSBtZWFudGltZSwgZG8gbm90IGFkZCB0aGlzIHdhcm5pbmcgdG8gdGhlXG4vLyBhbGxvd2xpc3Q7IHRoaXMgaXMgb25seSBmb3Igb3VyIGludGVybmFsIHVzZS5cbmVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgJysnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIExpa2VseSAnKydjYXVzZXMgaW5jbHVkZSBkZWxldGluZyB0aGUgc2FtZSBmaWJlciBtb3JlIHRoYW4gb25jZSwgY29tbWl0dGluZyBhbiAnKydhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG4nKydFcnJvciBtZXNzYWdlOlxcblxcbiVzJyxlcnJvciQxKTt9fWZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3Qsd2FrZWFibGUscGluZ2VkTGFuZXMpe3ZhciBwaW5nQ2FjaGU9cm9vdC5waW5nQ2FjaGU7aWYocGluZ0NhY2hlIT09bnVsbCl7Ly8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbi8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbnBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO312YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTttYXJrUm9vdFBpbmdlZChyb290LHBpbmdlZExhbmVzKTt3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KTtpZih3b3JrSW5Qcm9ncmVzc1Jvb3Q9PT1yb290JiZpc1N1YnNldE9mTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMscGluZ2VkTGFuZXMpKXsvLyBSZWNlaXZlZCBhIHBpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHkgbGV2ZWwgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5XG4vLyByZW5kZXJpbmcuIFdlIG1pZ2h0IHdhbnQgdG8gcmVzdGFydCB0aGlzIHJlbmRlci4gVGhpcyBzaG91bGQgbWlycm9yXG4vLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuLy8gVE9ETzogSWYgd2UncmUgcmVuZGVyaW5nIHN5bmMgZWl0aGVyIGR1ZSB0byBTeW5jLCBCYXRjaGVkIG9yIGV4cGlyZWQsXG4vLyB3ZSBzaG91bGQgcHJvYmFibHkgbmV2ZXIgcmVzdGFydC5cbi8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4vLyBzbyB3ZSBjYW4gYWx3YXlzIHJlc3RhcnQuXG5pZih3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzPT09Um9vdFN1c3BlbmRlZFdpdGhEZWxheXx8d29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cz09PVJvb3RTdXNwZW5kZWQmJmluY2x1ZGVzT25seVJldHJpZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpJiZub3coKS1nbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lPEZBTExCQUNLX1RIUk9UVExFX01TKXsvLyBSZXN0YXJ0IGZyb20gdGhlIHJvb3QuXG5wcmVwYXJlRnJlc2hTdGFjayhyb290LE5vTGFuZXMpO31lbHNley8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbi8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG53b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcz1tZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLHBpbmdlZExhbmVzKTt9fWVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGV2ZW50VGltZSk7fWZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLHJldHJ5TGFuZSl7Ly8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuLy8gcHJldmlvdXNseSB3YXMgcmVuZGVyZWQgaW4gaXRzIGZhbGxiYWNrIHN0YXRlLiBPbmUgb2YgdGhlIHByb21pc2VzIHRoYXRcbi8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4vLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBsYW5lcy5cbmlmKHJldHJ5TGFuZT09PU5vTGFuZSl7Ly8gVE9ETzogQXNzaWduIHRoaXMgdG8gYHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lYD8gdG8gYXZvaWRcbi8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cbnJldHJ5TGFuZT1yZXF1ZXN0UmV0cnlMYW5lKGJvdW5kYXJ5RmliZXIpO30vLyBUT0RPOiBTcGVjaWFsIGNhc2UgaWRsZSBwcmlvcml0eT9cbnZhciBldmVudFRpbWU9cmVxdWVzdEV2ZW50VGltZSgpO3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLHJldHJ5TGFuZSk7aWYocm9vdCE9PW51bGwpe21hcmtSb290VXBkYXRlZChyb290LHJldHJ5TGFuZSxldmVudFRpbWUpO2Vuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LGV2ZW50VGltZSk7fX1mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpe3ZhciBzdXNwZW5zZVN0YXRlPWJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTt2YXIgcmV0cnlMYW5lPU5vTGFuZTtpZihzdXNwZW5zZVN0YXRlIT09bnVsbCl7cmV0cnlMYW5lPXN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO31yZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlcixyZXRyeUxhbmUpO31mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLHdha2VhYmxlKXt2YXIgcmV0cnlMYW5lPU5vTGFuZTsvLyBEZWZhdWx0XG52YXIgcmV0cnlDYWNoZTtzd2l0Y2goYm91bmRhcnlGaWJlci50YWcpe2Nhc2UgU3VzcGVuc2VDb21wb25lbnQ6cmV0cnlDYWNoZT1ib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTt2YXIgc3VzcGVuc2VTdGF0ZT1ib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7aWYoc3VzcGVuc2VTdGF0ZSE9PW51bGwpe3JldHJ5TGFuZT1zdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTt9YnJlYWs7Y2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6cmV0cnlDYWNoZT1ib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcignUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gJysnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTt9aWYocmV0cnlDYWNoZSE9PW51bGwpey8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4vLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG5yZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7fXJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLHJldHJ5TGFuZSk7fS8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5mdW5jdGlvbiBqbmQodGltZUVsYXBzZWQpe3JldHVybiB0aW1lRWxhcHNlZDwxMjA/MTIwOnRpbWVFbGFwc2VkPDQ4MD80ODA6dGltZUVsYXBzZWQ8MTA4MD8xMDgwOnRpbWVFbGFwc2VkPDE5MjA/MTkyMDp0aW1lRWxhcHNlZDwzMDAwPzMwMDA6dGltZUVsYXBzZWQ8NDMyMD80MzIwOmNlaWwodGltZUVsYXBzZWQvMTk2MCkqMTk2MDt9ZnVuY3Rpb24gY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCl7aWYobmVzdGVkVXBkYXRlQ291bnQ+TkVTVEVEX1VQREFURV9MSU1JVCl7bmVzdGVkVXBkYXRlQ291bnQ9MDtyb290V2l0aE5lc3RlZFVwZGF0ZXM9bnVsbDt0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnKydyZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yICcrJ2NvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gJysncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTt9e2lmKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudD5ORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpe25lc3RlZFBhc3NpdmVVcGRhdGVDb3VudD0wO3Jvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXM9bnVsbDtlcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcrXCJjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IFwiKydoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnKydldmVyeSByZW5kZXIuJyk7fX19ZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCl7e1JlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTt7UmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTt9fX1mdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoZmliZXIsaGFzUGFzc2l2ZUVmZmVjdHMpe3svLyBUT0RPIChTdHJpY3RFZmZlY3RzKSBTaG91bGQgd2Ugc2V0IGEgbWFya2VyIG9uIHRoZSByb290IGlmIGl0IGNvbnRhaW5zIHN0cmljdCBlZmZlY3RzXG4vLyBzbyB3ZSBkb24ndCB0cmF2ZXJzZSB1bm5lY2Vzc2FyaWx5PyBzaW1pbGFyIHRvIHN1YnRyZWVGbGFncyBidXQganVzdCBhdCB0aGUgcm9vdCBsZXZlbC5cbi8vIE1heWJlIG5vdCBhIGJpZyBkZWFsIHNpbmNlIHRoaXMgaXMgREVWIG9ubHkgYmVoYXZpb3IuXG5zZXRDdXJyZW50RmliZXIoZmliZXIpO2ludm9rZUVmZmVjdHNJbkRldihmaWJlcixNb3VudExheW91dERldixpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYpO2lmKGhhc1Bhc3NpdmVFZmZlY3RzKXtpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsTW91bnRQYXNzaXZlRGV2LGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYpO31pbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsTW91bnRMYXlvdXREZXYsaW52b2tlTGF5b3V0RWZmZWN0TW91bnRJbkRFVik7aWYoaGFzUGFzc2l2ZUVmZmVjdHMpe2ludm9rZUVmZmVjdHNJbkRldihmaWJlcixNb3VudFBhc3NpdmVEZXYsaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYpO31yZXNldEN1cnJlbnRGaWJlcigpO319ZnVuY3Rpb24gaW52b2tlRWZmZWN0c0luRGV2KGZpcnN0Q2hpbGQsZmliZXJGbGFncyxpbnZva2VFZmZlY3RGbil7ey8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG52YXIgY3VycmVudD1maXJzdENoaWxkO3ZhciBzdWJ0cmVlUm9vdD1udWxsO3doaWxlKGN1cnJlbnQhPT1udWxsKXt2YXIgcHJpbWFyeVN1YnRyZWVGbGFnPWN1cnJlbnQuc3VidHJlZUZsYWdzJmZpYmVyRmxhZ3M7aWYoY3VycmVudCE9PXN1YnRyZWVSb290JiZjdXJyZW50LmNoaWxkIT09bnVsbCYmcHJpbWFyeVN1YnRyZWVGbGFnIT09Tm9GbGFncyl7Y3VycmVudD1jdXJyZW50LmNoaWxkO31lbHNle2lmKChjdXJyZW50LmZsYWdzJmZpYmVyRmxhZ3MpIT09Tm9GbGFncyl7aW52b2tlRWZmZWN0Rm4oY3VycmVudCk7fWlmKGN1cnJlbnQuc2libGluZyE9PW51bGwpe2N1cnJlbnQ9Y3VycmVudC5zaWJsaW5nO31lbHNle2N1cnJlbnQ9c3VidHJlZVJvb3Q9Y3VycmVudC5yZXR1cm47fX19fX12YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudD1udWxsO2Z1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpe3tpZigoZXhlY3V0aW9uQ29udGV4dCZSZW5kZXJDb250ZXh0KSE9PU5vQ29udGV4dCl7Ly8gV2UgbGV0IHRoZSBvdGhlciB3YXJuaW5nIGFib3V0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGRlYWwgd2l0aCB0aGlzIG9uZS5cbnJldHVybjt9aWYoIShmaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKSl7cmV0dXJuO312YXIgdGFnPWZpYmVyLnRhZztpZih0YWchPT1JbmRldGVybWluYXRlQ29tcG9uZW50JiZ0YWchPT1Ib3N0Um9vdCYmdGFnIT09Q2xhc3NDb21wb25lbnQmJnRhZyE9PUZ1bmN0aW9uQ29tcG9uZW50JiZ0YWchPT1Gb3J3YXJkUmVmJiZ0YWchPT1NZW1vQ29tcG9uZW50JiZ0YWchPT1TaW1wbGVNZW1vQ29tcG9uZW50KXsvLyBPbmx5IHdhcm4gZm9yIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLCBub3QgaW50ZXJuYWwgb25lcyBsaWtlIFN1c3BlbnNlLlxucmV0dXJuO30vLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4vLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxudmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdSZWFjdENvbXBvbmVudCc7aWYoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCE9PW51bGwpe2lmKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKXtyZXR1cm47fWRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO31lbHNle2RpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQ9bmV3IFNldChbY29tcG9uZW50TmFtZV0pO312YXIgcHJldmlvdXNGaWJlcj1jdXJyZW50O3RyeXtzZXRDdXJyZW50RmliZXIoZmliZXIpO2Vycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIrJ1RoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0ICcrJ2FzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byAnKyd1c2VFZmZlY3QgaW5zdGVhZC4nKTt9ZmluYWxseXtpZihwcmV2aW91c0ZpYmVyKXtzZXRDdXJyZW50RmliZXIoZmliZXIpO31lbHNle3Jlc2V0Q3VycmVudEZpYmVyKCk7fX19fXZhciBiZWdpbldvcmskMTt7dmFyIGR1bW15RmliZXI9bnVsbDtiZWdpbldvcmskMT1mdW5jdGlvbihjdXJyZW50LHVuaXRPZldvcmssbGFuZXMpey8vIElmIGEgY29tcG9uZW50IHRocm93cyBhbiBlcnJvciwgd2UgcmVwbGF5IGl0IGFnYWluIGluIGEgc3luY2hyb25vdXNseVxuLy8gZGlzcGF0Y2hlZCBldmVudCwgc28gdGhhdCB0aGUgZGVidWdnZXIgd2lsbCB0cmVhdCBpdCBhcyBhbiB1bmNhdWdodFxuLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbi8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNvcHkgdGhlIHdvcmstaW4tcHJvZ3Jlc3Mgb250byBhIGR1bW15XG4vLyBmaWJlci4gSWYgYmVnaW5Xb3JrIHRocm93cywgd2UnbGwgdXNlIHRoaXMgdG8gcmVzZXQgdGhlIHN0YXRlLlxudmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5PWFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKGR1bW15RmliZXIsdW5pdE9mV29yayk7dHJ5e3JldHVybiBiZWdpbldvcmsoY3VycmVudCx1bml0T2ZXb3JrLGxhbmVzKTt9Y2F0Y2gob3JpZ2luYWxFcnJvcil7aWYoZGlkU3VzcGVuZE9yRXJyb3JXaGlsZUh5ZHJhdGluZ0RFVigpfHxvcmlnaW5hbEVycm9yIT09bnVsbCYmdHlwZW9mIG9yaWdpbmFsRXJyb3I9PT0nb2JqZWN0JyYmdHlwZW9mIG9yaWdpbmFsRXJyb3IudGhlbj09PSdmdW5jdGlvbicpey8vIERvbid0IHJlcGxheSBwcm9taXNlcy5cbi8vIERvbid0IHJlcGxheSBlcnJvcnMgaWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgaGF2ZSBhbHJlYWR5IHN1c3BlbmRlZCBvciBoYW5kbGVkIGFuIGVycm9yXG50aHJvdyBvcmlnaW5hbEVycm9yO30vLyBLZWVwIHRoaXMgY29kZSBpbiBzeW5jIHdpdGggaGFuZGxlRXJyb3I7IGFueSBjaGFuZ2VzIGhlcmUgbXVzdCBoYXZlXG4vLyBjb3JyZXNwb25kaW5nIGNoYW5nZXMgdGhlcmUuXG5yZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtyZXNldEhvb2tzQWZ0ZXJUaHJvdygpOy8vIERvbid0IHJlc2V0IGN1cnJlbnQgZGVidWcgZmliZXIsIHNpbmNlIHdlJ3JlIGFib3V0IHRvIHdvcmsgb24gdGhlXG4vLyBzYW1lIGZpYmVyIGFnYWluLlxuLy8gVW53aW5kIHRoZSBmYWlsZWQgc3RhY2sgZnJhbWVcbnVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LHVuaXRPZldvcmspOy8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodW5pdE9mV29yayxvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7aWYodW5pdE9mV29yay5tb2RlJlByb2ZpbGVNb2RlKXsvLyBSZXNldCB0aGUgcHJvZmlsZXIgdGltZXIuXG5zdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7fS8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCxiZWdpbldvcmssbnVsbCxjdXJyZW50LHVuaXRPZldvcmssbGFuZXMpO2lmKGhhc0NhdWdodEVycm9yKCkpe3ZhciByZXBsYXlFcnJvcj1jbGVhckNhdWdodEVycm9yKCk7aWYodHlwZW9mIHJlcGxheUVycm9yPT09J29iamVjdCcmJnJlcGxheUVycm9yIT09bnVsbCYmcmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZyYmdHlwZW9mIG9yaWdpbmFsRXJyb3I9PT0nb2JqZWN0JyYmb3JpZ2luYWxFcnJvciE9PW51bGwmJiFvcmlnaW5hbEVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpey8vIElmIHN1cHByZXNzZWQsIGxldCB0aGUgZmxhZyBjYXJyeSBvdmVyIHRvIHRoZSBvcmlnaW5hbCBlcnJvciB3aGljaCBpcyB0aGUgb25lIHdlJ2xsIHJldGhyb3cuXG5vcmlnaW5hbEVycm9yLl9zdXBwcmVzc0xvZ2dpbmc9dHJ1ZTt9fS8vIFdlIGFsd2F5cyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gY2FzZSB0aGUgc2Vjb25kIHJlbmRlciBwYXNzIGlzIG5vdCBpZGVtcG90ZW50LlxuLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGEgbWVtb2l6ZWQgZnVuY3Rpb24gb3IgQ29tbW9uSlMgbW9kdWxlIGRvZXNuJ3QgdGhyb3cgYWZ0ZXIgZmlyc3QgaW52b2NhdGlvbi5cbnRocm93IG9yaWdpbmFsRXJyb3I7fX07fXZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcj1mYWxzZTt2YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O3tkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQ9bmV3IFNldCgpO31mdW5jdGlvbiB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcil7e2lmKGlzUmVuZGVyaW5nJiYhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpe3N3aXRjaChmaWJlci50YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBGb3J3YXJkUmVmOmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDp7dmFyIHJlbmRlcmluZ0NvbXBvbmVudE5hbWU9d29ya0luUHJvZ3Jlc3MmJmdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpfHwnVW5rbm93bic7Ly8gRGVkdXBlIGJ5IHRoZSByZW5kZXJpbmcgY29tcG9uZW50IGJlY2F1c2UgaXQncyB0aGUgb25lIHRoYXQgbmVlZHMgdG8gYmUgZml4ZWQuXG52YXIgZGVkdXBlS2V5PXJlbmRlcmluZ0NvbXBvbmVudE5hbWU7aWYoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5oYXMoZGVkdXBlS2V5KSl7ZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChkZWR1cGVLZXkpO3ZhciBzZXRTdGF0ZUNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdVbmtub3duJztlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJysnZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgJysnZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NldHN0YXRlLWluLXJlbmRlcicsc2V0U3RhdGVDb21wb25lbnROYW1lLHJlbmRlcmluZ0NvbXBvbmVudE5hbWUscmVuZGVyaW5nQ29tcG9uZW50TmFtZSk7fWJyZWFrO31jYXNlIENsYXNzQ29tcG9uZW50OntpZighZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIpe2Vycm9yKCdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcrJ3dpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgJysnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO2RpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyPXRydWU7fWJyZWFrO319fX19ZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LGxhbmVzKXt7aWYoaXNEZXZUb29sc1ByZXNlbnQpe3ZhciBtZW1vaXplZFVwZGF0ZXJzPXJvb3QubWVtb2l6ZWRVcGRhdGVyczttZW1vaXplZFVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24oc2NoZWR1bGluZ0ZpYmVyKXthZGRGaWJlclRvTGFuZXNNYXAocm9vdCxzY2hlZHVsaW5nRmliZXIsbGFuZXMpO30pOy8vIFRoaXMgZnVuY3Rpb24gaW50ZW50aW9uYWxseSBkb2VzIG5vdCBjbGVhciBtZW1vaXplZCB1cGRhdGVycy5cbi8vIFRob3NlIG1heSBzdGlsbCBiZSByZWxldmFudCB0byB0aGUgY3VycmVudCBjb21taXRcbi8vIGFuZCBhIGZ1dHVyZSBvbmUgKGUuZy4gU3VzcGVuc2UpLlxufX19dmFyIGZha2VBY3RDYWxsYmFja05vZGU9e307ZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayQxKHByaW9yaXR5TGV2ZWwsY2FsbGJhY2spe3svLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBieXBhc3MgU2NoZWR1bGVyIGFuZCBwdXNoIHRvXG4vLyB0aGUgYGFjdGAgcXVldWUgaW5zdGVhZC5cbnZhciBhY3RRdWV1ZT1SZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQ7aWYoYWN0UXVldWUhPT1udWxsKXthY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKTtyZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTt9ZWxzZXtyZXR1cm4gc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLGNhbGxiYWNrKTt9fX1mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSl7aWYoY2FsbGJhY2tOb2RlPT09ZmFrZUFjdENhbGxiYWNrTm9kZSl7cmV0dXJuO30vLyBJbiBwcm9kdWN0aW9uLCBhbHdheXMgY2FsbCBTY2hlZHVsZXIuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBvdXQuXG5yZXR1cm4gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTt9ZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCl7Ly8gTmV2ZXIgZm9yY2UgZmx1c2ggaW4gcHJvZHVjdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZ2V0IHN0cmlwcGVkIG91dC5cbnJldHVybiBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQhPT1udWxsO31mdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpe3tpZihmaWJlci5tb2RlJkNvbmN1cnJlbnRNb2RlKXtpZighaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSl7Ly8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxucmV0dXJuO319ZWxzZXsvLyBMZWdhY3kgbW9kZSBoYXMgYWRkaXRpb25hbCBjYXNlcyB3aGVyZSB3ZSBzdXBwcmVzcyBhIHdhcm5pbmcuXG5pZighaXNMZWdhY3lBY3RFbnZpcm9ubWVudCgpKXsvLyBOb3QgaW4gYW4gYWN0IGVudmlyb25tZW50LiBObyBuZWVkIHRvIHdhcm4uXG5yZXR1cm47fWlmKGV4ZWN1dGlvbkNvbnRleHQhPT1Ob0NvbnRleHQpey8vIExlZ2FjeSBtb2RlIGRvZXNuJ3Qgd2FybiBpZiB0aGUgdXBkYXRlIGlzIGJhdGNoZWQsIGkuZS5cbi8vIGJhdGNoZWRVcGRhdGVzIG9yIGZsdXNoU3luYy5cbnJldHVybjt9aWYoZmliZXIudGFnIT09RnVuY3Rpb25Db21wb25lbnQmJmZpYmVyLnRhZyE9PUZvcndhcmRSZWYmJmZpYmVyLnRhZyE9PVNpbXBsZU1lbW9Db21wb25lbnQpey8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHByZS1ob29rcyBjb2RlLCBsZWdhY3kgbW9kZSBvbmx5XG4vLyB3YXJucyBmb3IgdXBkYXRlcyB0aGF0IG9yaWdpbmF0ZSBmcm9tIGEgaG9vay5cbnJldHVybjt9fWlmKFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudD09PW51bGwpe3ZhciBwcmV2aW91c0ZpYmVyPWN1cnJlbnQ7dHJ5e3NldEN1cnJlbnRGaWJlcihmaWJlcik7ZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nKydXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJysnd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicrJ2FjdCgoKSA9PiB7XFxuJysnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicrJ30pO1xcbicrJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJytcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIrJ2luIHRoZSBicm93c2VyLicrJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JyxnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSk7fWZpbmFsbHl7aWYocHJldmlvdXNGaWJlcil7c2V0Q3VycmVudEZpYmVyKGZpYmVyKTt9ZWxzZXtyZXNldEN1cnJlbnRGaWJlcigpO319fX19ZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCl7e2lmKHJvb3QudGFnIT09TGVnYWN5Um9vdCYmaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSYmUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50PT09bnVsbCl7ZXJyb3IoJ0Egc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCAnKyd3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJysnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgJysnaW50byBhY3QoLi4uKTpcXG5cXG4nKydhY3QoKCkgPT4ge1xcbicrJyAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG4nKyd9KTtcXG4nKycvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicrXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiKydpbiB0aGUgYnJvd3Nlci4nKycgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcpO319fWZ1bmN0aW9uIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChpc1J1bm5pbmcpe3tpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3Q9aXNSdW5uaW5nO319LyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2RlcyAqL3ZhciByZXNvbHZlRmFtaWx5PW51bGw7Ly8gJEZsb3dGaXhNZSBGbG93IGdldHMgY29uZnVzZWQgYnkgYSBXZWFrU2V0IGZlYXR1cmUgY2hlY2sgYmVsb3cuXG52YXIgZmFpbGVkQm91bmRhcmllcz1udWxsO3ZhciBzZXRSZWZyZXNoSGFuZGxlcj1mdW5jdGlvbihoYW5kbGVyKXt7cmVzb2x2ZUZhbWlseT1oYW5kbGVyO319O2Z1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKXt7aWYocmVzb2x2ZUZhbWlseT09PW51bGwpey8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG5yZXR1cm4gdHlwZTt9dmFyIGZhbWlseT1yZXNvbHZlRmFtaWx5KHR5cGUpO2lmKGZhbWlseT09PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGU7fS8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxucmV0dXJuIGZhbWlseS5jdXJyZW50O319ZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpey8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxucmV0dXJuIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTt9ZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSl7e2lmKHJlc29sdmVGYW1pbHk9PT1udWxsKXsvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxucmV0dXJuIHR5cGU7fXZhciBmYW1pbHk9cmVzb2x2ZUZhbWlseSh0eXBlKTtpZihmYW1pbHk9PT11bmRlZmluZWQpey8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHJlYWwgZm9yd2FyZFJlZi4gRG9uJ3Qgd2FudCB0byBjcmFzaCBlYXJseS5cbmlmKHR5cGUhPT1udWxsJiZ0eXBlIT09dW5kZWZpbmVkJiZ0eXBlb2YgdHlwZS5yZW5kZXI9PT0nZnVuY3Rpb24nKXsvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuLy8gYnV0IGl0J3MgcG9zc2libGUgdGhhdCB3ZSBvbmx5IGhhdmUgaXRzIGlubmVyIHJlbmRlciBmdW5jdGlvbiBpbiB0aGUgbWFwLlxuLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG52YXIgY3VycmVudFJlbmRlcj1yZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpO2lmKHR5cGUucmVuZGVyIT09Y3VycmVudFJlbmRlcil7dmFyIHN5bnRoZXRpY1R5cGU9eyQkdHlwZW9mOlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUscmVuZGVyOmN1cnJlbnRSZW5kZXJ9O2lmKHR5cGUuZGlzcGxheU5hbWUhPT11bmRlZmluZWQpe3N5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWU9dHlwZS5kaXNwbGF5TmFtZTt9cmV0dXJuIHN5bnRoZXRpY1R5cGU7fX1yZXR1cm4gdHlwZTt9Ly8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5yZXR1cm4gZmFtaWx5LmN1cnJlbnQ7fX1mdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsZWxlbWVudCl7e2lmKHJlc29sdmVGYW1pbHk9PT1udWxsKXsvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxucmV0dXJuIGZhbHNlO312YXIgcHJldlR5cGU9ZmliZXIuZWxlbWVudFR5cGU7dmFyIG5leHRUeXBlPWVsZW1lbnQudHlwZTsvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxudmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzPWZhbHNlO3ZhciAkJHR5cGVvZk5leHRUeXBlPXR5cGVvZiBuZXh0VHlwZT09PSdvYmplY3QnJiZuZXh0VHlwZSE9PW51bGw/bmV4dFR5cGUuJCR0eXBlb2Y6bnVsbDtzd2l0Y2goZmliZXIudGFnKXtjYXNlIENsYXNzQ29tcG9uZW50OntpZih0eXBlb2YgbmV4dFR5cGU9PT0nZnVuY3Rpb24nKXtuZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31icmVhazt9Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDp7aWYodHlwZW9mIG5leHRUeXBlPT09J2Z1bmN0aW9uJyl7bmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9ZWxzZSBpZigkJHR5cGVvZk5leHRUeXBlPT09UkVBQ1RfTEFaWV9UWVBFKXsvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbi8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbi8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxubmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9YnJlYWs7fWNhc2UgRm9yd2FyZFJlZjp7aWYoJCR0eXBlb2ZOZXh0VHlwZT09PVJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpe25lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWVsc2UgaWYoJCR0eXBlb2ZOZXh0VHlwZT09PVJFQUNUX0xBWllfVFlQRSl7bmVlZHNDb21wYXJlRmFtaWxpZXM9dHJ1ZTt9YnJlYWs7fWNhc2UgTWVtb0NvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6e2lmKCQkdHlwZW9mTmV4dFR5cGU9PT1SRUFDVF9NRU1PX1RZUEUpey8vIFRPRE86IGlmIGl0IHdhcyBidXQgY2FuIG5vIGxvbmdlciBiZSBzaW1wbGUsXG4vLyB3ZSBzaG91bGRuJ3Qgc2V0IHRoaXMuXG5uZWVkc0NvbXBhcmVGYW1pbGllcz10cnVlO31lbHNlIGlmKCQkdHlwZW9mTmV4dFR5cGU9PT1SRUFDVF9MQVpZX1RZUEUpe25lZWRzQ29tcGFyZUZhbWlsaWVzPXRydWU7fWJyZWFrO31kZWZhdWx0OnJldHVybiBmYWxzZTt9Ly8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cbmlmKG5lZWRzQ29tcGFyZUZhbWlsaWVzKXsvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4vLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4vLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbi8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4vLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG52YXIgcHJldkZhbWlseT1yZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtpZihwcmV2RmFtaWx5IT09dW5kZWZpbmVkJiZwcmV2RmFtaWx5PT09cmVzb2x2ZUZhbWlseShuZXh0VHlwZSkpe3JldHVybiB0cnVlO319cmV0dXJuIGZhbHNlO319ZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpe3tpZihyZXNvbHZlRmFtaWx5PT09bnVsbCl7Ly8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbnJldHVybjt9aWYodHlwZW9mIFdlYWtTZXQhPT0nZnVuY3Rpb24nKXtyZXR1cm47fWlmKGZhaWxlZEJvdW5kYXJpZXM9PT1udWxsKXtmYWlsZWRCb3VuZGFyaWVzPW5ldyBXZWFrU2V0KCk7fWZhaWxlZEJvdW5kYXJpZXMuYWRkKGZpYmVyKTt9fXZhciBzY2hlZHVsZVJlZnJlc2g9ZnVuY3Rpb24ocm9vdCx1cGRhdGUpe3tpZihyZXNvbHZlRmFtaWx5PT09bnVsbCl7Ly8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbnJldHVybjt9dmFyIHN0YWxlRmFtaWxpZXM9dXBkYXRlLnN0YWxlRmFtaWxpZXMsdXBkYXRlZEZhbWlsaWVzPXVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7Zmx1c2hQYXNzaXZlRWZmZWN0cygpO2ZsdXNoU3luYyhmdW5jdGlvbigpe3NjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LHVwZGF0ZWRGYW1pbGllcyxzdGFsZUZhbWlsaWVzKTt9KTt9fTt2YXIgc2NoZWR1bGVSb290PWZ1bmN0aW9uKHJvb3QsZWxlbWVudCl7e2lmKHJvb3QuY29udGV4dCE9PWVtcHR5Q29udGV4dE9iamVjdCl7Ly8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4vLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4vLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG5yZXR1cm47fWZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtmbHVzaFN5bmMoZnVuY3Rpb24oKXt1cGRhdGVDb250YWluZXIoZWxlbWVudCxyb290LG51bGwsbnVsbCk7fSk7fX07ZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShmaWJlcix1cGRhdGVkRmFtaWxpZXMsc3RhbGVGYW1pbGllcyl7e3ZhciBhbHRlcm5hdGU9ZmliZXIuYWx0ZXJuYXRlLGNoaWxkPWZpYmVyLmNoaWxkLHNpYmxpbmc9ZmliZXIuc2libGluZyx0YWc9ZmliZXIudGFnLHR5cGU9ZmliZXIudHlwZTt2YXIgY2FuZGlkYXRlVHlwZT1udWxsO3N3aXRjaCh0YWcpe2Nhc2UgRnVuY3Rpb25Db21wb25lbnQ6Y2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OmNhc2UgQ2xhc3NDb21wb25lbnQ6Y2FuZGlkYXRlVHlwZT10eXBlO2JyZWFrO2Nhc2UgRm9yd2FyZFJlZjpjYW5kaWRhdGVUeXBlPXR5cGUucmVuZGVyO2JyZWFrO31pZihyZXNvbHZlRmFtaWx5PT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTt9dmFyIG5lZWRzUmVuZGVyPWZhbHNlO3ZhciBuZWVkc1JlbW91bnQ9ZmFsc2U7aWYoY2FuZGlkYXRlVHlwZSE9PW51bGwpe3ZhciBmYW1pbHk9cmVzb2x2ZUZhbWlseShjYW5kaWRhdGVUeXBlKTtpZihmYW1pbHkhPT11bmRlZmluZWQpe2lmKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpe25lZWRzUmVtb3VudD10cnVlO31lbHNlIGlmKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSl7aWYodGFnPT09Q2xhc3NDb21wb25lbnQpe25lZWRzUmVtb3VudD10cnVlO31lbHNle25lZWRzUmVuZGVyPXRydWU7fX19fWlmKGZhaWxlZEJvdW5kYXJpZXMhPT1udWxsKXtpZihmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcil8fGFsdGVybmF0ZSE9PW51bGwmJmZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpe25lZWRzUmVtb3VudD10cnVlO319aWYobmVlZHNSZW1vdW50KXtmaWJlci5fZGVidWdOZWVkc1JlbW91bnQ9dHJ1ZTt9aWYobmVlZHNSZW1vdW50fHxuZWVkc1JlbmRlcil7dmFyIF9yb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYoX3Jvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIoX3Jvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319aWYoY2hpbGQhPT1udWxsJiYhbmVlZHNSZW1vdW50KXtzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLHVwZGF0ZWRGYW1pbGllcyxzdGFsZUZhbWlsaWVzKTt9aWYoc2libGluZyE9PW51bGwpe3NjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoc2libGluZyx1cGRhdGVkRmFtaWxpZXMsc3RhbGVGYW1pbGllcyk7fX19dmFyIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaD1mdW5jdGlvbihyb290LGZhbWlsaWVzKXt7dmFyIGhvc3RJbnN0YW5jZXM9bmV3IFNldCgpO3ZhciB0eXBlcz1uZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbihmYW1pbHkpe3JldHVybiBmYW1pbHkuY3VycmVudDt9KSk7ZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCx0eXBlcyxob3N0SW5zdGFuY2VzKTtyZXR1cm4gaG9zdEluc3RhbmNlczt9fTtmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsdHlwZXMsaG9zdEluc3RhbmNlcyl7e3ZhciBjaGlsZD1maWJlci5jaGlsZCxzaWJsaW5nPWZpYmVyLnNpYmxpbmcsdGFnPWZpYmVyLnRhZyx0eXBlPWZpYmVyLnR5cGU7dmFyIGNhbmRpZGF0ZVR5cGU9bnVsbDtzd2l0Y2godGFnKXtjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OmNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpjYXNlIENsYXNzQ29tcG9uZW50OmNhbmRpZGF0ZVR5cGU9dHlwZTticmVhaztjYXNlIEZvcndhcmRSZWY6Y2FuZGlkYXRlVHlwZT10eXBlLnJlbmRlcjticmVhazt9dmFyIGRpZE1hdGNoPWZhbHNlO2lmKGNhbmRpZGF0ZVR5cGUhPT1udWxsKXtpZih0eXBlcy5oYXMoY2FuZGlkYXRlVHlwZSkpe2RpZE1hdGNoPXRydWU7fX1pZihkaWRNYXRjaCl7Ly8gV2UgaGF2ZSBhIG1hdGNoLiBUaGlzIG9ubHkgZHJpbGxzIGRvd24gdG8gdGhlIGNsb3Nlc3QgaG9zdCBjb21wb25lbnRzLlxuLy8gVGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaCBkZWVwZXIgYmVjYXVzZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZ2l2aW5nXG4vLyB2aXN1YWwgZmVlZGJhY2ssIFwiZmxhc2hpbmdcIiBvdXRlcm1vc3QgcGFyZW50IHJlY3RhbmdsZXMgaXMgc3VmZmljaWVudC5cbmZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsaG9zdEluc3RhbmNlcyk7fWVsc2V7Ly8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuaWYoY2hpbGQhPT1udWxsKXtmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsdHlwZXMsaG9zdEluc3RhbmNlcyk7fX1pZihzaWJsaW5nIT09bnVsbCl7ZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsdHlwZXMsaG9zdEluc3RhbmNlcyk7fX19ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlcixob3N0SW5zdGFuY2VzKXt7dmFyIGZvdW5kSG9zdEluc3RhbmNlcz1maW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsaG9zdEluc3RhbmNlcyk7aWYoZm91bmRIb3N0SW5zdGFuY2VzKXtyZXR1cm47fS8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxudmFyIG5vZGU9ZmliZXI7d2hpbGUodHJ1ZSl7c3dpdGNoKG5vZGUudGFnKXtjYXNlIEhvc3RDb21wb25lbnQ6aG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpO3JldHVybjtjYXNlIEhvc3RQb3J0YWw6aG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7cmV0dXJuO2Nhc2UgSG9zdFJvb3Q6aG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7cmV0dXJuO31pZihub2RlLnJldHVybj09PW51bGwpe3Rocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTt9bm9kZT1ub2RlLnJldHVybjt9fX1mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsaG9zdEluc3RhbmNlcyl7e3ZhciBub2RlPWZpYmVyO3ZhciBmb3VuZEhvc3RJbnN0YW5jZXM9ZmFsc2U7d2hpbGUodHJ1ZSl7aWYobm9kZS50YWc9PT1Ib3N0Q29tcG9uZW50KXsvLyBXZSBnb3QgYSBtYXRjaC5cbmZvdW5kSG9zdEluc3RhbmNlcz10cnVlO2hvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG59ZWxzZSBpZihub2RlLmNoaWxkIT09bnVsbCl7bm9kZS5jaGlsZC5yZXR1cm49bm9kZTtub2RlPW5vZGUuY2hpbGQ7Y29udGludWU7fWlmKG5vZGU9PT1maWJlcil7cmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlczt9d2hpbGUobm9kZS5zaWJsaW5nPT09bnVsbCl7aWYobm9kZS5yZXR1cm49PT1udWxsfHxub2RlLnJldHVybj09PWZpYmVyKXtyZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO31ub2RlPW5vZGUucmV0dXJuO31ub2RlLnNpYmxpbmcucmV0dXJuPW5vZGUucmV0dXJuO25vZGU9bm9kZS5zaWJsaW5nO319cmV0dXJuIGZhbHNlO312YXIgaGFzQmFkTWFwUG9seWZpbGw7e2hhc0JhZE1hcFBvbHlmaWxsPWZhbHNlO3RyeXt2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdD1PYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pOy8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL25ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LG51bGxdXSk7bmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pOy8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovfWNhdGNoKGUpey8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuaGFzQmFkTWFwUG9seWZpbGw9dHJ1ZTt9fWZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcscGVuZGluZ1Byb3BzLGtleSxtb2RlKXsvLyBJbnN0YW5jZVxudGhpcy50YWc9dGFnO3RoaXMua2V5PWtleTt0aGlzLmVsZW1lbnRUeXBlPW51bGw7dGhpcy50eXBlPW51bGw7dGhpcy5zdGF0ZU5vZGU9bnVsbDsvLyBGaWJlclxudGhpcy5yZXR1cm49bnVsbDt0aGlzLmNoaWxkPW51bGw7dGhpcy5zaWJsaW5nPW51bGw7dGhpcy5pbmRleD0wO3RoaXMucmVmPW51bGw7dGhpcy5wZW5kaW5nUHJvcHM9cGVuZGluZ1Byb3BzO3RoaXMubWVtb2l6ZWRQcm9wcz1udWxsO3RoaXMudXBkYXRlUXVldWU9bnVsbDt0aGlzLm1lbW9pemVkU3RhdGU9bnVsbDt0aGlzLmRlcGVuZGVuY2llcz1udWxsO3RoaXMubW9kZT1tb2RlOy8vIEVmZmVjdHNcbnRoaXMuZmxhZ3M9Tm9GbGFnczt0aGlzLnN1YnRyZWVGbGFncz1Ob0ZsYWdzO3RoaXMuZGVsZXRpb25zPW51bGw7dGhpcy5sYW5lcz1Ob0xhbmVzO3RoaXMuY2hpbGRMYW5lcz1Ob0xhbmVzO3RoaXMuYWx0ZXJuYXRlPW51bGw7ey8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgaXMgZG9uZSB0byBhdm9pZCBhIHY4IHBlcmZvcm1hbmNlIGNsaWZmLlxuLy9cbi8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuLy8gZG91YmxlIHZhbHVlcyB3aWxsIGNhdXNlIEZpYmVycyB0byBlbmQgdXAgaGF2aW5nIHNlcGFyYXRlIHNoYXBlcy5cbi8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cbi8vIFVuZm9ydHVuYXRlbHkgaXQgbWFrZXMgUmVhY3QgdW51c2FibHkgc2xvdyBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG4vLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuLy9cbi8vIExlYXJuIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxudGhpcy5hY3R1YWxEdXJhdGlvbj1OdW1iZXIuTmFOO3RoaXMuYWN0dWFsU3RhcnRUaW1lPU51bWJlci5OYU47dGhpcy5zZWxmQmFzZUR1cmF0aW9uPU51bWJlci5OYU47dGhpcy50cmVlQmFzZUR1cmF0aW9uPU51bWJlci5OYU47Ly8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4vLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbi8vIGFuZCBpdCBzaW1wbGlmaWVzIG90aGVyIHByb2ZpbGVyIGNvZGUgKGluY2x1ZGluZyBEZXZUb29scykuXG50aGlzLmFjdHVhbER1cmF0aW9uPTA7dGhpcy5hY3R1YWxTdGFydFRpbWU9LTE7dGhpcy5zZWxmQmFzZUR1cmF0aW9uPTA7dGhpcy50cmVlQmFzZUR1cmF0aW9uPTA7fXsvLyBUaGlzIGlzbid0IGRpcmVjdGx5IHVzZWQgYnV0IGlzIGhhbmR5IGZvciBkZWJ1Z2dpbmcgaW50ZXJuYWxzOlxudGhpcy5fZGVidWdTb3VyY2U9bnVsbDt0aGlzLl9kZWJ1Z093bmVyPW51bGw7dGhpcy5fZGVidWdOZWVkc1JlbW91bnQ9ZmFsc2U7dGhpcy5fZGVidWdIb29rVHlwZXM9bnVsbDtpZighaGFzQmFkTWFwUG9seWZpbGwmJnR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnM9PT0nZnVuY3Rpb24nKXtPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7fX19Ly8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG52YXIgY3JlYXRlRmliZXI9ZnVuY3Rpb24odGFnLHBlbmRpbmdQcm9wcyxrZXksbW9kZSl7Ly8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG5yZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcscGVuZGluZ1Byb3BzLGtleSxtb2RlKTt9O2Z1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCl7dmFyIHByb3RvdHlwZT1Db21wb25lbnQucHJvdG90eXBlO3JldHVybiEhKHByb3RvdHlwZSYmcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO31mdW5jdGlvbiBpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpe3JldHVybiB0eXBlb2YgdHlwZT09PSdmdW5jdGlvbicmJiFzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSYmdHlwZS5kZWZhdWx0UHJvcHM9PT11bmRlZmluZWQ7fWZ1bmN0aW9uIHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCl7aWYodHlwZW9mIENvbXBvbmVudD09PSdmdW5jdGlvbicpe3JldHVybiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpP0NsYXNzQ29tcG9uZW50OkZ1bmN0aW9uQ29tcG9uZW50O31lbHNlIGlmKENvbXBvbmVudCE9PXVuZGVmaW5lZCYmQ29tcG9uZW50IT09bnVsbCl7dmFyICQkdHlwZW9mPUNvbXBvbmVudC4kJHR5cGVvZjtpZigkJHR5cGVvZj09PVJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpe3JldHVybiBGb3J3YXJkUmVmO31pZigkJHR5cGVvZj09PVJFQUNUX01FTU9fVFlQRSl7cmV0dXJuIE1lbW9Db21wb25lbnQ7fX1yZXR1cm4gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDt9Ly8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQscGVuZGluZ1Byb3BzKXt2YXIgd29ya0luUHJvZ3Jlc3M9Y3VycmVudC5hbHRlcm5hdGU7aWYod29ya0luUHJvZ3Jlc3M9PT1udWxsKXsvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4vLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbi8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbi8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4vLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxud29ya0luUHJvZ3Jlc3M9Y3JlYXRlRmliZXIoY3VycmVudC50YWcscGVuZGluZ1Byb3BzLGN1cnJlbnQua2V5LGN1cnJlbnQubW9kZSk7d29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU9Y3VycmVudC5lbGVtZW50VHlwZTt3b3JrSW5Qcm9ncmVzcy50eXBlPWN1cnJlbnQudHlwZTt3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9Y3VycmVudC5zdGF0ZU5vZGU7ey8vIERFVi1vbmx5IGZpZWxkc1xud29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlPWN1cnJlbnQuX2RlYnVnU291cmNlO3dvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyPWN1cnJlbnQuX2RlYnVnT3duZXI7d29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzPWN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO313b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU9Y3VycmVudDtjdXJyZW50LmFsdGVybmF0ZT13b3JrSW5Qcm9ncmVzczt9ZWxzZXt3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM9cGVuZGluZ1Byb3BzOy8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG53b3JrSW5Qcm9ncmVzcy50eXBlPWN1cnJlbnQudHlwZTsvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG53b3JrSW5Qcm9ncmVzcy5mbGFncz1Ob0ZsYWdzOy8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG53b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3M9Tm9GbGFnczt3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM9bnVsbDt7Ly8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4vLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG53b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbj0wO3dvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZT0tMTt9fS8vIFJlc2V0IGFsbCBlZmZlY3RzIGV4Y2VwdCBzdGF0aWMgb25lcy5cbi8vIFN0YXRpYyBlZmZlY3RzIGFyZSBub3Qgc3BlY2lmaWMgdG8gYSByZW5kZXIuXG53b3JrSW5Qcm9ncmVzcy5mbGFncz1jdXJyZW50LmZsYWdzJlN0YXRpY01hc2s7d29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcz1jdXJyZW50LmNoaWxkTGFuZXM7d29ya0luUHJvZ3Jlc3MubGFuZXM9Y3VycmVudC5sYW5lczt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1jdXJyZW50LmNoaWxkO3dvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9Y3VycmVudC5tZW1vaXplZFByb3BzO3dvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU9Y3VycmVudC5tZW1vaXplZFN0YXRlO3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlPWN1cnJlbnQudXBkYXRlUXVldWU7Ly8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbi8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cbnZhciBjdXJyZW50RGVwZW5kZW5jaWVzPWN1cnJlbnQuZGVwZW5kZW5jaWVzO3dvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcz1jdXJyZW50RGVwZW5kZW5jaWVzPT09bnVsbD9udWxsOntsYW5lczpjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLGZpcnN0Q29udGV4dDpjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dH07Ly8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbndvcmtJblByb2dyZXNzLnNpYmxpbmc9Y3VycmVudC5zaWJsaW5nO3dvcmtJblByb2dyZXNzLmluZGV4PWN1cnJlbnQuaW5kZXg7d29ya0luUHJvZ3Jlc3MucmVmPWN1cnJlbnQucmVmO3t3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uPWN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjt3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uPWN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjt9e3dvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudD1jdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtzd2l0Y2god29ya0luUHJvZ3Jlc3MudGFnKXtjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6Y2FzZSBGdW5jdGlvbkNvbXBvbmVudDpjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6d29ya0luUHJvZ3Jlc3MudHlwZT1yZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTticmVhaztjYXNlIENsYXNzQ29tcG9uZW50OndvcmtJblByb2dyZXNzLnR5cGU9cmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7YnJlYWs7Y2FzZSBGb3J3YXJkUmVmOndvcmtJblByb2dyZXNzLnR5cGU9cmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTticmVhazt9fXJldHVybiB3b3JrSW5Qcm9ncmVzczt9Ly8gVXNlZCB0byByZXVzZSBhIEZpYmVyIGZvciBhIHNlY29uZCBwYXNzLlxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcyxyZW5kZXJMYW5lcyl7Ly8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbi8vIGhhdmUgc2V0IHRoZSB2YWx1ZXMgdG8gYmVmb3JlIGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSWRlYWxseSB0aGlzIHdvdWxkbid0XG4vLyBiZSBuZWNlc3NhcnkgYnV0IHVuZm9ydHVuYXRlbHkgbWFueSBjb2RlIHBhdGhzIHJlYWRzIGZyb20gdGhlIHdvcmtJblByb2dyZXNzXG4vLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuLy8gV2UgYXNzdW1lIHBlbmRpbmdQcm9wcywgaW5kZXgsIGtleSwgcmVmLCByZXR1cm4gYXJlIHN0aWxsIHVudG91Y2hlZCB0b1xuLy8gYXZvaWQgZG9pbmcgYW5vdGhlciByZWNvbmNpbGlhdGlvbi5cbi8vIFJlc2V0IHRoZSBlZmZlY3QgZmxhZ3MgYnV0IGtlZXAgYW55IFBsYWNlbWVudCB0YWdzLCBzaW5jZSB0aGF0J3Mgc29tZXRoaW5nXG4vLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG53b3JrSW5Qcm9ncmVzcy5mbGFncyY9U3RhdGljTWFza3xQbGFjZW1lbnQ7Ly8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cbnZhciBjdXJyZW50PXdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtpZihjdXJyZW50PT09bnVsbCl7Ly8gUmVzZXQgdG8gY3JlYXRlRmliZXIncyBpbml0aWFsIHZhbHVlcy5cbndvcmtJblByb2dyZXNzLmNoaWxkTGFuZXM9Tm9MYW5lczt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1yZW5kZXJMYW5lczt3b3JrSW5Qcm9ncmVzcy5jaGlsZD1udWxsO3dvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncz1Ob0ZsYWdzO3dvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM9bnVsbDt3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlPW51bGw7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9bnVsbDt3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM9bnVsbDt3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU9bnVsbDt7Ly8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4vLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbndvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb249MDt3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uPTA7fX1lbHNley8vIFJlc2V0IHRvIHRoZSBjbG9uZWQgdmFsdWVzIHRoYXQgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGQndmUuXG53b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzPWN1cnJlbnQuY2hpbGRMYW5lczt3b3JrSW5Qcm9ncmVzcy5sYW5lcz1jdXJyZW50LmxhbmVzO3dvcmtJblByb2dyZXNzLmNoaWxkPWN1cnJlbnQuY2hpbGQ7d29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzPU5vRmxhZ3M7d29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zPW51bGw7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcz1jdXJyZW50Lm1lbW9pemVkUHJvcHM7d29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZT1jdXJyZW50Lm1lbW9pemVkU3RhdGU7d29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU9Y3VycmVudC51cGRhdGVRdWV1ZTsvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxud29ya0luUHJvZ3Jlc3MudHlwZT1jdXJyZW50LnR5cGU7Ly8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbi8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cbnZhciBjdXJyZW50RGVwZW5kZW5jaWVzPWN1cnJlbnQuZGVwZW5kZW5jaWVzO3dvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcz1jdXJyZW50RGVwZW5kZW5jaWVzPT09bnVsbD9udWxsOntsYW5lczpjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLGZpcnN0Q29udGV4dDpjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dH07ey8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG53b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uPWN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjt3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uPWN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjt9fXJldHVybiB3b3JrSW5Qcm9ncmVzczt9ZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUpe3ZhciBtb2RlO2lmKHRhZz09PUNvbmN1cnJlbnRSb290KXttb2RlPUNvbmN1cnJlbnRNb2RlO2lmKGlzU3RyaWN0TW9kZT09PXRydWUpe21vZGV8PVN0cmljdExlZ2FjeU1vZGU7e21vZGV8PVN0cmljdEVmZmVjdHNNb2RlO319fWVsc2V7bW9kZT1Ob01vZGU7fWlmKGlzRGV2VG9vbHNQcmVzZW50KXsvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbi8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuLy8gV2l0aG91dCBzb21lIG5vZGVzIGluIHRoZSB0cmVlIGhhdmluZyBlbXB0eSBiYXNlIHRpbWVzLlxubW9kZXw9UHJvZmlsZU1vZGU7fXJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCxudWxsLG51bGwsbW9kZSk7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLC8vIFJlYWN0JEVsZW1lbnRUeXBlXG5rZXkscGVuZGluZ1Byb3BzLG93bmVyLG1vZGUsbGFuZXMpe3ZhciBmaWJlclRhZz1JbmRldGVybWluYXRlQ29tcG9uZW50Oy8vIFRoZSByZXNvbHZlZCB0eXBlIGlzIHNldCBpZiB3ZSBrbm93IHdoYXQgdGhlIGZpbmFsIHR5cGUgd2lsbCBiZS4gSS5lLiBpdCdzIG5vdCBsYXp5LlxudmFyIHJlc29sdmVkVHlwZT10eXBlO2lmKHR5cGVvZiB0eXBlPT09J2Z1bmN0aW9uJyl7aWYoc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpe2ZpYmVyVGFnPUNsYXNzQ29tcG9uZW50O3tyZXNvbHZlZFR5cGU9cmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7fX1lbHNle3tyZXNvbHZlZFR5cGU9cmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7fX19ZWxzZSBpZih0eXBlb2YgdHlwZT09PSdzdHJpbmcnKXtmaWJlclRhZz1Ib3N0Q29tcG9uZW50O31lbHNle2dldFRhZzpzd2l0Y2godHlwZSl7Y2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOnJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sbW9kZSxsYW5lcyxrZXkpO2Nhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpmaWJlclRhZz1Nb2RlO21vZGV8PVN0cmljdExlZ2FjeU1vZGU7aWYoKG1vZGUmQ29uY3VycmVudE1vZGUpIT09Tm9Nb2RlKXsvLyBTdHJpY3QgZWZmZWN0cyBzaG91bGQgbmV2ZXIgcnVuIG9uIGxlZ2FjeSByb290c1xubW9kZXw9U3RyaWN0RWZmZWN0c01vZGU7fWJyZWFrO2Nhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpyZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KTtjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6cmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSk7Y2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6cmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpO2Nhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6cmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpO2Nhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSBSRUFDVF9TQ09QRV9UWVBFOi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSBSRUFDVF9DQUNIRV9UWVBFOi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFOi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbmRlZmF1bHQ6e2lmKHR5cGVvZiB0eXBlPT09J29iamVjdCcmJnR5cGUhPT1udWxsKXtzd2l0Y2godHlwZS4kJHR5cGVvZil7Y2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOmZpYmVyVGFnPUNvbnRleHRQcm92aWRlcjticmVhayBnZXRUYWc7Y2FzZSBSRUFDVF9DT05URVhUX1RZUEU6Ly8gVGhpcyBpcyBhIGNvbnN1bWVyXG5maWJlclRhZz1Db250ZXh0Q29uc3VtZXI7YnJlYWsgZ2V0VGFnO2Nhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpmaWJlclRhZz1Gb3J3YXJkUmVmO3tyZXNvbHZlZFR5cGU9cmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTt9YnJlYWsgZ2V0VGFnO2Nhc2UgUkVBQ1RfTUVNT19UWVBFOmZpYmVyVGFnPU1lbW9Db21wb25lbnQ7YnJlYWsgZ2V0VGFnO2Nhc2UgUkVBQ1RfTEFaWV9UWVBFOmZpYmVyVGFnPUxhenlDb21wb25lbnQ7cmVzb2x2ZWRUeXBlPW51bGw7YnJlYWsgZ2V0VGFnO319dmFyIGluZm89Jyc7e2lmKHR5cGU9PT11bmRlZmluZWR8fHR5cGVvZiB0eXBlPT09J29iamVjdCcmJnR5cGUhPT1udWxsJiZPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGg9PT0wKXtpbmZvKz0nIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcrXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiKyduYW1lZCBpbXBvcnRzLic7fXZhciBvd25lck5hbWU9b3duZXI/Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcik6bnVsbDtpZihvd25lck5hbWUpe2luZm8rPSdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJytvd25lck5hbWUrJ2AuJzt9fXRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJysnY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSAnKyhcImJ1dCBnb3Q6IFwiKyh0eXBlPT1udWxsP3R5cGU6dHlwZW9mIHR5cGUpK1wiLlwiK2luZm8pKTt9fX12YXIgZmliZXI9Y3JlYXRlRmliZXIoZmliZXJUYWcscGVuZGluZ1Byb3BzLGtleSxtb2RlKTtmaWJlci5lbGVtZW50VHlwZT10eXBlO2ZpYmVyLnR5cGU9cmVzb2x2ZWRUeXBlO2ZpYmVyLmxhbmVzPWxhbmVzO3tmaWJlci5fZGVidWdPd25lcj1vd25lcjt9cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsbW9kZSxsYW5lcyl7dmFyIG93bmVyPW51bGw7e293bmVyPWVsZW1lbnQuX293bmVyO312YXIgdHlwZT1lbGVtZW50LnR5cGU7dmFyIGtleT1lbGVtZW50LmtleTt2YXIgcGVuZGluZ1Byb3BzPWVsZW1lbnQucHJvcHM7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLGtleSxwZW5kaW5nUHJvcHMsb3duZXIsbW9kZSxsYW5lcyk7e2ZpYmVyLl9kZWJ1Z1NvdXJjZT1lbGVtZW50Ll9zb3VyY2U7ZmliZXIuX2RlYnVnT3duZXI9ZWxlbWVudC5fb3duZXI7fXJldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsbW9kZSxsYW5lcyxrZXkpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihGcmFnbWVudCxlbGVtZW50cyxrZXksbW9kZSk7ZmliZXIubGFuZXM9bGFuZXM7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpe3tpZih0eXBlb2YgcGVuZGluZ1Byb3BzLmlkIT09J3N0cmluZycpe2Vycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJyx0eXBlb2YgcGVuZGluZ1Byb3BzLmlkKTt9fXZhciBmaWJlcj1jcmVhdGVGaWJlcihQcm9maWxlcixwZW5kaW5nUHJvcHMsa2V5LG1vZGV8UHJvZmlsZU1vZGUpO2ZpYmVyLmVsZW1lbnRUeXBlPVJFQUNUX1BST0ZJTEVSX1RZUEU7ZmliZXIubGFuZXM9bGFuZXM7e2ZpYmVyLnN0YXRlTm9kZT17ZWZmZWN0RHVyYXRpb246MCxwYXNzaXZlRWZmZWN0RHVyYXRpb246MH07fXJldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLG1vZGUsbGFuZXMsa2V5KXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoU3VzcGVuc2VDb21wb25lbnQscGVuZGluZ1Byb3BzLGtleSxtb2RlKTtmaWJlci5lbGVtZW50VHlwZT1SRUFDVF9TVVNQRU5TRV9UWVBFO2ZpYmVyLmxhbmVzPWxhbmVzO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcyxtb2RlLGxhbmVzLGtleSl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCxwZW5kaW5nUHJvcHMsa2V5LG1vZGUpO2ZpYmVyLmVsZW1lbnRUeXBlPVJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtmaWJlci5sYW5lcz1sYW5lcztyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsbW9kZSxsYW5lcyxrZXkpe3ZhciBmaWJlcj1jcmVhdGVGaWJlcihPZmZzY3JlZW5Db21wb25lbnQscGVuZGluZ1Byb3BzLGtleSxtb2RlKTtmaWJlci5lbGVtZW50VHlwZT1SRUFDVF9PRkZTQ1JFRU5fVFlQRTtmaWJlci5sYW5lcz1sYW5lczt2YXIgcHJpbWFyeUNoaWxkSW5zdGFuY2U9e2lzSGlkZGVuOmZhbHNlfTtmaWJlci5zdGF0ZU5vZGU9cHJpbWFyeUNoaWxkSW5zdGFuY2U7cmV0dXJuIGZpYmVyO31mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsbW9kZSxsYW5lcyl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKEhvc3RUZXh0LGNvbnRlbnQsbnVsbCxtb2RlKTtmaWJlci5sYW5lcz1sYW5lcztyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCl7dmFyIGZpYmVyPWNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsbnVsbCxudWxsLE5vTW9kZSk7ZmliZXIuZWxlbWVudFR5cGU9J0RFTEVURUQnO3JldHVybiBmaWJlcjt9ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KGRlaHlkcmF0ZWROb2RlKXt2YXIgZmliZXI9Y3JlYXRlRmliZXIoRGVoeWRyYXRlZEZyYWdtZW50LG51bGwsbnVsbCxOb01vZGUpO2ZpYmVyLnN0YXRlTm9kZT1kZWh5ZHJhdGVkTm9kZTtyZXR1cm4gZmliZXI7fWZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsbW9kZSxsYW5lcyl7dmFyIHBlbmRpbmdQcm9wcz1wb3J0YWwuY2hpbGRyZW4hPT1udWxsP3BvcnRhbC5jaGlsZHJlbjpbXTt2YXIgZmliZXI9Y3JlYXRlRmliZXIoSG9zdFBvcnRhbCxwZW5kaW5nUHJvcHMscG9ydGFsLmtleSxtb2RlKTtmaWJlci5sYW5lcz1sYW5lcztmaWJlci5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86cG9ydGFsLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbmltcGxlbWVudGF0aW9uOnBvcnRhbC5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGZpYmVyO30vLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LHNvdXJjZSl7aWYodGFyZ2V0PT09bnVsbCl7Ly8gVGhpcyBGaWJlcidzIGluaXRpYWwgcHJvcGVydGllcyB3aWxsIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5cbi8vIFdlIG9ubHkgdXNlIGEgRmliZXIgdG8gZW5zdXJlIHRoZSBzYW1lIGhpZGRlbiBjbGFzcyBzbyBERVYgaXNuJ3Qgc2xvdy5cbnRhcmdldD1jcmVhdGVGaWJlcihJbmRldGVybWluYXRlQ29tcG9uZW50LG51bGwsbnVsbCxOb01vZGUpO30vLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4vLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4vLyB0aGUgaG90dGVzdCBwYXRoLCBhbmQgT2JqZWN0LmFzc2lnbigpIHdhcyB0b28gc2xvdzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbi8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG50YXJnZXQudGFnPXNvdXJjZS50YWc7dGFyZ2V0LmtleT1zb3VyY2Uua2V5O3RhcmdldC5lbGVtZW50VHlwZT1zb3VyY2UuZWxlbWVudFR5cGU7dGFyZ2V0LnR5cGU9c291cmNlLnR5cGU7dGFyZ2V0LnN0YXRlTm9kZT1zb3VyY2Uuc3RhdGVOb2RlO3RhcmdldC5yZXR1cm49c291cmNlLnJldHVybjt0YXJnZXQuY2hpbGQ9c291cmNlLmNoaWxkO3RhcmdldC5zaWJsaW5nPXNvdXJjZS5zaWJsaW5nO3RhcmdldC5pbmRleD1zb3VyY2UuaW5kZXg7dGFyZ2V0LnJlZj1zb3VyY2UucmVmO3RhcmdldC5wZW5kaW5nUHJvcHM9c291cmNlLnBlbmRpbmdQcm9wczt0YXJnZXQubWVtb2l6ZWRQcm9wcz1zb3VyY2UubWVtb2l6ZWRQcm9wczt0YXJnZXQudXBkYXRlUXVldWU9c291cmNlLnVwZGF0ZVF1ZXVlO3RhcmdldC5tZW1vaXplZFN0YXRlPXNvdXJjZS5tZW1vaXplZFN0YXRlO3RhcmdldC5kZXBlbmRlbmNpZXM9c291cmNlLmRlcGVuZGVuY2llczt0YXJnZXQubW9kZT1zb3VyY2UubW9kZTt0YXJnZXQuZmxhZ3M9c291cmNlLmZsYWdzO3RhcmdldC5zdWJ0cmVlRmxhZ3M9c291cmNlLnN1YnRyZWVGbGFnczt0YXJnZXQuZGVsZXRpb25zPXNvdXJjZS5kZWxldGlvbnM7dGFyZ2V0LmxhbmVzPXNvdXJjZS5sYW5lczt0YXJnZXQuY2hpbGRMYW5lcz1zb3VyY2UuY2hpbGRMYW5lczt0YXJnZXQuYWx0ZXJuYXRlPXNvdXJjZS5hbHRlcm5hdGU7e3RhcmdldC5hY3R1YWxEdXJhdGlvbj1zb3VyY2UuYWN0dWFsRHVyYXRpb247dGFyZ2V0LmFjdHVhbFN0YXJ0VGltZT1zb3VyY2UuYWN0dWFsU3RhcnRUaW1lO3RhcmdldC5zZWxmQmFzZUR1cmF0aW9uPXNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO3RhcmdldC50cmVlQmFzZUR1cmF0aW9uPXNvdXJjZS50cmVlQmFzZUR1cmF0aW9uO310YXJnZXQuX2RlYnVnU291cmNlPXNvdXJjZS5fZGVidWdTb3VyY2U7dGFyZ2V0Ll9kZWJ1Z093bmVyPXNvdXJjZS5fZGVidWdPd25lcjt0YXJnZXQuX2RlYnVnTmVlZHNSZW1vdW50PXNvdXJjZS5fZGVidWdOZWVkc1JlbW91bnQ7dGFyZ2V0Ll9kZWJ1Z0hvb2tUeXBlcz1zb3VyY2UuX2RlYnVnSG9va1R5cGVzO3JldHVybiB0YXJnZXQ7fWZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbyx0YWcsaHlkcmF0ZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcil7dGhpcy50YWc9dGFnO3RoaXMuY29udGFpbmVySW5mbz1jb250YWluZXJJbmZvO3RoaXMucGVuZGluZ0NoaWxkcmVuPW51bGw7dGhpcy5jdXJyZW50PW51bGw7dGhpcy5waW5nQ2FjaGU9bnVsbDt0aGlzLmZpbmlzaGVkV29yaz1udWxsO3RoaXMudGltZW91dEhhbmRsZT1ub1RpbWVvdXQ7dGhpcy5jb250ZXh0PW51bGw7dGhpcy5wZW5kaW5nQ29udGV4dD1udWxsO3RoaXMuY2FsbGJhY2tOb2RlPW51bGw7dGhpcy5jYWxsYmFja1ByaW9yaXR5PU5vTGFuZTt0aGlzLmV2ZW50VGltZXM9Y3JlYXRlTGFuZU1hcChOb0xhbmVzKTt0aGlzLmV4cGlyYXRpb25UaW1lcz1jcmVhdGVMYW5lTWFwKE5vVGltZXN0YW1wKTt0aGlzLnBlbmRpbmdMYW5lcz1Ob0xhbmVzO3RoaXMuc3VzcGVuZGVkTGFuZXM9Tm9MYW5lczt0aGlzLnBpbmdlZExhbmVzPU5vTGFuZXM7dGhpcy5leHBpcmVkTGFuZXM9Tm9MYW5lczt0aGlzLm11dGFibGVSZWFkTGFuZXM9Tm9MYW5lczt0aGlzLmZpbmlzaGVkTGFuZXM9Tm9MYW5lczt0aGlzLmVudGFuZ2xlZExhbmVzPU5vTGFuZXM7dGhpcy5lbnRhbmdsZW1lbnRzPWNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7dGhpcy5pZGVudGlmaWVyUHJlZml4PWlkZW50aWZpZXJQcmVmaXg7dGhpcy5vblJlY292ZXJhYmxlRXJyb3I9b25SZWNvdmVyYWJsZUVycm9yO3t0aGlzLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9bnVsbDt9e3RoaXMuZWZmZWN0RHVyYXRpb249MDt0aGlzLnBhc3NpdmVFZmZlY3REdXJhdGlvbj0wO317dGhpcy5tZW1vaXplZFVwZGF0ZXJzPW5ldyBTZXQoKTt2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcD10aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA9W107Zm9yKHZhciBfaT0wO19pPFRvdGFsTGFuZXM7X2krKyl7cGVuZGluZ1VwZGF0ZXJzTGFuZU1hcC5wdXNoKG5ldyBTZXQoKSk7fX17c3dpdGNoKHRhZyl7Y2FzZSBDb25jdXJyZW50Um9vdDp0aGlzLl9kZWJ1Z1Jvb3RUeXBlPWh5ZHJhdGU/J2h5ZHJhdGVSb290KCknOidjcmVhdGVSb290KCknO2JyZWFrO2Nhc2UgTGVnYWN5Um9vdDp0aGlzLl9kZWJ1Z1Jvb3RUeXBlPWh5ZHJhdGU/J2h5ZHJhdGUoKSc6J3JlbmRlcigpJzticmVhazt9fX1mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbyx0YWcsaHlkcmF0ZSxpbml0aWFsQ2hpbGRyZW4saHlkcmF0aW9uQ2FsbGJhY2tzLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLC8vIFRPRE86IFdlIGhhdmUgc2V2ZXJhbCBvZiB0aGVzZSBhcmd1bWVudHMgdGhhdCBhcmUgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlXG4vLyBob3N0IGNvbmZpZywgYnV0IGJlY2F1c2UgdGhleSBhcmUgcGFzc2VkIGluIGF0IHJ1bnRpbWUsIHdlIGhhdmUgdG8gdGhyZWFkXG4vLyB0aGVtIHRocm91Z2ggdGhlIHJvb3QgY29uc3RydWN0b3IuIFBlcmhhcHMgd2Ugc2hvdWxkIHB1dCB0aGVtIGFsbCBpbnRvIGFcbi8vIHNpbmdsZSB0eXBlLCBsaWtlIGEgRHluYW1pY0hvc3RDb25maWcgdGhhdCBpcyBkZWZpbmVkIGJ5IHRoZSByZW5kZXJlci5cbmlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yLHRyYW5zaXRpb25DYWxsYmFja3Mpe3ZhciByb290PW5ldyBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IpOy8vIHN0YXRlTm9kZSBpcyBhbnkuXG52YXIgdW5pbml0aWFsaXplZEZpYmVyPWNyZWF0ZUhvc3RSb290RmliZXIodGFnLGlzU3RyaWN0TW9kZSk7cm9vdC5jdXJyZW50PXVuaW5pdGlhbGl6ZWRGaWJlcjt1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlPXJvb3Q7e3ZhciBfaW5pdGlhbFN0YXRlPXtlbGVtZW50OmluaXRpYWxDaGlsZHJlbixpc0RlaHlkcmF0ZWQ6aHlkcmF0ZSxjYWNoZTpudWxsLC8vIG5vdCBlbmFibGVkIHlldFxudHJhbnNpdGlvbnM6bnVsbCxwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOm51bGx9O3VuaW5pdGlhbGl6ZWRGaWJlci5tZW1vaXplZFN0YXRlPV9pbml0aWFsU3RhdGU7fWluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO3JldHVybiByb290O312YXIgUmVhY3RWZXJzaW9uPScxOC4zLjEnO2Z1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbixjb250YWluZXJJbmZvLC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbil7dmFyIGtleT1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106bnVsbDt7Y2hlY2tLZXlTdHJpbmdDb2VyY2lvbihrZXkpO31yZXR1cm57Ly8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuJCR0eXBlb2Y6UkVBQ1RfUE9SVEFMX1RZUEUsa2V5OmtleT09bnVsbD9udWxsOicnK2tleSxjaGlsZHJlbjpjaGlsZHJlbixjb250YWluZXJJbmZvOmNvbnRhaW5lckluZm8saW1wbGVtZW50YXRpb246aW1wbGVtZW50YXRpb259O312YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlczt2YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7e2RpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM9ZmFsc2U7ZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU9e307fWZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCl7aWYoIXBhcmVudENvbXBvbmVudCl7cmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDt9dmFyIGZpYmVyPWdldChwYXJlbnRDb21wb25lbnQpO3ZhciBwYXJlbnRDb250ZXh0PWZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtpZihmaWJlci50YWc9PT1DbGFzc0NvbXBvbmVudCl7dmFyIENvbXBvbmVudD1maWJlci50eXBlO2lmKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpe3JldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLENvbXBvbmVudCxwYXJlbnRDb250ZXh0KTt9fXJldHVybiBwYXJlbnRDb250ZXh0O31mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50LG1ldGhvZE5hbWUpe3t2YXIgZmliZXI9Z2V0KGNvbXBvbmVudCk7aWYoZmliZXI9PT11bmRlZmluZWQpe2lmKHR5cGVvZiBjb21wb25lbnQucmVuZGVyPT09J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7fWVsc2V7dmFyIGtleXM9T2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKCcsJyk7dGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIra2V5cyk7fX12YXIgaG9zdEZpYmVyPWZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtpZihob3N0RmliZXI9PT1udWxsKXtyZXR1cm4gbnVsbDt9aWYoaG9zdEZpYmVyLm1vZGUmU3RyaWN0TGVnYWN5TW9kZSl7dmFyIGNvbXBvbmVudE5hbWU9Z2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcil8fCdDb21wb25lbnQnO2lmKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSl7ZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV09dHJ1ZTt2YXIgcHJldmlvdXNGaWJlcj1jdXJyZW50O3RyeXtzZXRDdXJyZW50RmliZXIoaG9zdEZpYmVyKTtpZihmaWJlci5tb2RlJlN0cmljdExlZ2FjeU1vZGUpe2Vycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcrJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcrJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcrJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJysnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsbWV0aG9kTmFtZSxtZXRob2ROYW1lLGNvbXBvbmVudE5hbWUpO31lbHNle2Vycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcrJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnKydJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnKydMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLG1ldGhvZE5hbWUsbWV0aG9kTmFtZSxjb21wb25lbnROYW1lKTt9fWZpbmFsbHl7Ly8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4vLyByZW5kZXIgYW5kIHRoZXJlJ3MgYW5vdGhlciB3YXJuaW5nIGZvciB0aGF0IGFueXdheS5cbmlmKHByZXZpb3VzRmliZXIpe3NldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTt9ZWxzZXtyZXNldEN1cnJlbnRGaWJlcigpO319fX1yZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTt9fWZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLHRhZyxoeWRyYXRpb25DYWxsYmFja3MsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IsdHJhbnNpdGlvbkNhbGxiYWNrcyl7dmFyIGh5ZHJhdGU9ZmFsc2U7dmFyIGluaXRpYWxDaGlsZHJlbj1udWxsO3JldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbyx0YWcsaHlkcmF0ZSxpbml0aWFsQ2hpbGRyZW4saHlkcmF0aW9uQ2FsbGJhY2tzLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yKTt9ZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwvLyBUT0RPOiBSZW1vdmUgYGNhbGxiYWNrYCB3aGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZS5cbmNhbGxiYWNrLGNvbnRhaW5lckluZm8sdGFnLGh5ZHJhdGlvbkNhbGxiYWNrcyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcix0cmFuc2l0aW9uQ2FsbGJhY2tzKXt2YXIgaHlkcmF0ZT10cnVlO3ZhciByb290PWNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLHRhZyxoeWRyYXRlLGluaXRpYWxDaGlsZHJlbixoeWRyYXRpb25DYWxsYmFja3MsaXNTdHJpY3RNb2RlLGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsaWRlbnRpZmllclByZWZpeCxvblJlY292ZXJhYmxlRXJyb3IpOy8vIFRPRE86IE1vdmUgdGhpcyB0byBGaWJlclJvb3QgY29uc3RydWN0b3JcbnJvb3QuY29udGV4dD1nZXRDb250ZXh0Rm9yU3VidHJlZShudWxsKTsvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cbi8vIGEgcmVndWxhciB1cGRhdGUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgbXVzdCBtYXRjaCB3YXMgd2FzIHJlbmRlcmVkXG4vLyBvbiB0aGUgc2VydmVyLlxuLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG4vLyB0aGUgdXBkYXRlIHRvIHNjaGVkdWxlIHdvcmsgb24gdGhlIHJvb3QgZmliZXIgKGFuZCwgZm9yIGxlZ2FjeSByb290cywgdG9cbi8vIGVucXVldWUgdGhlIGNhbGxiYWNrIGlmIG9uZSBpcyBwcm92aWRlZCkuXG52YXIgY3VycmVudD1yb290LmN1cnJlbnQ7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7dmFyIHVwZGF0ZT1jcmVhdGVVcGRhdGUoZXZlbnRUaW1lLGxhbmUpO3VwZGF0ZS5jYWxsYmFjaz1jYWxsYmFjayE9PXVuZGVmaW5lZCYmY2FsbGJhY2shPT1udWxsP2NhbGxiYWNrOm51bGw7ZW5xdWV1ZVVwZGF0ZShjdXJyZW50LHVwZGF0ZSxsYW5lKTtzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCxsYW5lLGV2ZW50VGltZSk7cmV0dXJuIHJvb3Q7fWZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LGNvbnRhaW5lcixwYXJlbnRDb21wb25lbnQsY2FsbGJhY2spe3tvblNjaGVkdWxlUm9vdChjb250YWluZXIsZWxlbWVudCk7fXZhciBjdXJyZW50JDE9Y29udGFpbmVyLmN1cnJlbnQ7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7dmFyIGxhbmU9cmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCQxKTt7bWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTt9dmFyIGNvbnRleHQ9Z2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtpZihjb250YWluZXIuY29udGV4dD09PW51bGwpe2NvbnRhaW5lci5jb250ZXh0PWNvbnRleHQ7fWVsc2V7Y29udGFpbmVyLnBlbmRpbmdDb250ZXh0PWNvbnRleHQ7fXtpZihpc1JlbmRlcmluZyYmY3VycmVudCE9PW51bGwmJiFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKXtkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzPXRydWU7ZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnKyd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJysnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nKydDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCl8fCdVbmtub3duJyk7fX12YXIgdXBkYXRlPWNyZWF0ZVVwZGF0ZShldmVudFRpbWUsbGFuZSk7Ly8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxudXBkYXRlLnBheWxvYWQ9e2VsZW1lbnQ6ZWxlbWVudH07Y2FsbGJhY2s9Y2FsbGJhY2s9PT11bmRlZmluZWQ/bnVsbDpjYWxsYmFjaztpZihjYWxsYmFjayE9PW51bGwpe3tpZih0eXBlb2YgY2FsbGJhY2shPT0nZnVuY3Rpb24nKXtlcnJvcigncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnKydmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJyxjYWxsYmFjayk7fX11cGRhdGUuY2FsbGJhY2s9Y2FsbGJhY2s7fXZhciByb290PWVucXVldWVVcGRhdGUoY3VycmVudCQxLHVwZGF0ZSxsYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsY3VycmVudCQxLGxhbmUsZXZlbnRUaW1lKTtlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsY3VycmVudCQxLGxhbmUpO31yZXR1cm4gbGFuZTt9ZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcil7dmFyIGNvbnRhaW5lckZpYmVyPWNvbnRhaW5lci5jdXJyZW50O2lmKCFjb250YWluZXJGaWJlci5jaGlsZCl7cmV0dXJuIG51bGw7fXN3aXRjaChjb250YWluZXJGaWJlci5jaGlsZC50YWcpe2Nhc2UgSG9zdENvbXBvbmVudDpyZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtkZWZhdWx0OnJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7fX1mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24kMShmaWJlcil7c3dpdGNoKGZpYmVyLnRhZyl7Y2FzZSBIb3N0Um9vdDp7dmFyIHJvb3Q9ZmliZXIuc3RhdGVOb2RlO2lmKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpey8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbnZhciBsYW5lcz1nZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCk7Zmx1c2hSb290KHJvb3QsbGFuZXMpO31icmVhazt9Y2FzZSBTdXNwZW5zZUNvbXBvbmVudDp7Zmx1c2hTeW5jKGZ1bmN0aW9uKCl7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsZXZlbnRUaW1lKTt9fSk7Ly8gSWYgd2UncmUgc3RpbGwgYmxvY2tlZCBhZnRlciB0aGlzLCB3ZSBuZWVkIHRvIGluY3JlYXNlXG4vLyB0aGUgcHJpb3JpdHkgb2YgYW55IHByb21pc2VzIHJlc29sdmluZyB3aXRoaW4gdGhpc1xuLy8gYm91bmRhcnkgc28gdGhhdCB0aGV5IG5leHQgYXR0ZW1wdCBhbHNvIGhhcyBoaWdoZXIgcHJpLlxudmFyIHJldHJ5TGFuZT1TeW5jTGFuZTttYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlcixyZXRyeUxhbmUpO2JyZWFrO319fWZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLHJldHJ5TGFuZSl7dmFyIHN1c3BlbnNlU3RhdGU9ZmliZXIubWVtb2l6ZWRTdGF0ZTtpZihzdXNwZW5zZVN0YXRlIT09bnVsbCYmc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIT09bnVsbCl7c3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU9aGlnaGVyUHJpb3JpdHlMYW5lKHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lLHJldHJ5TGFuZSk7fX0vLyBJbmNyZWFzZXMgdGhlIHByaW9yaXR5IG9mIHRoZW5hYmxlcyB3aGVuIHRoZXkgcmVzb2x2ZSB3aXRoaW4gdGhpcyBib3VuZGFyeS5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLHJldHJ5TGFuZSl7bWFya1JldHJ5TGFuZUltcGwoZmliZXIscmV0cnlMYW5lKTt2YXIgYWx0ZXJuYXRlPWZpYmVyLmFsdGVybmF0ZTtpZihhbHRlcm5hdGUpe21hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSxyZXRyeUxhbmUpO319ZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMShmaWJlcil7aWYoZmliZXIudGFnIT09U3VzcGVuc2VDb21wb25lbnQpey8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4vLyB0aGVpciBwcmlvcml0eSBhbmQgdGhleSBzaG91bGQgbm90IHN1c3BlbmQgb24gSS9PLFxuLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbi8vIFN1c3BlbnNlLlxucmV0dXJuO312YXIgbGFuZT1TZWxlY3RpdmVIeWRyYXRpb25MYW5lO3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixsYW5lKTtpZihyb290IT09bnVsbCl7dmFyIGV2ZW50VGltZT1yZXF1ZXN0RXZlbnRUaW1lKCk7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsbGFuZSxldmVudFRpbWUpO31tYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlcixsYW5lKTt9ZnVuY3Rpb24gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEoZmliZXIpe2lmKGZpYmVyLnRhZyE9PVN1c3BlbnNlQ29tcG9uZW50KXsvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuLy8gdGhlaXIgcHJpb3JpdHkgb3RoZXIgdGhhbiBzeW5jaHJvbm91c2x5IGZsdXNoIGl0LlxucmV0dXJuO312YXIgbGFuZT1yZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLGxhbmUpO2lmKHJvb3QhPT1udWxsKXt2YXIgZXZlbnRUaW1lPXJlcXVlc3RFdmVudFRpbWUoKTtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixsYW5lLGV2ZW50VGltZSk7fW1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLGxhbmUpO31mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcil7dmFyIGhvc3RGaWJlcj1maW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO2lmKGhvc3RGaWJlcj09PW51bGwpe3JldHVybiBudWxsO31yZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTt9dmFyIHNob3VsZEVycm9ySW1wbD1mdW5jdGlvbihmaWJlcil7cmV0dXJuIG51bGw7fTtmdW5jdGlvbiBzaG91bGRFcnJvcihmaWJlcil7cmV0dXJuIHNob3VsZEVycm9ySW1wbChmaWJlcik7fXZhciBzaG91bGRTdXNwZW5kSW1wbD1mdW5jdGlvbihmaWJlcil7cmV0dXJuIGZhbHNlO307ZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcil7cmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTt9dmFyIG92ZXJyaWRlSG9va1N0YXRlPW51bGw7dmFyIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aD1udWxsO3ZhciBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg9bnVsbDt2YXIgb3ZlcnJpZGVQcm9wcz1udWxsO3ZhciBvdmVycmlkZVByb3BzRGVsZXRlUGF0aD1udWxsO3ZhciBvdmVycmlkZVByb3BzUmVuYW1lUGF0aD1udWxsO3ZhciBzY2hlZHVsZVVwZGF0ZT1udWxsO3ZhciBzZXRFcnJvckhhbmRsZXI9bnVsbDt2YXIgc2V0U3VzcGVuc2VIYW5kbGVyPW51bGw7e3ZhciBjb3B5V2l0aERlbGV0ZUltcGw9ZnVuY3Rpb24ob2JqLHBhdGgsaW5kZXgpe3ZhciBrZXk9cGF0aFtpbmRleF07dmFyIHVwZGF0ZWQ9aXNBcnJheShvYmopP29iai5zbGljZSgpOmFzc2lnbih7fSxvYmopO2lmKGluZGV4KzE9PT1wYXRoLmxlbmd0aCl7aWYoaXNBcnJheSh1cGRhdGVkKSl7dXBkYXRlZC5zcGxpY2Uoa2V5LDEpO31lbHNle2RlbGV0ZSB1cGRhdGVkW2tleV07fXJldHVybiB1cGRhdGVkO30vLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG51cGRhdGVkW2tleV09Y29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLHBhdGgsaW5kZXgrMSk7cmV0dXJuIHVwZGF0ZWQ7fTt2YXIgY29weVdpdGhEZWxldGU9ZnVuY3Rpb24ob2JqLHBhdGgpe3JldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLHBhdGgsMCk7fTt2YXIgY29weVdpdGhSZW5hbWVJbXBsPWZ1bmN0aW9uKG9iaixvbGRQYXRoLG5ld1BhdGgsaW5kZXgpe3ZhciBvbGRLZXk9b2xkUGF0aFtpbmRleF07dmFyIHVwZGF0ZWQ9aXNBcnJheShvYmopP29iai5zbGljZSgpOmFzc2lnbih7fSxvYmopO2lmKGluZGV4KzE9PT1vbGRQYXRoLmxlbmd0aCl7dmFyIG5ld0tleT1uZXdQYXRoW2luZGV4XTsvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG51cGRhdGVkW25ld0tleV09dXBkYXRlZFtvbGRLZXldO2lmKGlzQXJyYXkodXBkYXRlZCkpe3VwZGF0ZWQuc3BsaWNlKG9sZEtleSwxKTt9ZWxzZXtkZWxldGUgdXBkYXRlZFtvbGRLZXldO319ZWxzZXsvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG51cGRhdGVkW29sZEtleV09Y29weVdpdGhSZW5hbWVJbXBsKC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbm9ialtvbGRLZXldLG9sZFBhdGgsbmV3UGF0aCxpbmRleCsxKTt9cmV0dXJuIHVwZGF0ZWQ7fTt2YXIgY29weVdpdGhSZW5hbWU9ZnVuY3Rpb24ob2JqLG9sZFBhdGgsbmV3UGF0aCl7aWYob2xkUGF0aC5sZW5ndGghPT1uZXdQYXRoLmxlbmd0aCl7d2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aCcpO3JldHVybjt9ZWxzZXtmb3IodmFyIGk9MDtpPG5ld1BhdGgubGVuZ3RoLTE7aSsrKXtpZihvbGRQYXRoW2ldIT09bmV3UGF0aFtpXSl7d2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7cmV0dXJuO319fXJldHVybiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLG9sZFBhdGgsbmV3UGF0aCwwKTt9O3ZhciBjb3B5V2l0aFNldEltcGw9ZnVuY3Rpb24ob2JqLHBhdGgsaW5kZXgsdmFsdWUpe2lmKGluZGV4Pj1wYXRoLmxlbmd0aCl7cmV0dXJuIHZhbHVlO312YXIga2V5PXBhdGhbaW5kZXhdO3ZhciB1cGRhdGVkPWlzQXJyYXkob2JqKT9vYmouc2xpY2UoKTphc3NpZ24oe30sb2JqKTsvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG51cGRhdGVkW2tleV09Y29weVdpdGhTZXRJbXBsKG9ialtrZXldLHBhdGgsaW5kZXgrMSx2YWx1ZSk7cmV0dXJuIHVwZGF0ZWQ7fTt2YXIgY29weVdpdGhTZXQ9ZnVuY3Rpb24ob2JqLHBhdGgsdmFsdWUpe3JldHVybiBjb3B5V2l0aFNldEltcGwob2JqLHBhdGgsMCx2YWx1ZSk7fTt2YXIgZmluZEhvb2s9ZnVuY3Rpb24oZmliZXIsaWQpey8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbi8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG52YXIgY3VycmVudEhvb2s9ZmliZXIubWVtb2l6ZWRTdGF0ZTt3aGlsZShjdXJyZW50SG9vayE9PW51bGwmJmlkPjApe2N1cnJlbnRIb29rPWN1cnJlbnRIb29rLm5leHQ7aWQtLTt9cmV0dXJuIGN1cnJlbnRIb29rO307Ly8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxub3ZlcnJpZGVIb29rU3RhdGU9ZnVuY3Rpb24oZmliZXIsaWQscGF0aCx2YWx1ZSl7dmFyIGhvb2s9ZmluZEhvb2soZmliZXIsaWQpO2lmKGhvb2shPT1udWxsKXt2YXIgbmV3U3RhdGU9Y29weVdpdGhTZXQoaG9vay5tZW1vaXplZFN0YXRlLHBhdGgsdmFsdWUpO2hvb2subWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTtob29rLmJhc2VTdGF0ZT1uZXdTdGF0ZTsvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4vLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbi8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4vLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuZmliZXIubWVtb2l6ZWRQcm9wcz1hc3NpZ24oe30sZmliZXIubWVtb2l6ZWRQcm9wcyk7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319fTtvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg9ZnVuY3Rpb24oZmliZXIsaWQscGF0aCl7dmFyIGhvb2s9ZmluZEhvb2soZmliZXIsaWQpO2lmKGhvb2shPT1udWxsKXt2YXIgbmV3U3RhdGU9Y29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLHBhdGgpO2hvb2subWVtb2l6ZWRTdGF0ZT1uZXdTdGF0ZTtob29rLmJhc2VTdGF0ZT1uZXdTdGF0ZTsvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4vLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbi8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4vLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuZmliZXIubWVtb2l6ZWRQcm9wcz1hc3NpZ24oe30sZmliZXIubWVtb2l6ZWRQcm9wcyk7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319fTtvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg9ZnVuY3Rpb24oZmliZXIsaWQsb2xkUGF0aCxuZXdQYXRoKXt2YXIgaG9vaz1maW5kSG9vayhmaWJlcixpZCk7aWYoaG9vayE9PW51bGwpe3ZhciBuZXdTdGF0ZT1jb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsb2xkUGF0aCxuZXdQYXRoKTtob29rLm1lbW9pemVkU3RhdGU9bmV3U3RhdGU7aG9vay5iYXNlU3RhdGU9bmV3U3RhdGU7Ly8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4vLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbi8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cbmZpYmVyLm1lbW9pemVkUHJvcHM9YXNzaWduKHt9LGZpYmVyLm1lbW9pemVkUHJvcHMpO3ZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fX07Ly8gU3VwcG9ydCBEZXZUb29scyBwcm9wcyBmb3IgZnVuY3Rpb24gY29tcG9uZW50cywgZm9yd2FyZFJlZiwgbWVtbywgaG9zdCBjb21wb25lbnRzLCBldGMuXG5vdmVycmlkZVByb3BzPWZ1bmN0aW9uKGZpYmVyLHBhdGgsdmFsdWUpe2ZpYmVyLnBlbmRpbmdQcm9wcz1jb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLHBhdGgsdmFsdWUpO2lmKGZpYmVyLmFsdGVybmF0ZSl7ZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7fXZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fTtvdmVycmlkZVByb3BzRGVsZXRlUGF0aD1mdW5jdGlvbihmaWJlcixwYXRoKXtmaWJlci5wZW5kaW5nUHJvcHM9Y29weVdpdGhEZWxldGUoZmliZXIubWVtb2l6ZWRQcm9wcyxwYXRoKTtpZihmaWJlci5hbHRlcm5hdGUpe2ZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHM9ZmliZXIucGVuZGluZ1Byb3BzO312YXIgcm9vdD1lbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsU3luY0xhbmUpO2lmKHJvb3QhPT1udWxsKXtzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCxmaWJlcixTeW5jTGFuZSxOb1RpbWVzdGFtcCk7fX07b3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg9ZnVuY3Rpb24oZmliZXIsb2xkUGF0aCxuZXdQYXRoKXtmaWJlci5wZW5kaW5nUHJvcHM9Y29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcyxvbGRQYXRoLG5ld1BhdGgpO2lmKGZpYmVyLmFsdGVybmF0ZSl7ZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcz1maWJlci5wZW5kaW5nUHJvcHM7fXZhciByb290PWVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlcixTeW5jTGFuZSk7aWYocm9vdCE9PW51bGwpe3NjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LGZpYmVyLFN5bmNMYW5lLE5vVGltZXN0YW1wKTt9fTtzY2hlZHVsZVVwZGF0ZT1mdW5jdGlvbihmaWJlcil7dmFyIHJvb3Q9ZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLFN5bmNMYW5lKTtpZihyb290IT09bnVsbCl7c2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsZmliZXIsU3luY0xhbmUsTm9UaW1lc3RhbXApO319O3NldEVycm9ySGFuZGxlcj1mdW5jdGlvbihuZXdTaG91bGRFcnJvckltcGwpe3Nob3VsZEVycm9ySW1wbD1uZXdTaG91bGRFcnJvckltcGw7fTtzZXRTdXNwZW5zZUhhbmRsZXI9ZnVuY3Rpb24obmV3U2hvdWxkU3VzcGVuZEltcGwpe3Nob3VsZFN1c3BlbmRJbXBsPW5ld1Nob3VsZFN1c3BlbmRJbXBsO307fWZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKXt2YXIgaG9zdEZpYmVyPWZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtpZihob3N0RmliZXI9PT1udWxsKXtyZXR1cm4gbnVsbDt9cmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7fWZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2Upe3JldHVybiBudWxsO31mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpe3JldHVybiBjdXJyZW50O31mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpe3ZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZT1kZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTt2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcj1SZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO3JldHVybiBpbmplY3RJbnRlcm5hbHMoe2J1bmRsZVR5cGU6ZGV2VG9vbHNDb25maWcuYnVuZGxlVHlwZSx2ZXJzaW9uOmRldlRvb2xzQ29uZmlnLnZlcnNpb24scmVuZGVyZXJQYWNrYWdlTmFtZTpkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLHJlbmRlcmVyQ29uZmlnOmRldlRvb2xzQ29uZmlnLnJlbmRlcmVyQ29uZmlnLG92ZXJyaWRlSG9va1N0YXRlOm92ZXJyaWRlSG9va1N0YXRlLG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDpvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxvdmVycmlkZVByb3BzOm92ZXJyaWRlUHJvcHMsb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6b3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6b3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsc2V0RXJyb3JIYW5kbGVyOnNldEVycm9ySGFuZGxlcixzZXRTdXNwZW5zZUhhbmRsZXI6c2V0U3VzcGVuc2VIYW5kbGVyLHNjaGVkdWxlVXBkYXRlOnNjaGVkdWxlVXBkYXRlLGN1cnJlbnREaXNwYXRjaGVyUmVmOlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsLy8gUmVhY3QgUmVmcmVzaFxuZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOmZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCxzY2hlZHVsZVJlZnJlc2g6c2NoZWR1bGVSZWZyZXNoLHNjaGVkdWxlUm9vdDpzY2hlZHVsZVJvb3Qsc2V0UmVmcmVzaEhhbmRsZXI6c2V0UmVmcmVzaEhhbmRsZXIsLy8gRW5hYmxlcyBEZXZUb29scyB0byBhcHBlbmQgb3duZXIgc3RhY2tzIHRvIGVycm9yIG1lc3NhZ2VzIGluIERFViBtb2RlLlxuZ2V0Q3VycmVudEZpYmVyOmdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzLC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gZGV0ZWN0IHJlY29uY2lsZXIgdmVyc2lvbiByYXRoZXIgdGhhbiByZW5kZXJlciB2ZXJzaW9uXG4vLyB3aGljaCBtYXkgbm90IG1hdGNoIGZvciB0aGlyZCBwYXJ0eSByZW5kZXJlcnMuXG5yZWNvbmNpbGVyVmVyc2lvbjpSZWFjdFZlcnNpb259KTt9LyogZ2xvYmFsIHJlcG9ydEVycm9yICovdmFyIGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I9dHlwZW9mIHJlcG9ydEVycm9yPT09J2Z1bmN0aW9uJz8vLyBJbiBtb2Rlcm4gYnJvd3NlcnMsIHJlcG9ydEVycm9yIHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQsXG4vLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbnJlcG9ydEVycm9yOmZ1bmN0aW9uKGVycm9yKXsvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5jb25zb2xlWydlcnJvciddKGVycm9yKTt9O2Z1bmN0aW9uIFJlYWN0RE9NUm9vdChpbnRlcm5hbFJvb3Qpe3RoaXMuX2ludGVybmFsUm9vdD1pbnRlcm5hbFJvb3Q7fVJlYWN0RE9NSHlkcmF0aW9uUm9vdC5wcm90b3R5cGUucmVuZGVyPVJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGNoaWxkcmVuKXt2YXIgcm9vdD10aGlzLl9pbnRlcm5hbFJvb3Q7aWYocm9vdD09PW51bGwpe3Rocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBhbiB1bm1vdW50ZWQgcm9vdC4nKTt9e2lmKHR5cGVvZiBhcmd1bWVudHNbMV09PT0nZnVuY3Rpb24nKXtlcnJvcigncmVuZGVyKC4uLik6IGRvZXMgbm90IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gJysnVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7fWVsc2UgaWYoaXNWYWxpZENvbnRhaW5lcihhcmd1bWVudHNbMV0pKXtlcnJvcignWW91IHBhc3NlZCBhIGNvbnRhaW5lciB0byB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIHJvb3QucmVuZGVyKC4uLikuICcrXCJZb3UgZG9uJ3QgbmVlZCB0byBwYXNzIGl0IGFnYWluIHNpbmNlIHlvdSBhbHJlYWR5IHBhc3NlZCBpdCB0byBjcmVhdGUgdGhlIHJvb3QuXCIpO31lbHNlIGlmKHR5cGVvZiBhcmd1bWVudHNbMV0hPT0ndW5kZWZpbmVkJyl7ZXJyb3IoJ1lvdSBwYXNzZWQgYSBzZWNvbmQgYXJndW1lbnQgdG8gcm9vdC5yZW5kZXIoLi4uKSBidXQgaXQgb25seSBhY2NlcHRzICcrJ29uZSBhcmd1bWVudC4nKTt9dmFyIGNvbnRhaW5lcj1yb290LmNvbnRhaW5lckluZm87aWYoY29udGFpbmVyLm5vZGVUeXBlIT09Q09NTUVOVF9OT0RFKXt2YXIgaG9zdEluc3RhbmNlPWZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKHJvb3QuY3VycmVudCk7aWYoaG9zdEluc3RhbmNlKXtpZihob3N0SW5zdGFuY2UucGFyZW50Tm9kZSE9PWNvbnRhaW5lcil7ZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoZSAnKydyb290IGNvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnKydzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcrXCJyb290LnVubW91bnQoKSB0byBlbXB0eSBhIHJvb3QncyBjb250YWluZXIuXCIpO319fX11cGRhdGVDb250YWluZXIoY2hpbGRyZW4scm9vdCxudWxsLG51bGwpO307UmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bm1vdW50PVJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbigpe3tpZih0eXBlb2YgYXJndW1lbnRzWzBdPT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ3VubW91bnQoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGxiYWNrIGFyZ3VtZW50LiAnKydUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTt9fXZhciByb290PXRoaXMuX2ludGVybmFsUm9vdDtpZihyb290IT09bnVsbCl7dGhpcy5faW50ZXJuYWxSb290PW51bGw7dmFyIGNvbnRhaW5lcj1yb290LmNvbnRhaW5lckluZm87e2lmKGlzQWxyZWFkeVJlbmRlcmluZygpKXtlcnJvcignQXR0ZW1wdGVkIHRvIHN5bmNocm9ub3VzbHkgdW5tb3VudCBhIHJvb3Qgd2hpbGUgUmVhY3Qgd2FzIGFscmVhZHkgJysncmVuZGVyaW5nLiBSZWFjdCBjYW5ub3QgZmluaXNoIHVubW91bnRpbmcgdGhlIHJvb3QgdW50aWwgdGhlICcrJ2N1cnJlbnQgcmVuZGVyIGhhcyBjb21wbGV0ZWQsIHdoaWNoIG1heSBsZWFkIHRvIGEgcmFjZSBjb25kaXRpb24uJyk7fX1mbHVzaFN5bmMoZnVuY3Rpb24oKXt1cGRhdGVDb250YWluZXIobnVsbCxyb290LG51bGwsbnVsbCk7fSk7dW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7fX07ZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsb3B0aW9ucyl7aWYoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCdjcmVhdGVSb290KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7fXdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKTt2YXIgaXNTdHJpY3RNb2RlPWZhbHNlO3ZhciBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlPWZhbHNlO3ZhciBpZGVudGlmaWVyUHJlZml4PScnO3ZhciBvblJlY292ZXJhYmxlRXJyb3I9ZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcjt2YXIgdHJhbnNpdGlvbkNhbGxiYWNrcz1udWxsO2lmKG9wdGlvbnMhPT1udWxsJiZvcHRpb25zIT09dW5kZWZpbmVkKXt7aWYob3B0aW9ucy5oeWRyYXRlKXt3YXJuKCdoeWRyYXRlIHRocm91Z2ggY3JlYXRlUm9vdCBpcyBkZXByZWNhdGVkLiBVc2UgUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoY29udGFpbmVyLCA8QXBwIC8+KSBpbnN0ZWFkLicpO31lbHNle2lmKHR5cGVvZiBvcHRpb25zPT09J29iamVjdCcmJm9wdGlvbnMhPT1udWxsJiZvcHRpb25zLiQkdHlwZW9mPT09UkVBQ1RfRUxFTUVOVF9UWVBFKXtlcnJvcignWW91IHBhc3NlZCBhIEpTWCBlbGVtZW50IHRvIGNyZWF0ZVJvb3QuIFlvdSBwcm9iYWJseSBtZWFudCB0byAnKydjYWxsIHJvb3QucmVuZGVyIGluc3RlYWQuICcrJ0V4YW1wbGUgdXNhZ2U6XFxuXFxuJysnICBsZXQgcm9vdCA9IGNyZWF0ZVJvb3QoZG9tQ29udGFpbmVyKTtcXG4nKycgIHJvb3QucmVuZGVyKDxBcHAgLz4pOycpO319fWlmKG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZT09PXRydWUpe2lzU3RyaWN0TW9kZT10cnVlO31pZihvcHRpb25zLmlkZW50aWZpZXJQcmVmaXghPT11bmRlZmluZWQpe2lkZW50aWZpZXJQcmVmaXg9b3B0aW9ucy5pZGVudGlmaWVyUHJlZml4O31pZihvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciE9PXVuZGVmaW5lZCl7b25SZWNvdmVyYWJsZUVycm9yPW9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yO31pZihvcHRpb25zLnRyYW5zaXRpb25DYWxsYmFja3MhPT11bmRlZmluZWQpe3RyYW5zaXRpb25DYWxsYmFja3M9b3B0aW9ucy50cmFuc2l0aW9uQ2FsbGJhY2tzO319dmFyIHJvb3Q9Y3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lcixDb25jdXJyZW50Um9vdCxudWxsLGlzU3RyaWN0TW9kZSxjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLGlkZW50aWZpZXJQcmVmaXgsb25SZWNvdmVyYWJsZUVycm9yKTttYXJrQ29udGFpbmVyQXNSb290KHJvb3QuY3VycmVudCxjb250YWluZXIpO3ZhciByb290Q29udGFpbmVyRWxlbWVudD1jb250YWluZXIubm9kZVR5cGU9PT1DT01NRU5UX05PREU/Y29udGFpbmVyLnBhcmVudE5vZGU6Y29udGFpbmVyO2xpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KTtyZXR1cm4gbmV3IFJlYWN0RE9NUm9vdChyb290KTt9ZnVuY3Rpb24gUmVhY3RET01IeWRyYXRpb25Sb290KGludGVybmFsUm9vdCl7dGhpcy5faW50ZXJuYWxSb290PWludGVybmFsUm9vdDt9ZnVuY3Rpb24gc2NoZWR1bGVIeWRyYXRpb24odGFyZ2V0KXtpZih0YXJnZXQpe3F1ZXVlRXhwbGljaXRIeWRyYXRpb25UYXJnZXQodGFyZ2V0KTt9fVJlYWN0RE9NSHlkcmF0aW9uUm9vdC5wcm90b3R5cGUudW5zdGFibGVfc2NoZWR1bGVIeWRyYXRpb249c2NoZWR1bGVIeWRyYXRpb247ZnVuY3Rpb24gaHlkcmF0ZVJvb3QoY29udGFpbmVyLGluaXRpYWxDaGlsZHJlbixvcHRpb25zKXtpZighaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKXt0aHJvdyBuZXcgRXJyb3IoJ2h5ZHJhdGVSb290KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7fXdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKTt7aWYoaW5pdGlhbENoaWxkcmVuPT09dW5kZWZpbmVkKXtlcnJvcignTXVzdCBwcm92aWRlIGluaXRpYWwgY2hpbGRyZW4gYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGh5ZHJhdGVSb290LiAnKydFeGFtcGxlIHVzYWdlOiBoeWRyYXRlUm9vdChkb21Db250YWluZXIsIDxBcHAgLz4pJyk7fX0vLyBGb3Igbm93IHdlIHJldXNlIHRoZSB3aG9sZSBiYWcgb2Ygb3B0aW9ucyBzaW5jZSB0aGV5IGNvbnRhaW5cbi8vIHRoZSBoeWRyYXRpb24gY2FsbGJhY2tzLlxudmFyIGh5ZHJhdGlvbkNhbGxiYWNrcz1vcHRpb25zIT1udWxsP29wdGlvbnM6bnVsbDsvLyBUT0RPOiBEZWxldGUgdGhpcyBvcHRpb25cbnZhciBtdXRhYmxlU291cmNlcz1vcHRpb25zIT1udWxsJiZvcHRpb25zLmh5ZHJhdGVkU291cmNlc3x8bnVsbDt2YXIgaXNTdHJpY3RNb2RlPWZhbHNlO3ZhciBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlPWZhbHNlO3ZhciBpZGVudGlmaWVyUHJlZml4PScnO3ZhciBvblJlY292ZXJhYmxlRXJyb3I9ZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcjtpZihvcHRpb25zIT09bnVsbCYmb3B0aW9ucyE9PXVuZGVmaW5lZCl7aWYob3B0aW9ucy51bnN0YWJsZV9zdHJpY3RNb2RlPT09dHJ1ZSl7aXNTdHJpY3RNb2RlPXRydWU7fWlmKG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCE9PXVuZGVmaW5lZCl7aWRlbnRpZmllclByZWZpeD1vcHRpb25zLmlkZW50aWZpZXJQcmVmaXg7fWlmKG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yIT09dW5kZWZpbmVkKXtvblJlY292ZXJhYmxlRXJyb3I9b3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3I7fX12YXIgcm9vdD1jcmVhdGVIeWRyYXRpb25Db250YWluZXIoaW5pdGlhbENoaWxkcmVuLG51bGwsY29udGFpbmVyLENvbmN1cnJlbnRSb290LGh5ZHJhdGlvbkNhbGxiYWNrcyxpc1N0cmljdE1vZGUsY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxpZGVudGlmaWVyUHJlZml4LG9uUmVjb3ZlcmFibGVFcnJvcik7bWFya0NvbnRhaW5lckFzUm9vdChyb290LmN1cnJlbnQsY29udGFpbmVyKTsvLyBUaGlzIGNhbid0IGJlIGEgY29tbWVudCBub2RlIHNpbmNlIGh5ZHJhdGlvbiBkb2Vzbid0IHdvcmsgb24gY29tbWVudCBub2RlcyBhbnl3YXkuXG5saXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhjb250YWluZXIpO2lmKG11dGFibGVTb3VyY2VzKXtmb3IodmFyIGk9MDtpPG11dGFibGVTb3VyY2VzLmxlbmd0aDtpKyspe3ZhciBtdXRhYmxlU291cmNlPW11dGFibGVTb3VyY2VzW2ldO3JlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LG11dGFibGVTb3VyY2UpO319cmV0dXJuIG5ldyBSZWFjdERPTUh5ZHJhdGlvblJvb3Qocm9vdCk7fWZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSl7cmV0dXJuISEobm9kZSYmKG5vZGUubm9kZVR5cGU9PT1FTEVNRU5UX05PREV8fG5vZGUubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFfHxub2RlLm5vZGVUeXBlPT09RE9DVU1FTlRfRlJBR01FTlRfTk9ERXx8IWRpc2FibGVDb21tZW50c0FzRE9NQ29udGFpbmVycykpO30vLyBUT0RPOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiB3aGljaCBhbHNvIGluY2x1ZGVzIGNvbW1lbnQgbm9kZXMuXG4vLyBXZSBvbmx5IHVzZSBpdCBpbiBwbGFjZXMgdGhhdCBhcmUgY3VycmVudGx5IG1vcmUgcmVsYXhlZC5cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXJMZWdhY3kobm9kZSl7cmV0dXJuISEobm9kZSYmKG5vZGUubm9kZVR5cGU9PT1FTEVNRU5UX05PREV8fG5vZGUubm9kZVR5cGU9PT1ET0NVTUVOVF9OT0RFfHxub2RlLm5vZGVUeXBlPT09RE9DVU1FTlRfRlJBR01FTlRfTk9ERXx8bm9kZS5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERSYmbm9kZS5ub2RlVmFsdWU9PT0nIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTt9ZnVuY3Rpb24gd2FybklmUmVhY3RET01Db250YWluZXJJbkRFVihjb250YWluZXIpe3tpZihjb250YWluZXIubm9kZVR5cGU9PT1FTEVNRU5UX05PREUmJmNvbnRhaW5lci50YWdOYW1lJiZjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpPT09J0JPRFknKXtlcnJvcignY3JlYXRlUm9vdCgpOiBDcmVhdGluZyByb290cyBkaXJlY3RseSB3aXRoIGRvY3VtZW50LmJvZHkgaXMgJysnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJysnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnKydyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSB1c2luZyBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJysnZm9yIHlvdXIgYXBwLicpO31pZihpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpKXtpZihjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcil7ZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnKydwYXNzZWQgdG8gUmVhY3RET00ucmVuZGVyKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4nKTt9ZWxzZXtlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKSBvbiBhIGNvbnRhaW5lciB0aGF0ICcrJ2hhcyBhbHJlYWR5IGJlZW4gcGFzc2VkIHRvIGNyZWF0ZVJvb3QoKSBiZWZvcmUuIEluc3RlYWQsIGNhbGwgJysncm9vdC5yZW5kZXIoKSBvbiB0aGUgZXhpc3Rpbmcgcm9vdCBpbnN0ZWFkIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBpdC4nKTt9fX19dmFyIFJlYWN0Q3VycmVudE93bmVyJDM9UmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7dmFyIHRvcExldmVsVXBkYXRlV2FybmluZ3M7e3RvcExldmVsVXBkYXRlV2FybmluZ3M9ZnVuY3Rpb24oY29udGFpbmVyKXtpZihjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciYmY29udGFpbmVyLm5vZGVUeXBlIT09Q09NTUVOVF9OT0RFKXt2YXIgaG9zdEluc3RhbmNlPWZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO2lmKGhvc3RJbnN0YW5jZSl7aWYoaG9zdEluc3RhbmNlLnBhcmVudE5vZGUhPT1jb250YWluZXIpe2Vycm9yKCdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcrJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnKydzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcrJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJyk7fX19dmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3Q9ISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjt2YXIgcm9vdEVsPWdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO3ZhciBoYXNOb25Sb290UmVhY3RDaGlsZD0hIShyb290RWwmJmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7aWYoaGFzTm9uUm9vdFJlYWN0Q2hpbGQmJiFpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0KXtlcnJvcigncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJysnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcrJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJysnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKTt9aWYoY29udGFpbmVyLm5vZGVUeXBlPT09RUxFTUVOVF9OT0RFJiZjb250YWluZXIudGFnTmFtZSYmY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKT09PSdCT0RZJyl7ZXJyb3IoJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJysnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJysnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnKydyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJysnZm9yIHlvdXIgYXBwLicpO319O31mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKXtpZighY29udGFpbmVyKXtyZXR1cm4gbnVsbDt9aWYoY29udGFpbmVyLm5vZGVUeXBlPT09RE9DVU1FTlRfTk9ERSl7cmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7fWVsc2V7cmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO319ZnVuY3Rpb24gbm9vcE9uUmVjb3ZlcmFibGVFcnJvcigpey8vIFRoaXMgaXNuJ3QgcmVhY2hhYmxlIGJlY2F1c2Ugb25SZWNvdmVyYWJsZUVycm9yIGlzbid0IGNhbGxlZCBpbiB0aGVcbi8vIGxlZ2FjeSBBUEkuXG59ZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLGluaXRpYWxDaGlsZHJlbixwYXJlbnRDb21wb25lbnQsY2FsbGJhY2ssaXNIeWRyYXRpb25Db250YWluZXIpe2lmKGlzSHlkcmF0aW9uQ29udGFpbmVyKXtpZih0eXBlb2YgY2FsbGJhY2s9PT0nZnVuY3Rpb24nKXt2YXIgb3JpZ2luYWxDYWxsYmFjaz1jYWxsYmFjaztjYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBpbnN0YW5jZT1nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7b3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTt9O312YXIgcm9vdD1jcmVhdGVIeWRyYXRpb25Db250YWluZXIoaW5pdGlhbENoaWxkcmVuLGNhbGxiYWNrLGNvbnRhaW5lcixMZWdhY3lSb290LG51bGwsLy8gaHlkcmF0aW9uQ2FsbGJhY2tzXG5mYWxzZSwvLyBpc1N0cmljdE1vZGVcbmZhbHNlLC8vIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4nJywvLyBpZGVudGlmaWVyUHJlZml4XG5ub29wT25SZWNvdmVyYWJsZUVycm9yKTtjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcj1yb290O21hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LGNvbnRhaW5lcik7dmFyIHJvb3RDb250YWluZXJFbGVtZW50PWNvbnRhaW5lci5ub2RlVHlwZT09PUNPTU1FTlRfTk9ERT9jb250YWluZXIucGFyZW50Tm9kZTpjb250YWluZXI7bGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO2ZsdXNoU3luYygpO3JldHVybiByb290O31lbHNley8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxudmFyIHJvb3RTaWJsaW5nO3doaWxlKHJvb3RTaWJsaW5nPWNvbnRhaW5lci5sYXN0Q2hpbGQpe2NvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7fWlmKHR5cGVvZiBjYWxsYmFjaz09PSdmdW5jdGlvbicpe3ZhciBfb3JpZ2luYWxDYWxsYmFjaz1jYWxsYmFjaztjYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBpbnN0YW5jZT1nZXRQdWJsaWNSb290SW5zdGFuY2UoX3Jvb3QpO19vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO307fXZhciBfcm9vdD1jcmVhdGVDb250YWluZXIoY29udGFpbmVyLExlZ2FjeVJvb3QsbnVsbCwvLyBoeWRyYXRpb25DYWxsYmFja3NcbmZhbHNlLC8vIGlzU3RyaWN0TW9kZVxuZmFsc2UsLy8gY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxcbicnLC8vIGlkZW50aWZpZXJQcmVmaXhcbm5vb3BPblJlY292ZXJhYmxlRXJyb3IpO2NvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyPV9yb290O21hcmtDb250YWluZXJBc1Jvb3QoX3Jvb3QuY3VycmVudCxjb250YWluZXIpO3ZhciBfcm9vdENvbnRhaW5lckVsZW1lbnQ9Y29udGFpbmVyLm5vZGVUeXBlPT09Q09NTUVOVF9OT0RFP2NvbnRhaW5lci5wYXJlbnROb2RlOmNvbnRhaW5lcjtsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhfcm9vdENvbnRhaW5lckVsZW1lbnQpOy8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuZmx1c2hTeW5jKGZ1bmN0aW9uKCl7dXBkYXRlQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbixfcm9vdCxwYXJlbnRDb21wb25lbnQsY2FsbGJhY2spO30pO3JldHVybiBfcm9vdDt9fWZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLGNhbGxlck5hbWUpe3tpZihjYWxsYmFjayE9PW51bGwmJnR5cGVvZiBjYWxsYmFjayE9PSdmdW5jdGlvbicpe2Vycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJysnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsY2FsbGVyTmFtZSxjYWxsYmFjayk7fX19ZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LGNoaWxkcmVuLGNvbnRhaW5lcixmb3JjZUh5ZHJhdGUsY2FsbGJhY2spe3t0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7d2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2s9PT11bmRlZmluZWQ/bnVsbDpjYWxsYmFjaywncmVuZGVyJyk7fXZhciBtYXliZVJvb3Q9Y29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7dmFyIHJvb3Q7aWYoIW1heWJlUm9vdCl7Ly8gSW5pdGlhbCBtb3VudFxucm9vdD1sZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsY2hpbGRyZW4scGFyZW50Q29tcG9uZW50LGNhbGxiYWNrLGZvcmNlSHlkcmF0ZSk7fWVsc2V7cm9vdD1tYXliZVJvb3Q7aWYodHlwZW9mIGNhbGxiYWNrPT09J2Z1bmN0aW9uJyl7dmFyIG9yaWdpbmFsQ2FsbGJhY2s9Y2FsbGJhY2s7Y2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgaW5zdGFuY2U9Z2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7fTt9Ly8gVXBkYXRlXG51cGRhdGVDb250YWluZXIoY2hpbGRyZW4scm9vdCxwYXJlbnRDb21wb25lbnQsY2FsbGJhY2spO31yZXR1cm4gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO312YXIgZGlkV2FybkFib3V0RmluZERPTU5vZGU9ZmFsc2U7ZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KXt7aWYoIWRpZFdhcm5BYm91dEZpbmRET01Ob2RlKXtkaWRXYXJuQWJvdXRGaW5kRE9NTm9kZT10cnVlO2Vycm9yKCdmaW5kRE9NTm9kZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgJysncmVsZWFzZS4gSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50ICcrJ3RvIHJlZmVyZW5jZS4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnKydodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJyk7fXZhciBvd25lcj1SZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQ7aWYob3duZXIhPT1udWxsJiZvd25lci5zdGF0ZU5vZGUhPT1udWxsKXt2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI9b3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtpZighd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpe2Vycm9yKCclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJysncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnKyduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnKydyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnKydjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKXx8J0EgY29tcG9uZW50Jyk7fW93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI9dHJ1ZTt9fWlmKGNvbXBvbmVudE9yRWxlbWVudD09bnVsbCl7cmV0dXJuIG51bGw7fWlmKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSl7cmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDt9e3JldHVybiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50T3JFbGVtZW50LCdmaW5kRE9NTm9kZScpO319ZnVuY3Rpb24gaHlkcmF0ZShlbGVtZW50LGNvbnRhaW5lcixjYWxsYmFjayl7e2Vycm9yKCdSZWFjdERPTS5oeWRyYXRlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBoeWRyYXRlUm9vdCAnKydpbnN0ZWFkLiBVbnRpbCB5b3Ugc3dpdGNoIHRvIHRoZSBuZXcgQVBJLCB5b3VyIGFwcCB3aWxsIGJlaGF2ZSBhcyAnK1wiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIisnbW9yZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N3aXRjaC10by1jcmVhdGVyb290Jyk7fWlmKCFpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KGNvbnRhaW5lcikpe3Rocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9e3ZhciBpc01vZGVyblJvb3Q9aXNDb250YWluZXJNYXJrZWRBc1Jvb3QoY29udGFpbmVyKSYmY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9PT11bmRlZmluZWQ7aWYoaXNNb2Rlcm5Sb290KXtlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcrJ3Bhc3NlZCB0byBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gJysnRGlkIHlvdSBtZWFuIHRvIGNhbGwgaHlkcmF0ZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KT8nKTt9fS8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbnJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLGVsZW1lbnQsY29udGFpbmVyLHRydWUsY2FsbGJhY2spO31mdW5jdGlvbiByZW5kZXIoZWxlbWVudCxjb250YWluZXIsY2FsbGJhY2spe3tlcnJvcignUmVhY3RET00ucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290ICcrJ2luc3RlYWQuIFVudGlsIHlvdSBzd2l0Y2ggdG8gdGhlIG5ldyBBUEksIHlvdXIgYXBwIHdpbGwgYmVoYXZlIGFzICcrXCJpZiBpdCdzIHJ1bm5pbmcgUmVhY3QgMTcuIExlYXJuIFwiKydtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTt9aWYoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO317dmFyIGlzTW9kZXJuUm9vdD1pc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpJiZjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcj09PXVuZGVmaW5lZDtpZihpc01vZGVyblJvb3Qpe2Vycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnKydwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcrJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QucmVuZGVyKGVsZW1lbnQpPycpO319cmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsZWxlbWVudCxjb250YWluZXIsZmFsc2UsY2FsbGJhY2spO31mdW5jdGlvbiB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsZWxlbWVudCxjb250YWluZXJOb2RlLGNhbGxiYWNrKXt7ZXJyb3IoJ1JlYWN0RE9NLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAnKydpbiBSZWFjdCAxOC4gQ29uc2lkZXIgdXNpbmcgYSBwb3J0YWwgaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byAnK1widGhlIGNyZWF0ZVJvb3QgQVBJLCB5b3VyIGFwcCB3aWxsIGJlaGF2ZSBhcyBpZiBpdCdzIHJ1bm5pbmcgUmVhY3QgXCIrJzE3LiBMZWFybiBtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTt9aWYoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyTm9kZSkpe3Rocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTt9aWYocGFyZW50Q29tcG9uZW50PT1udWxsfHwhaGFzKHBhcmVudENvbXBvbmVudCkpe3Rocm93IG5ldyBFcnJvcigncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKTt9cmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCxlbGVtZW50LGNvbnRhaW5lck5vZGUsZmFsc2UsY2FsbGJhY2spO312YXIgZGlkV2FybkFib3V0VW5tb3VudENvbXBvbmVudEF0Tm9kZT1mYWxzZTtmdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcil7e2lmKCFkaWRXYXJuQWJvdXRVbm1vdW50Q29tcG9uZW50QXROb2RlKXtkaWRXYXJuQWJvdXRVbm1vdW50Q29tcG9uZW50QXROb2RlPXRydWU7ZXJyb3IoJ3VubW91bnRDb21wb25lbnRBdE5vZGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSAnKyduZXh0IG1ham9yIHJlbGVhc2UuIFN3aXRjaCB0byB0aGUgY3JlYXRlUm9vdCBBUEkuIExlYXJuICcrJ21vcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zd2l0Y2gtdG8tY3JlYXRlcm9vdCcpO319aWYoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7fXt2YXIgaXNNb2Rlcm5Sb290PWlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikmJmNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyPT09dW5kZWZpbmVkO2lmKGlzTW9kZXJuUm9vdCl7ZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnKydwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO319aWYoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpe3t2YXIgcm9vdEVsPWdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO3ZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3Q9cm9vdEVsJiYhZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO2lmKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCl7ZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIrJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJyk7fX0vLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbmZsdXNoU3luYyhmdW5jdGlvbigpe2xlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsbnVsbCxjb250YWluZXIsZmFsc2UsZnVuY3Rpb24oKXsvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbDt1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTt9KTt9KTsvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5yZXR1cm4gdHJ1ZTt9ZWxzZXt7dmFyIF9yb290RWw9Z2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7dmFyIGhhc05vblJvb3RSZWFjdENoaWxkPSEhKF9yb290RWwmJmdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOy8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxudmFyIGlzQ29udGFpbmVyUmVhY3RSb290PWNvbnRhaW5lci5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSYmaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIucGFyZW50Tm9kZSkmJiEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihoYXNOb25Sb290UmVhY3RDaGlsZCl7ZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIrJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLGlzQ29udGFpbmVyUmVhY3RSb290PydZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcrJ29mIGl0cyBjb250YWluZXIuJzonSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnKydyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJyk7fX1yZXR1cm4gZmFsc2U7fX1zZXRBdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uJDEpO3NldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEpO3NldEF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMSk7c2V0R2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSk7c2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5KTt7aWYodHlwZW9mIE1hcCE9PSdmdW5jdGlvbid8fC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbk1hcC5wcm90b3R5cGU9PW51bGx8fHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ghPT0nZnVuY3Rpb24nfHx0eXBlb2YgU2V0IT09J2Z1bmN0aW9uJ3x8Ly8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBTZXQgaGFzIG5vIHByb3RvdHlwZVxuU2V0LnByb3RvdHlwZT09bnVsbHx8dHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIhPT0nZnVuY3Rpb24nfHx0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoIT09J2Z1bmN0aW9uJyl7ZXJyb3IoJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJysncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTt9fXNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMpO3NldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oYmF0Y2hlZFVwZGF0ZXMkMSxkaXNjcmV0ZVVwZGF0ZXMsZmx1c2hTeW5jKTtmdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbixjb250YWluZXIpe3ZhciBrZXk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOm51bGw7aWYoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSl7dGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO30vLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuLy8gJEZsb3dGaXhNZSBUaGUgRmxvdyB0eXBlIGlzIG9wYXF1ZSBidXQgdGhlcmUncyBubyB3YXkgdG8gYWN0dWFsbHkgY3JlYXRlIGl0LlxucmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbixjb250YWluZXIsbnVsbCxrZXkpO31mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsZWxlbWVudCxjb250YWluZXJOb2RlLGNhbGxiYWNrKXtyZXR1cm4gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LGVsZW1lbnQsY29udGFpbmVyTm9kZSxjYWxsYmFjayk7fXZhciBJbnRlcm5hbHM9e3VzaW5nQ2xpZW50RW50cnlQb2ludDpmYWxzZSwvLyBLZWVwIGluIHN5bmMgd2l0aCBSZWFjdFRlc3RVdGlscy5qcy5cbi8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG5FdmVudHM6W2dldEluc3RhbmNlRnJvbU5vZGUsZ2V0Tm9kZUZyb21JbnN0YW5jZSxnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlLGVucXVldWVTdGF0ZVJlc3RvcmUscmVzdG9yZVN0YXRlSWZOZWVkZWQsYmF0Y2hlZFVwZGF0ZXMkMV19O2Z1bmN0aW9uIGNyZWF0ZVJvb3QkMShjb250YWluZXIsb3B0aW9ucyl7e2lmKCFJbnRlcm5hbHMudXNpbmdDbGllbnRFbnRyeVBvaW50JiYhZmFsc2Upe2Vycm9yKCdZb3UgYXJlIGltcG9ydGluZyBjcmVhdGVSb290IGZyb20gXCJyZWFjdC1kb21cIiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLiAnKydZb3Ugc2hvdWxkIGluc3RlYWQgaW1wb3J0IGl0IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCIuJyk7fX1yZXR1cm4gY3JlYXRlUm9vdChjb250YWluZXIsb3B0aW9ucyk7fWZ1bmN0aW9uIGh5ZHJhdGVSb290JDEoY29udGFpbmVyLGluaXRpYWxDaGlsZHJlbixvcHRpb25zKXt7aWYoIUludGVybmFscy51c2luZ0NsaWVudEVudHJ5UG9pbnQmJiFmYWxzZSl7ZXJyb3IoJ1lvdSBhcmUgaW1wb3J0aW5nIGh5ZHJhdGVSb290IGZyb20gXCJyZWFjdC1kb21cIiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLiAnKydZb3Ugc2hvdWxkIGluc3RlYWQgaW1wb3J0IGl0IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCIuJyk7fX1yZXR1cm4gaHlkcmF0ZVJvb3QoY29udGFpbmVyLGluaXRpYWxDaGlsZHJlbixvcHRpb25zKTt9Ly8gT3ZlcmxvYWQgdGhlIGRlZmluaXRpb24gdG8gdGhlIHR3byB2YWxpZCBzaWduYXR1cmVzLlxuLy8gV2FybmluZywgdGhpcyBvcHRzLW91dCBvZiBjaGVja2luZyB0aGUgZnVuY3Rpb24gYm9keS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyQxKGZuKXt7aWYoaXNBbHJlYWR5UmVuZGVyaW5nKCkpe2Vycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnKydmbHVzaCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBjYWxsIHRvICcrJ2Egc2NoZWR1bGVyIHRhc2sgb3IgbWljcm8gdGFzay4nKTt9fXJldHVybiBmbHVzaFN5bmMoZm4pO312YXIgZm91bmREZXZUb29scz1pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLGJ1bmRsZVR5cGU6MSx2ZXJzaW9uOlJlYWN0VmVyc2lvbixyZW5kZXJlclBhY2thZ2VOYW1lOidyZWFjdC1kb20nfSk7e2lmKCFmb3VuZERldlRvb2xzJiZjYW5Vc2VET00mJndpbmRvdy50b3A9PT13aW5kb3cuc2VsZil7Ly8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG5pZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpPi0xJiZuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKT09PS0xfHxuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKT4tMSl7dmFyIHByb3RvY29sPXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDsvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5pZigvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbmNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJysnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycrKHByb3RvY29sPT09J2ZpbGU6Jz8nXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcrJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scy1mYXEnOicnKSwnZm9udC13ZWlnaHQ6Ym9sZCcpO319fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPUludGVybmFscztleHBvcnRzLmNyZWF0ZVBvcnRhbD1jcmVhdGVQb3J0YWwkMTtleHBvcnRzLmNyZWF0ZVJvb3Q9Y3JlYXRlUm9vdCQxO2V4cG9ydHMuZmluZERPTU5vZGU9ZmluZERPTU5vZGU7ZXhwb3J0cy5mbHVzaFN5bmM9Zmx1c2hTeW5jJDE7ZXhwb3J0cy5oeWRyYXRlPWh5ZHJhdGU7ZXhwb3J0cy5oeWRyYXRlUm9vdD1oeWRyYXRlUm9vdCQxO2V4cG9ydHMucmVuZGVyPXJlbmRlcjtleHBvcnRzLnVubW91bnRDb21wb25lbnRBdE5vZGU9dW5tb3VudENvbXBvbmVudEF0Tm9kZTtleHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPWJhdGNoZWRVcGRhdGVzJDE7ZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcj1yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtleHBvcnRzLnZlcnNpb249UmVhY3RWZXJzaW9uOy8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9pZih0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3A9PT0nZnVuY3Rpb24nKXtfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO319KSgpO30iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar m = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nif (false) {} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function (c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function (c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsb0RBQVc7QUFDM0IsSUFBSSxLQUFxQyxFQUFFLEVBRzFDLENBQUM7QUFDRjtBQUNBLEVBQUUsa0JBQWtCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9jbGllbnQuanM/MGUxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBtID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBtLmNyZWF0ZVJvb3Q7XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBtLmh5ZHJhdGVSb290O1xufSBlbHNlIHtcbiAgdmFyIGkgPSBtLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoYywgbykge1xuICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG0uY3JlYXRlUm9vdChjLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBmdW5jdGlvbiAoYywgaCwgbykge1xuICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG0uaHlkcmF0ZVJvb3QoYywgaCwgbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gZmFsc2U7XG4gICAgfVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/client.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQyxFQUFFLEVBSzFDLENBQUM7QUFDRixFQUFFLG1JQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzPzUxMjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var react_dom__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_ErrorResponseImpl),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   unstable_useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-router */ \"./node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.23.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === \"_self\") &&\n  // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement(\"form\"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    }\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"],\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"],\n  _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\n// HEY YOU! DON'T TOUCH THIS VARIABLE!\n//\n// It is replaced with the proper version at build time via a babel plugin in\n// the rollup config.\n//\n// Export a global property onto the window for React Router detection by the\n// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\n// to detect and properly classify live websites as being built with React Router:\n// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\nconst REACT_ROUTER_VERSION = \"6\";\ntry {\n  window.__reactRouterVersion = REACT_ROUTER_VERSION;\n} catch (e) {\n  // no-op\n}\nfunction createBrowserRouter(routes, opts) {\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  isTransitioning: false\n});\nif (true) {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\nif (true) {\n  FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = /*#__PURE__*/ (react_dom__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (react_dom__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(react_dom__WEBPACK_IMPORTED_MODULE_1__, 2)))[FLUSH_SYNC];\nconst USE_ID = \"useId\";\nconst useIdImpl = react__WEBPACK_IMPORTED_MODULE_0__[USE_ID];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl) {\n    startTransitionImpl(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nclass Deferred {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = value => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = reason => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n  let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cb => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach(key => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== undefined) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n    // If this isn't a view transition or it's not available in this browser,\n    // just update and be done with it\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    // flushSync + startViewTransition\n    if (flushSync) {\n      // Flush through the context to mark DOM elements as transition=ing\n      flushSyncSafe(() => {\n        // Cancel any pending transitions\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      // Update the DOM\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      // Clean up after the animation completes\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    // startTransition + startViewTransition\n    if (transition) {\n      // Interrupting an in-progress transition, cancel and let everything flush\n      // out, and then kick off a new transition from the interruption state\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      // Completed navigation update with opted-in view transitions, let 'er rip\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  // When we start a view transition, create a Deferred we can use for the\n  // eventual \"completed\" render\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  // Once the deferred is created, kick off startViewTransition() to update the\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n  // happened)\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition.finished.finally(() => {\n        setRenderDfd(undefined);\n        setTransition(undefined);\n        setPendingState(undefined);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  // When the new location finally renders and is committed to the DOM, this\n  // effect will run to resolve the transition\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  // If we get interrupted with a new navigation during a transition, we skip\n  // the active transition, let it cleanup, then kick it off again here\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(undefined);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref3;\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRoutesImpl)(routes, undefined, state, future);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref4;\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref5;\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\nif (true) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nconst Link = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref7,\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can't do external URL detection without a valid URL\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useHref)(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return /*#__PURE__*/(\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (true) {\n  Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */\nconst NavLink = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      unstable_viewTransition,\n      children\n    } = _ref8,\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n    relative: rest.relative\n  });\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n  let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n  let {\n    navigator,\n    basename\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n  let isTransitioning = routerState != null &&\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  if (nextLocationPathname && basename) {\n    nextLocationPathname = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(nextLocationPathname, basename) || nextLocationPathname;\n  }\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n  // we're looking for a slash _after_ what's in `to`.  For example:\n  //\n  // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n  // both want to look for a / at index 6 to match URL `/users/matt`\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to,\n    unstable_viewTransition: unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref9, forwardedRef) => {\n  let {\n      fetcherKey,\n      navigate,\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref9,\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (true) {\n  Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (true) {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext);\n  !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n  !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n    relative\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n   true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() =>\n  // Only merge in the defaults if we haven't yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can't\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n  let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId)();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n  !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(action ? action : \".\", {\n    relative\n  }));\n  // If no action was specified, browsers will persist current search params\n  // when determining the path, so match that behavior\n  // https://github.com/remix-run/remix/issues/927\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove any included ?index param\n    // since it might not apply to our contextual route.  We add it back based\n    // on match.route.index below\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.joinPaths)([basename, path.pathname]);\n  }\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : 0 : void 0;\n  !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n  !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\n  // Fetcher key handling\n  // OK to call conditionally to feature detect `useId`\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let defaultKey = useIdImpl ? useIdImpl() : \"\";\n  let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    // We will only fall through here when `useId` is not available\n    setFetcherKey(getUniqueFetcherId());\n  }\n  // Registration/cleanup\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n      // will not delete immediately but instead queue up a delete after the\n      // fetcher returns to an `idle` state\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  // Fetcher additions\n  let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((href, opts) => {\n    !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, opts) => {\n    submitImpl(target, _extends({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    let FetcherForm = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\n        navigate: false,\n        fetcherKey: fetcherKey,\n        ref: ref\n      }));\n    });\n    if (true) {\n      FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n  }, [fetcherKey]);\n  // Exposed FetcherWithComponents\n  let fetcher = state.fetchers.get(fetcherKey) || react_router__WEBPACK_IMPORTED_MODULE_2__.IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _extends({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return Array.from(state.fetchers.entries()).map(_ref11 => {\n    let [key, fetcher] = _ref11;\n    return _extends({}, fetcher, {\n      key\n    });\n  });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n  let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches)();\n  let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation)();\n  // Trigger manual scroll restoration while we're active\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n       true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey(\n      // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker)(when);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird \"race\" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n  !(vtContext != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : 0 : void 0;\n  let {\n    basename\n  } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  // Transition is active if we're going to or coming from the indicated\n  // destination.  This ensures that other PUSH navigations that reverse\n  // an indicated transition apply.  I.e., on the list view you have:\n  //\n  //   <NavLink to=\"/details/1\" unstable_viewTransition>\n  //\n  // If you click the breadcrumb back to the list view:\n  //\n  //   <NavLink to=\"/list\" unstable_viewTransition>\n  //\n  // We should apply the transition because it's indicated as active going\n  // from /list -> /details/1 and therefore should be active on the reverse\n  // (even though this isn't strictly a POP reverse)\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, nextPath) != null || (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, currentPath) != null;\n}\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytCO0FBQ087QUFDbVI7QUFDMGU7QUFDMWxCO0FBQzVJO0FBQzdEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxL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IjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcz9jZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIERPTSB2Ni4yMy4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBSb3V0ZXIsIFVOU0FGRV91c2VSb3V0ZXNJbXBsLCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIHVzZUhyZWYsIHVzZVJlc29sdmVkUGF0aCwgdXNlTG9jYXRpb24sIHVzZU5hdmlnYXRlLCBjcmVhdGVQYXRoLCBVTlNBRkVfdXNlUm91dGVJZCwgVU5TQUZFX1JvdXRlQ29udGV4dCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGlvbiwgdXNlQmxvY2tlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQXdhaXQsIE1lbW9yeVJvdXRlciwgTmF2aWdhdGUsIE5hdmlnYXRpb25UeXBlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlcywgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LCBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBVTlNBRkVfUm91dGVDb250ZXh0LCBVTlNBRkVfdXNlUm91dGVJZCwgY3JlYXRlTWVtb3J5Um91dGVyLCBjcmVhdGVQYXRoLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cywgZGVmZXIsIGdlbmVyYXRlUGF0aCwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpzb24sIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlbmRlck1hdGNoZXMsIHJlc29sdmVQYXRoLCB1c2VBY3Rpb25EYXRhLCB1c2VBc3luY0Vycm9yLCB1c2VBc3luY1ZhbHVlLCB1c2VCbG9ja2VyLCB1c2VIcmVmLCB1c2VJblJvdXRlckNvbnRleHQsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGUsIHVzZU5hdmlnYXRpb24sIHVzZU5hdmlnYXRpb25UeXBlLCB1c2VPdXRsZXQsIHVzZU91dGxldENvbnRleHQsIHVzZVBhcmFtcywgdXNlUmVzb2x2ZWRQYXRoLCB1c2VSZXZhbGlkYXRvciwgdXNlUm91dGVFcnJvciwgdXNlUm91dGVMb2FkZXJEYXRhLCB1c2VSb3V0ZXMgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgc3RyaXBCYXNlbmFtZSwgVU5TQUZFX3dhcm5pbmcsIGNyZWF0ZVJvdXRlciwgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsIFVOU0FGRV9pbnZhcmlhbnQsIGpvaW5QYXRocywgSURMRV9GRVRDSEVSLCBtYXRjaFBhdGggfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5leHBvcnQgeyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwgfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBkZWZhdWx0TWV0aG9kID0gXCJnZXRcIjtcbmNvbnN0IGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgKFxuICAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiZcbiAgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShpbml0KSB8fCBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gaW5pdCA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgIHJldHVybiBtZW1vLmNvbmNhdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dKTtcbiAgfSwgW10pKTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVzZSBgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKC4uLilgIGhlcmUgaW5zdGVhZCBvZiBpdGVyYXRpbmcgb2ZcbiAgICAvLyBgZGVmYXVsdFNlYXJjaFBhcmFtcy5rZXlzKClgIHRvIHdvcmstYXJvdW5kIGEgYnVnIGluIEZpcmVmb3ggcmVsYXRlZCB0b1xuICAgIC8vIHdlYiBleHRlbnNpb25zLiBSZWxldmFudCBCdWd6aWxsYSB0aWNrZXRzOlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MTQ2MDJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDIzOTg0XG4gICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbi8vIE9uZS10aW1lIGNoZWNrIGZvciBzdWJtaXR0ZXIgc3VwcG9ydFxubGV0IF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gbnVsbDtcbmZ1bmN0aW9uIGlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSB7XG4gIGlmIChfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9PT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRm9ybURhdGEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGlmIEZvcm1EYXRhIHN1cHBvcnRzIHRoZSBzdWJtaXR0ZXIgcGFyYW1ldGVyLCB0aGlzIHdpbGwgdGhyb3dcbiAgICAgIDApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbmNvbnN0IHN1cHBvcnRlZEZvcm1FbmNUeXBlcyA9IG5ldyBTZXQoW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0pO1xuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZSkge1xuICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiXFxcIlwiICsgZW5jVHlwZSArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBgZW5jVHlwZWAgZm9yIGA8Rm9ybT5gL2A8ZmV0Y2hlci5Gb3JtPmAgXCIgKyAoXCJhbmQgd2lsbCBkZWZhdWx0IHRvIFxcXCJcIiArIGRlZmF1bHRFbmNUeXBlICsgXCJcXFwiXCIpKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5jVHlwZTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKSB7XG4gIGxldCBtZXRob2Q7XG4gIGxldCBhY3Rpb247XG4gIGxldCBlbmNUeXBlO1xuICBsZXQgZm9ybURhdGE7XG4gIGxldCBib2R5O1xuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIj4gd2l0aG91dCBhIDxmb3JtPlwiKTtcbiAgICB9XG4gICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG4gICAgLy8gV2hlbiBncmFiYmluZyB0aGUgYWN0aW9uIGZyb20gdGhlIGVsZW1lbnQsIGl0IHdpbGwgaGF2ZSBoYWQgdGhlIGJhc2VuYW1lXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8IGdldEZvcm1FbmNUeXBlKGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgLy8gQnVpbGQgYSBGb3JtRGF0YSBvYmplY3QgcG9wdWxhdGVkIGZyb20gYSBmb3JtIGFuZCBzdWJtaXR0ZXJcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGBGb3JtRGF0YShlbCwgc3VibWl0dGVyKWAgZm9ybWF0LFxuICAgIC8vIHRoZW4gdGFjayBvbiB0aGUgc3VibWl0dGVyIHZhbHVlIGF0IHRoZSBlbmQuICBUaGlzIGlzIGEgbGlnaHR3ZWlnaHRcbiAgICAvLyBzb2x1dGlvbiB0aGF0IGlzIG5vdCAxMDAlIHNwZWMgY29tcGxpYW50LiAgRm9yIGNvbXBsZXRlIHN1cHBvcnQgaW4gb2xkZXJcbiAgICAvLyBicm93c2VycywgY29uc2lkZXIgdXNpbmcgdGhlIGBmb3JtZGF0YS1zdWJtaXR0ZXItcG9seWZpbGxgIHBhY2thZ2VcbiAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBuYW1lID8gbmFtZSArIFwiLlwiIDogXCJcIjtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKHByZWZpeCArIFwieFwiLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChwcmVmaXggKyBcInlcIiwgXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBcIiArIFwiPGlucHV0IHR5cGU9XFxcInN1Ym1pdHxpbWFnZVxcXCI+XCIpO1xuICB9IGVsc2Uge1xuICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID0gbnVsbDtcbiAgICBlbmNUeXBlID0gZGVmYXVsdEVuY1R5cGU7XG4gICAgYm9keSA9IHRhcmdldDtcbiAgfVxuICAvLyBTZW5kIGJvZHkgZm9yIDxGb3JtIGVuY1R5cGU9XCJ0ZXh0L3BsYWluXCIgc28gd2UgZW5jb2RlIGl0IGludG8gdGV4dFxuICBpZiAoZm9ybURhdGEgJiYgZW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICBib2R5ID0gZm9ybURhdGE7XG4gICAgZm9ybURhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb24sXG4gICAgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICBlbmNUeXBlLFxuICAgIGZvcm1EYXRhLFxuICAgIGJvZHlcbiAgfTtcbn1cbmNvbnN0IF9leGNsdWRlZCA9IFtcIm9uQ2xpY2tcIiwgXCJyZWxhdGl2ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwidGFyZ2V0XCIsIFwidG9cIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiwgXCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvblwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImFyaWEtY3VycmVudFwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJjbGFzc05hbWVcIiwgXCJlbmRcIiwgXCJzdHlsZVwiLCBcInRvXCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIiwgXCJjaGlsZHJlblwiXSxcbiAgX2V4Y2x1ZGVkMyA9IFtcImZldGNoZXJLZXlcIiwgXCJuYXZpZ2F0ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwibWV0aG9kXCIsIFwiYWN0aW9uXCIsIFwib25TdWJtaXRcIiwgXCJyZWxhdGl2ZVwiLCBcInByZXZlbnRTY3JvbGxSZXNldFwiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCJdO1xuLy8gSEVZIFlPVSEgRE9OJ1QgVE9VQ0ggVEhJUyBWQVJJQUJMRSFcbi8vXG4vLyBJdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBwcm9wZXIgdmVyc2lvbiBhdCBidWlsZCB0aW1lIHZpYSBhIGJhYmVsIHBsdWdpbiBpblxuLy8gdGhlIHJvbGx1cCBjb25maWcuXG4vL1xuLy8gRXhwb3J0IGEgZ2xvYmFsIHByb3BlcnR5IG9udG8gdGhlIHdpbmRvdyBmb3IgUmVhY3QgUm91dGVyIGRldGVjdGlvbiBieSB0aGVcbi8vIENvcmUgV2ViIFZpdGFscyBUZWNobm9sb2d5IFJlcG9ydC4gIFRoaXMgd2F5IHRoZXkgY2FuIGNvbmZpZ3VyZSB0aGUgYHdhcHBhbHl6ZXJgXG4vLyB0byBkZXRlY3QgYW5kIHByb3Blcmx5IGNsYXNzaWZ5IGxpdmUgd2Vic2l0ZXMgYXMgYmVpbmcgYnVpbHQgd2l0aCBSZWFjdCBSb3V0ZXI6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vSFRUUEFyY2hpdmUvd2FwcGFseXplci9ibG9iL21haW4vc3JjL3RlY2hub2xvZ2llcy9yLmpzb25cbmNvbnN0IFJFQUNUX1JPVVRFUl9WRVJTSU9OID0gXCI2XCI7XG50cnkge1xuICB3aW5kb3cuX19yZWFjdFJvdXRlclZlcnNpb24gPSBSRUFDVF9ST1VURVJfVkVSU0lPTjtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gbm8tb3Bcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVCcm93c2VySGlzdG9yeSh7XG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICB1bnN0YWJsZV9kYXRhU3RyYXRlZ3k6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudW5zdGFibGVfZGF0YVN0cmF0ZWd5LFxuICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUhhc2hIaXN0b3J5KHtcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhKSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIHVuc3RhYmxlX2RhdGFTdHJhdGVneTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51bnN0YWJsZV9kYXRhU3RyYXRlZ3ksXG4gICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBwYXJzZUh5ZHJhdGlvbkRhdGEoKSB7XG4gIHZhciBfd2luZG93O1xuICBsZXQgc3RhdGUgPSAoX3dpbmRvdyA9IHdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gSGV5IHlvdSEgIElmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIGNoYW5nZSB0aGUgY29ycmVzcG9uZGluZyBsb2dpYyBpblxuICAgIC8vIHNlcmlhbGl6ZUVycm9ycyBpbiByZWFjdC1yb3V0ZXItZG9tL3NlcnZlci50c3ggOilcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwodmFsLnN0YXR1cywgdmFsLnN0YXR1c1RleHQsIHZhbC5kYXRhLCB2YWwuaW50ZXJuYWwgPT09IHRydWUpO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbnN0cnVjdCB0aGUgcmlnaHQgdHlwZSBvZiBFcnJvciAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpXG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBuby1vcCAtIGZhbGwgdGhyb3VnaCBhbmQgY3JlYXRlIGEgbm9ybWFsIEVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmNvbnN0IFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcbn1cbmNvbnN0IEZldGNoZXJzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG5ldyBNYXAoKSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEZldGNoZXJzQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRmV0Y2hlcnNcIjtcbn1cbi8vI2VuZHJlZ2lvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBDb21wb25lbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XG4gICogaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uIH0gZnJvbSBcInJlYWN0XCJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgTW92aW5nIGl0IHRvIGEgY29uc3RhbnQgc3VjaCBhcyB0aGUgZm9sbG93aW5nIHNvbHZlcyB0aGUgV2VicGFjay9SZWFjdCAxNyBpc3N1ZTpcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgIFNUQVJUX1RSQU5TSVRJT04gaW4gUmVhY3QgPyBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBIb3dldmVyLCB0aGF0IGludHJvZHVjZXMgd2VicGFjay90ZXJzZXIgbWluaWZpY2F0aW9uIGlzc3VlcyBpbiBwcm9kdWN0aW9uIGJ1aWxkc1xuICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXG4gIHRoaXMgZXhwb3J0ZWQgcmVmZXJlbmNlIG9uY2UgdXAgZnJvbnQgcmVzb2x2ZXMgdGhhdCBpc3N1ZS5cblxuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4qL1xuY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG5jb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl07XG5jb25zdCBGTFVTSF9TWU5DID0gXCJmbHVzaFN5bmNcIjtcbmNvbnN0IGZsdXNoU3luY0ltcGwgPSBSZWFjdERPTVtGTFVTSF9TWU5DXTtcbmNvbnN0IFVTRV9JRCA9IFwidXNlSWRcIjtcbmNvbnN0IHVzZUlkSW1wbCA9IFJlYWN0W1VTRV9JRF07XG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb25TYWZlKGNiKSB7XG4gIGlmIChzdGFydFRyYW5zaXRpb25JbXBsKSB7XG4gICAgc3RhcnRUcmFuc2l0aW9uSW1wbChjYik7XG4gIH0gZWxzZSB7XG4gICAgY2IoKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hTeW5jU2FmZShjYikge1xuICBpZiAoZmx1c2hTeW5jSW1wbCkge1xuICAgIGZsdXNoU3luY0ltcGwoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cbmNsYXNzIERlZmVycmVkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVhc29uID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBmYWxsYmFja0VsZW1lbnQsXG4gICAgcm91dGVyLFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCBbcGVuZGluZ1N0YXRlLCBzZXRQZW5kaW5nU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICB9KTtcbiAgbGV0IFtyZW5kZXJEZmQsIHNldFJlbmRlckRmZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBsZXQgW3RyYW5zaXRpb24sIHNldFRyYW5zaXRpb25dID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgbGV0IFtpbnRlcnJ1cHRpb24sIHNldEludGVycnVwdGlvbl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdC51c2VSZWYobmV3IE1hcCgpKTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IG9wdEluU3RhcnRUcmFuc2l0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soY2IgPT4ge1xuICAgIGlmICh2N19zdGFydFRyYW5zaXRpb24pIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSwgW3Y3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygobmV3U3RhdGUsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGRlbGV0ZWRGZXRjaGVycyxcbiAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzOiB2aWV3VHJhbnNpdGlvbk9wdHNcbiAgICB9ID0gX3JlZjI7XG4gICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goa2V5ID0+IGZldGNoZXJEYXRhLmN1cnJlbnQuZGVsZXRlKGtleSkpO1xuICAgIG5ld1N0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoZXIuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZldGNoZXJEYXRhLmN1cnJlbnQuc2V0KGtleSwgZmV0Y2hlci5kYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlID0gcm91dGVyLndpbmRvdyA9PSBudWxsIHx8IHR5cGVvZiByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24gIT09IFwiZnVuY3Rpb25cIjtcbiAgICAvLyBJZiB0aGlzIGlzbid0IGEgdmlldyB0cmFuc2l0aW9uIG9yIGl0J3Mgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXIsXG4gICAgLy8ganVzdCB1cGRhdGUgYW5kIGJlIGRvbmUgd2l0aCBpdFxuICAgIGlmICghdmlld1RyYW5zaXRpb25PcHRzIHx8IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSkge1xuICAgICAgaWYgKGZsdXNoU3luYykge1xuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0SW5TdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGZsdXNoU3luYyArIHN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgICBpZiAoZmx1c2hTeW5jKSB7XG4gICAgICAvLyBGbHVzaCB0aHJvdWdoIHRoZSBjb250ZXh0IHRvIG1hcmsgRE9NIGVsZW1lbnRzIGFzIHRyYW5zaXRpb249aW5nXG4gICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zaXRpb25zXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgIGZsdXNoU3luYzogdHJ1ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBVcGRhdGUgdGhlIERPTVxuICAgICAgbGV0IHQgPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgfSk7XG4gICAgICAvLyBDbGVhbiB1cCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuICAgICAgdC5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiB7XG4gICAgICAgICAgc2V0UmVuZGVyRGZkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgIHNldFBlbmRpbmdTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFRyYW5zaXRpb24odCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzdGFydFRyYW5zaXRpb24gKyBzdGFydFZpZXdUcmFuc2l0aW9uXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIC8vIEludGVycnVwdGluZyBhbiBpbi1wcm9ncmVzcyB0cmFuc2l0aW9uLCBjYW5jZWwgYW5kIGxldCBldmVyeXRoaW5nIGZsdXNoXG4gICAgICAvLyBvdXQsIGFuZCB0aGVuIGtpY2sgb2ZmIGEgbmV3IHRyYW5zaXRpb24gZnJvbSB0aGUgaW50ZXJydXB0aW9uIHN0YXRlXG4gICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgIHNldEludGVycnVwdGlvbih7XG4gICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb21wbGV0ZWQgbmF2aWdhdGlvbiB1cGRhdGUgd2l0aCBvcHRlZC1pbiB2aWV3IHRyYW5zaXRpb25zLCBsZXQgJ2VyIHJpcFxuICAgICAgc2V0UGVuZGluZ1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3JvdXRlci53aW5kb3csIHRyYW5zaXRpb24sIHJlbmRlckRmZCwgZmV0Y2hlckRhdGEsIG9wdEluU3RhcnRUcmFuc2l0aW9uXSk7XG4gIC8vIE5lZWQgdG8gdXNlIGEgbGF5b3V0IGVmZmVjdCBoZXJlIHNvIHdlIGFyZSBzdWJzY3JpYmVkIGVhcmx5IGVub3VnaCB0b1xuICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgLy8gV2hlbiB3ZSBzdGFydCBhIHZpZXcgdHJhbnNpdGlvbiwgY3JlYXRlIGEgRGVmZXJyZWQgd2UgY2FuIHVzZSBmb3IgdGhlXG4gIC8vIGV2ZW50dWFsIFwiY29tcGxldGVkXCIgcmVuZGVyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgIXZ0Q29udGV4dC5mbHVzaFN5bmMpIHtcbiAgICAgIHNldFJlbmRlckRmZChuZXcgRGVmZXJyZWQoKSk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0XSk7XG4gIC8vIE9uY2UgdGhlIGRlZmVycmVkIGlzIGNyZWF0ZWQsIGtpY2sgb2ZmIHN0YXJ0Vmlld1RyYW5zaXRpb24oKSB0byB1cGRhdGUgdGhlXG4gIC8vIERPTSBhbmQgdGhlbiB3YWl0IG9uIHRoZSBEZWZlcnJlZCB0byByZXNvbHZlIChpbmRpY2F0aW5nIHRoZSBET00gdXBkYXRlIGhhc1xuICAvLyBoYXBwZW5lZClcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiByb3V0ZXIud2luZG93KSB7XG4gICAgICBsZXQgbmV3U3RhdGUgPSBwZW5kaW5nU3RhdGU7XG4gICAgICBsZXQgcmVuZGVyUHJvbWlzZSA9IHJlbmRlckRmZC5wcm9taXNlO1xuICAgICAgbGV0IHRyYW5zaXRpb24gPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgYXdhaXQgcmVuZGVyUHJvbWlzZTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNpdGlvbi5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyRGZkKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFRyYW5zaXRpb24odW5kZWZpbmVkKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgc2V0VHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICB9XG4gIH0sIFtvcHRJblN0YXJ0VHJhbnNpdGlvbiwgcGVuZGluZ1N0YXRlLCByZW5kZXJEZmQsIHJvdXRlci53aW5kb3ddKTtcbiAgLy8gV2hlbiB0aGUgbmV3IGxvY2F0aW9uIGZpbmFsbHkgcmVuZGVycyBhbmQgaXMgY29tbWl0dGVkIHRvIHRoZSBET00sIHRoaXNcbiAgLy8gZWZmZWN0IHdpbGwgcnVuIHRvIHJlc29sdmUgdGhlIHRyYW5zaXRpb25cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiBzdGF0ZS5sb2NhdGlvbi5rZXkgPT09IHBlbmRpbmdTdGF0ZS5sb2NhdGlvbi5rZXkpIHtcbiAgICAgIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCBbcmVuZGVyRGZkLCB0cmFuc2l0aW9uLCBzdGF0ZS5sb2NhdGlvbiwgcGVuZGluZ1N0YXRlXSk7XG4gIC8vIElmIHdlIGdldCBpbnRlcnJ1cHRlZCB3aXRoIGEgbmV3IG5hdmlnYXRpb24gZHVyaW5nIGEgdHJhbnNpdGlvbiwgd2Ugc2tpcFxuICAvLyB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGxldCBpdCBjbGVhbnVwLCB0aGVuIGtpY2sgaXQgb2ZmIGFnYWluIGhlcmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgaW50ZXJydXB0aW9uKSB7XG4gICAgICBzZXRQZW5kaW5nU3RhdGUoaW50ZXJydXB0aW9uLnN0YXRlKTtcbiAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBpbnRlcnJ1cHRpb24uY3VycmVudExvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGludGVycnVwdGlvbi5uZXh0TG9jYXRpb25cbiAgICAgIH0pO1xuICAgICAgc2V0SW50ZXJydXB0aW9uKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZywgaW50ZXJydXB0aW9uXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsbGJhY2tFbGVtZW50ID09IG51bGwgfHwgIXJvdXRlci5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiwgXCJgPFJvdXRlclByb3ZpZGVyIGZhbGxiYWNrRWxlbWVudD5gIGlzIGRlcHJlY2F0ZWQgd2hlbiB1c2luZyBcIiArIFwiYHY3X3BhcnRpYWxIeWRyYXRpb25gLCB1c2UgYSBgSHlkcmF0ZUZhbGxiYWNrYCBjb21wb25lbnQgaW5zdGVhZFwiKSA6IHZvaWQgMDtcbiAgICAvLyBPbmx5IGxvZyB0aGlzIG9uY2Ugb24gaW5pdGlhbCBtb3VudFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiBuID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByb3V0ZXIsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogZmFsc2UsXG4gICAgYmFzZW5hbWVcbiAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcbiAgLy8gVGhlIGZyYWdtZW50IGFuZCB7bnVsbH0gaGVyZSBhcmUgaW1wb3J0YW50ISAgV2UgbmVlZCB0aGVtIHRvIGtlZXAgUmVhY3QgMTgnc1xuICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAvLyBjb250YWluaW5nIHRoZSBoeWRyYXRlZCBzZXJ2ZXItc2lkZSBzdGF0aWNDb250ZXh0IChmcm9tIFN0YXRpY1JvdXRlclByb3ZpZGVyKS5cbiAgLy8gdXNlSWQgcmVsaWVzIG9uIHRoZSBjb21wb25lbnQgdHJlZSBzdHJ1Y3R1cmUgdG8gZ2VuZXJhdGUgZGV0ZXJtaW5pc3RpYyBpZCdzXG4gIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAvLyB3ZSBkb24ndCBuZWVkIHRoZSA8c2NyaXB0PiB0YWdcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZldGNoZXJEYXRhLmN1cnJlbnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZ0Q29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yLFxuICAgIGZ1dHVyZToge1xuICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IHJvdXRlci5mdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGhcbiAgICB9XG4gIH0sIHN0YXRlLmluaXRpYWxpemVkIHx8IHJvdXRlci5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXMsIHtcbiAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXG4gICAgZnV0dXJlOiByb3V0ZXIuZnV0dXJlLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KSA6IGZhbGxiYWNrRWxlbWVudCkpKSkpLCBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjMpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXMsXG4gICAgZnV0dXJlLFxuICAgIHN0YXRlXG4gIH0gPSBfcmVmMztcbiAgcmV0dXJuIFVOU0FGRV91c2VSb3V0ZXNJbXBsKHJvdXRlcywgdW5kZWZpbmVkLCBzdGF0ZSwgZnV0dXJlKTtcbn1cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqL1xuZnVuY3Rpb24gQnJvd3NlclJvdXRlcihfcmVmNCkge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGZ1dHVyZSxcbiAgICB3aW5kb3dcbiAgfSA9IF9yZWY0O1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7XG4gICAgICB3aW5kb3csXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeSxcbiAgICBmdXR1cmU6IGZ1dHVyZVxuICB9KTtcbn1cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXG4gKiBwb3J0aW9uIG9mIHRoZSBVUkwgc28gaXQgaXMgbm90IHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gSGFzaFJvdXRlcihfcmVmNSkge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGZ1dHVyZSxcbiAgICB3aW5kb3dcbiAgfSA9IF9yZWY1O1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICB3aW5kb3csXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeSxcbiAgICBmdXR1cmU6IGZ1dHVyZVxuICB9KTtcbn1cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XG4gKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoX3JlZjYpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBmdXR1cmUsXG4gICAgaGlzdG9yeVxuICB9ID0gX3JlZjY7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgIGZ1dHVyZTogZnV0dXJlXG4gIH0pO1xufVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSBgPGE+YC5cbiAqL1xuY29uc3QgTGluayA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtXaXRoUmVmKF9yZWY3LCByZWYpIHtcbiAgbGV0IHtcbiAgICAgIG9uQ2xpY2ssXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgIH0gPSBfcmVmNyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjcsIF9leGNsdWRlZCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgYWJzb2x1dGUgVVJMc1xuICBsZXQgYWJzb2x1dGVIcmVmO1xuICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KHRvKSkge1xuICAgIC8vIFJlbmRlciB0aGUgYWJzb2x1dGUgaHJlZiBzZXJ2ZXItIGFuZCBjbGllbnQtc2lkZVxuICAgIGFic29sdXRlSHJlZiA9IHRvO1xuICAgIC8vIE9ubHkgY2hlY2sgZm9yIGV4dGVybmFsIG9yaWdpbnMgY2xpZW50LXNpZGVcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pIDogbmV3IFVSTCh0byk7XG4gICAgICAgIGxldCBwYXRoID0gc3RyaXBCYXNlbmFtZSh0YXJnZXRVcmwucGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICAgICAgaWYgKHRhcmdldFVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIHBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFN0cmlwIHRoZSBwcm90b2NvbC9vcmlnaW4vYmFzZW5hbWUgZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIFVSTHNcbiAgICAgICAgICB0byA9IHBhdGggKyB0YXJnZXRVcmwuc2VhcmNoICsgdGFyZ2V0VXJsLmhhc2g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZXh0ZXJuYWwgVVJMIGRldGVjdGlvbiB3aXRob3V0IGEgdmFsaWQgVVJMXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIjxMaW5rIHRvPVxcXCJcIiArIHRvICsgXCJcXFwiPiBjb250YWlucyBhbiBpbnZhbGlkIFVSTCB3aGljaCB3aWxsIHByb2JhYmx5IGJyZWFrIFwiICsgXCJ3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciByZWxhdGl2ZSBVUkxzXG4gIGxldCBocmVmID0gdXNlSHJlZih0bywge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICAgIHJlcGxhY2UsXG4gICAgc3RhdGUsXG4gICAgdGFyZ2V0LFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICByZWxhdGl2ZSxcbiAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICB9KTtcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qLyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGhyZWY6IGFic29sdXRlSHJlZiB8fCBocmVmLFxuICAgICAgb25DbGljazogaXNFeHRlcm5hbCB8fCByZWxvYWREb2N1bWVudCA/IG9uQ2xpY2sgOiBoYW5kbGVDbGljayxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9KSlcbiAgKTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG4vKipcbiAqIEEgYDxMaW5rPmAgd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmNvbnN0IE5hdkxpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihfcmVmOCwgcmVmKSB7XG4gIGxldCB7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICBlbmQgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgICB0byxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uLFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjgsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY4LCBfZXhjbHVkZWQyKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbmF2aWdhdG9yLFxuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBpc1RyYW5zaXRpb25pbmcgPSByb3V0ZXJTdGF0ZSAhPSBudWxsICYmXG4gIC8vIENvbmRpdGlvbmFsIHVzYWdlIGlzIE9LIGhlcmUgYmVjYXVzZSB0aGUgdXNhZ2Ugb2YgYSBkYXRhIHJvdXRlciBpcyBzdGF0aWNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUocGF0aCkgJiYgdW5zdGFibGVfdmlld1RyYW5zaXRpb24gPT09IHRydWU7XG4gIGxldCB0b1BhdGhuYW1lID0gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKHBhdGgpLnBhdGhuYW1lIDogcGF0aC5wYXRobmFtZTtcbiAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZSA6IG51bGw7XG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZSA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIHRvUGF0aG5hbWUgPSB0b1BhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgaWYgKG5leHRMb2NhdGlvblBhdGhuYW1lICYmIGJhc2VuYW1lKSB7XG4gICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvblBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbmV4dExvY2F0aW9uUGF0aG5hbWU7XG4gIH1cbiAgLy8gSWYgdGhlIGB0b2AgaGFzIGEgdHJhaWxpbmcgc2xhc2gsIGxvb2sgYXQgdGhhdCBleGFjdCBzcG90LiAgT3RoZXJ3aXNlLFxuICAvLyB3ZSdyZSBsb29raW5nIGZvciBhIHNsYXNoIF9hZnRlcl8gd2hhdCdzIGluIGB0b2AuICBGb3IgZXhhbXBsZTpcbiAgLy9cbiAgLy8gPE5hdkxpbmsgdG89XCIvdXNlcnNcIj4gYW5kIDxOYXZMaW5rIHRvPVwiL3VzZXJzL1wiPlxuICAvLyBib3RoIHdhbnQgdG8gbG9vayBmb3IgYSAvIGF0IGluZGV4IDYgdG8gbWF0Y2ggVVJMIGAvdXNlcnMvbWF0dGBcbiAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9IHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZS5sZW5ndGggLSAxIDogdG9QYXRobmFtZS5sZW5ndGg7XG4gIGxldCBpc0FjdGl2ZSA9IGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQoZW5kU2xhc2hQb3NpdGlvbikgPT09IFwiL1wiO1xuICBsZXQgaXNQZW5kaW5nID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgIT0gbnVsbCAmJiAobmV4dExvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcbiAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgIGlzQWN0aXZlLFxuICAgIGlzUGVuZGluZyxcbiAgICBpc1RyYW5zaXRpb25pbmdcbiAgfTtcbiAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG4gIGxldCBjbGFzc05hbWU7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcChyZW5kZXJQcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgLy8gY2xhc3MgZm9yIDxOYXZMaW5rIC8+cyB0aGF0IGFyZSBhY3RpdmUuIEluIHY1IGBhY3RpdmVgIHdhcyB0aGUgZGVmYXVsdFxuICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAvLyBzaW1wbGUgc3R5bGluZyBydWxlcyB3b3JraW5nIGFzIHRoZXkgY3VycmVudGx5IGRvLlxuICAgIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVQcm9wLCBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsLCBpc1BlbmRpbmcgPyBcInBlbmRpbmdcIiA6IG51bGwsIGlzVHJhbnNpdGlvbmluZyA/IFwidHJhbnNpdGlvbmluZ1wiIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICB9XG4gIGxldCBzdHlsZSA9IHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlUHJvcChyZW5kZXJQcm9wcykgOiBzdHlsZVByb3A7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHJlZjogcmVmLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB0bzogdG8sXG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb246IHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gIH0pLCB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHJlbmRlclByb3BzKSA6IGNoaWxkcmVuKTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG59XG4vKipcbiAqIEEgYEByZW1peC1ydW4vcm91dGVyYC1hd2FyZSBgPGZvcm0+YC4gSXQgYmVoYXZlcyBsaWtlIGEgbm9ybWFsIGZvcm0gZXhjZXB0XG4gKiB0aGF0IHRoZSBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgaXMgd2l0aCBgZmV0Y2hgIGluc3RlYWQgb2YgbmV3IGRvY3VtZW50XG4gKiByZXF1ZXN0cywgYWxsb3dpbmcgY29tcG9uZW50cyB0byBhZGQgbmljZXIgVVggdG8gdGhlIHBhZ2UgYXMgdGhlIGZvcm0gaXNcbiAqIHN1Ym1pdHRlZCBhbmQgcmV0dXJucyB3aXRoIGRhdGEuXG4gKi9cbmNvbnN0IEZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoX3JlZjksIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQge1xuICAgICAgZmV0Y2hlcktleSxcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgICAgYWN0aW9uLFxuICAgICAgb25TdWJtaXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgfSA9IF9yZWY5LFxuICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjksIF9leGNsdWRlZDMpO1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0KCk7XG4gIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgbGV0IHN1Ym1pdEhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgc3VibWl0dGVyID0gZXZlbnQubmF0aXZlRXZlbnQuc3VibWl0dGVyO1xuICAgIGxldCBzdWJtaXRNZXRob2QgPSAoc3VibWl0dGVyID09IG51bGwgPyB2b2lkIDAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSkgfHwgbWV0aG9kO1xuICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgZmV0Y2hlcktleSxcbiAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgbmF2aWdhdGUsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgIG1ldGhvZDogZm9ybU1ldGhvZCxcbiAgICBhY3Rpb246IGZvcm1BY3Rpb24sXG4gICAgb25TdWJtaXQ6IHJlbG9hZERvY3VtZW50ID8gb25TdWJtaXQgOiBzdWJtaXRIYW5kbGVyXG4gIH0sIHByb3BzKSk7XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGVtdWxhdGUgdGhlIGJyb3dzZXIncyBzY3JvbGwgcmVzdG9yYXRpb24gb24gbG9jYXRpb25cbiAqIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKF9yZWYxMCkge1xuICBsZXQge1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0gPSBfcmVmMTA7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgICBnZXRLZXksXG4gICAgc3RvcmFnZUtleVxuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhvb2tzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xudmFyIERhdGFSb3V0ZXJIb29rO1xuKGZ1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xuICBEYXRhUm91dGVySG9va1tcIlVzZVNjcm9sbFJlc3RvcmF0aW9uXCJdID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdFwiXSA9IFwidXNlU3VibWl0XCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU3VibWl0RmV0Y2hlclwiXSA9IFwidXNlU3VibWl0RmV0Y2hlclwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZUZldGNoZXJcIl0gPSBcInVzZUZldGNoZXJcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCJdID0gXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCI7XG59KShEYXRhUm91dGVySG9vayB8fCAoRGF0YVJvdXRlckhvb2sgPSB7fSkpO1xudmFyIERhdGFSb3V0ZXJTdGF0ZUhvb2s7XG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUZldGNoZXJcIl0gPSBcInVzZUZldGNoZXJcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUZldGNoZXJzXCJdID0gXCJ1c2VGZXRjaGVyc1wiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XG59KShEYXRhUm91dGVyU3RhdGVIb29rIHx8IChEYXRhUm91dGVyU3RhdGVIb29rID0ge30pKTtcbi8vIEludGVybmFsIGhvb2tzXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQpO1xuICAhY3R4ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICFzdGF0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gc3RhdGU7XG59XG4vLyBFeHRlcm5hbCBob29rc1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICogdXNlIGluIG91ciBleHBvcnRlZCBgPExpbms+YC5cbiAqL1xuZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgX3RlbXApIHtcbiAgbGV0IHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlbGF0aXZlLFxuICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlIHVubGVzcyB0aGUgcmVwbGFjZSBwcm9wIGlzIGV4cGxpY2l0bHkgc2V0XG4gICAgICBsZXQgcmVwbGFjZSA9IHJlcGxhY2VQcm9wICE9PSB1bmRlZmluZWQgPyByZXBsYWNlUHJvcCA6IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuICAgICAgbmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtsb2NhdGlvbiwgbmF2aWdhdGUsIHBhdGgsIHJlcGxhY2VQcm9wLCBzdGF0ZSwgdGFyZ2V0LCB0bywgcHJldmVudFNjcm9sbFJlc2V0LCByZWxhdGl2ZSwgdW5zdGFibGVfdmlld1RyYW5zaXRpb25dKTtcbn1cbi8qKlxuICogQSBjb252ZW5pZW50IHdyYXBwZXIgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgc2VhcmNoIHBhcmFtZXRlcnMgdmlhIHRoZVxuICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cbiAqL1xuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsIFwiWW91IGNhbm5vdCB1c2UgdGhlIGB1c2VTZWFyY2hQYXJhbXNgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3QgXCIgKyBcInN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgXCIgKyBcIkV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIFwiICsgXCJodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXNcXG5cXG5cIiArIFwiSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IFwiICsgXCJodHRwczovL3BvbHlmaWxsLmlvL3YzLyB3aGljaCBwcm92aWRlcyBzb21lIHJlY29tbWVuZGF0aW9ucyBhYm91dCBob3cgXCIgKyBcInRvIGxvYWQgcG9seWZpbGxzIG9ubHkgZm9yIHVzZXJzIHRoYXQgbmVlZCB0aGVtLCBpbnN0ZWFkIG9mIGZvciBldmVyeSBcIiArIFwidXNlci5cIikgOiB2b2lkIDA7XG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT5cbiAgLy8gT25seSBtZXJnZSBpbiB0aGUgZGVmYXVsdHMgaWYgd2UgaGF2ZW4ndCB5ZXQgY2FsbGVkIHNldFNlYXJjaFBhcmFtcy5cbiAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uLnNlYXJjaCwgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50KSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2soKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXModHlwZW9mIG5leHRJbml0ID09PSBcImZ1bmN0aW9uXCIgPyBuZXh0SW5pdChzZWFyY2hQYXJhbXMpIDogbmV4dEluaXQpO1xuICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcbiAgfSwgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdKTtcbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNsaWVudFNpZGVTdWJtaXNzaW9uKCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBjYWxsaW5nIHN1Ym1pdCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIuIFwiICsgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIik7XG4gIH1cbn1cbmxldCBmZXRjaGVySWQgPSAwO1xubGV0IGdldFVuaXF1ZUZldGNoZXJJZCA9ICgpID0+IFwiX19cIiArIFN0cmluZygrK2ZldGNoZXJJZCkgKyBcIl9fXCI7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgc3VibWl0IGEgZm9ybSAob3JcbiAqIHNvbWUgYXJiaXRyYXJ5IGRhdGEpIHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVN1Ym1pdCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGN1cnJlbnRSb3V0ZUlkID0gVU5TQUZFX3VzZVJvdXRlSWQoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKTtcbiAgICBsZXQge1xuICAgICAgYWN0aW9uLFxuICAgICAgbWV0aG9kLFxuICAgICAgZW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgYm9keVxuICAgIH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBiYXNlbmFtZSk7XG4gICAgaWYgKG9wdGlvbnMubmF2aWdhdGUgPT09IGZhbHNlKSB7XG4gICAgICBsZXQga2V5ID0gb3B0aW9ucy5mZXRjaGVyS2V5IHx8IGdldFVuaXF1ZUZldGNoZXJJZCgpO1xuICAgICAgcm91dGVyLmZldGNoKGtleSwgY3VycmVudFJvdXRlSWQsIG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogb3B0aW9ucy51bnN0YWJsZV9mbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZXIubmF2aWdhdGUob3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBib2R5LFxuICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgZnJvbVJvdXRlSWQ6IGN1cnJlbnRSb3V0ZUlkLFxuICAgICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdGlvbnMudW5zdGFibGVfZmx1c2hTeW5jLFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbjogb3B0aW9ucy51bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgY3VycmVudFJvdXRlSWRdKTtcbn1cbi8vIHY3OiBFdmVudHVhbGx5IHdlIHNob3VsZCBkZXByZWNhdGUgdGhpcyBlbnRpcmVseSBpbiBmYXZvciBvZiB1c2luZyB0aGVcbi8vIHJvdXRlciBtZXRob2QgZGlyZWN0bHk/XG5mdW5jdGlvbiB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgX3RlbXAyKSB7XG4gIGxldCB7XG4gICAgcmVsYXRpdmVcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX1JvdXRlQ29udGV4dCk7XG4gICFyb3V0ZUNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgLy8gU2hhbGxvdyBjbG9uZSBwYXRoIHNvIHdlIGNhbiBtb2RpZnkgaXQgYmVsb3csIG90aGVyd2lzZSB3ZSBtb2RpZnkgdGhlXG4gIC8vIG9iamVjdCByZWZlcmVuY2VkIGJ5IHVzZU1lbW8gaW5zaWRlIHVzZVJlc29sdmVkUGF0aFxuICBsZXQgcGF0aCA9IF9leHRlbmRzKHt9LCB1c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHtcbiAgICByZWxhdGl2ZVxuICB9KSk7XG4gIC8vIElmIG5vIGFjdGlvbiB3YXMgc3BlY2lmaWVkLCBicm93c2VycyB3aWxsIHBlcnNpc3QgY3VycmVudCBzZWFyY2ggcGFyYW1zXG4gIC8vIHdoZW4gZGV0ZXJtaW5pbmcgdGhlIHBhdGgsIHNvIG1hdGNoIHRoYXQgYmVoYXZpb3JcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIC8vIFNhZmUgdG8gd3JpdGUgdG8gdGhpcyBkaXJlY3RseSBoZXJlIHNpbmNlIGlmIGFjdGlvbiB3YXMgdW5kZWZpbmVkLCB3ZVxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgLy8gV2hlbiBncmFiYmluZyBzZWFyY2ggcGFyYW1zIGZyb20gdGhlIFVSTCwgcmVtb3ZlIGFueSBpbmNsdWRlZCA/aW5kZXggcGFyYW1cbiAgICAvLyBzaW5jZSBpdCBtaWdodCBub3QgYXBwbHkgdG8gb3VyIGNvbnRleHR1YWwgcm91dGUuICBXZSBhZGQgaXQgYmFjayBiYXNlZFxuICAgIC8vIG9uIG1hdGNoLnJvdXRlLmluZGV4IGJlbG93XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgIGlmIChwYXJhbXMuaGFzKFwiaW5kZXhcIikgJiYgcGFyYW1zLmdldChcImluZGV4XCIpID09PSBcIlwiKSB7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhcmFtcy50b1N0cmluZygpID8gXCI/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBmb3JtIGFjdGlvbi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2VcbiAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSB1c2VGZXRjaGVyIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcihfdGVtcDMpIHtcbiAgdmFyIF9yb3V0ZSRtYXRjaGVzO1xuICBsZXQge1xuICAgIGtleVxuICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVyKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QudXNlQ29udGV4dChGZXRjaGVyc0NvbnRleHQpO1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVJZCA9IChfcm91dGUkbWF0Y2hlcyA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZSRtYXRjaGVzLnJvdXRlLmlkO1xuICAhZmV0Y2hlckRhdGEgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIEZldGNoZXJzQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhKHJvdXRlSWQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFxcXCJpZFxcXCJcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgLy8gRmV0Y2hlciBrZXkgaGFuZGxpbmdcbiAgLy8gT0sgdG8gY2FsbCBjb25kaXRpb25hbGx5IHRvIGZlYXR1cmUgZGV0ZWN0IGB1c2VJZGBcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIGxldCBkZWZhdWx0S2V5ID0gdXNlSWRJbXBsID8gdXNlSWRJbXBsKCkgOiBcIlwiO1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QudXNlU3RhdGUoa2V5IHx8IGRlZmF1bHRLZXkpO1xuICBpZiAoa2V5ICYmIGtleSAhPT0gZmV0Y2hlcktleSkge1xuICAgIHNldEZldGNoZXJLZXkoa2V5KTtcbiAgfSBlbHNlIGlmICghZmV0Y2hlcktleSkge1xuICAgIC8vIFdlIHdpbGwgb25seSBmYWxsIHRocm91Z2ggaGVyZSB3aGVuIGB1c2VJZGAgaXMgbm90IGF2YWlsYWJsZVxuICAgIHNldEZldGNoZXJLZXkoZ2V0VW5pcXVlRmV0Y2hlcklkKCkpO1xuICB9XG4gIC8vIFJlZ2lzdHJhdGlvbi9jbGVhbnVwXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcm91dGVyLmdldEZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFRlbGwgdGhlIHJvdXRlciB3ZSd2ZSB1bm1vdW50ZWQgLSBpZiB2N19mZXRjaGVyUGVyc2lzdCBpcyBlbmFibGVkIHRoaXNcbiAgICAgIC8vIHdpbGwgbm90IGRlbGV0ZSBpbW1lZGlhdGVseSBidXQgaW5zdGVhZCBxdWV1ZSB1cCBhIGRlbGV0ZSBhZnRlciB0aGVcbiAgICAgIC8vIGZldGNoZXIgcmV0dXJucyB0byBhbiBgaWRsZWAgc3RhdGVcbiAgICAgIHJvdXRlci5kZWxldGVGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIH07XG4gIH0sIFtyb3V0ZXIsIGZldGNoZXJLZXldKTtcbiAgLy8gRmV0Y2hlciBhZGRpdGlvbnNcbiAgbGV0IGxvYWQgPSBSZWFjdC51c2VDYWxsYmFjaygoaHJlZiwgb3B0cykgPT4ge1xuICAgICFyb3V0ZUlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZiwgb3B0cyk7XG4gIH0sIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdKTtcbiAgbGV0IHN1Ym1pdEltcGwgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IHN1Ym1pdCA9IFJlYWN0LnVzZUNhbGxiYWNrKCh0YXJnZXQsIG9wdHMpID0+IHtcbiAgICBzdWJtaXRJbXBsKHRhcmdldCwgX2V4dGVuZHMoe30sIG9wdHMsIHtcbiAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgIGZldGNoZXJLZXlcbiAgICB9KSk7XG4gIH0sIFtmZXRjaGVyS2V5LCBzdWJtaXRJbXBsXSk7XG4gIGxldCBGZXRjaGVyRm9ybSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBGZXRjaGVyRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hlcktleTogZmV0Y2hlcktleSxcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgfVxuICAgIHJldHVybiBGZXRjaGVyRm9ybTtcbiAgfSwgW2ZldGNoZXJLZXldKTtcbiAgLy8gRXhwb3NlZCBGZXRjaGVyV2l0aENvbXBvbmVudHNcbiAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoZmV0Y2hlcktleSkgfHwgSURMRV9GRVRDSEVSO1xuICBsZXQgZGF0YSA9IGZldGNoZXJEYXRhLmdldChmZXRjaGVyS2V5KTtcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gX2V4dGVuZHMoe1xuICAgIEZvcm06IEZldGNoZXJGb3JtLFxuICAgIHN1Ym1pdCxcbiAgICBsb2FkXG4gIH0sIGZldGNoZXIsIHtcbiAgICBkYXRhXG4gIH0pLCBbRmV0Y2hlckZvcm0sIHN1Ym1pdCwgbG9hZCwgZmV0Y2hlciwgZGF0YV0pO1xuICByZXR1cm4gZmV0Y2hlcldpdGhDb21wb25lbnRzO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICogcm91dGVzIHRoYXQgbmVlZCB0byBwcm92aWRlIHBlbmRpbmcvb3B0aW1pc3RpYyBVSSByZWdhcmRpbmcgdGhlIGZldGNoLlxuICovXG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcnMpO1xuICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZS5mZXRjaGVycy5lbnRyaWVzKCkpLm1hcChfcmVmMTEgPT4ge1xuICAgIGxldCBba2V5LCBmZXRjaGVyXSA9IF9yZWYxMTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGZldGNoZXIsIHtcbiAgICAgIGtleVxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbmxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHt9O1xuLyoqXG4gKiBXaGVuIHJlbmRlcmVkIGluc2lkZSBhIFJvdXRlclByb3ZpZGVyLCB3aWxsIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9ucyBvbiBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbihfdGVtcDQpIHtcbiAgbGV0IHtcbiAgICBnZXRLZXksXG4gICAgc3RvcmFnZUtleVxuICB9ID0gX3RlbXA0ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNDtcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IHtcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0XG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvbik7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICAvLyBUcmlnZ2VyIG1hbnVhbCBzY3JvbGwgcmVzdG9yYXRpb24gd2hpbGUgd2UncmUgYWN0aXZlXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgLy8gU2F2ZSBwb3NpdGlvbnMgb24gcGFnZWhpZGVcbiAgdXNlUGFnZUhpZGUoUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgbGV0IGtleSA9IChnZXRLZXkgPyBnZXRLZXkobG9jYXRpb24sIG1hdGNoZXMpIDogbnVsbCkgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiRmFpbGVkIHRvIHNhdmUgc2Nyb2xsIHBvc2l0aW9ucyBpbiBzZXNzaW9uU3RvcmFnZSwgPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHdpbGwgbm90IHdvcmsgcHJvcGVybHkgKFwiICsgZXJyb3IgKyBcIikuXCIpIDogdm9pZCAwO1xuICAgIH1cbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbc3RvcmFnZUtleSwgZ2V0S2V5LCBuYXZpZ2F0aW9uLnN0YXRlLCBsb2NhdGlvbiwgbWF0Y2hlc10pKTtcbiAgLy8gUmVhZCBpbiBhbnkgc2F2ZWQgc2Nyb2xsIGxvY2F0aW9uc1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vLW9wLCB1c2UgZGVmYXVsdCBlbXB0eSBvYmplY3RcbiAgICAgIH1cbiAgICB9LCBbc3RvcmFnZUtleV0pO1xuICAgIC8vIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gaW4gdGhlIHJvdXRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZ2V0S2V5V2l0aG91dEJhc2VuYW1lID0gZ2V0S2V5ICYmIGJhc2VuYW1lICE9PSBcIi9cIiA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT4gZ2V0S2V5KFxuICAgICAgLy8gU3RyaXAgdGhlIGJhc2VuYW1lIHRvIG1hdGNoIHVzZUxvY2F0aW9uKClcbiAgICAgIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KSwgbWF0Y2hlcykgOiBnZXRLZXk7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXIuZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oc2F2ZWRTY3JvbGxQb3NpdGlvbnMsICgpID0+IHdpbmRvdy5zY3JvbGxZLCBnZXRLZXlXaXRob3V0QmFzZW5hbWUpO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgZ2V0S2V5XSk7XG4gICAgLy8gUmVzdG9yZSBzY3JvbGxpbmcgd2hlbiBzdGF0ZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24gY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBFeHBsaWNpdCBmYWxzZSBtZWFucyBkb24ndCBkbyBhbnl0aGluZyAodXNlZCBmb3Igc3VibWlzc2lvbnMpXG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkZWNvZGVVUklDb21wb25lbnQobG9jYXRpb24uaGFzaC5zbGljZSgxKSkpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcmVzZXQgaWYgdGhpcyBuYXZpZ2F0aW9uIG9wdGVkIG91dFxuICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfSwgW2xvY2F0aW9uLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldF0pO1xuICB9XG59XG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBiZWZvcmV1bmxvYWRgIGV2ZW50LiBUaGlzIGlzXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gKiByZWZyZXNoZXMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQge1xuICAgIGNhcHR1cmVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLiAgVGhpcyBldmVudCBpcyBiZXR0ZXIgc3VwcG9ydGVkIHRoYW4gYmVmb3JldW5sb2FkIGFjcm9zcyBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuZnVuY3Rpb24gdXNlUGFnZUhpZGUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBjYXB0dXJlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgY2FwdHVyZVxuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB1c2VCbG9ja2VyIHRvIHNob3cgYSB3aW5kb3cuY29uZmlybSBwcm9tcHQgdG8gdXNlcnMgaW5zdGVhZFxuICogb2YgYnVpbGRpbmcgYSBjdXN0b20gVUkgd2l0aCB1c2VCbG9ja2VyLlxuICpcbiAqIFdhcm5pbmc6IFRoaXMgaGFzICphIGxvdCBvZiByb3VnaCBlZGdlcyogYW5kIGJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSAoYW5kXG4gKiB2ZXJ5IGluY29ycmVjdGx5IGluIHNvbWUgY2FzZXMpIGFjcm9zcyBicm93c2VycyBpZiB1c2VyIGNsaWNrIGFkZGl0aW9uXG4gKiBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbnMgd2hpbGUgdGhlIGNvbmZpcm0gaXMgb3Blbi4gIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICovXG5mdW5jdGlvbiB1c2VQcm9tcHQoX3JlZjEyKSB7XG4gIGxldCB7XG4gICAgd2hlbixcbiAgICBtZXNzYWdlXG4gIH0gPSBfcmVmMTI7XG4gIGxldCBibG9ja2VyID0gdXNlQmxvY2tlcih3aGVuKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICBpZiAocHJvY2VlZCkge1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgbmVlZGVkIHRvIGF2b2lkIGEgd2VpcmQgXCJyYWNlXCIgb24gUE9QIG5hdmlnYXRpb25zXG4gICAgICAgIC8vIGJldHdlZW4gdGhlIGB3aW5kb3cuaGlzdG9yeWAgcmV2ZXJ0IG5hdmlnYXRpb24gYW5kIHRoZSByZXN1bHQgb2ZcbiAgICAgICAgLy8gYHdpbmRvdy5jb25maXJtYFxuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tlciwgbWVzc2FnZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSB2aWV3IHRyYW5zaXRpb24gdG8gdGhlXG4gKiBnaXZlbiBocmVmLiAgWW91IGNhbiB1c2UgdGhpcyB2YWx1ZSB0byByZW5kZXIgQ1NTIGNsYXNzZXMgb3Igdmlld1RyYW5zaXRpb25OYW1lXG4gKiBzdHlsZXMgb250byB5b3VyIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIGhyZWYgVGhlIGRlc3RpbmF0aW9uIGhyZWZcbiAqIEBwYXJhbSBbb3B0cy5yZWxhdGl2ZV0gUmVsYXRpdmUgcm91dGluZyB0eXBlIChcInJvdXRlXCIgfCBcInBhdGhcIilcbiAqL1xuZnVuY3Rpb24gdXNlVmlld1RyYW5zaXRpb25TdGF0ZSh0bywgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGxldCB2dENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gICEodnRDb250ZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgXCIgKyBcIkRpZCB5b3UgYWNjaWRlbnRhbGx5IGltcG9ydCBgUm91dGVyUHJvdmlkZXJgIGZyb20gYHJlYWN0LXJvdXRlcmA/XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLnVzZVZpZXdUcmFuc2l0aW9uU3RhdGUpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlOiBvcHRzLnJlbGF0aXZlXG4gIH0pO1xuICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN1cnJlbnRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcbiAgLy8gVHJhbnNpdGlvbiBpcyBhY3RpdmUgaWYgd2UncmUgZ29pbmcgdG8gb3IgY29taW5nIGZyb20gdGhlIGluZGljYXRlZFxuICAvLyBkZXN0aW5hdGlvbi4gIFRoaXMgZW5zdXJlcyB0aGF0IG90aGVyIFBVU0ggbmF2aWdhdGlvbnMgdGhhdCByZXZlcnNlXG4gIC8vIGFuIGluZGljYXRlZCB0cmFuc2l0aW9uIGFwcGx5LiAgSS5lLiwgb24gdGhlIGxpc3QgdmlldyB5b3UgaGF2ZTpcbiAgLy9cbiAgLy8gICA8TmF2TGluayB0bz1cIi9kZXRhaWxzLzFcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgLy9cbiAgLy8gSWYgeW91IGNsaWNrIHRoZSBicmVhZGNydW1iIGJhY2sgdG8gdGhlIGxpc3QgdmlldzpcbiAgLy9cbiAgLy8gICA8TmF2TGluayB0bz1cIi9saXN0XCIgdW5zdGFibGVfdmlld1RyYW5zaXRpb24+XG4gIC8vXG4gIC8vIFdlIHNob3VsZCBhcHBseSB0aGUgdHJhbnNpdGlvbiBiZWNhdXNlIGl0J3MgaW5kaWNhdGVkIGFzIGFjdGl2ZSBnb2luZ1xuICAvLyBmcm9tIC9saXN0IC0+IC9kZXRhaWxzLzEgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgYWN0aXZlIG9uIHRoZSByZXZlcnNlXG4gIC8vIChldmVuIHRob3VnaCB0aGlzIGlzbid0IHN0cmljdGx5IGEgUE9QIHJldmVyc2UpXG4gIHJldHVybiBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIGN1cnJlbnRQYXRoKSAhPSBudWxsO1xufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEZvcm0sIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmssIFJvdXRlclByb3ZpZGVyLCBTY3JvbGxSZXN0b3JhdGlvbiwgRmV0Y2hlcnNDb250ZXh0IGFzIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQsIFZpZXdUcmFuc2l0aW9uQ29udGV4dCBhcyBVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0LCB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24sIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsIGNyZWF0ZUhhc2hSb3V0ZXIsIGNyZWF0ZVNlYXJjaFBhcmFtcywgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyLCB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0LCB1c2VWaWV3VHJhbnNpdGlvblN0YXRlIGFzIHVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGUsIHVzZUJlZm9yZVVubG9hZCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUxpbmtDbGlja0hhbmRsZXIsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/dist/index.js\n");

/***/ }),

/***/ "./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router v6.23.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  AwaitContext.displayName = \"Await\";\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nconst NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (true) {\n  RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  let {\n    basename,\n    navigator\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname), [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nconst navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  let {\n    basename,\n    future,\n    navigator\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we're not in a data router,\n    // otherwise it'll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    future\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n  let {\n    navigator\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (true) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : 0 : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = pathname;\n  if (parentPathnameBase !== \"/\") {\n    // Determine the remaining pathname by removing the # of URL segments the\n    // parentPathnameBase has, instead of removing based on character count.\n    // This is because we can't guarantee that incoming/outgoing encodings/\n    // decodings will match exactly.\n    // We decode paths before matching on a per-segment basis with\n    // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\n    // match what `window.location.pathname` would reflect.  Those don't 100%\n    // align when it comes to encoded URI characters such as % and &.\n    //\n    // So we may end up with:\n    //   pathname:           \"/descendant/a%25b/match\"\n    //   parentPathnameBase: \"/descendant/a%b\"\n    //\n    // And the direct substring removal approach won't work :/\n    let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n    let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n  }\n  let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n    pathname: remainingPathname\n  });\n  if (true) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : 0;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterState, future);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (true) {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error !== undefined ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error !== undefined ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n}\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (future === void 0) {\n    future = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);\n    !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n\n  // If we're in a partial hydration mode, detect if we need to render down to\n  // a given HydrateFallback while we load the rest of the hydration data\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState && future && future.v7_partialHydration) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      // Track the deepest fallback up until the first route without data\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.id) {\n        let {\n          loaderData,\n          errors\n        } = dataRouterState;\n        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n        if (match.route.lazy || needsToRunLoader) {\n          // We found the first route that's not ready to render (waiting on\n          // lazy, or has a loader that hasn't run yet).  Flag that we need to\n          // render a fallback and render up until the appropriate fallback\n          renderFallback = true;\n          if (fallbackIndex >= 0) {\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n          } else {\n            renderedMatches = [renderedMatches[0]];\n          }\n          break;\n        }\n      }\n    }\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    // Only data routers handle errors/fallbacks\n    let error;\n    let shouldRenderHydrateFallback = false;\n    let errorElement = null;\n    let hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : undefined;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet,\n          matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n  !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => matches.map(m => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData)), [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : undefined;\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error !== undefined) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */\nfunction useAsyncValue() {\n  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */\nfunction useAsyncError() {\n  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(arg => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we've got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\n    if (v7_startTransition && startTransitionImpl) {\n      startTransitionImpl(() => setStateImpl(newState));\n    } else {\n      setStateImpl(newState);\n    }\n  }, [setStateImpl, v7_startTransition]);\n\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref2;\n  return useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future: future\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false,\n  // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n  let {\n    future,\n    static: isStatic\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n  let {\n    matches\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop,\n    navigator,\n    static: staticProp = false,\n    future\n  } = _ref5;\n  !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp,\n    future: _extends({\n      v7_relativeSplatPath: false\n    }, future)\n  }), [basename, future, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(() => {});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n    !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (true) {\n      if (route.element) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n      }\n    }\n    Object.assign(updates, {\n      element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.HydrateFallback) {\n    if (true) {\n      if (route.hydrateFallbackElement) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : 0;\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\n      HydrateFallback: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (true) {\n      if (route.errorElement) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties,\n    unstable_dataStrategy: opts == null ? void 0 : opts.unstable_dataStrategy\n  }).initialize();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0I7QUFDa1I7QUFDckY7QUFDNU47QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLGdEQUFtQjtBQUMxRCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSw0Q0FBNEMsZ0RBQW1CO0FBQy9ELElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBLGtDQUFrQyxnREFBbUI7QUFDckQsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxnREFBbUI7QUFDMUQsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0EscUNBQXFDLGdEQUFtQjtBQUN4RCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSx1Q0FBdUMsZ0RBQW1CO0FBQzFELElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QiwwQkFBMEIsS0FBcUMsR0FBRyxtRUFBZ0I7QUFDbEY7QUFDQTtBQUNBLDBFQUEwRSxDQUF1QjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFB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SztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrREFBWTtBQUNyQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLEtBQUs7QUFDTCxhQUFhLHNFQUFtQjtBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9pbmRleC5qcz8yZjAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIHY2LjIzLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVU5TQUZFX2ludmFyaWFudCwgam9pblBhdGhzLCBtYXRjaFBhdGgsIFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzLCBVTlNBRkVfd2FybmluZywgcmVzb2x2ZVRvLCBwYXJzZVBhdGgsIG1hdGNoUm91dGVzLCBBY3Rpb24sIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgc3RyaXBCYXNlbmFtZSwgSURMRV9CTE9DS0VSLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgQWJvcnRlZERlZmVycmVkRXJyb3IsIGNyZWF0ZVJvdXRlciB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsIGNyZWF0ZVBhdGgsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXNvbHZlUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLyBDcmVhdGUgcmVhY3Qtc3BlY2lmaWMgdHlwZXMgZnJvbSB0aGUgYWdub3N0aWMgdHlwZXMgaW4gQHJlbWl4LXJ1bi9yb3V0ZXIgdG9cbi8vIGV4cG9ydCBmcm9tIHJlYWN0LXJvdXRlclxuY29uc3QgRGF0YVJvdXRlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbn1cbmNvbnN0IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG59XG5jb25zdCBBd2FpdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xufVxuXG4vKipcbiAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAqXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXG4gKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCBgPFJvdXRlcj5gIEFQSVxuICogd2hlcmUgYm90aCB0aGUgbG9jYXRpb24gYW5kIGEgbmF2aWdhdG9yIG11c3QgYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBpbiBvcmRlclxuICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXG4gKiBhbmQvb3IgbG9jYXRpb24gd2VyZSB0byBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGhpc3RvcnkgaW5zdGFuY2UuXG4gKi9cblxuY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5jb25zdCBSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW10sXG4gIGlzRGF0YVJvdXRlOiBmYWxzZVxufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cbmNvbnN0IFJvdXRlRXJyb3JDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWhyZWZcbiAqL1xuZnVuY3Rpb24gdXNlSHJlZih0bywgX3RlbXApIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsXG4gIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBoYXNoLFxuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaFxuICB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGhyZWYuICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlIHRoZSByYXdcbiAgLy8gYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZVxuICAvLyBvZiBhIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7XG4gICAgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSBgPFJvdXRlcj5gLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWluLXJvdXRlci1jb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcbiAqIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXG4gKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gKiBiZSBhYmxlIHRvIHByb3ZpZGUgc29tZXRoaW5nIGhpZ2hlci1sZXZlbCB0byBiZXR0ZXIgc3VpdCB5b3VyIG5lZWRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLFxuICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5sb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gYWN0aW9uIHdoaWNoIGRlc2NyaWJlcyBob3cgdGhlIHJvdXRlciBjYW1lIHRvXG4gKiB0aGUgY3VycmVudCBsb2NhdGlvbiwgZWl0aGVyIGJ5IGEgcG9wLCBwdXNoLCBvciByZXBsYWNlIG9uIHRoZSBoaXN0b3J5IHN0YWNrLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRpb24tdHlwZVxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUGF0aE1hdGNoIG9iamVjdCBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIGA8TmF2TGluaz5gLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW1hdGNoXG4gKi9cbmZ1bmN0aW9uIHVzZU1hdGNoKHBhdHRlcm4pIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSxcbiAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgcGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSksIFtwYXRobmFtZSwgcGF0dGVybl0pO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAqL1xuXG5jb25zdCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcgPSBcIllvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIFwiICsgXCJ5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5cIjtcblxuLy8gTXV0ZSB3YXJuaW5ncyBmb3IgY2FsbHMgdG8gdXNlTmF2aWdhdGUgaW4gU1NSIGVudmlyb25tZW50c1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICBsZXQgaXNTdGF0aWMgPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWM7XG4gIGlmICghaXNTdGF0aWMpIHtcbiAgICAvLyBXZSBzaG91bGQgYmUgYWJsZSB0byBnZXQgcmlkIG9mIHRoaXMgb25jZSByZWFjdCAxOC4zIGlzIHJlbGVhc2VkXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdChjYik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgYDxMaW5rPmBzLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgbGV0IHtcbiAgICBpc0RhdGFSb3V0ZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICByZXR1cm4gaXNEYXRhUm91dGUgPyB1c2VOYXZpZ2F0ZVN0YWJsZSgpIDogdXNlTmF2aWdhdGVVbnN0YWJsZSgpO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGVVbnN0YWJsZSgpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSxcbiAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGZ1dHVyZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCkpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA6IHZvaWQgMDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaGVyZSBzaW5jZSBpZiB0aGlzIGhhcHBlbnMgb24gZmlyc3QgcmVuZGVyIHRoZSBuYXZpZ2F0ZVxuICAgIC8vIGlzIHVzZWxlc3MgYmVjYXVzZSB3ZSBoYXZlbid0IHdpcmVkIHVwIG91ciBoaXN0b3J5IGxpc3RlbmVyIHlldFxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIik7XG5cbiAgICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgLy8gb3RoZXJ3aXNlIGl0J2xsIHByZXBlbmQgdGhlIGJhc2VuYW1lIGluc2lkZSBvZiB0aGUgcm91dGVyKS5cbiAgICAvLyBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIHdlIG5hdmlnYXRlIHRvIHRoZSByYXcgYmFzZW5hbWVcbiAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAvLyB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gICAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ID09IG51bGwgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICB9XG4gICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkocGF0aCwgb3B0aW9ucy5zdGF0ZSwgb3B0aW9ucyk7XG4gIH0sIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIGRhdGFSb3V0ZXJDb250ZXh0XSk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbmNvbnN0IE91dGxldENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0LWNvbnRleHRcbiAqL1xuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSBgPE91dGxldD5gIHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0XG4gKi9cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgb3V0bGV0KTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xuICovXG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJlc29sdmVkLXBhdGhcbiAqL1xuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgbGV0IHtcbiAgICBmdXR1cmVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCkpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKSwgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gYDxPdXRsZXQ+YCB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICogZWxlbWVudC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG59XG5cbi8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIHdpdGggYWNjZXB0IG9wdGlvbmFsIHBhcmFtIGZvciBSb3V0ZXJQcm92aWRlciB1c2FnZVxuZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLFxuICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UocGFyZW50UGF0aG5hbWUsICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSwgXCJZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIGB1c2VSb3V0ZXMoKWApIGF0IFwiICsgKFwiXFxcIlwiICsgcGFyZW50UGF0aG5hbWUgKyBcIlxcXCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCI+KSBidXQgdGhlIFwiKSArIFwicGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFxcXCIqXFxcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgXCIgKyBcImRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIFwiICsgXCJyb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuXCIgKyAoXCJQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4gdG8gPFJvdXRlIFwiKSArIChcInBhdGg9XFxcIlwiICsgKHBhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBwYXJlbnRQYXRoICsgXCIvKlwiKSArIFwiXFxcIj4uXCIpKTtcbiAgfVxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gICAgIShwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8ICgoX3BhcnNlZExvY2F0aW9uQXJnJHBhID0gcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyc2VkTG9jYXRpb25BcmckcGEuc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIldoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgYDxSb3V0ZXMgbG9jYXRpb24+YCBvciBgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pYCwgXCIgKyBcInRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBcIiArIChcIm1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXFxcIlwiICsgcGFyZW50UGF0aG5hbWVCYXNlICsgXCJcXFwiIFwiKSArIChcImJ1dCBwYXRobmFtZSBcXFwiXCIgKyBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSArIFwiXFxcIiB3YXMgZ2l2ZW4gaW4gdGhlIGBsb2NhdGlvbmAgcHJvcC5cIikpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAocGFyZW50UGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgIC8vIERldGVybWluZSB0aGUgcmVtYWluaW5nIHBhdGhuYW1lIGJ5IHJlbW92aW5nIHRoZSAjIG9mIFVSTCBzZWdtZW50cyB0aGVcbiAgICAvLyBwYXJlbnRQYXRobmFtZUJhc2UgaGFzLCBpbnN0ZWFkIG9mIHJlbW92aW5nIGJhc2VkIG9uIGNoYXJhY3RlciBjb3VudC5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgY2FuJ3QgZ3VhcmFudGVlIHRoYXQgaW5jb21pbmcvb3V0Z29pbmcgZW5jb2RpbmdzL1xuICAgIC8vIGRlY29kaW5ncyB3aWxsIG1hdGNoIGV4YWN0bHkuXG4gICAgLy8gV2UgZGVjb2RlIHBhdGhzIGJlZm9yZSBtYXRjaGluZyBvbiBhIHBlci1zZWdtZW50IGJhc2lzIHdpdGhcbiAgICAvLyBkZWNvZGVVUklDb21wb25lbnQoKSwgYnV0IHdlIHJlLWVuY29kZSBwYXRobmFtZXMgdmlhIGBuZXcgVVJMKClgIHNvIHRoZXlcbiAgICAvLyBtYXRjaCB3aGF0IGB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVgIHdvdWxkIHJlZmxlY3QuICBUaG9zZSBkb24ndCAxMDAlXG4gICAgLy8gYWxpZ24gd2hlbiBpdCBjb21lcyB0byBlbmNvZGVkIFVSSSBjaGFyYWN0ZXJzIHN1Y2ggYXMgJSBhbmQgJi5cbiAgICAvL1xuICAgIC8vIFNvIHdlIG1heSBlbmQgdXAgd2l0aDpcbiAgICAvLyAgIHBhdGhuYW1lOiAgICAgICAgICAgXCIvZGVzY2VuZGFudC9hJTI1Yi9tYXRjaFwiXG4gICAgLy8gICBwYXJlbnRQYXRobmFtZUJhc2U6IFwiL2Rlc2NlbmRhbnQvYSViXCJcbiAgICAvL1xuICAgIC8vIEFuZCB0aGUgZGlyZWN0IHN1YnN0cmluZyByZW1vdmFsIGFwcHJvYWNoIHdvbid0IHdvcmsgOi9cbiAgICBsZXQgcGFyZW50U2VnbWVudHMgPSBwYXJlbnRQYXRobmFtZUJhc2UucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgc2VnbWVudHMgPSBwYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gXCIvXCIgKyBzZWdtZW50cy5zbGljZShwYXJlbnRTZWdtZW50cy5sZW5ndGgpLmpvaW4oXCIvXCIpO1xuICB9XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7XG4gICAgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lXG4gIH0pO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcocGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLCBcIk5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLkNvbXBvbmVudCAhPT0gdW5kZWZpbmVkIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5sYXp5ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIiArIFwiZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBcIiArIFwibnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcXFwiZW1wdHlcXFwiIHBhZ2UuXCIpIDogdm9pZCAwO1xuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzICYmIG1hdGNoZXMubWFwKG1hdGNoID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXSksXG4gICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gIH0pKSwgcGFyZW50TWF0Y2hlcywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpO1xuXG4gIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQgaW4gYSBuZXcgYExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcmAgaW4gb3JkZXIgZm9yIGB1c2VMb2NhdGlvbmBcbiAgLy8gdG8gdXNlIHRoZSBzY29wZWQgbG9jYXRpb24gaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbG9jYXRpb246IF9leHRlbmRzKHtcbiAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAga2V5OiBcImRlZmF1bHRcIlxuICAgICAgICB9LCBsb2NhdGlvbiksXG4gICAgICAgIG5hdmlnYXRpb25UeXBlOiBBY3Rpb24uUG9wXG4gICAgICB9XG4gICAgfSwgcmVuZGVyZWRNYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzO1xufVxuZnVuY3Rpb24gRGVmYXVsdEVycm9yQ29tcG9uZW50KCkge1xuICBsZXQgZXJyb3IgPSB1c2VSb3V0ZUVycm9yKCk7XG4gIGxldCBtZXNzYWdlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzICsgXCIgXCIgKyBlcnJvci5zdGF0dXNUZXh0IDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgbGV0IHByZVN0eWxlcyA9IHtcbiAgICBwYWRkaW5nOiBcIjAuNXJlbVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gIH07XG4gIGxldCBjb2RlU3R5bGVzID0ge1xuICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gIH07XG4gIGxldCBkZXZJbmZvID0gbnVsbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsIGVycm9yKTtcbiAgICBkZXZJbmZvID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdUQ4M0RcXHVEQ0JGIEhleSBkZXZlbG9wZXIgXFx1RDgzRFxcdURDNEJcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIllvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycyBieSBwcm92aWRpbmcgeW91ciBvd24gXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiRXJyb3JCb3VuZGFyeVwiKSwgXCIgb3JcIiwgXCIgXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgIH1cbiAgfSwgbWVzc2FnZSksIHN0YWNrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHN0eWxlOiBwcmVTdHlsZXNcbiAgfSwgc3RhY2spIDogbnVsbCwgZGV2SW5mbyk7XG59XG5jb25zdCBkZWZhdWx0RXJyb3JFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbmNsYXNzIFJlbmRlckVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiwgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZSBjb250aW51ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3Igd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXG4gICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciAhPT0gdW5kZWZpbmVkID8gcHJvcHMuZXJyb3IgOiBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgIT09IHVuZGVmaW5lZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY29tcG9uZW50XG4gICAgfSkpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZShfcmVmKSB7XG4gIGxldCB7XG4gICAgcm91dGVDb250ZXh0LFxuICAgIG1hdGNoLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcblxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICBpZiAoZGF0YVJvdXRlckNvbnRleHQgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiYgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJvdXRlQ29udGV4dFxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTI7XG4gIGlmIChwYXJlbnRNYXRjaGVzID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRNYXRjaGVzID0gW107XG4gIH1cbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGF0YVJvdXRlclN0YXRlID0gbnVsbDtcbiAgfVxuICBpZiAoZnV0dXJlID09PSB2b2lkIDApIHtcbiAgICBmdXR1cmUgPSBudWxsO1xuICB9XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTtcbiAgICBpZiAoKF9kYXRhUm91dGVyU3RhdGUgPSBkYXRhUm91dGVyU3RhdGUpICE9IG51bGwgJiYgX2RhdGFSb3V0ZXJTdGF0ZS5lcnJvcnMpIHtcbiAgICAgIC8vIERvbid0IGJhaWwgaWYgd2UgaGF2ZSBkYXRhIHJvdXRlciBlcnJvcnMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGluIHRoZVxuICAgICAgLy8gYm91bmRhcnkuICBVc2UgdGhlIHByZS1tYXRjaGVkIChvciBzaGltbWVkKSBtYXRjaGVzXG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcblxuICAvLyBJZiB3ZSBoYXZlIGRhdGEgZXJyb3JzLCB0cmltIG1hdGNoZXMgdG8gdGhlIGhpZ2hlc3QgZXJyb3IgYm91bmRhcnlcbiAgbGV0IGVycm9ycyA9IChfZGF0YVJvdXRlclN0YXRlMiA9IGRhdGFSb3V0ZXJTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUm91dGVyU3RhdGUyLmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCAmJiAoZXJyb3JzID09IG51bGwgPyB2b2lkIDAgOiBlcnJvcnNbbS5yb3V0ZS5pZF0pICE9PSB1bmRlZmluZWQpO1xuICAgICEoZXJyb3JJbmRleCA+PSAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogXCIgKyBPYmplY3Qua2V5cyhlcnJvcnMpLmpvaW4oXCIsXCIpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSkpO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgaW4gYSBwYXJ0aWFsIGh5ZHJhdGlvbiBtb2RlLCBkZXRlY3QgaWYgd2UgbmVlZCB0byByZW5kZXIgZG93biB0b1xuICAvLyBhIGdpdmVuIEh5ZHJhdGVGYWxsYmFjayB3aGlsZSB3ZSBsb2FkIHRoZSByZXN0IG9mIHRoZSBoeWRyYXRpb24gZGF0YVxuICBsZXQgcmVuZGVyRmFsbGJhY2sgPSBmYWxzZTtcbiAgbGV0IGZhbGxiYWNrSW5kZXggPSAtMTtcbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSAmJiBmdXR1cmUgJiYgZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1hdGNoID0gcmVuZGVyZWRNYXRjaGVzW2ldO1xuICAgICAgLy8gVHJhY2sgdGhlIGRlZXBlc3QgZmFsbGJhY2sgdXAgdW50aWwgdGhlIGZpcnN0IHJvdXRlIHdpdGhvdXQgZGF0YVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLkh5ZHJhdGVGYWxsYmFjayB8fCBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIGZhbGxiYWNrSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzVG9SdW5Mb2FkZXIgPSBtYXRjaC5yb3V0ZS5sb2FkZXIgJiYgbG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCAmJiAoIWVycm9ycyB8fCBlcnJvcnNbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWF0Y2gucm91dGUubGF6eSB8fCBuZWVkc1RvUnVuTG9hZGVyKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGZpcnN0IHJvdXRlIHRoYXQncyBub3QgcmVhZHkgdG8gcmVuZGVyICh3YWl0aW5nIG9uXG4gICAgICAgICAgLy8gbGF6eSwgb3IgaGFzIGEgbG9hZGVyIHRoYXQgaGFzbid0IHJ1biB5ZXQpLiAgRmxhZyB0aGF0IHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyByZW5kZXIgYSBmYWxsYmFjayBhbmQgcmVuZGVyIHVwIHVudGlsIHRoZSBhcHByb3ByaWF0ZSBmYWxsYmFja1xuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgZmFsbGJhY2tJbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSBbcmVuZGVyZWRNYXRjaGVzWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAvLyBPbmx5IGRhdGEgcm91dGVycyBoYW5kbGUgZXJyb3JzL2ZhbGxiYWNrc1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gZmFsc2U7XG4gICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XG4gICAgbGV0IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIGVycm9yID0gZXJyb3JzICYmIG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgICAgaWYgKHJlbmRlckZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHdhcm5pbmdPbmNlKFwicm91dGUtZmFsbGJhY2tcIiwgZmFsc2UsIFwiTm8gYEh5ZHJhdGVGYWxsYmFja2AgZWxlbWVudCBwcm92aWRlZCB0byByZW5kZXIgZHVyaW5nIGluaXRpYWwgaHlkcmF0aW9uXCIpO1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hdGNoZXMgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4ge1xuICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZXJyb3JFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2spIHtcbiAgICAgICAgY2hpbGRyZW4gPSBoeWRyYXRlRmFsbGJhY2tFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5Db21wb25lbnQpIHtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIGRlLW9wdGltaXplZCBwYXRoIHNpbmNlIFJlYWN0IHdvbid0IHJlLXVzZSB0aGVcbiAgICAgICAgLy8gUmVhY3RFbGVtZW50IHNpbmNlIGl0J3MgaWRlbnRpdHkgY2hhbmdlcyB3aXRoIGVhY2ggbmV3XG4gICAgICAgIC8vIFJlYWN0LmNyZWF0ZUVsZW1lbnQgY2FsbC4gIFdlIGtlZXAgdGhpcyBzbyBmb2xrcyBjYW4gdXNlXG4gICAgICAgIC8vIGA8Um91dGUgQ29tcG9uZW50PXsuLi59PmAgaW4gYDxSb3V0ZXM+YCBidXQgZ2VuZXJhbGx5IGBDb21wb25lbnRgXG4gICAgICAgIC8vIHVzYWdlIGlzIG9ubHkgYWR2aXNlZCBpbiBgUm91dGVyUHJvdmlkZXJgIHdoZW4gd2UgY2FuIGNvbnZlcnQgaXQgdG9cbiAgICAgICAgLy8gYGVsZW1lbnRgIGFoZWFkIG9mIHRpbWUuXG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQobWF0Y2gucm91dGUuQ29tcG9uZW50LCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuZWxlbWVudCkge1xuICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IG91dGxldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW5kZXJlZFJvdXRlLCB7XG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgaXNEYXRhUm91dGU6IGRhdGFSb3V0ZXJTdGF0ZSAhPSBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBPbmx5IHdyYXAgaW4gYW4gZXJyb3IgYm91bmRhcnkgd2l0aGluIGRhdGEgcm91dGVyIHVzYWdlcyB3aGVuIHdlIGhhdmUgYW5cbiAgICAvLyBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudCBvbiB0aGlzIHJvdXRlLiAgT3RoZXJ3aXNlIGxldCBpdCBidWJibGUgdXAgdG9cbiAgICAvLyBhbiBhbmNlc3RvciBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudFxuICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbmRlckVycm9yQm91bmRhcnksIHtcbiAgICAgIGxvY2F0aW9uOiBkYXRhUm91dGVyU3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgICBjb21wb25lbnQ6IGVycm9yRWxlbWVudCxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgIG91dGxldDogbnVsbCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEYXRhUm91dGU6IHRydWVcbiAgICAgIH1cbiAgICB9KSA6IGdldENoaWxkcmVuKCk7XG4gIH0sIG51bGwpO1xufVxudmFyIERhdGFSb3V0ZXJIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xuICBEYXRhUm91dGVySG9va1tcIlVzZUJsb2NrZXJcIl0gPSBcInVzZUJsb2NrZXJcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgcmV0dXJuIERhdGFSb3V0ZXJIb29rO1xufShEYXRhUm91dGVySG9vayB8fCB7fSk7XG52YXIgRGF0YVJvdXRlclN0YXRlSG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTG9hZGVyRGF0YVwiXSA9IFwidXNlTG9hZGVyRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQWN0aW9uRGF0YVwiXSA9IFwidXNlQWN0aW9uRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVFcnJvclwiXSA9IFwidXNlUm91dGVFcnJvclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGlvblwiXSA9IFwidXNlTmF2aWdhdGlvblwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVMb2FkZXJEYXRhXCJdID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU1hdGNoZXNcIl0gPSBcInVzZU1hdGNoZXNcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJldmFsaWRhdG9yXCJdID0gXCJ1c2VSZXZhbGlkYXRvclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUlkXCJdID0gXCJ1c2VSb3V0ZUlkXCI7XG4gIHJldHVybiBEYXRhUm91dGVyU3RhdGVIb29rO1xufShEYXRhUm91dGVyU3RhdGVIb29rIHx8IHt9KTtcbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICFzdGF0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vLyBJbnRlcm5hbCB2ZXJzaW9uIHdpdGggaG9va05hbWUtYXdhcmUgZGVidWdnaW5nXG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICBsZXQgdGhpc1JvdXRlID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAhdGhpc1JvdXRlLnJvdXRlLmlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgaG9va05hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgbmVhcmVzdCBjb250ZXh0dWFsIHJvdXRlXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlSWQoKSB7XG4gIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlSWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cbiAqIG5vIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGlvbik7XG4gIHJldHVybiBzdGF0ZS5uYXZpZ2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXZhbGlkYXRlIGZ1bmN0aW9uIGZvciBtYW51YWxseSB0cmlnZ2VyaW5nIHJldmFsaWRhdGlvbiwgYXMgd2VsbFxuICogYXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYW55IG1hbnVhbCByZXZhbGlkYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZXZhbGlkYXRlOiBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSxcbiAgICBzdGF0ZTogc3RhdGUucmV2YWxpZGF0aW9uXG4gIH0pLCBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLCB1c2VmdWwgZm9yIGFjY2Vzc2luZyBsb2FkZXJEYXRhIGZvclxuICogcGFyZW50L2NoaWxkIHJvdXRlcyBvciB0aGUgcm91dGUgXCJoYW5kbGVcIiBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgbG9hZGVyRGF0YVxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTWF0Y2hlcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG0gPT4gVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIGxvYWRlckRhdGEpKSwgW21hdGNoZXMsIGxvYWRlckRhdGFdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2FkZXIgZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIGlmIChzdGF0ZS5lcnJvcnMgJiYgc3RhdGUuZXJyb3JzW3JvdXRlSWRdICE9IG51bGwpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYW4gZXJyb3JFbGVtZW50IChyb3V0ZUlkOiBcIiArIHJvdXRlSWQgKyBcIilcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2FkZXJEYXRhIGZvciB0aGUgZ2l2ZW4gcm91dGVJZFxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUxvYWRlckRhdGEpO1xuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3Rpb24gZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGVycm9yLCB3aGljaCBjb3VsZCBiZSBhIGxvYWRlci9hY3Rpb25cbiAqIGVycm9yIG9yIGEgcmVuZGVyIGVycm9yLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSB5b3VyXG4gKiBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudCB0byBkaXNwbGF5IGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gIHZhciBfc3RhdGUkZXJyb3JzO1xuICBsZXQgZXJyb3IgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcblxuICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAvLyBvZiBSZW5kZXJFcnJvckJvdW5kYXJ5XG4gIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGVycm9ycyBmcm9tIG91ciBkYXRhIHJvdXRlciBzdGF0ZVxuICByZXR1cm4gKF9zdGF0ZSRlcnJvcnMgPSBzdGF0ZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZXJyb3JzW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGhhcHB5LXBhdGggZGF0YSBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZUFzeW5jRXJyb3IoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZXJyb3I7XG59XG5sZXQgYmxvY2tlcklkID0gMDtcblxuLyoqXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXG4gKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAqIHVzaW5nIGhhbGYtZmlsbGVkIGZvcm0gZGF0YS4gIFRoaXMgZG9lcyBub3QgaGFuZGxlIGhhcmQtcmVsb2FkcyBvclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxuICovXG5mdW5jdGlvbiB1c2VCbG9ja2VyKHNob3VsZEJsb2NrKSB7XG4gIGxldCB7XG4gICAgcm91dGVyLFxuICAgIGJhc2VuYW1lXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VCbG9ja2VyKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdC51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGFyZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBzaG91bGRCbG9jayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gISFzaG91bGRCbG9jaztcbiAgICB9XG4gICAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKGFyZyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhleSBwcm92aWRlZCB1cyBhIGZ1bmN0aW9uIGFuZCB3ZSd2ZSBnb3QgYW4gYWN0aXZlIGJhc2VuYW1lLCBzdHJpcFxuICAgIC8vIGl0IGZyb20gdGhlIGxvY2F0aW9ucyB3ZSBleHBvc2UgdG8gdGhlIHVzZXIgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIG9mXG4gICAgLy8gdXNlTG9jYXRpb25cbiAgICBsZXQge1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0gPSBhcmc7XG4gICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pLFxuICAgICAgbmV4dExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgbmV4dExvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSksXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSk7XG4gIH0sIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdKTtcblxuICAvLyBUaGlzIGVmZmVjdCBpcyBpbiBjaGFyZ2Ugb2YgYmxvY2tlciBrZXkgYXNzaWdubWVudCBhbmQgZGVsZXRpb24gKHdoaWNoIGlzXG4gIC8vIHRpZ2h0bHkgY291cGxlZCB0byB0aGUga2V5KVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIC8vIFRoaXMgZWZmZWN0IGhhbmRsZXMgYXNzaWduaW5nIHRoZSBibG9ja2VyRnVuY3Rpb24uICBUaGlzIGlzIHRvIGhhbmRsZVxuICAvLyB1bnN0YWJsZSBibG9ja2VyIGZ1bmN0aW9uIGlkZW50aXRpZXMsIGFuZCBoYXBwZW5zIG9ubHkgYWZ0ZXIgdGhlIHByaW9yXG4gIC8vIGVmZmVjdCBzbyB3ZSBkb24ndCBnZXQgYW4gb3JwaGFuZWQgYmxvY2tlckZ1bmN0aW9uIGluIHRoZSByb3V0ZXIgd2l0aCBhXG4gIC8vIGtleSBvZiBcIlwiLiAgVW50aWwgdGhlbiB3ZSBqdXN0IGhhdmUgdGhlIElETEVfQkxPQ0tFUi5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuXG4gIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XG4gIC8vIGlzIG1lbW9pemVkIHNvIHRoaXMgZW5zdXJlcyB3ZSB1cGRhdGUgb24gYmxvY2tlciBzdGF0ZSB1cGRhdGVzXG4gIHJldHVybiBibG9ja2VyS2V5ICYmIHN0YXRlLmJsb2NrZXJzLmhhcyhibG9ja2VyS2V5KSA/IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KSA6IElETEVfQkxPQ0tFUjtcbn1cblxuLyoqXG4gKiBTdGFibGUgdmVyc2lvbiBvZiB1c2VOYXZpZ2F0ZSB0aGF0IGlzIHVzZWQgd2hlbiB3ZSBhcmUgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIGEgUm91dGVyUHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZykgOiB2b2lkIDA7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGhlcmUgc2luY2UgaWYgdGhpcyBoYXBwZW5zIG9uIGZpcnN0IHJlbmRlciB0aGUgbmF2aWdhdGVcbiAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgcm91dGVyIHN1YnNjcmliZXIgeWV0XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywgX2V4dGVuZHMoe1xuICAgICAgICBmcm9tUm91dGVJZDogaWRcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGlkXSk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbmNvbnN0IGFscmVhZHlXYXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgY29tcGxhaW5zIHRoYXQgYHN0YXJ0VHJhbnNpdGlvbmAgZG9lc24ndCBleGlzdCBpbiBgUmVhY3RgOlxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xuICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuKi9cbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xuXG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBmYWxsYmFja0VsZW1lbnQsXG4gICAgcm91dGVyLFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfVxuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcblxuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgLy8gcGljayB1cCBvbiBhbnkgcmVuZGVyLWRyaXZlbiByZWRpcmVjdHMvbmF2aWdhdGlvbnMgKHVzZUVmZmVjdC88TmF2aWdhdGU+KVxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsbGJhY2tFbGVtZW50ID09IG51bGwgfHwgIXJvdXRlci5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiwgXCJgPFJvdXRlclByb3ZpZGVyIGZhbGxiYWNrRWxlbWVudD5gIGlzIGRlcHJlY2F0ZWQgd2hlbiB1c2luZyBcIiArIFwiYHY3X3BhcnRpYWxIeWRyYXRpb25gLCB1c2UgYSBgSHlkcmF0ZUZhbGxiYWNrYCBjb21wb25lbnQgaW5zdGVhZFwiKSA6IHZvaWQgMDtcbiAgICAvLyBPbmx5IGxvZyB0aGlzIG9uY2Ugb24gaW5pdGlhbCBtb3VudFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiBuID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByb3V0ZXIsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogZmFsc2UsXG4gICAgYmFzZW5hbWVcbiAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcblxuICAvLyBUaGUgZnJhZ21lbnQgYW5kIHtudWxsfSBoZXJlIGFyZSBpbXBvcnRhbnQhICBXZSBuZWVkIHRoZW0gdG8ga2VlcCBSZWFjdCAxOCdzXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAvLyB1c2VJZCByZWxpZXMgb24gdGhlIGNvbXBvbmVudCB0cmVlIHN0cnVjdHVyZSB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGlkJ3NcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBmdXR1cmU6IHtcbiAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiByb3V0ZXIuZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoXG4gICAgfVxuICB9LCBzdGF0ZS5pbml0aWFsaXplZCB8fCByb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVzLCB7XG4gICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xufVxuZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMikge1xuICBsZXQge1xuICAgIHJvdXRlcyxcbiAgICBmdXR1cmUsXG4gICAgc3RhdGVcbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHVuZGVmaW5lZCwgc3RhdGUsIGZ1dHVyZSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9tZW1vcnktcm91dGVyXG4gKi9cbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcihfcmVmMykge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGluaXRpYWxFbnRyaWVzLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWYzO1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXG4gICAgZnV0dXJlOiBmdXR1cmVcbiAgfSk7XG59XG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRlKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgdG8sXG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICByZWxhdGl2ZVxuICB9ID0gX3JlZjQ7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsXG4gIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwiPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGZ1dHVyZSxcbiAgICBzdGF0aWM6IGlzU3RhdGljXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoIWlzU3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcblxuICAvLyBSZXNvbHZlIHRoZSBwYXRoIG91dHNpZGUgb2YgdGhlIGVmZmVjdCBzbyB0aGF0IHdoZW4gZWZmZWN0cyBydW4gdHdpY2UgaW5cbiAgLy8gU3RyaWN0TW9kZSB0aGV5IG5hdmlnYXRlIHRvIHRoZSBzYW1lIHBsYWNlXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvLCBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpO1xuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IG5hdmlnYXRlKEpTT04ucGFyc2UoanNvblBhdGgpLCB7XG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICByZWxhdGl2ZVxuICB9KSwgW25hdmlnYXRlLCBqc29uUGF0aCwgcmVsYXRpdmUsIHJlcGxhY2UsIHN0YXRlXSk7XG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvb3V0bGV0XG4gKi9cbmZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAqL1xuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBcIiArIFwibmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIGA8Um91dGVyPmAgZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSBgPEJyb3dzZXJSb3V0ZXI+YFxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgYDxTdGF0aWNSb3V0ZXI+YCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxuICovXG5mdW5jdGlvbiBSb3V0ZXIoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgY2hpbGRyZW4gPSBudWxsLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gICAgbmF2aWdhdGlvblR5cGUgPSBBY3Rpb24uUG9wLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZSxcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWY1O1xuICAhIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LlwiICsgXCIgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gUHJlc2VydmUgdHJhaWxpbmcgc2xhc2hlcyBvbiBiYXNlbmFtZSwgc28gd2UgY2FuIGxldCB0aGUgdXNlciBjb250cm9sXG4gIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxuICBsZXQgYmFzZW5hbWUgPSBiYXNlbmFtZVByb3AucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBzdGF0aWNQcm9wLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe1xuICAgICAgdjdfcmVsYXRpdmVTcGxhdFBhdGg6IGZhbHNlXG4gICAgfSwgZnV0dXJlKVxuICB9KSwgW2Jhc2VuYW1lLCBmdXR1cmUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF0pO1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgaWYgKHRyYWlsaW5nUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgICAgc2VhcmNoLFxuICAgICAgICBoYXNoLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvblR5cGVcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXksIG5hdmlnYXRpb25UeXBlXSk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLCBcIjxSb3V0ZXIgYmFzZW5hbWU9XFxcIlwiICsgYmFzZW5hbWUgKyBcIlxcXCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgXCIgKyAoXCJcXFwiXCIgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggKyBcIlxcXCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBcIikgKyBcImJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLlwiKSA6IHZvaWQgMDtcbiAgaWYgKGxvY2F0aW9uQ29udGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG5hdmlnYXRpb25Db250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICB2YWx1ZTogbG9jYXRpb25Db250ZXh0XG4gIH0pKTtcbn1cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgYDxSb3V0ZT5gIGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVzXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcyhfcmVmNikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uXG4gIH0gPSBfcmVmNjtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG4vKipcbiAqIENvbXBvbmVudCB0byB1c2UgZm9yIHJlbmRlcmluZyBsYXppbHkgbG9hZGVkIGRhdGEgZnJvbSByZXR1cm5pbmcgZGVmZXIoKVxuICogaW4gYSBsb2FkZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gQXdhaXQoX3JlZjcpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlcnJvckVsZW1lbnQsXG4gICAgcmVzb2x2ZVxuICB9ID0gX3JlZjc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdEVycm9yQm91bmRhcnksIHtcbiAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgIGVycm9yRWxlbWVudDogZXJyb3JFbGVtZW50XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlc29sdmVBd2FpdCwgbnVsbCwgY2hpbGRyZW4pKTtcbn1cbnZhciBBd2FpdFJlbmRlclN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQXdhaXRSZW5kZXJTdGF0dXMpIHtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJwZW5kaW5nXCJdID0gMF0gPSBcInBlbmRpbmdcIjtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJzdWNjZXNzXCJdID0gMV0gPSBcInN1Y2Nlc3NcIjtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJlcnJvclwiXSA9IDJdID0gXCJlcnJvclwiO1xuICByZXR1cm4gQXdhaXRSZW5kZXJTdGF0dXM7XG59KEF3YWl0UmVuZGVyU3RhdHVzIHx8IHt9KTtcbmNvbnN0IG5ldmVyU2V0dGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5jbGFzcyBBd2FpdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiPEF3YWl0PiBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsIGVycm9yLCBlcnJvckluZm8pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBlcnJvckVsZW1lbnQsXG4gICAgICByZXNvbHZlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgIGxldCBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgLy8gRGlkbid0IGdldCBhIHByb21pc2UgLSBwcm92aWRlIGFzIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIC8vIENhdWdodCBhIHJlbmRlciBlcnJvciwgcHJvdmlkZSBpdCBhcyBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHt9KTsgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbiB3YXJuaW5nc1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZW5kZXJFcnJvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlLl90cmFja2VkKSB7XG4gICAgICAvLyBBbHJlYWR5IHRyYWNrZWQgcHJvbWlzZSAtIGNoZWNrIGNvbnRlbnRzXG4gICAgICBwcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHN0YXR1cyA9IHByb21pc2UuX2Vycm9yICE9PSB1bmRlZmluZWQgPyBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciA6IHByb21pc2UuX2RhdGEgIT09IHVuZGVmaW5lZCA/IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MgOiBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSYXcgKHVudHJhY2tlZCkgcHJvbWlzZSAtIHRyYWNrIGl0XG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5wZW5kaW5nO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihkYXRhID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9kYXRhXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBkYXRhXG4gICAgICB9KSwgZXJyb3IgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiBwcm9taXNlLl9lcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yKSB7XG4gICAgICAvLyBGcmVlemUgdGhlIFVJIGJ5IHRocm93aW5nIGEgbmV2ZXIgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgdGhyb3cgbmV2ZXJTZXR0bGVkUHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgLy8gTm8gZXJyb3JFbGVtZW50LCB0aHJvdyB0byB0aGUgbmVhcmVzdCByb3V0ZS1sZXZlbCBlcnJvciBib3VuZGFyeVxuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yKSB7XG4gICAgICAvLyBSZW5kZXIgdmlhIG91ciBlcnJvckVsZW1lbnRcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb21pc2UsXG4gICAgICAgIGNoaWxkcmVuOiBlcnJvckVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzKSB7XG4gICAgICAvLyBSZW5kZXIgY2hpbGRyZW4gd2l0aCByZXNvbHZlZCB2YWx1ZVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvbWlzZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUaHJvdyB0byB0aGUgc3VzcGVuc2UgYm91bmRhcnlcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEluZGlyZWN0aW9uIHRvIGxldmVyYWdlIHVzZUFzeW5jVmFsdWUgZm9yIGEgcmVuZGVyLXByb3AgQVBJIG9uIGA8QXdhaXQ+YFxuICovXG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoX3JlZjgpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjg7XG4gIGxldCBkYXRhID0gdXNlQXN5bmNWYWx1ZSgpO1xuICBsZXQgdG9SZW5kZXIgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGRhdGEpIDogY2hpbGRyZW47XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdG9SZW5kZXIpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9jcmVhdGUtcm91dGVzLWZyb20tY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRQYXRoKSB7XG4gIGlmIChwYXJlbnRQYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRQYXRoID0gW107XG4gIH1cbiAgbGV0IHJvdXRlcyA9IFtdO1xuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoISAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgcm91dGVzLnB1c2guYXBwbHkocm91dGVzLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIShlbGVtZW50LnR5cGUgPT09IFJvdXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiW1wiICsgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZSkgKyBcIl0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJBbiBpbmRleCByb3V0ZSBjYW5ub3QgaGF2ZSBjaGlsZCByb3V0ZXMuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbGV0IHJvdXRlID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCAhPSBudWxsLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICAgIGxhenk6IGVsZW1lbnQucHJvcHMubGF6eVxuICAgIH07XG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKTtcbiAgICB9XG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiByZW5kZXJNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gIGxldCB1cGRhdGVzID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgQ29tcG9uZW50YCBhbmQgYGVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBIeWRyYXRlRmFsbGJhY2tgIGFuZCBgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmVycm9yRWxlbWVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXg6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEluZGV4XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdW5zdGFibGVfZGF0YVN0cmF0ZWd5OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVuc3RhYmxlX2RhdGFTdHJhdGVneVxuICB9KS5pbml0aWFsaXplKCk7XG59XG5leHBvcnQgeyBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgT3V0bGV0LCBSb3V0ZSwgUm91dGVyLCBSb3V0ZXJQcm92aWRlciwgUm91dGVzLCBEYXRhUm91dGVyQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIExvY2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBOYXZpZ2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LCBtYXBSb3V0ZVByb3BlcnRpZXMgYXMgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcywgdXNlUm91dGVJZCBhcyBVTlNBRkVfdXNlUm91dGVJZCwgdXNlUm91dGVzSW1wbCBhcyBVTlNBRkVfdXNlUm91dGVzSW1wbCwgY3JlYXRlTWVtb3J5Um91dGVyLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBhcyBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsIHJlbmRlck1hdGNoZXMsIHVzZUFjdGlvbkRhdGEsIHVzZUFzeW5jRXJyb3IsIHVzZUFzeW5jVmFsdWUsIHVzZUJsb2NrZXIsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvbiwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJldmFsaWRhdG9yLCB1c2VSb3V0ZUVycm9yLCB1c2VSb3V0ZUxvYWRlckRhdGEsIHVzZVJvdXRlcyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/dist/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var ReactVersion = '18.3.1';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n    var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n    var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n    var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    /**\n     * Keeps track of the current dispatcher.\n     */\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          stack += impl() || '';\n        }\n        return stack;\n      };\n    }\n\n    // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    }\n\n    // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          printWarning('warn', format, args);\n        }\n      }\n    }\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n          printWarning('error', format, args);\n        }\n      }\n    }\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    var didWarnStateUpdateForUnmountedComponent = {};\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function (publicInstance) {\n        return false;\n      },\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function (publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function (methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function () {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n      if (displayName) {\n        return displayName;\n      }\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n            if (outerName !== null) {\n              return outerName;\n            }\n            return getComponentNameFromType(type.type) || 'Memo';\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n      return null;\n    }\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function () {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function () {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n    var ReactElement = function (type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (typeof element === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n      return index.toString(36);\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n      var invokeCallback = false;\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + (\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n          array.push(mappedChild);\n        }\n        return 1;\n      }\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n      return subtreeCount;\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n      return children;\n    }\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function () {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n              return context.Provider;\n            },\n            set: function (_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function () {\n              return context._currentValue;\n            },\n            set: function (_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function () {\n              return context._currentValue2;\n            },\n            set: function (_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function () {\n              return context._threadCount;\n            },\n            set: function (_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function () {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function () {\n              return context.displayName;\n            },\n            set: function (displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject.default;\n      } else {\n        throw payload._result;\n      }\n    }\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function () {\n              return defaultProps;\n            },\n            set: function (newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function () {\n              return propTypes;\n            },\n            set: function (newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n    }\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n      if (typeof type === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function () {\n            return ownName;\n          },\n          set: function (name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n    function disabledLog() {}\n    disabledLog.__reactDisabledLog = true;\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        disabledDepth++;\n      }\n    }\n    function reenableLogs() {\n      {\n        disabledDepth--;\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n        return '\\n' + prefix + name;\n      }\n    }\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n      {\n        var frame = componentFrameCache.get(fn);\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n      if (typeof type === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n      return '';\n    }\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n              setCurrentlyValidatingElement(null);\n            }\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n    var ownerHasKeyUseWarning = {};\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n    function validateChildKeys(node, parentType) {\n      if (typeof node !== 'object') {\n        return;\n      }\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n        var propTypes;\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n        var typeString;\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = typeof type;\n        }\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n      return element;\n    }\n    var didWarnAboutDeprecatedCreateFactory = false;\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function () {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function (callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n      return enqueueTaskImpl(task);\n    }\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function (resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n            var _thenable = {\n              then: function (resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function (resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n    var isFlushing = false;\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.act = act;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBLHlDQUF5Qzs7QUFFekMsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGFBQWE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGVBQWU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsU0FBUyxHQUFHOztBQUVaLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtOQUFrTjtBQUNsTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0Isa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQixXQUFXO0FBQzVCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFdBQVc7QUFDNUIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFdBQVc7QUFDNUIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QiwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLGVBQWU7QUFDOUIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCLDJCQUEyQixrQkFBa0I7O0FBRTdDO0FBQ0EsNkJBQTZCOztBQUU3QixnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUlBQXlJLHlDQUF5QztBQUNsTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCOztBQUVBO0FBQ0E7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LElBQUksMERBQTBEO0FBQzlELElBQUksV0FBVztBQUNmLElBQUksb0JBQW9CO0FBQ3hCLElBQUkscUJBQXFCO0FBQ3pCLElBQUkscUJBQXFCO0FBQ3pCLElBQUkscUJBQXFCO0FBQ3pCLElBQUksaUJBQWlCO0FBQ3JCLElBQUksa0JBQWtCO0FBQ3RCLElBQUksc0JBQXNCO0FBQzFCLElBQUksWUFBWTtBQUNoQixJQUFJLFlBQVk7QUFDaEIsSUFBSSx1QkFBdUI7QUFDM0IsSUFBSSxvQkFBb0I7QUFDeEIsSUFBSSxtQkFBbUI7QUFDdkIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSxpQkFBaUI7QUFDckIsSUFBSSxhQUFhO0FBQ2pCLElBQUksMkJBQTJCO0FBQy9CLElBQUksMEJBQTBCO0FBQzlCLElBQUksdUJBQXVCO0FBQzNCLElBQUksZUFBZTtBQUNuQixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLGNBQWM7QUFDbEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanM/ODdmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xuICAgIH1cbiAgICB2YXIgUmVhY3RWZXJzaW9uID0gJzE4LjMuMSc7XG5cbiAgICAvLyBBVFRFTlRJT05cbiAgICAvLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4gICAgLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuICAgIC8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxuICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gICAgdmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG4gICAgdmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICAgIHZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgICB2YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gICAgdmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICAgIHZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gICAgdmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICAgIHZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICAgIHZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG4gICAgdmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbiAgICB2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgICB2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgICAgIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gICAgICovXG4gICAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgICAgICovXG4gICAgICBjdXJyZW50OiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICAgICAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAgICAgKi9cbiAgICB2YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gICAgICB0cmFuc2l0aW9uOiBudWxsXG4gICAgfTtcbiAgICB2YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSB7XG4gICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS5cbiAgICAgIGlzQmF0Y2hpbmdMZWdhY3k6IGZhbHNlLFxuICAgICAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6IGZhbHNlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICAgICAqXG4gICAgICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICAgICAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICB2YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgICAgICovXG4gICAgICBjdXJyZW50OiBudWxsXG4gICAgfTtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuICAgIHZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAgICAgIHtcbiAgICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICB7XG4gICAgICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICAgICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuICAgICAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBpZiAoaW1wbCkge1xuICAgICAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuICAgIHZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbiAgICB2YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxuICAgIHZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4gICAgLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuICAgIC8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG4gICAgdmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxuICAgIHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gICAgICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXJcbiAgICB9O1xuICAgIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbiAgICB9XG5cbiAgICAvLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuICAgIC8vXG4gICAgLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbiAgICAvLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbiAgICBmdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICAgIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAgICAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gICAgICB7XG4gICAgICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICAgICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cbiAgICAgICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgICAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgICAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAgICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgICAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gICAgICovXG5cbiAgICB2YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQGZpbmFsXG4gICAgICAgKi9cbiAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICAgICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICAgICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICAgICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqL1xuICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICAgICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgICAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqL1xuICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAgICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICAgICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgICAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbiAgICB2YXIgZW1wdHlPYmplY3QgPSB7fTtcbiAgICB7XG4gICAgICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgICAgIC8vIHJlbmRlcmVyLlxuXG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICAgICAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gICAgICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gICAgICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAgICAgKiBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAgICAgKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAgICAgKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICAgICAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gICAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAgICAgKiBhc3NpZ25lZCB0byB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAgICAgKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAgICAgKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICAgICAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICAgICAqL1xuXG4gICAge1xuICAgICAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgICAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gICAgICB9O1xuICAgICAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgICAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbiAgICBDb21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgdmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuICAgIHB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuICAgIGFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbiAgICBwdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuICAgIC8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICAgICAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgfTtcbiAgICAgIHtcbiAgICAgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWZPYmplY3Q7XG4gICAgfVxuICAgIHZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gICAgICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAgICAgKlxuICAgICAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAgICAgKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gICAgICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAgICAgKi9cbiAgICAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuICAgIGZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gICAgICB7XG4gICAgICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICAgICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cbiAgICBmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICAgICAge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgICAgIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gICAgICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gICAgICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgICAgIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gICAgICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgICAgIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAgICAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gICAgICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAgICAgLy9cbiAgICAgIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgICAgIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgICAgIC8vXG4gICAgICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAgICAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gICAgICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gICAgICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAgICAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAgICAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAgICAgLy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG4gICAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG4gICAgfSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuICAgIGZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0JztcbiAgICB9IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1BvcnRhbCc7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICAgICAga2V5OiB0cnVlLFxuICAgICAgcmVmOiB0cnVlLFxuICAgICAgX19zZWxmOiB0cnVlLFxuICAgICAgX19zb3VyY2U6IHRydWVcbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG4gICAge1xuICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAgICAgKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICAgICAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICAgICAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHR5cGVcbiAgICAgKiBAcGFyYW0geyp9IHByb3BzXG4gICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICAgICAqIEBwYXJhbSB7Kn0gb3duZXJcbiAgICAgKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAgICAgKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gICAgICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAgICAgKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gICAgICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICAgICAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG5cbiAgICB2YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAge1xuICAgICAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAgICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAgICAgLy8gaWdub3JlcyBpdC5cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICB2YXIga2V5ID0gbnVsbDtcbiAgICAgIHZhciByZWYgPSBudWxsO1xuICAgICAgdmFyIHNlbGYgPSBudWxsO1xuICAgICAgdmFyIHNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAgICAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cbiAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG4gICAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAge1xuICAgICAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgICAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gICAgICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgICAgIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgICAgIC8vIHRydWUgb3duZXIuXG5cbiAgICAgIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICAgICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAgICAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cbiAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gICAgICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAgICAgKiBAZmluYWxcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgICB9XG4gICAgdmFyIFNFUEFSQVRPUiA9ICcuJztcbiAgICB2YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuICAgIC8qKlxuICAgICAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gICAgICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgICAgICc9JzogJz0wJyxcbiAgICAgICAgJzonOiAnPTInXG4gICAgICB9O1xuICAgICAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICAgICAqIHBhdHRlcm4uXG4gICAgICovXG5cbiAgICB2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICAgIHZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG4gICAgZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oZWxlbWVudC5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gICAgICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cbiAgICAgIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuICAgICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG4gICAgICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgICAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgICAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcbiAgICAgICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFRoZSBgaWZgIHN0YXRlbWVudCBoZXJlIHByZXZlbnRzIGF1dG8tZGlzYWJsaW5nIG9mIHRoZSBzYWZlXG4gICAgICAgICAgICAgIC8vIGNvZXJjaW9uIEVTTGludCBydWxlLCBzbyB3ZSBtdXN0IG1hbnVhbGx5IGRpc2FibGUgaXQgYmVsb3cuXG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgICAgICBpZiAobWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1hcHBlZENoaWxkLmtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICAgICAgZXNjYXBlZFByZWZpeCArIChcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgP1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIHZhciBuZXh0TmFtZTtcbiAgICAgIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gICAgICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICAgICAqXG4gICAgICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiBsZWFmIGNoaWxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICAgICAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqIGxlYWYgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gICAgICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICAgICAgfSwgZm9yRWFjaENvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICAgICAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9KSB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gICAgICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gICAgICpcbiAgICAgKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gICAgICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAgICAgKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICAgICAqIHN0cnVjdHVyZS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IFNlY29uZCBhcmd1bWVudCB1c2VkIHRvIGJlIGFuIG9wdGlvbmFsIGBjYWxjdWxhdGVDaGFuZ2VkQml0c2BcbiAgICAgIC8vIGZ1bmN0aW9uLiBXYXJuIHRvIHJlc2VydmUgZm9yIGZ1dHVyZSB1c2U/XG4gICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAgICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAgICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgICAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICAgICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgICAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAgICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgLy8gQWRkIHRoZXNlIHRvIHVzZSBzYW1lIGhpZGRlbiBjbGFzcyBpbiBWTSBhcyBTZXJ2ZXJDb250ZXh0XG4gICAgICAgIF9kZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgICAgIF9nbG9iYWxOYW1lOiBudWxsXG4gICAgICB9O1xuICAgICAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgICB9O1xuICAgICAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gICAgICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgICAgIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuICAgICAge1xuICAgICAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgICAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICAgICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBDb25zdW1lcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgICAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHZhciBVbmluaXRpYWxpemVkID0gLTE7XG4gICAgdmFyIFBlbmRpbmcgPSAwO1xuICAgIHZhciBSZXNvbHZlZCA9IDE7XG4gICAgdmFyIFJlamVjdGVkID0gMjtcbiAgICBmdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICAvLyBUaGlzIG1pZ2h0IHRocm93IGVpdGhlciBiZWNhdXNlIGl0J3MgbWlzc2luZyBvciB0aHJvd3MuIElmIHNvLCB3ZSB0cmVhdCBpdFxuICAgICAgICAvLyBhcyBzdGlsbCB1bmluaXRpYWxpemVkIGFuZCB0cnkgYWdhaW4gbmV4dCB0aW1lLiBXaGljaCBpcyB0aGUgc2FtZSBhcyB3aGF0XG4gICAgICAgIC8vIGhhcHBlbnMgaWYgdGhlIGN0b3Igb3IgYW55IHdyYXBwZXJzIHByb2Nlc3NpbmcgdGhlIGN0b3IgdGhyb3dzLiBUaGlzIG1pZ2h0XG4gICAgICAgIC8vIGVuZCB1cCBmaXhpbmcgaXQgaWYgdGhlIHJlc29sdXRpb24gd2FzIGEgY29uY3VycmVuY3kgYnVnLlxuXG4gICAgICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcgfHwgcGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAgIC8vIEluIGNhc2UsIHdlJ3JlIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIHRoZW4gd2UncmUgd2FpdGluZyBmb3IgdGhlIHRoZW5hYmxlXG4gICAgICAgICAgLy8gdG8gcmVzb2x2ZS4gU2V0IGl0IGFzIHBlbmRpbmcgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICAgICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgICAgICB2YXIgbW9kdWxlT2JqZWN0ID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKG1vZHVsZU9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArXG4gICAgICAgICAgICAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5cIiArICdEaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0PycsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoISgnZGVmYXVsdCcgaW4gbW9kdWxlT2JqZWN0KSkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgK1xuICAgICAgICAgICAgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgICAgICBfc3RhdHVzOiBVbmluaXRpYWxpemVkLFxuICAgICAgICBfcmVzdWx0OiBjdG9yXG4gICAgICB9O1xuICAgICAgdmFyIGxhenlUeXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICAgICAgfTtcbiAgICAgIHtcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgICAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgICAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuICAgICAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuICAgICAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXp5VHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgICAgIHJlbmRlcjogcmVuZGVyXG4gICAgICB9O1xuICAgICAge1xuICAgICAgICB2YXIgb3duTmFtZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cbiAgICAgICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG4gICAgICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAgICAgLy8gICBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7Li4ufSk7XG4gICAgICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgICAgICBpZiAoIXJlbmRlci5uYW1lICYmICFyZW5kZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlO1xuICAgIH1cbiAgICB2YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcbiAgICB7XG4gICAgICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgfHwgZW5hYmxlQ2FjaGVFbGVtZW50IHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgICAvLyB3aXRoLlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICAgICAge1xuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIHZhciBvd25OYW1lO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIHVzZWQgZWxzZXdoZXJlLlxuICAgICAgICAgICAgLy8gQnV0IGl0J3MgbmljZSBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB0byBpbmhlcml0IHRoZSBuYW1lLFxuICAgICAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgICAgIC8vIEFuIGFub255bW91cyBmdW5jdGlvbiBnZW5lcmFsbHkgc3VnZ2VzdHMgYSBwYXR0ZXJuIGxpa2U6XG4gICAgICAgICAgICAvLyAgIFJlYWN0Lm1lbW8oKHByb3BzKSA9PiB7Li4ufSk7XG4gICAgICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgICAgICBpZiAoIXR5cGUubmFtZSAmJiAhdHlwZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAge1xuICAgICAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZG9uJ3QgdGhyb3cgb3VyIG93biBlcnJvciBiZWNhdXNlIHRoaXMgaXMgaW4gYSBob3QgcGF0aC5cbiAgICAgIC8vIEFsc28gaGVscHMgZW5zdXJlIHRoaXMgaXMgaW5saW5lZC5cblxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG4gICAgICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAge1xuICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZVRyYW5zaXRpb24oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUlkKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4gICAgLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3RcbiAgICAvLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4gICAgLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG4gICAgdmFyIGRpc2FibGVkRGVwdGggPSAwO1xuICAgIHZhciBwcmV2TG9nO1xuICAgIHZhciBwcmV2SW5mbztcbiAgICB2YXIgcHJldldhcm47XG4gICAgdmFyIHByZXZFcnJvcjtcbiAgICB2YXIgcHJldkdyb3VwO1xuICAgIHZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG4gICAgdmFyIHByZXZHcm91cEVuZDtcbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIHtcbiAgICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbiAgICB2YXIgcHJlZml4O1xuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICAgICAge1xuICAgICAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuICAgICAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVlbnRyeSA9IGZhbHNlO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuICAgIHtcbiAgICAgIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvbnRyb2w7XG4gICAgICByZWVudHJ5ID0gdHJ1ZTtcbiAgICAgIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICB7XG4gICAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAgICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgICAgYy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVudHJ5ID0gZmFsc2U7XG4gICAgICAgIHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuICAgICAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgICAgIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICAgICAge1xuICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG4gICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gICAgICB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICAgICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG4gICAgICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcbiAgICB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICAgICAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgICAqIHVwZGF0ZXMuXG4gICAgICovXG5cbiAgICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAgICAgKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAgICAgKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAgICAgKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAgICAgKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAgICAgKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcbiAgICAgICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAgICAgKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICAgICAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gICAgICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcFR5cGVzO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICAgICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuICAgICAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG4gICAgICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG4gICAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVTdHJpbmc7XG4gICAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG4gICAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgdmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gICAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuICAgICAge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuICAgICAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0ge307XG4gICAgICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICAgICAge1xuICAgICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NvcGUoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbiA9PT0gbnVsbCAmJiBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycykge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG4gICAgICAgICAgICBpZiAodXBkYXRlZEZpYmVyc0NvdW50ID4gMTApIHtcbiAgICAgICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gZmFsc2U7XG4gICAgdmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgaWYgKGVucXVldWVUYXNrSW1wbCA9PT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHJlYWQgcmVxdWlyZSBvZmYgdGhlIG1vZHVsZSBvYmplY3QgdG8gZ2V0IGFyb3VuZCB0aGUgYnVuZGxlcnMuXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGRldGVjdCBhIHJlcXVpcmUgYW5kIGJ1bmRsZSBhIE5vZGUgcG9seWZpbGwuXG4gICAgICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICAgICAgdmFyIG5vZGVSZXF1aXJlID0gbW9kdWxlICYmIG1vZHVsZVtyZXF1aXJlU3RyaW5nXTsgLy8gYXNzdW1pbmcgd2UncmUgaW4gbm9kZSwgbGV0J3MgdHJ5IHRvIGdldCBub2RlJ3NcbiAgICAgICAgICAvLyB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZSwgYnlwYXNzaW5nIGZha2UgdGltZXJzIGlmIGFueS5cblxuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgLy8gd2UncmUgaW4gYSBicm93c2VyXG4gICAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgICAgICAvLyBzbyB3ZSB0cnkgTWVzc2FnZUNoYW5uZWwrcG9zdE1lc3NhZ2UgaW5zdGVhZFxuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgJyArICdzbyBlbnF1ZXVpbmcgdGFza3MgdmlhIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pIHdpbGwgZmFpbC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzICcgKyAnaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5xdWV1ZVRhc2tJbXBsKHRhc2spO1xuICAgIH1cbiAgICB2YXIgYWN0U2NvcGVEZXB0aCA9IDA7XG4gICAgdmFyIGRpZFdhcm5Ob0F3YWl0QWN0ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gYWN0KGNhbGxiYWNrKSB7XG4gICAgICB7XG4gICAgICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQsIHNvIHdlIHRyYWNrIHRoZSBkZXB0aC4gVGhpcyByZXByZXNlbnRzIHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgYGFjdGAgc2NvcGVzIG9uIHRoZSBzdGFjay5cbiAgICAgICAgdmFyIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICAgICAgYWN0U2NvcGVEZXB0aCsrO1xuICAgICAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZS4gSW5pdGlhbGl6ZSB0aGUgcXVldWUuIFRoZSByZWNvbmNpbGVyXG4gICAgICAgICAgLy8gd2lsbCBkZXRlY3QgdGhlIHF1ZXVlIGFuZCB1c2UgaXQgaW5zdGVhZCBvZiBTY2hlZHVsZXIuXG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2SXNCYXRjaGluZ0xlZ2FjeSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3k7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS4gT25seVxuICAgICAgICAgIC8vIHNldCB0byBgdHJ1ZWAgd2hpbGUgdGhlIGdpdmVuIGNhbGxiYWNrIGlzIGV4ZWN1dGVkLCBub3QgZm9yIHVwZGF0ZXNcbiAgICAgICAgICAvLyB0cmlnZ2VyZWQgZHVyaW5nIGFuIGFzeW5jIGV2ZW50LCBiZWNhdXNlIHRoaXMgaXMgaG93IHRoZSBsZWdhY3lcbiAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgYWN0YCBiZWhhdmVkLlxuICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3kgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7IC8vIFJlcGxpY2F0ZSBiZWhhdmlvciBvZiBvcmlnaW5hbCBgYWN0YCBpbXBsZW1lbnRhdGlvbiBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICAgICAvLyB3aGljaCBmbHVzaGVkIHVwZGF0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHNjb3BlIGZ1bmN0aW9uIGV4aXRzLCBldmVuXG4gICAgICAgICAgLy8gaWYgaXQncyBhbiBhc3luYyBmdW5jdGlvbi5cblxuICAgICAgICAgIGlmICghcHJldklzQmF0Y2hpbmdMZWdhY3kgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGVSZXN1bHQgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBhbiBhc3luYyBmdW5jdGlvbiAoaS5lLiByZXR1cm5lZCBhIHByb21pc2UpLiBXYWl0XG4gICAgICAgICAgLy8gZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlIGV4aXRpbmcgdGhlIGN1cnJlbnQgc2NvcGUuXG5cbiAgICAgICAgICB2YXIgd2FzQXdhaXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciB0aGVuYWJsZSA9IHtcbiAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgd2FzQXdhaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoZW5hYmxlUmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBleGl0ZWQgdGhlIG91dGVybW9zdCBhY3Qgc2NvcGUuIFJlY3Vyc2l2ZWx5IGZsdXNoIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gcXVldWUgdW50aWwgdGhlcmUncyBubyByZW1haW5pbmcgd29yay5cbiAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2Fybk5vQXdhaXRBY3QgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHt9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0F3YWl0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuICcgKyAnVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsICcgKyAnaW50ZXJsZWF2aW5nIG11bHRpcGxlIGFjdCBjYWxscyBhbmQgbWl4aW5nIHRoZWlyICcgKyAnc2NvcGVzLiAnICsgJ1lvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVzdWx0OyAvLyBUaGUgY2FsbGJhY2sgaXMgbm90IGFuIGFzeW5jIGZ1bmN0aW9uLiBFeGl0IHRoZSBjdXJyZW50IHNjb3BlXG4gICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdpdGhvdXQgYXdhaXRpbmcuXG5cbiAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgaWYgKGFjdFNjb3BlRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEV4aXRpbmcgdGhlIG91dGVybW9zdCBhY3Qgc2NvcGUuIEZsdXNoIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIHZhciBfcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKF9xdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKF9xdWV1ZSk7XG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfSAvLyBSZXR1cm4gYSB0aGVuYWJsZS4gSWYgdGhlIHVzZXIgYXdhaXRzIGl0LCB3ZSdsbCBmbHVzaCBhZ2FpbiBpblxuICAgICAgICAgICAgLy8gY2FzZSBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cblxuICAgICAgICAgICAgdmFyIF90aGVuYWJsZSA9IHtcbiAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIENvbmZpcm0gd2UgaGF2ZW4ndCByZS1lbnRlcmVkIGFub3RoZXIgYGFjdGAgc2NvcGUsIGluIGNhc2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBkb2VzIHNvbWV0aGluZyB3ZWlyZCBsaWtlIGF3YWl0IHRoZSB0aGVuYWJsZVxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbHVzaCB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBubyByZW1haW5pbmcgd29yay5cbiAgICAgICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfdGhlbmFibGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIGluc2lkZSBhIG5lc3RlZCBgYWN0YCBzY29wZSwgdGhlIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSByZXNvbHZlcy4gVGhlIG91dGVyIHNjb3BlIHdpbGwgZmx1c2ggdGhlIHF1ZXVlLlxuICAgICAgICAgICAgdmFyIF90aGVuYWJsZTIgPSB7XG4gICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfdGhlbmFibGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCkge1xuICAgICAge1xuICAgICAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxKSB7XG4gICAgICAgICAgZXJyb3IoJ1lvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gJyArICdCZSBzdXJlIHRvIGF3YWl0IHByZXZpb3VzIGFjdCgpIGNhbGxzIGJlZm9yZSBtYWtpbmcgYSBuZXcgb25lLiAnKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RTY29wZURlcHRoID0gcHJldkFjdFNjb3BlRGVwdGg7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAge1xuICAgICAgICB2YXIgcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuICAgICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZC4gRmluaXNoLlxuICAgICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgd29yayB1bnRpbCB0aGVyZSdzIG5vbmUgbGVmdC5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICAgICAgaXNGbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgcXVldWUgPSBxdWV1ZS5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY3JlYXRlRWxlbWVudCQxID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uO1xuICAgIHZhciBjbG9uZUVsZW1lbnQkMSA9IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uO1xuICAgIHZhciBjcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uO1xuICAgIHZhciBDaGlsZHJlbiA9IHtcbiAgICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgICB9O1xuICAgIGV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICBleHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuICAgIGV4cG9ydHMuYWN0ID0gYWN0O1xuICAgIGV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG4gICAgZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG4gICAgZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbiAgICBleHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbiAgICBleHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbiAgICBleHBvcnRzLmxhenkgPSBsYXp5O1xuICAgIGV4cG9ydHMubWVtbyA9IG1lbW87XG4gICAgZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBzdGFydFRyYW5zaXRpb247XG4gICAgZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBhY3Q7XG4gICAgZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuICAgIGV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG4gICAgZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbiAgICBleHBvcnRzLnVzZURlZmVycmVkVmFsdWUgPSB1c2VEZWZlcnJlZFZhbHVlO1xuICAgIGV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuICAgIGV4cG9ydHMudXNlSWQgPSB1c2VJZDtcbiAgICBleHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuICAgIGV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gdXNlSW5zZXJ0aW9uRWZmZWN0O1xuICAgIGV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuICAgIGV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG4gICAgZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbiAgICBleHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbiAgICBleHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuICAgIGV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb247XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbiAgICB9XG4gIH0pKCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVIQUFzRDtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/OWNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n      var first = heap[0];\n      var last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n      return first;\n    }\n    function siftUp(heap, node, i) {\n      var index = i;\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    }\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    function markTaskErrored(task, ms) {}\n\n    /* eslint-disable no-var */\n\n    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n        var callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n      var timeout;\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function unstable_pauseExecution() {}\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n      return true;\n    }\n    function requestPaint() {}\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n    var performWorkUntilDeadline = function () {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n    };\n    var schedulePerformWorkUntilDeadline;\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QyxtREFBbUQ7O0FBRW5EO0FBQ0EseUJBQXlCOztBQUV6QiwyQkFBMkI7QUFDM0I7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSx1RkFBdUY7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGtDQUFrQztBQUN0QyxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDBCQUEwQjtBQUM5QixJQUFJLHFDQUFxQztBQUN6QyxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLGtDQUFrQztBQUN0QyxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLHdDQUF3QztBQUM1QyxJQUFJLHFDQUFxQztBQUN6QyxJQUFJLHFCQUFxQjtBQUN6QixJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGdDQUFnQztBQUNwQyxJQUFJLGlDQUFpQztBQUNyQyxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/ODY1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbiAgICB9XG4gICAgdmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xuICAgIHZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcbiAgICB2YXIgZnJhbWVZaWVsZE1zID0gNTtcbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT09IDAgPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmIChoZWFwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gICAgICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG4gICAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgICAgICB2YXIgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG4gICAgICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAgICAgLy8gVGhlIHBhcmVudCBpcyBsYXJnZXIuIFN3YXAgcG9zaXRpb25zLlxuICAgICAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcbiAgICAgIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICAgICAgd2hpbGUgKGluZGV4IDwgaGFsZkxlbmd0aCkge1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICAgICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICAgICAgaWYgKGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICAgICAgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XG4gICAgICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcbiAgICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXG4gICAgICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gICAgICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2Ugc3ltYm9scz9cbiAgICB2YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIHZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG4gICAgdmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbiAgICB2YXIgTG93UHJpb3JpdHkgPSA0O1xuICAgIHZhciBJZGxlUHJpb3JpdHkgPSA1O1xuICAgIGZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge31cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG4gICAgdmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICAgICAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfSAvLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbiAgICAvLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4gICAgLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuICAgIHZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG4gICAgdmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7IC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5cbiAgICB2YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xuICAgIHZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG4gICAgdmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7IC8vIE5ldmVyIHRpbWVzIG91dFxuXG4gICAgdmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxuICAgIHZhciB0YXNrUXVldWUgPSBbXTtcbiAgICB2YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbiAgICB2YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICB2YXIgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIHZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5OyAvLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY2UuXG5cbiAgICB2YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICAgIHZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7IC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuXG4gICAgdmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IG51bGw7XG4gICAgdmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IG51bGw7XG4gICAgdmFyIGxvY2FsU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBudWxsOyAvLyBJRSBhbmQgTm9kZS5qcyArIGpzZG9tXG5cbiAgICB2YXIgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3Iuc2NoZWR1bGluZyAhPT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWQgPyBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZy5iaW5kKG5hdmlnYXRvci5zY2hlZHVsaW5nKSA6IG51bGw7XG4gICAgZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAgICAgLy8gQ2hlY2sgZm9yIHRhc2tzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWxheWVkIGFuZCBhZGQgdGhlbSB0byB0aGUgcXVldWUuXG4gICAgICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgd2hpbGUgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgICAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hXb3JrKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gV2Ugc2NoZWR1bGVkIGEgdGltZW91dCBidXQgaXQncyBubyBsb25nZXIgbmVlZGVkLiBDYW5jZWwgaXQuXG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgbWFya1Rhc2tFcnJvcmVkKGN1cnJlbnRUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXNrICE9PSBudWxsICYmICFlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpKSB7XG4gICAgICAgICAgLy8gVGhpcyBjdXJyZW50VGFzayBoYXNuJ3QgZXhwaXJlZCwgYW5kIHdlJ3ZlIHJlYWNoZWQgdGhlIGRlYWRsaW5lLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSkge1xuICAgICAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cbiAgICAgIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gICAgICB2YXIgcHJpb3JpdHlMZXZlbDtcbiAgICAgIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB2YXIgdGltZW91dDtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICAgIHRpbWVvdXQgPSBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICAgIHRpbWVvdXQgPSBMT1dfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xuICAgICAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgc29ydEluZGV4OiAtMVxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgICAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICAgICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcbiAgICAgICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG4gICAgICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3VGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7fVxuICAgIGZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG4gICAgICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gICAgICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gICAgICAvLyBhcnJheSBiYXNlZCBoZWFwLCBvbmx5IHRoZSBmaXJzdCBvbmUuKVxuXG4gICAgICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICAgIHZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgIHZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgIHZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuICAgIC8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cbiAgICAvLyBJdCBkb2VzIG5vdCBhdHRlbXB0IHRvIGFsaWduIHdpdGggZnJhbWUgYm91bmRhcmllcywgc2luY2UgbW9zdCB0YXNrcyBkb24ndFxuICAgIC8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbiAgICB2YXIgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgICB2YXIgc3RhcnRUaW1lID0gLTE7XG4gICAgZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gICAgICB2YXIgdGltZUVsYXBzZWQgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKHRpbWVFbGFwc2VkIDwgZnJhbWVJbnRlcnZhbCkge1xuICAgICAgICAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIG9ubHkgYmVlbiBibG9ja2VkIGZvciBhIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZTtcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBiZWVuIGJsb2NrZWQgZm9yIGEgbm9uLW5lZ2xpZ2libGUgYW1vdW50IG9mIHRpbWUuIFdlXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0UGFpbnQoKSB7fVxuICAgIGZ1bmN0aW9uIGZvcmNlRnJhbWVSYXRlKGZwcykge1xuICAgICAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgICBjb25zb2xlWydlcnJvciddKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnBzID4gMCkge1xuICAgICAgICBmcmFtZUludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICAgICAgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gbWVhc3VyZSBob3cgbG9uZyB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgLy8gaGFzIGJlZW4gYmxvY2tlZC5cblxuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlOyAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYSB0cnktY2F0Y2gsIHNpbmNlIHRoYXQgbWFrZXMgc29tZSBkZWJ1Z2dpbmdcbiAgICAgICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBzY2hlZHVsZWRIb3N0Q2FsbGJhY2tgIGVycm9ycywgdGhlblxuICAgICAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG4gICAgICAgIHZhciBoYXNNb3JlV29yayA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYXNNb3JlV29yaykge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gICAgfTtcbiAgICB2YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gTm9kZS5qcyBhbmQgb2xkIElFLlxuICAgICAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBVbmxpa2UgTWVzc2FnZUNoYW5uZWwsIGl0IGRvZXNuJ3QgcHJldmVudCBhIE5vZGUuanMgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG4gICAgICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAgICAgLy8gd2l0aCBhIG1peCBvZiBOb2RlLmpzIDE1Kywgd2hpY2ggaGFzIGEgTWVzc2FnZUNoYW5uZWwsIGFuZCBqc2RvbS4pXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNzU2XG4gICAgICAvL1xuICAgICAgLy8gQnV0IGFsc28sIGl0IHJ1bnMgZWFybGllciB3aGljaCBpcyB0aGUgc2VtYW50aWMgd2Ugd2FudC5cbiAgICAgIC8vIElmIG90aGVyIGJyb3dzZXJzIGV2ZXIgaW1wbGVtZW50IGl0LCBpdCdzIGJldHRlciB0byB1c2UgaXQuXG4gICAgICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gRE9NIGFuZCBXb3JrZXIgZW52aXJvbm1lbnRzLlxuICAgICAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzaG91bGQgb25seSBmYWxsYmFjayBoZXJlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgICAgIHRhc2tUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsSG9zdFRpbWVvdXQoKSB7XG4gICAgICBsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKTtcbiAgICAgIHRhc2tUaW1lb3V0SUQgPSAtMTtcbiAgICB9XG4gICAgdmFyIHVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcbiAgICB2YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuICAgIGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IHVuc3RhYmxlX1Byb2ZpbGluZztcbiAgICBleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuICAgIGV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZm9yY2VGcmFtZVJhdGU7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHVuc3RhYmxlX3JlcXVlc3RQYWludDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG4gICAgfVxuICB9KSgpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSUFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz84MTJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scheduler/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebSocketClient)\n/* harmony export */ });\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nvar WebSocketClient = /*#__PURE__*/function () {\n  /**\n   * @param {string} url\n   */\n  function WebSocketClient(url) {\n    _classCallCheck(this, WebSocketClient);\n    this.client = new WebSocket(url);\n    this.client.onerror = function (error) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_0__.log.error(error);\n    };\n  }\n\n  /**\n   * @param {(...args: any[]) => void} f\n   */\n  _createClass(WebSocketClient, [{\n    key: \"onOpen\",\n    value: function onOpen(f) {\n      this.client.onopen = f;\n    }\n\n    /**\n     * @param {(...args: any[]) => void} f\n     */\n  }, {\n    key: \"onClose\",\n    value: function onClose(f) {\n      this.client.onclose = f;\n    }\n\n    // call f with the message string as the first argument\n    /**\n     * @param {(...args: any[]) => void} f\n     */\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(f) {\n      this.client.onmessage = function (e) {\n        f(e.data);\n      };\n    }\n  }]);\n  return WebSocketClient;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1dlYlNvY2tldENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQUc7QUFDVDtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9XZWJTb2NrZXRDbGllbnQuanM/ZWY1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vdXRpbHMvbG9nLmpzXCI7XG52YXIgV2ViU29ja2V0Q2xpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICovXG4gIGZ1bmN0aW9uIFdlYlNvY2tldENsaWVudCh1cmwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU29ja2V0Q2xpZW50KTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICB0aGlzLmNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGZcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhXZWJTb2NrZXRDbGllbnQsIFt7XG4gICAga2V5OiBcIm9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW4oZikge1xuICAgICAgdGhpcy5jbGllbnQub25vcGVuID0gZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLmNsaWVudC5vbmNsb3NlID0gZjtcbiAgICB9XG5cbiAgICAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGZcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuY2xpZW50Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXZWJTb2NrZXRDbGllbnQ7XG59KCk7XG5leHBvcnQgeyBXZWJTb2NrZXRDbGllbnQgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var __resourceQuery = \"?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/log.js */ \"./node_modules/webpack/hot/log.js\");\n/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/stripAnsi.js */ \"./node_modules/webpack-dev-server/client/utils/stripAnsi.js\");\n/* harmony import */ var _utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/parseURL.js */ \"./node_modules/webpack-dev-server/client/utils/parseURL.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./socket.js */ \"./node_modules/webpack-dev-server/client/socket.js\");\n/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overlay.js */ \"./node_modules/webpack-dev-server/client/overlay.js\");\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\n/* harmony import */ var _utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/sendMessage.js */ \"./node_modules/webpack-dev-server/client/utils/sendMessage.js\");\n/* harmony import */ var _utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/reloadApp.js */ \"./node_modules/webpack-dev-server/client/utils/reloadApp.js\");\n/* harmony import */ var _utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/createSocketURL.js */ \"./node_modules/webpack-dev-server/client/utils/createSocketURL.js\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/* global __resourceQuery, __webpack_hash__ */\n/// <reference types=\"webpack/module\" />\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} OverlayOptions\n * @property {boolean | (error: Error) => boolean} [warnings]\n * @property {boolean | (error: Error) => boolean} [errors]\n * @property {boolean | (error: Error) => boolean} [runtimeErrors]\n * @property {string} [trustedTypesPolicyName]\n */\n\n/**\n * @typedef {Object} Options\n * @property {boolean} hot\n * @property {boolean} liveReload\n * @property {boolean} progress\n * @property {boolean | OverlayOptions} overlay\n * @property {string} [logging]\n * @property {number} [reconnect]\n */\n\n/**\n * @typedef {Object} Status\n * @property {boolean} isUnloading\n * @property {string} currentHash\n * @property {string} [previousHash]\n */\n\n/**\n * @param {boolean | { warnings?: boolean | string; errors?: boolean | string; runtimeErrors?: boolean | string; }} overlayOptions\n */\nvar decodeOverlayOptions = function decodeOverlayOptions(overlayOptions) {\n  if (typeof overlayOptions === \"object\") {\n    [\"warnings\", \"errors\", \"runtimeErrors\"].forEach(function (property) {\n      if (typeof overlayOptions[property] === \"string\") {\n        var overlayFilterFunctionString = decodeURIComponent(overlayOptions[property]);\n\n        // eslint-disable-next-line no-new-func\n        var overlayFilterFunction = new Function(\"message\", \"var callback = \".concat(overlayFilterFunctionString, \"\\n        return callback(message)\"));\n        overlayOptions[property] = overlayFilterFunction;\n      }\n    });\n  }\n};\n\n/**\n * @type {Status}\n */\nvar status = {\n  isUnloading: false,\n  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement\n  // eslint-disable-next-line camelcase\n  currentHash:  true ? __webpack_require__.h() : 0\n};\n\n/** @type {Options} */\nvar options = {\n  hot: false,\n  liveReload: false,\n  progress: false,\n  overlay: false\n};\nvar parsedResourceQuery = (0,_utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(__resourceQuery);\nvar enabledFeatures = {\n  \"Hot Module Replacement\": false,\n  \"Live Reloading\": false,\n  Progress: false,\n  Overlay: false\n};\nif (parsedResourceQuery.hot === \"true\") {\n  options.hot = true;\n  enabledFeatures[\"Hot Module Replacement\"] = true;\n}\nif (parsedResourceQuery[\"live-reload\"] === \"true\") {\n  options.liveReload = true;\n  enabledFeatures[\"Live Reloading\"] = true;\n}\nif (parsedResourceQuery.progress === \"true\") {\n  options.progress = true;\n  enabledFeatures.Progress = true;\n}\nif (parsedResourceQuery.overlay) {\n  try {\n    options.overlay = JSON.parse(parsedResourceQuery.overlay);\n  } catch (e) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(\"Error parsing overlay options from resource query:\", e);\n  }\n\n  // Fill in default \"true\" params for partially-specified objects.\n  if (typeof options.overlay === \"object\") {\n    options.overlay = _objectSpread({\n      errors: true,\n      warnings: true,\n      runtimeErrors: true\n    }, options.overlay);\n    decodeOverlayOptions(options.overlay);\n  }\n  enabledFeatures.Overlay = true;\n}\nif (parsedResourceQuery.logging) {\n  options.logging = parsedResourceQuery.logging;\n}\nif (typeof parsedResourceQuery.reconnect !== \"undefined\") {\n  options.reconnect = Number(parsedResourceQuery.reconnect);\n}\n\n/**\n * @param {string} level\n */\nfunction setAllLogLevel(level) {\n  // This is needed because the HMR logger operate separately from dev server logger\n  webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default().setLogLevel(level === \"verbose\" || level === \"log\" ? \"info\" : level);\n  (0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.setLogLevel)(level);\n}\nif (options.logging) {\n  setAllLogLevel(options.logging);\n}\n(0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.logEnabledFeatures)(enabledFeatures);\nself.addEventListener(\"beforeunload\", function () {\n  status.isUnloading = true;\n});\nvar overlay = typeof window !== \"undefined\" ? (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.createOverlay)(typeof options.overlay === \"object\" ? {\n  trustedTypesPolicyName: options.overlay.trustedTypesPolicyName,\n  catchRuntimeError: options.overlay.runtimeErrors\n} : {\n  trustedTypesPolicyName: false,\n  catchRuntimeError: options.overlay\n}) : {\n  send: function send() {}\n};\nvar onSocketMessage = {\n  hot: function hot() {\n    if (parsedResourceQuery.hot === \"false\") {\n      return;\n    }\n    options.hot = true;\n  },\n  liveReload: function liveReload() {\n    if (parsedResourceQuery[\"live-reload\"] === \"false\") {\n      return;\n    }\n    options.liveReload = true;\n  },\n  invalid: function invalid() {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"App updated. Recompiling...\");\n\n    // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Invalid\");\n  },\n  /**\n   * @param {string} hash\n   */\n  hash: function hash(_hash) {\n    status.previousHash = status.currentHash;\n    status.currentHash = _hash;\n  },\n  logging: setAllLogLevel,\n  /**\n   * @param {boolean} value\n   */\n  overlay: function overlay(value) {\n    if (typeof document === \"undefined\") {\n      return;\n    }\n    options.overlay = value;\n    decodeOverlayOptions(options.overlay);\n  },\n  /**\n   * @param {number} value\n   */\n  reconnect: function reconnect(value) {\n    if (parsedResourceQuery.reconnect === \"false\") {\n      return;\n    }\n    options.reconnect = value;\n  },\n  /**\n   * @param {boolean} value\n   */\n  progress: function progress(value) {\n    options.progress = value;\n  },\n  /**\n   * @param {{ pluginName?: string, percent: number, msg: string }} data\n   */\n  \"progress-update\": function progressUpdate(data) {\n    if (options.progress) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"\".concat(data.pluginName ? \"[\".concat(data.pluginName, \"] \") : \"\").concat(data.percent, \"% - \").concat(data.msg, \".\"));\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Progress\", data);\n  },\n  \"still-ok\": function stillOk() {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"Nothing changed.\");\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"StillOk\");\n  },\n  ok: function ok() {\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Ok\");\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(options, status);\n  },\n  // TODO: remove in v5 in favor of 'static-changed'\n  /**\n   * @param {string} file\n   */\n  \"content-changed\": function contentChanged(file) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"\".concat(file ? \"\\\"\".concat(file, \"\\\"\") : \"Content\", \" from static directory was changed. Reloading...\"));\n    self.location.reload();\n  },\n  /**\n   * @param {string} file\n   */\n  \"static-changed\": function staticChanged(file) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"\".concat(file ? \"\\\"\".concat(file, \"\\\"\") : \"Content\", \" from static directory was changed. Reloading...\"));\n    self.location.reload();\n  },\n  /**\n   * @param {Error[]} warnings\n   * @param {any} params\n   */\n  warnings: function warnings(_warnings, params) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(\"Warnings while compiling.\");\n    var printableWarnings = _warnings.map(function (error) {\n      var _formatProblem = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.formatProblem)(\"warning\", error),\n        header = _formatProblem.header,\n        body = _formatProblem.body;\n      return \"\".concat(header, \"\\n\").concat((0,_utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(body));\n    });\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Warnings\", printableWarnings);\n    for (var i = 0; i < printableWarnings.length; i++) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(printableWarnings[i]);\n    }\n    var overlayWarningsSetting = typeof options.overlay === \"boolean\" ? options.overlay : options.overlay && options.overlay.warnings;\n    if (overlayWarningsSetting) {\n      var warningsToDisplay = typeof overlayWarningsSetting === \"function\" ? _warnings.filter(overlayWarningsSetting) : _warnings;\n      if (warningsToDisplay.length) {\n        overlay.send({\n          type: \"BUILD_ERROR\",\n          level: \"warning\",\n          messages: _warnings\n        });\n      }\n    }\n    if (params && params.preventReloading) {\n      return;\n    }\n    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(options, status);\n  },\n  /**\n   * @param {Error[]} errors\n   */\n  errors: function errors(_errors) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(\"Errors while compiling. Reload prevented.\");\n    var printableErrors = _errors.map(function (error) {\n      var _formatProblem2 = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.formatProblem)(\"error\", error),\n        header = _formatProblem2.header,\n        body = _formatProblem2.body;\n      return \"\".concat(header, \"\\n\").concat((0,_utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(body));\n    });\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Errors\", printableErrors);\n    for (var i = 0; i < printableErrors.length; i++) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(printableErrors[i]);\n    }\n    var overlayErrorsSettings = typeof options.overlay === \"boolean\" ? options.overlay : options.overlay && options.overlay.errors;\n    if (overlayErrorsSettings) {\n      var errorsToDisplay = typeof overlayErrorsSettings === \"function\" ? _errors.filter(overlayErrorsSettings) : _errors;\n      if (errorsToDisplay.length) {\n        overlay.send({\n          type: \"BUILD_ERROR\",\n          level: \"error\",\n          messages: _errors\n        });\n      }\n    }\n  },\n  /**\n   * @param {Error} error\n   */\n  error: function error(_error) {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(_error);\n  },\n  close: function close() {\n    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info(\"Disconnected!\");\n    if (options.overlay) {\n      overlay.send({\n        type: \"DISMISS\"\n      });\n    }\n    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"Close\");\n  }\n};\nvar socketURL = (0,_utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(parsedResourceQuery);\n(0,_socket_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(socketURL, onSocketMessage, options.reconnect);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz9wcm90b2NvbD13cyUzQSZob3N0bmFtZT0wLjAuMC4wJnBvcnQ9MzAwMCZwYXRobmFtZT0lMkZ3cyZsb2dnaW5nPW5vbmUmb3ZlcmxheT10cnVlJnJlY29ubmVjdD0xMCZob3Q9dHJ1ZSZsaXZlLXJlbG9hZD10cnVlIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDRjtBQUNGO0FBQ1Y7QUFDMkI7QUFDVTtBQUNyQjtBQUNKO0FBQ1k7O0FBRXpEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMscUNBQXFDO0FBQ25ELGNBQWMscUNBQXFDO0FBQ25ELGNBQWMscUNBQXFDO0FBQ25ELGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsV0FBVyxZQUFZLDZCQUE2QiwyQkFBMkIscUNBQXFD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QUs7QUFDTCxJQUFJLGlFQUFXO0FBQ2Ysb0JBQW9CLDRCQUE0QjtBQUNoRCxNQUFNLDhDQUFHO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLElBQUksOENBQUc7QUFDUCxHQUFHO0FBQ0g7QUFDQSxJQUFJLDhDQUFHO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSxpRUFBVztBQUNmO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQWU7QUFDL0Isc0RBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvaW5kZXguanM/M2U2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSwgX193ZWJwYWNrX2hhc2hfXyAqL1xuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJ3ZWJwYWNrL21vZHVsZVwiIC8+XG5pbXBvcnQgd2VicGFja0hvdExvZyBmcm9tIFwid2VicGFjay9ob3QvbG9nLmpzXCI7XG5pbXBvcnQgc3RyaXBBbnNpIGZyb20gXCIuL3V0aWxzL3N0cmlwQW5zaS5qc1wiO1xuaW1wb3J0IHBhcnNlVVJMIGZyb20gXCIuL3V0aWxzL3BhcnNlVVJMLmpzXCI7XG5pbXBvcnQgc29ja2V0IGZyb20gXCIuL3NvY2tldC5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0UHJvYmxlbSwgY3JlYXRlT3ZlcmxheSB9IGZyb20gXCIuL292ZXJsYXkuanNcIjtcbmltcG9ydCB7IGxvZywgbG9nRW5hYmxlZEZlYXR1cmVzLCBzZXRMb2dMZXZlbCB9IGZyb20gXCIuL3V0aWxzL2xvZy5qc1wiO1xuaW1wb3J0IHNlbmRNZXNzYWdlIGZyb20gXCIuL3V0aWxzL3NlbmRNZXNzYWdlLmpzXCI7XG5pbXBvcnQgcmVsb2FkQXBwIGZyb20gXCIuL3V0aWxzL3JlbG9hZEFwcC5qc1wiO1xuaW1wb3J0IGNyZWF0ZVNvY2tldFVSTCBmcm9tIFwiLi91dGlscy9jcmVhdGVTb2NrZXRVUkwuanNcIjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPdmVybGF5T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFuIHwgKGVycm9yOiBFcnJvcikgPT4gYm9vbGVhbn0gW3dhcm5pbmdzXVxuICogQHByb3BlcnR5IHtib29sZWFuIHwgKGVycm9yOiBFcnJvcikgPT4gYm9vbGVhbn0gW2Vycm9yc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IChlcnJvcjogRXJyb3IpID0+IGJvb2xlYW59IFtydW50aW1lRXJyb3JzXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0cnVzdGVkVHlwZXNQb2xpY3lOYW1lXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBob3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGl2ZVJlbG9hZFxuICogQHByb3BlcnR5IHtib29sZWFufSBwcm9ncmVzc1xuICogQHByb3BlcnR5IHtib29sZWFuIHwgT3ZlcmxheU9wdGlvbnN9IG92ZXJsYXlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9nZ2luZ11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVjb25uZWN0XVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhdHVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVW5sb2FkaW5nXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3VycmVudEhhc2hcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJldmlvdXNIYXNoXVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFuIHwgeyB3YXJuaW5ncz86IGJvb2xlYW4gfCBzdHJpbmc7IGVycm9ycz86IGJvb2xlYW4gfCBzdHJpbmc7IHJ1bnRpbWVFcnJvcnM/OiBib29sZWFuIHwgc3RyaW5nOyB9fSBvdmVybGF5T3B0aW9uc1xuICovXG52YXIgZGVjb2RlT3ZlcmxheU9wdGlvbnMgPSBmdW5jdGlvbiBkZWNvZGVPdmVybGF5T3B0aW9ucyhvdmVybGF5T3B0aW9ucykge1xuICBpZiAodHlwZW9mIG92ZXJsYXlPcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgW1wid2FybmluZ3NcIiwgXCJlcnJvcnNcIiwgXCJydW50aW1lRXJyb3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBpZiAodHlwZW9mIG92ZXJsYXlPcHRpb25zW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgb3ZlcmxheUZpbHRlckZ1bmN0aW9uU3RyaW5nID0gZGVjb2RlVVJJQ29tcG9uZW50KG92ZXJsYXlPcHRpb25zW3Byb3BlcnR5XSk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAgIHZhciBvdmVybGF5RmlsdGVyRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb24oXCJtZXNzYWdlXCIsIFwidmFyIGNhbGxiYWNrID0gXCIuY29uY2F0KG92ZXJsYXlGaWx0ZXJGdW5jdGlvblN0cmluZywgXCJcXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKVwiKSk7XG4gICAgICAgIG92ZXJsYXlPcHRpb25zW3Byb3BlcnR5XSA9IG92ZXJsYXlGaWx0ZXJGdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7U3RhdHVzfVxuICovXG52YXIgc3RhdHVzID0ge1xuICBpc1VubG9hZGluZzogZmFsc2UsXG4gIC8vIFRPRE8gV29ya2Fyb3VuZCBmb3Igd2VicGFjayB2NCwgYF9fd2VicGFja19oYXNoX19gIGlzIG5vdCByZXBsYWNlZCB3aXRob3V0IEhvdE1vZHVsZVJlcGxhY2VtZW50XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgY3VycmVudEhhc2g6IHR5cGVvZiBfX3dlYnBhY2tfaGFzaF9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX2hhc2hfXyA6IFwiXCJcbn07XG5cbi8qKiBAdHlwZSB7T3B0aW9uc30gKi9cbnZhciBvcHRpb25zID0ge1xuICBob3Q6IGZhbHNlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgcHJvZ3Jlc3M6IGZhbHNlLFxuICBvdmVybGF5OiBmYWxzZVxufTtcbnZhciBwYXJzZWRSZXNvdXJjZVF1ZXJ5ID0gcGFyc2VVUkwoX19yZXNvdXJjZVF1ZXJ5KTtcbnZhciBlbmFibGVkRmVhdHVyZXMgPSB7XG4gIFwiSG90IE1vZHVsZSBSZXBsYWNlbWVudFwiOiBmYWxzZSxcbiAgXCJMaXZlIFJlbG9hZGluZ1wiOiBmYWxzZSxcbiAgUHJvZ3Jlc3M6IGZhbHNlLFxuICBPdmVybGF5OiBmYWxzZVxufTtcbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmhvdCA9PT0gXCJ0cnVlXCIpIHtcbiAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICBlbmFibGVkRmVhdHVyZXNbXCJIb3QgTW9kdWxlIFJlcGxhY2VtZW50XCJdID0gdHJ1ZTtcbn1cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5W1wibGl2ZS1yZWxvYWRcIl0gPT09IFwidHJ1ZVwiKSB7XG4gIG9wdGlvbnMubGl2ZVJlbG9hZCA9IHRydWU7XG4gIGVuYWJsZWRGZWF0dXJlc1tcIkxpdmUgUmVsb2FkaW5nXCJdID0gdHJ1ZTtcbn1cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LnByb2dyZXNzID09PSBcInRydWVcIikge1xuICBvcHRpb25zLnByb2dyZXNzID0gdHJ1ZTtcbiAgZW5hYmxlZEZlYXR1cmVzLlByb2dyZXNzID0gdHJ1ZTtcbn1cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5Lm92ZXJsYXkpIHtcbiAgdHJ5IHtcbiAgICBvcHRpb25zLm92ZXJsYXkgPSBKU09OLnBhcnNlKHBhcnNlZFJlc291cmNlUXVlcnkub3ZlcmxheSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3IoXCJFcnJvciBwYXJzaW5nIG92ZXJsYXkgb3B0aW9ucyBmcm9tIHJlc291cmNlIHF1ZXJ5OlwiLCBlKTtcbiAgfVxuXG4gIC8vIEZpbGwgaW4gZGVmYXVsdCBcInRydWVcIiBwYXJhbXMgZm9yIHBhcnRpYWxseS1zcGVjaWZpZWQgb2JqZWN0cy5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICBvcHRpb25zLm92ZXJsYXkgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGVycm9yczogdHJ1ZSxcbiAgICAgIHdhcm5pbmdzOiB0cnVlLFxuICAgICAgcnVudGltZUVycm9yczogdHJ1ZVxuICAgIH0sIG9wdGlvbnMub3ZlcmxheSk7XG4gICAgZGVjb2RlT3ZlcmxheU9wdGlvbnMob3B0aW9ucy5vdmVybGF5KTtcbiAgfVxuICBlbmFibGVkRmVhdHVyZXMuT3ZlcmxheSA9IHRydWU7XG59XG5pZiAocGFyc2VkUmVzb3VyY2VRdWVyeS5sb2dnaW5nKSB7XG4gIG9wdGlvbnMubG9nZ2luZyA9IHBhcnNlZFJlc291cmNlUXVlcnkubG9nZ2luZztcbn1cbmlmICh0eXBlb2YgcGFyc2VkUmVzb3VyY2VRdWVyeS5yZWNvbm5lY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgb3B0aW9ucy5yZWNvbm5lY3QgPSBOdW1iZXIocGFyc2VkUmVzb3VyY2VRdWVyeS5yZWNvbm5lY3QpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbFxuICovXG5mdW5jdGlvbiBzZXRBbGxMb2dMZXZlbChsZXZlbCkge1xuICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBITVIgbG9nZ2VyIG9wZXJhdGUgc2VwYXJhdGVseSBmcm9tIGRldiBzZXJ2ZXIgbG9nZ2VyXG4gIHdlYnBhY2tIb3RMb2cuc2V0TG9nTGV2ZWwobGV2ZWwgPT09IFwidmVyYm9zZVwiIHx8IGxldmVsID09PSBcImxvZ1wiID8gXCJpbmZvXCIgOiBsZXZlbCk7XG4gIHNldExvZ0xldmVsKGxldmVsKTtcbn1cbmlmIChvcHRpb25zLmxvZ2dpbmcpIHtcbiAgc2V0QWxsTG9nTGV2ZWwob3B0aW9ucy5sb2dnaW5nKTtcbn1cbmxvZ0VuYWJsZWRGZWF0dXJlcyhlbmFibGVkRmVhdHVyZXMpO1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xudmFyIG92ZXJsYXkgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gY3JlYXRlT3ZlcmxheSh0eXBlb2Ygb3B0aW9ucy5vdmVybGF5ID09PSBcIm9iamVjdFwiID8ge1xuICB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lOiBvcHRpb25zLm92ZXJsYXkudHJ1c3RlZFR5cGVzUG9saWN5TmFtZSxcbiAgY2F0Y2hSdW50aW1lRXJyb3I6IG9wdGlvbnMub3ZlcmxheS5ydW50aW1lRXJyb3JzXG59IDoge1xuICB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lOiBmYWxzZSxcbiAgY2F0Y2hSdW50aW1lRXJyb3I6IG9wdGlvbnMub3ZlcmxheVxufSkgOiB7XG4gIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoKSB7fVxufTtcbnZhciBvblNvY2tldE1lc3NhZ2UgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIGlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmhvdCA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMuaG90ID0gdHJ1ZTtcbiAgfSxcbiAgbGl2ZVJlbG9hZDogZnVuY3Rpb24gbGl2ZVJlbG9hZCgpIHtcbiAgICBpZiAocGFyc2VkUmVzb3VyY2VRdWVyeVtcImxpdmUtcmVsb2FkXCJdID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbyhcIkFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLlwiKTtcblxuICAgIC8vIEZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiRElTTUlTU1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UoXCJJbnZhbGlkXCIpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAgICovXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBzdGF0dXMucHJldmlvdXNIYXNoID0gc3RhdHVzLmN1cnJlbnRIYXNoO1xuICAgIHN0YXR1cy5jdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuICBsb2dnaW5nOiBzZXRBbGxMb2dMZXZlbCxcbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMub3ZlcmxheSA9IHZhbHVlO1xuICAgIGRlY29kZU92ZXJsYXlPcHRpb25zKG9wdGlvbnMub3ZlcmxheSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlY29ubmVjdDogZnVuY3Rpb24gcmVjb25uZWN0KHZhbHVlKSB7XG4gICAgaWYgKHBhcnNlZFJlc291cmNlUXVlcnkucmVjb25uZWN0ID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucy5yZWNvbm5lY3QgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSkge1xuICAgIG9wdGlvbnMucHJvZ3Jlc3MgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7eyBwbHVnaW5OYW1lPzogc3RyaW5nLCBwZXJjZW50OiBudW1iZXIsIG1zZzogc3RyaW5nIH19IGRhdGFcbiAgICovXG4gIFwicHJvZ3Jlc3MtdXBkYXRlXCI6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy5wcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZGF0YS5wbHVnaW5OYW1lID8gXCJbXCIuY29uY2F0KGRhdGEucGx1Z2luTmFtZSwgXCJdIFwiKSA6IFwiXCIpLmNvbmNhdChkYXRhLnBlcmNlbnQsIFwiJSAtIFwiKS5jb25jYXQoZGF0YS5tc2csIFwiLlwiKSk7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKFwiUHJvZ3Jlc3NcIiwgZGF0YSk7XG4gIH0sXG4gIFwic3RpbGwtb2tcIjogZnVuY3Rpb24gc3RpbGxPaygpIHtcbiAgICBsb2cuaW5mbyhcIk5vdGhpbmcgY2hhbmdlZC5cIik7XG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJESVNNSVNTXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShcIlN0aWxsT2tcIik7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTWVzc2FnZShcIk9rXCIpO1xuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiRElTTUlTU1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIC8vIFRPRE86IHJlbW92ZSBpbiB2NSBpbiBmYXZvciBvZiAnc3RhdGljLWNoYW5nZWQnXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxuICAgKi9cbiAgXCJjb250ZW50LWNoYW5nZWRcIjogZnVuY3Rpb24gY29udGVudENoYW5nZWQoZmlsZSkge1xuICAgIGxvZy5pbmZvKFwiXCIuY29uY2F0KGZpbGUgPyBcIlxcXCJcIi5jb25jYXQoZmlsZSwgXCJcXFwiXCIpIDogXCJDb250ZW50XCIsIFwiIGZyb20gc3RhdGljIGRpcmVjdG9yeSB3YXMgY2hhbmdlZC4gUmVsb2FkaW5nLi4uXCIpKTtcbiAgICBzZWxmLmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVcbiAgICovXG4gIFwic3RhdGljLWNoYW5nZWRcIjogZnVuY3Rpb24gc3RhdGljQ2hhbmdlZChmaWxlKSB7XG4gICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZmlsZSA/IFwiXFxcIlwiLmNvbmNhdChmaWxlLCBcIlxcXCJcIikgOiBcIkNvbnRlbnRcIiwgXCIgZnJvbSBzdGF0aWMgZGlyZWN0b3J5IHdhcyBjaGFuZ2VkLiBSZWxvYWRpbmcuLi5cIikpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yW119IHdhcm5pbmdzXG4gICAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAgICovXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MsIHBhcmFtcykge1xuICAgIGxvZy53YXJuKFwiV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLlwiKTtcbiAgICB2YXIgcHJpbnRhYmxlV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdmFyIF9mb3JtYXRQcm9ibGVtID0gZm9ybWF0UHJvYmxlbShcIndhcm5pbmdcIiwgZXJyb3IpLFxuICAgICAgICBoZWFkZXIgPSBfZm9ybWF0UHJvYmxlbS5oZWFkZXIsXG4gICAgICAgIGJvZHkgPSBfZm9ybWF0UHJvYmxlbS5ib2R5O1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGhlYWRlciwgXCJcXG5cIikuY29uY2F0KHN0cmlwQW5zaShib2R5KSk7XG4gICAgfSk7XG4gICAgc2VuZE1lc3NhZ2UoXCJXYXJuaW5nc1wiLCBwcmludGFibGVXYXJuaW5ncyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmludGFibGVXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4ocHJpbnRhYmxlV2FybmluZ3NbaV0pO1xuICAgIH1cbiAgICB2YXIgb3ZlcmxheVdhcm5pbmdzU2V0dGluZyA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5vdmVybGF5IDogb3B0aW9ucy5vdmVybGF5ICYmIG9wdGlvbnMub3ZlcmxheS53YXJuaW5ncztcbiAgICBpZiAob3ZlcmxheVdhcm5pbmdzU2V0dGluZykge1xuICAgICAgdmFyIHdhcm5pbmdzVG9EaXNwbGF5ID0gdHlwZW9mIG92ZXJsYXlXYXJuaW5nc1NldHRpbmcgPT09IFwiZnVuY3Rpb25cIiA/IF93YXJuaW5ncy5maWx0ZXIob3ZlcmxheVdhcm5pbmdzU2V0dGluZykgOiBfd2FybmluZ3M7XG4gICAgICBpZiAod2FybmluZ3NUb0Rpc3BsYXkubGVuZ3RoKSB7XG4gICAgICAgIG92ZXJsYXkuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJCVUlMRF9FUlJPUlwiLFxuICAgICAgICAgIGxldmVsOiBcIndhcm5pbmdcIixcbiAgICAgICAgICBtZXNzYWdlczogX3dhcm5pbmdzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5wcmV2ZW50UmVsb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcltdfSBlcnJvcnNcbiAgICovXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoXCJFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLlwiKTtcbiAgICB2YXIgcHJpbnRhYmxlRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB2YXIgX2Zvcm1hdFByb2JsZW0yID0gZm9ybWF0UHJvYmxlbShcImVycm9yXCIsIGVycm9yKSxcbiAgICAgICAgaGVhZGVyID0gX2Zvcm1hdFByb2JsZW0yLmhlYWRlcixcbiAgICAgICAgYm9keSA9IF9mb3JtYXRQcm9ibGVtMi5ib2R5O1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGhlYWRlciwgXCJcXG5cIikuY29uY2F0KHN0cmlwQW5zaShib2R5KSk7XG4gICAgfSk7XG4gICAgc2VuZE1lc3NhZ2UoXCJFcnJvcnNcIiwgcHJpbnRhYmxlRXJyb3JzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW50YWJsZUVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHByaW50YWJsZUVycm9yc1tpXSk7XG4gICAgfVxuICAgIHZhciBvdmVybGF5RXJyb3JzU2V0dGluZ3MgPSB0eXBlb2Ygb3B0aW9ucy5vdmVybGF5ID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMub3ZlcmxheSA6IG9wdGlvbnMub3ZlcmxheSAmJiBvcHRpb25zLm92ZXJsYXkuZXJyb3JzO1xuICAgIGlmIChvdmVybGF5RXJyb3JzU2V0dGluZ3MpIHtcbiAgICAgIHZhciBlcnJvcnNUb0Rpc3BsYXkgPSB0eXBlb2Ygb3ZlcmxheUVycm9yc1NldHRpbmdzID09PSBcImZ1bmN0aW9uXCIgPyBfZXJyb3JzLmZpbHRlcihvdmVybGF5RXJyb3JzU2V0dGluZ3MpIDogX2Vycm9ycztcbiAgICAgIGlmIChlcnJvcnNUb0Rpc3BsYXkubGVuZ3RoKSB7XG4gICAgICAgIG92ZXJsYXkuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJCVUlMRF9FUlJPUlwiLFxuICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZXM6IF9lcnJvcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICovXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5pbmZvKFwiRGlzY29ubmVjdGVkIVwiKTtcbiAgICBpZiAob3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNlbmQoe1xuICAgICAgICB0eXBlOiBcIkRJU01JU1NcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKFwiQ2xvc2VcIik7XG4gIH1cbn07XG52YXIgc29ja2V0VVJMID0gY3JlYXRlU29ja2V0VVJMKHBhcnNlZFJlc291cmNlUXVlcnkpO1xuc29ja2V0KHNvY2tldFVSTCwgb25Tb2NrZXRNZXNzYWdlLCBvcHRpb25zLnJlY29ubmVjdCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/logger/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/logger/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/******/(function () {\n  // webpackBootstrap\n  /******/\n  \"use strict\";\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\"./client-src/modules/logger/SyncBailHookFake.js\": (\n    /*!*******************************************************!*\\\n      !*** ./client-src/modules/logger/SyncBailHookFake.js ***!\n      \\*******************************************************/\n    /***/\n    function (module) {\n      /**\n       * Client stub for tapable SyncBailHook\n       */\n      module.exports = function clientTapableSyncBailHook() {\n        return {\n          call: function call() {}\n        };\n      };\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/Logger.js\": (\n    /*!****************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/Logger.js ***!\n      \\****************************************************/\n    /***/\n    function (__unused_webpack_module, exports) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n      }\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n      }\n      function _iterableToArray(iter) {\n        if (typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) !== \"undefined\" && iter[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n      }\n      function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n      }\n      function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n        return arr2;\n      }\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n        }\n      }\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        Object.defineProperty(Constructor, \"prototype\", {\n          writable: false\n        });\n        return Constructor;\n      }\n      function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, \"string\");\n        return typeof key === \"symbol\" ? key : String(key);\n      }\n      function _toPrimitive(input, hint) {\n        if (typeof input !== \"object\" || input === null) return input;\n        var prim = input[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).toPrimitive];\n        if (prim !== undefined) {\n          var res = prim.call(input, hint || \"default\");\n          if (typeof res !== \"object\") return res;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (hint === \"string\" ? String : Number)(input);\n      }\n      var LogType = Object.freeze({\n        error: /** @type {\"error\"} */\"error\",\n        // message, c style arguments\n        warn: /** @type {\"warn\"} */\"warn\",\n        // message, c style arguments\n        info: /** @type {\"info\"} */\"info\",\n        // message, c style arguments\n        log: /** @type {\"log\"} */\"log\",\n        // message, c style arguments\n        debug: /** @type {\"debug\"} */\"debug\",\n        // message, c style arguments\n\n        trace: /** @type {\"trace\"} */\"trace\",\n        // no arguments\n\n        group: /** @type {\"group\"} */\"group\",\n        // [label]\n        groupCollapsed: /** @type {\"groupCollapsed\"} */\"groupCollapsed\",\n        // [label]\n        groupEnd: /** @type {\"groupEnd\"} */\"groupEnd\",\n        // [label]\n\n        profile: /** @type {\"profile\"} */\"profile\",\n        // [profileName]\n        profileEnd: /** @type {\"profileEnd\"} */\"profileEnd\",\n        // [profileName]\n\n        time: /** @type {\"time\"} */\"time\",\n        // name, time as [seconds, nanoseconds]\n\n        clear: /** @type {\"clear\"} */\"clear\",\n        // no arguments\n        status: /** @type {\"status\"} */\"status\" // message, arguments\n      });\n      exports.LogType = LogType;\n\n      /** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */\n\n      var LOG_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger raw log method\");\n      var TIMERS_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger times\");\n      var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger aggregated times\");\n      var WebpackLogger = /*#__PURE__*/function () {\n        /**\n         * @param {function(LogTypeEnum, any[]=): void} log log function\n         * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger\n         */\n        function WebpackLogger(log, getChildLogger) {\n          _classCallCheck(this, WebpackLogger);\n          this[LOG_SYMBOL] = log;\n          this.getChildLogger = getChildLogger;\n        }\n        _createClass(WebpackLogger, [{\n          key: \"error\",\n          value: function error() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            this[LOG_SYMBOL](LogType.error, args);\n          }\n        }, {\n          key: \"warn\",\n          value: function warn() {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n            this[LOG_SYMBOL](LogType.warn, args);\n          }\n        }, {\n          key: \"info\",\n          value: function info() {\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n            this[LOG_SYMBOL](LogType.info, args);\n          }\n        }, {\n          key: \"log\",\n          value: function log() {\n            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              args[_key4] = arguments[_key4];\n            }\n            this[LOG_SYMBOL](LogType.log, args);\n          }\n        }, {\n          key: \"debug\",\n          value: function debug() {\n            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              args[_key5] = arguments[_key5];\n            }\n            this[LOG_SYMBOL](LogType.debug, args);\n          }\n        }, {\n          key: \"assert\",\n          value: function assert(assertion) {\n            if (!assertion) {\n              for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n                args[_key6 - 1] = arguments[_key6];\n              }\n              this[LOG_SYMBOL](LogType.error, args);\n            }\n          }\n        }, {\n          key: \"trace\",\n          value: function trace() {\n            this[LOG_SYMBOL](LogType.trace, [\"Trace\"]);\n          }\n        }, {\n          key: \"clear\",\n          value: function clear() {\n            this[LOG_SYMBOL](LogType.clear);\n          }\n        }, {\n          key: \"status\",\n          value: function status() {\n            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n              args[_key7] = arguments[_key7];\n            }\n            this[LOG_SYMBOL](LogType.status, args);\n          }\n        }, {\n          key: \"group\",\n          value: function group() {\n            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n              args[_key8] = arguments[_key8];\n            }\n            this[LOG_SYMBOL](LogType.group, args);\n          }\n        }, {\n          key: \"groupCollapsed\",\n          value: function groupCollapsed() {\n            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n              args[_key9] = arguments[_key9];\n            }\n            this[LOG_SYMBOL](LogType.groupCollapsed, args);\n          }\n        }, {\n          key: \"groupEnd\",\n          value: function groupEnd() {\n            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n              args[_key10] = arguments[_key10];\n            }\n            this[LOG_SYMBOL](LogType.groupEnd, args);\n          }\n        }, {\n          key: \"profile\",\n          value: function profile(label) {\n            this[LOG_SYMBOL](LogType.profile, [label]);\n          }\n        }, {\n          key: \"profileEnd\",\n          value: function profileEnd(label) {\n            this[LOG_SYMBOL](LogType.profileEnd, [label]);\n          }\n        }, {\n          key: \"time\",\n          value: function time(label) {\n            this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();\n            this[TIMERS_SYMBOL].set(label, process.hrtime());\n          }\n        }, {\n          key: \"timeLog\",\n          value: function timeLog(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeLog()\"));\n            }\n            var time = process.hrtime(prev);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }, {\n          key: \"timeEnd\",\n          value: function timeEnd(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeEnd()\"));\n            }\n            var time = process.hrtime(prev);\n            this[TIMERS_SYMBOL].delete(label);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }, {\n          key: \"timeAggregate\",\n          value: function timeAggregate(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeAggregate()\"));\n            }\n            var time = process.hrtime(prev);\n            this[TIMERS_SYMBOL].delete(label);\n            this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();\n            var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n            if (current !== undefined) {\n              if (time[1] + current[1] > 1e9) {\n                time[0] += current[0] + 1;\n                time[1] = time[1] - 1e9 + current[1];\n              } else {\n                time[0] += current[0];\n                time[1] += current[1];\n              }\n            }\n            this[TIMERS_AGGREGATES_SYMBOL].set(label, time);\n          }\n        }, {\n          key: \"timeAggregateEnd\",\n          value: function timeAggregateEnd(label) {\n            if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;\n            var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n            if (time === undefined) return;\n            this[TIMERS_AGGREGATES_SYMBOL].delete(label);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }]);\n        return WebpackLogger;\n      }();\n      exports.Logger = WebpackLogger;\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/createConsoleLogger.js\": (\n    /*!*****************************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!\n      \\*****************************************************************/\n    /***/\n    function (module, __unused_webpack_exports, __nested_webpack_require_13160__) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n      }\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n      }\n      function _iterableToArray(iter) {\n        if (typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) !== \"undefined\" && iter[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n      }\n      function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n      }\n      function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n        return arr2;\n      }\n      var _require = __nested_webpack_require_13160__( /*! ./Logger */\"./node_modules/webpack/lib/logging/Logger.js\"),\n        LogType = _require.LogType;\n\n      /** @typedef {import(\"../../declarations/WebpackOptions\").FilterItemTypes} FilterItemTypes */\n      /** @typedef {import(\"../../declarations/WebpackOptions\").FilterTypes} FilterTypes */\n      /** @typedef {import(\"./Logger\").LogTypeEnum} LogTypeEnum */\n\n      /** @typedef {function(string): boolean} FilterFunction */\n\n      /**\n       * @typedef {Object} LoggerConsole\n       * @property {function(): void} clear\n       * @property {function(): void} trace\n       * @property {(...args: any[]) => void} info\n       * @property {(...args: any[]) => void} log\n       * @property {(...args: any[]) => void} warn\n       * @property {(...args: any[]) => void} error\n       * @property {(...args: any[]) => void=} debug\n       * @property {(...args: any[]) => void=} group\n       * @property {(...args: any[]) => void=} groupCollapsed\n       * @property {(...args: any[]) => void=} groupEnd\n       * @property {(...args: any[]) => void=} status\n       * @property {(...args: any[]) => void=} profile\n       * @property {(...args: any[]) => void=} profileEnd\n       * @property {(...args: any[]) => void=} logTime\n       */\n\n      /**\n       * @typedef {Object} LoggerOptions\n       * @property {false|true|\"none\"|\"error\"|\"warn\"|\"info\"|\"log\"|\"verbose\"} level loglevel\n       * @property {FilterTypes|boolean} debug filter for debug logging\n       * @property {LoggerConsole} console the console to log to\n       */\n\n      /**\n       * @param {FilterItemTypes} item an input item\n       * @returns {FilterFunction} filter function\n       */\n      var filterToFunction = function filterToFunction(item) {\n        if (typeof item === \"string\") {\n          var regExp = new RegExp(\"[\\\\\\\\/]\".concat(item.replace(\n          // eslint-disable-next-line no-useless-escape\n          /[-[\\]{}()*+?.\\\\^$|]/g, \"\\\\$&\"), \"([\\\\\\\\/]|$|!|\\\\?)\"));\n          return function (ident) {\n            return regExp.test(ident);\n          };\n        }\n        if (item && typeof item === \"object\" && typeof item.test === \"function\") {\n          return function (ident) {\n            return item.test(ident);\n          };\n        }\n        if (typeof item === \"function\") {\n          return item;\n        }\n        if (typeof item === \"boolean\") {\n          return function () {\n            return item;\n          };\n        }\n      };\n\n      /**\n       * @enum {number}\n       */\n      var LogLevel = {\n        none: 6,\n        false: 6,\n        error: 5,\n        warn: 4,\n        info: 3,\n        log: 2,\n        true: 2,\n        verbose: 1\n      };\n\n      /**\n       * @param {LoggerOptions} options options object\n       * @returns {function(string, LogTypeEnum, any[]): void} logging function\n       */\n      module.exports = function (_ref) {\n        var _ref$level = _ref.level,\n          level = _ref$level === void 0 ? \"info\" : _ref$level,\n          _ref$debug = _ref.debug,\n          debug = _ref$debug === void 0 ? false : _ref$debug,\n          console = _ref.console;\n        var debugFilters = typeof debug === \"boolean\" ? [function () {\n          return debug;\n        }] : /** @type {FilterItemTypes[]} */[].concat(debug).map(filterToFunction);\n        /** @type {number} */\n        var loglevel = LogLevel[\"\".concat(level)] || 0;\n\n        /**\n         * @param {string} name name of the logger\n         * @param {LogTypeEnum} type type of the log entry\n         * @param {any[]} args arguments of the log entry\n         * @returns {void}\n         */\n        var logger = function logger(name, type, args) {\n          var labeledArgs = function labeledArgs() {\n            if (Array.isArray(args)) {\n              if (args.length > 0 && typeof args[0] === \"string\") {\n                return [\"[\".concat(name, \"] \").concat(args[0])].concat(_toConsumableArray(args.slice(1)));\n              } else {\n                return [\"[\".concat(name, \"]\")].concat(_toConsumableArray(args));\n              }\n            } else {\n              return [];\n            }\n          };\n          var debug = debugFilters.some(function (f) {\n            return f(name);\n          });\n          switch (type) {\n            case LogType.debug:\n              if (!debug) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.debug === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.debug.apply(console, _toConsumableArray(labeledArgs()));\n              } else {\n                console.log.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.log:\n              if (!debug && loglevel > LogLevel.log) return;\n              console.log.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.info:\n              if (!debug && loglevel > LogLevel.info) return;\n              console.info.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.warn:\n              if (!debug && loglevel > LogLevel.warn) return;\n              console.warn.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.error:\n              if (!debug && loglevel > LogLevel.error) return;\n              console.error.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.trace:\n              if (!debug) return;\n              console.trace();\n              break;\n            case LogType.groupCollapsed:\n              if (!debug && loglevel > LogLevel.log) return;\n              if (!debug && loglevel > LogLevel.verbose) {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                if (typeof console.groupCollapsed === \"function\") {\n                  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                  console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));\n                } else {\n                  console.log.apply(console, _toConsumableArray(labeledArgs()));\n                }\n                break;\n              }\n            // falls through\n            case LogType.group:\n              if (!debug && loglevel > LogLevel.log) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.group === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.group.apply(console, _toConsumableArray(labeledArgs()));\n              } else {\n                console.log.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.groupEnd:\n              if (!debug && loglevel > LogLevel.log) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.groupEnd === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.groupEnd();\n              }\n              break;\n            case LogType.time:\n              {\n                if (!debug && loglevel > LogLevel.log) return;\n                var ms = args[1] * 1000 + args[2] / 1000000;\n                var msg = \"[\".concat(name, \"] \").concat(args[0], \": \").concat(ms, \" ms\");\n                if (typeof console.logTime === \"function\") {\n                  console.logTime(msg);\n                } else {\n                  console.log(msg);\n                }\n                break;\n              }\n            case LogType.profile:\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.profile === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.profile.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.profileEnd:\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.profileEnd === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.clear:\n              if (!debug && loglevel > LogLevel.log) return;\n              // eslint-disable-next-line node/no-unsupported-features/node-builtins\n              if (typeof console.clear === \"function\") {\n                // eslint-disable-next-line node/no-unsupported-features/node-builtins\n                console.clear();\n              }\n              break;\n            case LogType.status:\n              if (!debug && loglevel > LogLevel.info) return;\n              if (typeof console.status === \"function\") {\n                if (args.length === 0) {\n                  console.status();\n                } else {\n                  console.status.apply(console, _toConsumableArray(labeledArgs()));\n                }\n              } else {\n                if (args.length !== 0) {\n                  console.info.apply(console, _toConsumableArray(labeledArgs()));\n                }\n              }\n              break;\n            default:\n              throw new Error(\"Unexpected LogType \".concat(type));\n          }\n        };\n        return logger;\n      };\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/runtime.js\": (\n    /*!*****************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/runtime.js ***!\n      \\*****************************************************/\n    /***/\n    function (__unused_webpack_module, exports, __nested_webpack_require_24776__) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _extends() {\n        _extends = Object.assign ? Object.assign.bind() : function (target) {\n          for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n            for (var key in source) {\n              if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n              }\n            }\n          }\n          return target;\n        };\n        return _extends.apply(this, arguments);\n      }\n      var SyncBailHook = __nested_webpack_require_24776__( /*! tapable/lib/SyncBailHook */\"./client-src/modules/logger/SyncBailHookFake.js\");\n      var _require = __nested_webpack_require_24776__( /*! ./Logger */\"./node_modules/webpack/lib/logging/Logger.js\"),\n        Logger = _require.Logger;\n      var createConsoleLogger = __nested_webpack_require_24776__( /*! ./createConsoleLogger */\"./node_modules/webpack/lib/logging/createConsoleLogger.js\");\n\n      /** @type {createConsoleLogger.LoggerOptions} */\n      var currentDefaultLoggerOptions = {\n        level: \"info\",\n        debug: false,\n        console: console\n      };\n      var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n\n      /**\n       * @param {string} name name of the logger\n       * @returns {Logger} a logger\n       */\n      exports.getLogger = function (name) {\n        return new Logger(function (type, args) {\n          if (exports.hooks.log.call(name, type, args) === undefined) {\n            currentDefaultLogger(name, type, args);\n          }\n        }, function (childName) {\n          return exports.getLogger(\"\".concat(name, \"/\").concat(childName));\n        });\n      };\n\n      /**\n       * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options\n       * @returns {void}\n       */\n      exports.configureDefaultLogger = function (options) {\n        _extends(currentDefaultLoggerOptions, options);\n        currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n      };\n      exports.hooks = {\n        log: new SyncBailHook([\"origin\", \"type\", \"args\"])\n      };\n\n      /***/\n    })\n\n    /******/\n  };\n  /************************************************************************/\n  /******/ // The module cache\n  /******/\n  var __webpack_module_cache__ = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __nested_webpack_require_27242__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n    if (cachedModule !== undefined) {\n      /******/return cachedModule.exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/ // no module.id needed\n      /******/ // no module.loaded needed\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_27242__);\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /************************************************************************/\n  /******/ /* webpack/runtime/define property getters */\n  /******/\n  !function () {\n    /******/ // define getter functions for harmony exports\n    /******/__nested_webpack_require_27242__.d = function (exports, definition) {\n      /******/for (var key in definition) {\n        /******/if (__nested_webpack_require_27242__.o(definition, key) && !__nested_webpack_require_27242__.o(exports, key)) {\n          /******/Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key]\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  }();\n  /******/\n  /******/ /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  !function () {\n    /******/__nested_webpack_require_27242__.o = function (obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n    /******/\n  }();\n  /******/\n  /******/ /* webpack/runtime/make namespace object */\n  /******/\n  !function () {\n    /******/ // define __esModule on exports\n    /******/__nested_webpack_require_27242__.r = function (exports) {\n      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        /******/Object.defineProperty(exports, Symbol.toStringTag, {\n          value: 'Module'\n        });\n        /******/\n      }\n      /******/\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      /******/\n    };\n    /******/\n  }();\n  /******/\n  /************************************************************************/\n  var __nested_webpack_exports__ = {};\n  // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n  !function () {\n    /*!********************************************!*\\\n      !*** ./client-src/modules/logger/index.js ***!\n      \\********************************************/\n    __nested_webpack_require_27242__.r(__nested_webpack_exports__);\n    /* harmony export */\n    __nested_webpack_require_27242__.d(__nested_webpack_exports__, {\n      /* harmony export */\"default\": function () {\n        return /* reexport default export from named module */webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__;\n      }\n      /* harmony export */\n    });\n    /* harmony import */\n    var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27242__( /*! webpack/lib/logging/runtime.js */\"./node_modules/webpack/lib/logging/runtime.js\");\n  }();\n  var __webpack_export_target__ = exports;\n  for (var i in __nested_webpack_exports__) __webpack_export_target__[i] = __nested_webpack_exports__[i];\n  if (__nested_webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", {\n    value: true\n  });\n  /******/\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSwwQkFBMEIsU0FBUztBQUNuQzs7QUFFQSwwQkFBMEIsU0FBUztBQUNuQzs7QUFFQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQSw2QkFBNkIsWUFBWTtBQUN6Qzs7QUFFQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBLCtCQUEr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QW1CO0FBQ3ZGLE1BQU0sMEJBQW1CO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcz82MmVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovKGZ1bmN0aW9uICgpIHtcbiAgLy8gd2VicGFja0Jvb3RzdHJhcFxuICAvKioqKioqL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKioqKioqL1xuICB2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IHtcbiAgICAvKioqL1wiLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL1N5bmNCYWlsSG9va0Zha2UuanNcIjogKFxuICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAhKioqIC4vY2xpZW50LXNyYy9tb2R1bGVzL2xvZ2dlci9TeW5jQmFpbEhvb2tGYWtlLmpzICoqKiFcbiAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQ2xpZW50IHN0dWIgZm9yIHRhcGFibGUgU3luY0JhaWxIb29rXG4gICAgICAgKi9cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xpZW50VGFwYWJsZVN5bmNCYWlsSG9vaygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYWxsOiBmdW5jdGlvbiBjYWxsKCkge31cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8qKiovXG4gICAgfSksXG4gICAgLyoqKi9cIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzXCI6IChcbiAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qcyAqKiohXG4gICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgIC8qXG4gICAgICBcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gICAgICBcdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgICAgIGlmICghbykgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgICAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgICAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgICAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICAgICAgICByZXR1cm4gYXJyMjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gICAgICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgICAgIHZhciBwcmltID0gaW5wdXRbKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS50b1ByaW1pdGl2ZV07XG4gICAgICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gICAgICB9XG4gICAgICB2YXIgTG9nVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBlcnJvcjogLyoqIEB0eXBlIHtcImVycm9yXCJ9ICovXCJlcnJvclwiLFxuICAgICAgICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICAgICAgICB3YXJuOiAvKiogQHR5cGUge1wid2FyblwifSAqL1wid2FyblwiLFxuICAgICAgICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICAgICAgICBpbmZvOiAvKiogQHR5cGUge1wiaW5mb1wifSAqL1wiaW5mb1wiLFxuICAgICAgICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICAgICAgICBsb2c6IC8qKiBAdHlwZSB7XCJsb2dcIn0gKi9cImxvZ1wiLFxuICAgICAgICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICAgICAgICBkZWJ1ZzogLyoqIEB0eXBlIHtcImRlYnVnXCJ9ICovXCJkZWJ1Z1wiLFxuICAgICAgICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuXG4gICAgICAgIHRyYWNlOiAvKiogQHR5cGUge1widHJhY2VcIn0gKi9cInRyYWNlXCIsXG4gICAgICAgIC8vIG5vIGFyZ3VtZW50c1xuXG4gICAgICAgIGdyb3VwOiAvKiogQHR5cGUge1wiZ3JvdXBcIn0gKi9cImdyb3VwXCIsXG4gICAgICAgIC8vIFtsYWJlbF1cbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IC8qKiBAdHlwZSB7XCJncm91cENvbGxhcHNlZFwifSAqL1wiZ3JvdXBDb2xsYXBzZWRcIixcbiAgICAgICAgLy8gW2xhYmVsXVxuICAgICAgICBncm91cEVuZDogLyoqIEB0eXBlIHtcImdyb3VwRW5kXCJ9ICovXCJncm91cEVuZFwiLFxuICAgICAgICAvLyBbbGFiZWxdXG5cbiAgICAgICAgcHJvZmlsZTogLyoqIEB0eXBlIHtcInByb2ZpbGVcIn0gKi9cInByb2ZpbGVcIixcbiAgICAgICAgLy8gW3Byb2ZpbGVOYW1lXVxuICAgICAgICBwcm9maWxlRW5kOiAvKiogQHR5cGUge1wicHJvZmlsZUVuZFwifSAqL1wicHJvZmlsZUVuZFwiLFxuICAgICAgICAvLyBbcHJvZmlsZU5hbWVdXG5cbiAgICAgICAgdGltZTogLyoqIEB0eXBlIHtcInRpbWVcIn0gKi9cInRpbWVcIixcbiAgICAgICAgLy8gbmFtZSwgdGltZSBhcyBbc2Vjb25kcywgbmFub3NlY29uZHNdXG5cbiAgICAgICAgY2xlYXI6IC8qKiBAdHlwZSB7XCJjbGVhclwifSAqL1wiY2xlYXJcIixcbiAgICAgICAgLy8gbm8gYXJndW1lbnRzXG4gICAgICAgIHN0YXR1czogLyoqIEB0eXBlIHtcInN0YXR1c1wifSAqL1wic3RhdHVzXCIgLy8gbWVzc2FnZSwgYXJndW1lbnRzXG4gICAgICB9KTtcbiAgICAgIGV4cG9ydHMuTG9nVHlwZSA9IExvZ1R5cGU7XG5cbiAgICAgIC8qKiBAdHlwZWRlZiB7dHlwZW9mIExvZ1R5cGVba2V5b2YgdHlwZW9mIExvZ1R5cGVdfSBMb2dUeXBlRW51bSAqL1xuXG4gICAgICB2YXIgTE9HX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KShcIndlYnBhY2sgbG9nZ2VyIHJhdyBsb2cgbWV0aG9kXCIpO1xuICAgICAgdmFyIFRJTUVSU19TWU1CT0wgPSAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSkoXCJ3ZWJwYWNrIGxvZ2dlciB0aW1lc1wiKTtcbiAgICAgIHZhciBUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0wgPSAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSkoXCJ3ZWJwYWNrIGxvZ2dlciBhZ2dyZWdhdGVkIHRpbWVzXCIpO1xuICAgICAgdmFyIFdlYnBhY2tMb2dnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihMb2dUeXBlRW51bSwgYW55W109KTogdm9pZH0gbG9nIGxvZyBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyB8IGZ1bmN0aW9uKCk6IHN0cmluZyk6IFdlYnBhY2tMb2dnZXJ9IGdldENoaWxkTG9nZ2VyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBjaGlsZCBsb2dnZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFdlYnBhY2tMb2dnZXIobG9nLCBnZXRDaGlsZExvZ2dlcikge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJwYWNrTG9nZ2VyKTtcbiAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdID0gbG9nO1xuICAgICAgICAgIHRoaXMuZ2V0Q2hpbGRMb2dnZXIgPSBnZXRDaGlsZExvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBfY3JlYXRlQ2xhc3MoV2VicGFja0xvZ2dlciwgW3tcbiAgICAgICAgICBrZXk6IFwiZXJyb3JcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5lcnJvciwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIndhcm5cIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2FybigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUud2FybiwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImluZm9cIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbygpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuaW5mbywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImxvZ1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2coKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmxvZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRlYnVnXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5kZWJ1ZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImFzc2VydFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYgPiAxID8gX2xlbjYgLSAxIDogMCksIF9rZXk2ID0gMTsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleTYgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmVycm9yLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidHJhY2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudHJhY2UsIFtcIlRyYWNlXCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuY2xlYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGF0dXNcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdHVzKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5zdGF0dXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJncm91cFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOCksIF9rZXk4ID0gMDsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZ3JvdXAsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJncm91cENvbGxhcHNlZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cENvbGxhcHNlZCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW45ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOSksIF9rZXk5ID0gMDsgX2tleTkgPCBfbGVuOTsgX2tleTkrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXk5XSA9IGFyZ3VtZW50c1tfa2V5OV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZ3JvdXBDb2xsYXBzZWQsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJncm91cEVuZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cEVuZCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5ncm91cEVuZCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInByb2ZpbGVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZmlsZShsYWJlbCkge1xuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnByb2ZpbGUsIFtsYWJlbF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJwcm9maWxlRW5kXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2ZpbGVFbmQobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS5wcm9maWxlRW5kLCBbbGFiZWxdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidGltZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19TWU1CT0xdID0gdGhpc1tUSU1FUlNfU1lNQk9MXSB8fCBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19TWU1CT0xdLnNldChsYWJlbCwgcHJvY2Vzcy5ocnRpbWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInRpbWVMb2dcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUxvZyhsYWJlbCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzW1RJTUVSU19TWU1CT0xdICYmIHRoaXNbVElNRVJTX1NZTUJPTF0uZ2V0KGxhYmVsKTtcbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsICdcIi5jb25jYXQobGFiZWwsIFwiJyBmb3IgV2VicGFja0xvZ2dlci50aW1lTG9nKClcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgICAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50aW1lLCBbbGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGltZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwidGltZUVuZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWwgJ1wiLmNvbmNhdChsYWJlbCwgXCInIGZvciBXZWJwYWNrTG9nZ2VyLnRpbWVFbmQoKVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKHByZXYpO1xuICAgICAgICAgICAgdGhpc1tUSU1FUlNfU1lNQk9MXS5kZWxldGUobGFiZWwpO1xuICAgICAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnRpbWUsIFtsYWJlbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aW1lKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0aW1lQWdncmVnYXRlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVBZ2dyZWdhdGUobGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpc1tUSU1FUlNfU1lNQk9MXSAmJiB0aGlzW1RJTUVSU19TWU1CT0xdLmdldChsYWJlbCk7XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUFnZ3JlZ2F0ZSgpXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUocHJldik7XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19TWU1CT0xdLmRlbGV0ZShsYWJlbCk7XG4gICAgICAgICAgICB0aGlzW1RJTUVSU19BR0dSRUdBVEVTX1NZTUJPTF0gPSB0aGlzW1RJTUVSU19BR0dSRUdBVEVTX1NZTUJPTF0gfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzW1RJTUVSU19BR0dSRUdBVEVTX1NZTUJPTF0uZ2V0KGxhYmVsKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHRpbWVbMV0gKyBjdXJyZW50WzFdID4gMWU5KSB7XG4gICAgICAgICAgICAgICAgdGltZVswXSArPSBjdXJyZW50WzBdICsgMTtcbiAgICAgICAgICAgICAgICB0aW1lWzFdID0gdGltZVsxXSAtIDFlOSArIGN1cnJlbnRbMV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGltZVswXSArPSBjdXJyZW50WzBdO1xuICAgICAgICAgICAgICAgIHRpbWVbMV0gKz0gY3VycmVudFsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLnNldChsYWJlbCwgdGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInRpbWVBZ2dyZWdhdGVFbmRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUFnZ3JlZ2F0ZUVuZChsYWJlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGltZSA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXS5nZXQobGFiZWwpO1xuICAgICAgICAgICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLmRlbGV0ZShsYWJlbCk7XG4gICAgICAgICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudGltZSwgW2xhYmVsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRpbWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHJldHVybiBXZWJwYWNrTG9nZ2VyO1xuICAgICAgfSgpO1xuICAgICAgZXhwb3J0cy5Mb2dnZXIgPSBXZWJwYWNrTG9nZ2VyO1xuXG4gICAgICAvKioqL1xuICAgIH0pLFxuICAgIC8qKiovXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL2NyZWF0ZUNvbnNvbGVMb2dnZXIuanNcIjogKFxuICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL2NyZWF0ZUNvbnNvbGVMb2dnZXIuanMgKioqIVxuICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqL1xuICAgIGZ1bmN0aW9uIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgLypcbiAgICAgIFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgICAgIFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICAgICAgaWYgKCFvKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICAgICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgICAgICBpZiAodHlwZW9mICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlclsodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbCA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICAgIHJldHVybiBhcnIyO1xuICAgICAgfVxuICAgICAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggLyohIC4vTG9nZ2VyICovXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qc1wiKSxcbiAgICAgICAgTG9nVHlwZSA9IF9yZXF1aXJlLkxvZ1R5cGU7XG5cbiAgICAgIC8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZGVjbGFyYXRpb25zL1dlYnBhY2tPcHRpb25zXCIpLkZpbHRlckl0ZW1UeXBlc30gRmlsdGVySXRlbVR5cGVzICovXG4gICAgICAvKiogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2RlY2xhcmF0aW9ucy9XZWJwYWNrT3B0aW9uc1wiKS5GaWx0ZXJUeXBlc30gRmlsdGVyVHlwZXMgKi9cbiAgICAgIC8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9Mb2dnZXJcIikuTG9nVHlwZUVudW19IExvZ1R5cGVFbnVtICovXG5cbiAgICAgIC8qKiBAdHlwZWRlZiB7ZnVuY3Rpb24oc3RyaW5nKTogYm9vbGVhbn0gRmlsdGVyRnVuY3Rpb24gKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dnZXJDb25zb2xlXG4gICAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IHZvaWR9IGNsZWFyXG4gICAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IHZvaWR9IHRyYWNlXG4gICAgICAgKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gaW5mb1xuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGxvZ1xuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IHdhcm5cbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBlcnJvclxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBkZWJ1Z1xuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBncm91cFxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBncm91cENvbGxhcHNlZFxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBncm91cEVuZFxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBzdGF0dXNcbiAgICAgICAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gcHJvZmlsZVxuICAgICAgICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBwcm9maWxlRW5kXG4gICAgICAgKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IGxvZ1RpbWVcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IExvZ2dlck9wdGlvbnNcbiAgICAgICAqIEBwcm9wZXJ0eSB7ZmFsc2V8dHJ1ZXxcIm5vbmVcInxcImVycm9yXCJ8XCJ3YXJuXCJ8XCJpbmZvXCJ8XCJsb2dcInxcInZlcmJvc2VcIn0gbGV2ZWwgbG9nbGV2ZWxcbiAgICAgICAqIEBwcm9wZXJ0eSB7RmlsdGVyVHlwZXN8Ym9vbGVhbn0gZGVidWcgZmlsdGVyIGZvciBkZWJ1ZyBsb2dnaW5nXG4gICAgICAgKiBAcHJvcGVydHkge0xvZ2dlckNvbnNvbGV9IGNvbnNvbGUgdGhlIGNvbnNvbGUgdG8gbG9nIHRvXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0ZpbHRlckl0ZW1UeXBlc30gaXRlbSBhbiBpbnB1dCBpdGVtXG4gICAgICAgKiBAcmV0dXJucyB7RmlsdGVyRnVuY3Rpb259IGZpbHRlciBmdW5jdGlvblxuICAgICAgICovXG4gICAgICB2YXIgZmlsdGVyVG9GdW5jdGlvbiA9IGZ1bmN0aW9uIGZpbHRlclRvRnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChcIltcXFxcXFxcXC9dXCIuY29uY2F0KGl0ZW0ucmVwbGFjZShcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgICAgICAvWy1bXFxde30oKSorPy5cXFxcXiR8XS9nLCBcIlxcXFwkJlwiKSwgXCIoW1xcXFxcXFxcL118JHwhfFxcXFw/KVwiKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ0V4cC50ZXN0KGlkZW50KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBpdGVtLnRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRlc3QoaWRlbnQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQGVudW0ge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdmFyIExvZ0xldmVsID0ge1xuICAgICAgICBub25lOiA2LFxuICAgICAgICBmYWxzZTogNixcbiAgICAgICAgZXJyb3I6IDUsXG4gICAgICAgIHdhcm46IDQsXG4gICAgICAgIGluZm86IDMsXG4gICAgICAgIGxvZzogMixcbiAgICAgICAgdHJ1ZTogMixcbiAgICAgICAgdmVyYm9zZTogMVxuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0xvZ2dlck9wdGlvbnN9IG9wdGlvbnMgb3B0aW9ucyBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIExvZ1R5cGVFbnVtLCBhbnlbXSk6IHZvaWR9IGxvZ2dpbmcgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZiRsZXZlbCA9IF9yZWYubGV2ZWwsXG4gICAgICAgICAgbGV2ZWwgPSBfcmVmJGxldmVsID09PSB2b2lkIDAgPyBcImluZm9cIiA6IF9yZWYkbGV2ZWwsXG4gICAgICAgICAgX3JlZiRkZWJ1ZyA9IF9yZWYuZGVidWcsXG4gICAgICAgICAgZGVidWcgPSBfcmVmJGRlYnVnID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGVidWcsXG4gICAgICAgICAgY29uc29sZSA9IF9yZWYuY29uc29sZTtcbiAgICAgICAgdmFyIGRlYnVnRmlsdGVycyA9IHR5cGVvZiBkZWJ1ZyA9PT0gXCJib29sZWFuXCIgPyBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICAgICAgfV0gOiAvKiogQHR5cGUge0ZpbHRlckl0ZW1UeXBlc1tdfSAqL1tdLmNvbmNhdChkZWJ1ZykubWFwKGZpbHRlclRvRnVuY3Rpb24pO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdmFyIGxvZ2xldmVsID0gTG9nTGV2ZWxbXCJcIi5jb25jYXQobGV2ZWwpXSB8fCAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBsb2dnZXJcbiAgICAgICAgICogQHBhcmFtIHtMb2dUeXBlRW51bX0gdHlwZSB0eXBlIG9mIHRoZSBsb2cgZW50cnlcbiAgICAgICAgICogQHBhcmFtIHthbnlbXX0gYXJncyBhcmd1bWVudHMgb2YgdGhlIGxvZyBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBsb2dnZXIgPSBmdW5jdGlvbiBsb2dnZXIobmFtZSwgdHlwZSwgYXJncykge1xuICAgICAgICAgIHZhciBsYWJlbGVkQXJncyA9IGZ1bmN0aW9uIGxhYmVsZWRBcmdzKCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCJbXCIuY29uY2F0KG5hbWUsIFwiXSBcIikuY29uY2F0KGFyZ3NbMF0pXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3Muc2xpY2UoMSkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiW1wiLmNvbmNhdChuYW1lLCBcIl1cIildLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZGVidWcgPSBkZWJ1Z0ZpbHRlcnMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIGYobmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuZGVidWc6XG4gICAgICAgICAgICAgIGlmICghZGVidWcpIHJldHVybjtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuZGVidWcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS5sb2c6XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuaW5mbzpcbiAgICAgICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmluZm8pIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLndhcm46XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC53YXJuKSByZXR1cm47XG4gICAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS5lcnJvcjpcbiAgICAgICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmVycm9yKSByZXR1cm47XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUudHJhY2U6XG4gICAgICAgICAgICAgIGlmICghZGVidWcpIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS5ncm91cENvbGxhcHNlZDpcbiAgICAgICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZC5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLmdyb3VwOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmdyb3VwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cC5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuZ3JvdXBFbmQ6XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuZ3JvdXBFbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUudGltZTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbXMgPSBhcmdzWzFdICogMTAwMCArIGFyZ3NbMl0gLyAxMDAwMDAwO1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIltcIi5jb25jYXQobmFtZSwgXCJdIFwiKS5jb25jYXQoYXJnc1swXSwgXCI6IFwiKS5jb25jYXQobXMsIFwiIG1zXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5sb2dUaW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nVGltZShtc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBMb2dUeXBlLnByb2ZpbGU6XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnByb2ZpbGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICBjb25zb2xlLnByb2ZpbGUuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTG9nVHlwZS5wcm9maWxlRW5kOlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5wcm9maWxlRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgY29uc29sZS5wcm9maWxlRW5kLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuY2xlYXI6XG4gICAgICAgICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuY2xlYXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ1R5cGUuc3RhdHVzOlxuICAgICAgICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwuaW5mbykgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuc3RhdHVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuc3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuc3RhdHVzLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBMb2dUeXBlIFwiLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgICAgfTtcblxuICAgICAgLyoqKi9cbiAgICB9KSxcbiAgICAvKioqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzXCI6IChcbiAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICEqKiogLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzICoqKiFcbiAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqKi9cbiAgICBmdW5jdGlvbiAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgIC8qXG4gICAgICBcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gICAgICBcdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgICAgICovXG5cbiAgICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgdmFyIFN5bmNCYWlsSG9vayA9IF9fd2VicGFja19yZXF1aXJlX18oIC8qISB0YXBhYmxlL2xpYi9TeW5jQmFpbEhvb2sgKi9cIi4vY2xpZW50LXNyYy9tb2R1bGVzL2xvZ2dlci9TeW5jQmFpbEhvb2tGYWtlLmpzXCIpO1xuICAgICAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyggLyohIC4vTG9nZ2VyICovXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qc1wiKSxcbiAgICAgICAgTG9nZ2VyID0gX3JlcXVpcmUuTG9nZ2VyO1xuICAgICAgdmFyIGNyZWF0ZUNvbnNvbGVMb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKCAvKiEgLi9jcmVhdGVDb25zb2xlTG9nZ2VyICovXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL2NyZWF0ZUNvbnNvbGVMb2dnZXIuanNcIik7XG5cbiAgICAgIC8qKiBAdHlwZSB7Y3JlYXRlQ29uc29sZUxvZ2dlci5Mb2dnZXJPcHRpb25zfSAqL1xuICAgICAgdmFyIGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucyA9IHtcbiAgICAgICAgbGV2ZWw6IFwiaW5mb1wiLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGNvbnNvbGU6IGNvbnNvbGVcbiAgICAgIH07XG4gICAgICB2YXIgY3VycmVudERlZmF1bHRMb2dnZXIgPSBjcmVhdGVDb25zb2xlTG9nZ2VyKGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbG9nZ2VyXG4gICAgICAgKiBAcmV0dXJucyB7TG9nZ2VyfSBhIGxvZ2dlclxuICAgICAgICovXG4gICAgICBleHBvcnRzLmdldExvZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKGZ1bmN0aW9uICh0eXBlLCBhcmdzKSB7XG4gICAgICAgICAgaWYgKGV4cG9ydHMuaG9va3MubG9nLmNhbGwobmFtZSwgdHlwZSwgYXJncykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudERlZmF1bHRMb2dnZXIobmFtZSwgdHlwZSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2V0TG9nZ2VyKFwiXCIuY29uY2F0KG5hbWUsIFwiL1wiKS5jb25jYXQoY2hpbGROYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2NyZWF0ZUNvbnNvbGVMb2dnZXIuTG9nZ2VyT3B0aW9uc30gb3B0aW9ucyBuZXcgb3B0aW9ucywgbWVyZ2Ugd2l0aCBvbGQgb3B0aW9uc1xuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGV4cG9ydHMuY29uZmlndXJlRGVmYXVsdExvZ2dlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIF9leHRlbmRzKGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGN1cnJlbnREZWZhdWx0TG9nZ2VyID0gY3JlYXRlQ29uc29sZUxvZ2dlcihjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIGV4cG9ydHMuaG9va3MgPSB7XG4gICAgICAgIGxvZzogbmV3IFN5bmNCYWlsSG9vayhbXCJvcmlnaW5cIiwgXCJ0eXBlXCIsIFwiYXJnc1wiXSlcbiAgICAgIH07XG5cbiAgICAgIC8qKiovXG4gICAgfSlcblxuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbiAgLyoqKioqKi9cbiAgdmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuICAvKioqKioqL1xuICAvKioqKioqLyAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuICAvKioqKioqL1xuICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgLyoqKioqKi8gLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gICAgLyoqKioqKi92YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbiAgICAvKioqKioqL1xuICAgIGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqKioqKi9yZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4gICAgICAvKioqKioqL1xuICAgIH1cbiAgICAvKioqKioqLyAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuICAgIC8qKioqKiovXG4gICAgdmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4gICAgICAvKioqKioqLyAvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4gICAgICAvKioqKioqLyAvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuICAgICAgLyoqKioqKi9leHBvcnRzOiB7fVxuICAgICAgLyoqKioqKi9cbiAgICB9O1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi8gLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gICAgLyoqKioqKi9cbiAgICBfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gICAgLyoqKioqKi9cbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gICAgLyoqKioqKi9cbiAgfVxuICAvKioqKioqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbiAgLyoqKioqKi9cbiAgIWZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqLyAvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4gICAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbiAoZXhwb3J0cywgZGVmaW5pdGlvbikge1xuICAgICAgLyoqKioqKi9mb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuICAgICAgICAvKioqKioqL2lmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbiAgICAgICAgICAvKioqKioqL09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGRlZmluaXRpb25ba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH1cbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH1cbiAgICAgIC8qKioqKiovXG4gICAgfTtcbiAgICAvKioqKioqL1xuICB9KCk7XG4gIC8qKioqKiovXG4gIC8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbiAgLyoqKioqKi9cbiAgIWZ1bmN0aW9uICgpIHtcbiAgICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uIChvYmosIHByb3ApIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbiAgICB9O1xuICAgIC8qKioqKiovXG4gIH0oKTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuICAvKioqKioqL1xuICAhZnVuY3Rpb24gKCkge1xuICAgIC8qKioqKiovIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiAgICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgICAvKioqKioqL2lmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgICAgLyoqKioqKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgdmFsdWU6ICdNb2R1bGUnXG4gICAgICAgIH0pO1xuICAgICAgICAvKioqKioqL1xuICAgICAgfVxuICAgICAgLyoqKioqKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgLyoqKioqKi9cbiAgICB9O1xuICAgIC8qKioqKiovXG4gIH0oKTtcbiAgLyoqKioqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgdmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbiAgLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbiAgIWZ1bmN0aW9uICgpIHtcbiAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICEqKiogLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL2luZGV4LmpzICoqKiFcbiAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovXG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovXCJkZWZhdWx0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC8qIHJlZXhwb3J0IGRlZmF1bHQgZXhwb3J0IGZyb20gbmFtZWQgbW9kdWxlICovd2VicGFja19saWJfbG9nZ2luZ19ydW50aW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX187XG4gICAgICB9XG4gICAgICAvKiBoYXJtb255IGV4cG9ydCAqL1xuICAgIH0pO1xuICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG4gICAgdmFyIHdlYnBhY2tfbGliX2xvZ2dpbmdfcnVudGltZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyggLyohIHdlYnBhY2svbGliL2xvZ2dpbmcvcnVudGltZS5qcyAqL1wiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzXCIpO1xuICB9KCk7XG4gIHZhciBfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fID0gZXhwb3J0cztcbiAgZm9yICh2YXIgaSBpbiBfX3dlYnBhY2tfZXhwb3J0c19fKSBfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fW2ldID0gX193ZWJwYWNrX2V4cG9ydHNfX1tpXTtcbiAgaWYgKF9fd2VicGFja19leHBvcnRzX18uX19lc01vZHVsZSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRfdGFyZ2V0X18sIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIC8qKioqKiovXG59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/modules/logger/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOverlay: () => (/* binding */ createOverlay),\n/* harmony export */   formatProblem: () => (/* binding */ formatProblem)\n/* harmony export */ });\n/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-html-community */ \"./node_modules/ansi-html-community/index.js\");\n/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ansi_html_community__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! html-entities */ \"./node_modules/html-entities/lib/index.js\");\n/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(html_entities__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overlay/runtime-error.js */ \"./node_modules/webpack-dev-server/client/overlay/runtime-error.js\");\n/* harmony import */ var _overlay_state_machine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay/state-machine.js */ \"./node_modules/webpack-dev-server/client/overlay/state-machine.js\");\n/* harmony import */ var _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlay/styles.js */ \"./node_modules/webpack-dev-server/client/overlay/styles.js\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\n\n\n\n\n\n\nvar colors = {\n  reset: [\"transparent\", \"transparent\"],\n  black: \"181818\",\n  red: \"E36049\",\n  green: \"B3CB74\",\n  yellow: \"FFD080\",\n  blue: \"7CAFC2\",\n  magenta: \"7FACCA\",\n  cyan: \"C3C2EF\",\n  lightgrey: \"EBE7E3\",\n  darkgrey: \"6D7891\"\n};\nansi_html_community__WEBPACK_IMPORTED_MODULE_0___default().setColors(colors);\n\n/**\n * @param {string} type\n * @param {string  | { file?: string, moduleName?: string, loc?: string, message?: string; stack?: string[] }} item\n * @returns {{ header: string, body: string }}\n */\nfunction formatProblem(type, item) {\n  var header = type === \"warning\" ? \"WARNING\" : \"ERROR\";\n  var body = \"\";\n  if (typeof item === \"string\") {\n    body += item;\n  } else {\n    var file = item.file || \"\";\n    // eslint-disable-next-line no-nested-ternary\n    var moduleName = item.moduleName ? item.moduleName.indexOf(\"!\") !== -1 ? \"\".concat(item.moduleName.replace(/^(\\s|\\S)*!/, \"\"), \" (\").concat(item.moduleName, \")\") : \"\".concat(item.moduleName) : \"\";\n    var loc = item.loc;\n    header += \"\".concat(moduleName || file ? \" in \".concat(moduleName ? \"\".concat(moduleName).concat(file ? \" (\".concat(file, \")\") : \"\") : file).concat(loc ? \" \".concat(loc) : \"\") : \"\");\n    body += item.message || \"\";\n  }\n  if (Array.isArray(item.stack)) {\n    item.stack.forEach(function (stack) {\n      if (typeof stack === \"string\") {\n        body += \"\\r\\n\".concat(stack);\n      }\n    });\n  }\n  return {\n    header: header,\n    body: body\n  };\n}\n\n/**\n * @typedef {Object} CreateOverlayOptions\n * @property {string | null} trustedTypesPolicyName\n * @property {boolean | (error: Error) => void} [catchRuntimeError]\n */\n\n/**\n *\n * @param {CreateOverlayOptions} options\n */\nvar createOverlay = function createOverlay(options) {\n  /** @type {HTMLIFrameElement | null | undefined} */\n  var iframeContainerElement;\n  /** @type {HTMLDivElement | null | undefined} */\n  var containerElement;\n  /** @type {HTMLDivElement | null | undefined} */\n  var headerElement;\n  /** @type {Array<(element: HTMLDivElement) => void>} */\n  var onLoadQueue = [];\n  /** @type {TrustedTypePolicy | undefined} */\n  var overlayTrustedTypesPolicy;\n\n  /**\n   *\n   * @param {HTMLElement} element\n   * @param {CSSStyleDeclaration} style\n   */\n  function applyStyle(element, style) {\n    Object.keys(style).forEach(function (prop) {\n      element.style[prop] = style[prop];\n    });\n  }\n\n  /**\n   * @param {string | null} trustedTypesPolicyName\n   */\n  function createContainer(trustedTypesPolicyName) {\n    // Enable Trusted Types if they are available in the current browser.\n    if (window.trustedTypes) {\n      overlayTrustedTypesPolicy = window.trustedTypes.createPolicy(trustedTypesPolicyName || \"webpack-dev-server#overlay\", {\n        createHTML: function createHTML(value) {\n          return value;\n        }\n      });\n    }\n    iframeContainerElement = document.createElement(\"iframe\");\n    iframeContainerElement.id = \"webpack-dev-server-client-overlay\";\n    iframeContainerElement.src = \"about:blank\";\n    applyStyle(iframeContainerElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.iframeStyle);\n    iframeContainerElement.onload = function () {\n      var contentElement = /** @type {Document} */\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.contentDocument.createElement(\"div\");\n      containerElement = /** @type {Document} */\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.contentDocument.createElement(\"div\");\n      contentElement.id = \"webpack-dev-server-client-overlay-div\";\n      applyStyle(contentElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.containerStyle);\n      headerElement = document.createElement(\"div\");\n      headerElement.innerText = \"Compiled with problems:\";\n      applyStyle(headerElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.headerStyle);\n      var closeButtonElement = document.createElement(\"button\");\n      applyStyle(closeButtonElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.dismissButtonStyle);\n      closeButtonElement.innerText = \"\";\n      closeButtonElement.ariaLabel = \"Dismiss\";\n      closeButtonElement.addEventListener(\"click\", function () {\n        // eslint-disable-next-line no-use-before-define\n        overlayService.send({\n          type: \"DISMISS\"\n        });\n      });\n      contentElement.appendChild(headerElement);\n      contentElement.appendChild(closeButtonElement);\n      contentElement.appendChild(containerElement);\n\n      /** @type {Document} */\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.contentDocument.body.appendChild(contentElement);\n      onLoadQueue.forEach(function (onLoad) {\n        onLoad( /** @type {HTMLDivElement} */contentElement);\n      });\n      onLoadQueue = [];\n\n      /** @type {HTMLIFrameElement} */\n      iframeContainerElement.onload = null;\n    };\n    document.body.appendChild(iframeContainerElement);\n  }\n\n  /**\n   * @param {(element: HTMLDivElement) => void} callback\n   * @param {string | null} trustedTypesPolicyName\n   */\n  function ensureOverlayExists(callback, trustedTypesPolicyName) {\n    if (containerElement) {\n      containerElement.innerHTML = \"\";\n      // Everything is ready, call the callback right away.\n      callback(containerElement);\n      return;\n    }\n    onLoadQueue.push(callback);\n    if (iframeContainerElement) {\n      return;\n    }\n    createContainer(trustedTypesPolicyName);\n  }\n\n  // Successful compilation.\n  function hide() {\n    if (!iframeContainerElement) {\n      return;\n    }\n\n    // Clean up and reset internal state.\n    document.body.removeChild(iframeContainerElement);\n    iframeContainerElement = null;\n    containerElement = null;\n  }\n\n  // Compilation with errors (e.g. syntax error or missing modules).\n  /**\n   * @param {string} type\n   * @param {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string }>} messages\n   * @param {string | null} trustedTypesPolicyName\n   * @param {'build' | 'runtime'} messageSource\n   */\n  function show(type, messages, trustedTypesPolicyName, messageSource) {\n    ensureOverlayExists(function () {\n      headerElement.innerText = messageSource === \"runtime\" ? \"Uncaught runtime errors:\" : \"Compiled with problems:\";\n      messages.forEach(function (message) {\n        var entryElement = document.createElement(\"div\");\n        var msgStyle = type === \"warning\" ? _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgStyles.warning : _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgStyles.error;\n        applyStyle(entryElement, _objectSpread(_objectSpread({}, msgStyle), {}, {\n          padding: \"1rem 1rem 1.5rem 1rem\"\n        }));\n        var typeElement = document.createElement(\"div\");\n        var _formatProblem = formatProblem(type, message),\n          header = _formatProblem.header,\n          body = _formatProblem.body;\n        typeElement.innerText = header;\n        applyStyle(typeElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgTypeStyle);\n        if (message.moduleIdentifier) {\n          applyStyle(typeElement, {\n            cursor: \"pointer\"\n          });\n          // element.dataset not supported in IE\n          typeElement.setAttribute(\"data-can-open\", true);\n          typeElement.addEventListener(\"click\", function () {\n            fetch(\"/webpack-dev-server/open-editor?fileName=\".concat(message.moduleIdentifier));\n          });\n        }\n\n        // Make it look similar to our terminal.\n        var text = ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default()((0,html_entities__WEBPACK_IMPORTED_MODULE_4__.encode)(body));\n        var messageTextNode = document.createElement(\"div\");\n        applyStyle(messageTextNode, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgTextStyle);\n        messageTextNode.innerHTML = overlayTrustedTypesPolicy ? overlayTrustedTypesPolicy.createHTML(text) : text;\n        entryElement.appendChild(typeElement);\n        entryElement.appendChild(messageTextNode);\n\n        /** @type {HTMLDivElement} */\n        containerElement.appendChild(entryElement);\n      });\n    }, trustedTypesPolicyName);\n  }\n  var overlayService = (0,_overlay_state_machine_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n    showOverlay: function showOverlay(_ref) {\n      var _ref$level = _ref.level,\n        level = _ref$level === void 0 ? \"error\" : _ref$level,\n        messages = _ref.messages,\n        messageSource = _ref.messageSource;\n      return show(level, messages, options.trustedTypesPolicyName, messageSource);\n    },\n    hideOverlay: hide\n  });\n  if (options.catchRuntimeError) {\n    /**\n     * @param {Error | undefined} error\n     * @param {string} fallbackMessage\n     */\n    var handleError = function handleError(error, fallbackMessage) {\n      var errorObject = error instanceof Error ? error : new Error(error || fallbackMessage);\n      var shouldDisplay = typeof options.catchRuntimeError === \"function\" ? options.catchRuntimeError(errorObject) : true;\n      if (shouldDisplay) {\n        overlayService.send({\n          type: \"RUNTIME_ERROR\",\n          messages: [{\n            message: errorObject.message,\n            stack: (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.parseErrorToStacks)(errorObject)\n          }]\n        });\n      }\n    };\n    (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.listenToRuntimeError)(function (errorEvent) {\n      // error property may be empty in older browser like IE\n      var error = errorEvent.error,\n        message = errorEvent.message;\n      if (!error && !message) {\n        return;\n      }\n      handleError(error, message);\n    });\n    (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.listenToUnhandledRejection)(function (promiseRejectionEvent) {\n      var reason = promiseRejectionEvent.reason;\n      handleError(reason, \"Unknown promise rejection reason\");\n    });\n  }\n  return overlayService;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDO0FBQ0o7QUFDMkU7QUFDcEQ7QUFDNEU7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQWtCOztBQUVsQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVksb0VBQW9FLG9CQUFvQjtBQUMvRyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsa0NBQWtDO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7QUFDQSxhQUFhLCtCQUErQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQVc7QUFDbEQ7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRCxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0EsaUNBQWlDLDhEQUFjO0FBQy9DO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVc7QUFDM0M7QUFDQSxxQ0FBcUMsa0VBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0MsT0FBTztBQUNQOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQixnRkFBZ0YsR0FBRztBQUNsSCxhQUFhLGVBQWU7QUFDNUIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlEQUFTLFdBQVcseURBQVM7QUFDekUsK0RBQStELGVBQWU7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0REFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxtQkFBbUIsMERBQVEsQ0FBQyxxREFBTTtBQUNsQztBQUNBLG9DQUFvQyw0REFBWTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSx1QkFBdUIscUVBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2RUFBa0I7QUFDckMsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSSwrRUFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxxRkFBMEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcz9mMzI5Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG4vLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxuaW1wb3J0IGFuc2lIVE1MIGZyb20gXCJhbnNpLWh0bWwtY29tbXVuaXR5XCI7XG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiaHRtbC1lbnRpdGllc1wiO1xuaW1wb3J0IHsgbGlzdGVuVG9SdW50aW1lRXJyb3IsIGxpc3RlblRvVW5oYW5kbGVkUmVqZWN0aW9uLCBwYXJzZUVycm9yVG9TdGFja3MgfSBmcm9tIFwiLi9vdmVybGF5L3J1bnRpbWUtZXJyb3IuanNcIjtcbmltcG9ydCBjcmVhdGVPdmVybGF5TWFjaGluZSBmcm9tIFwiLi9vdmVybGF5L3N0YXRlLW1hY2hpbmUuanNcIjtcbmltcG9ydCB7IGNvbnRhaW5lclN0eWxlLCBkaXNtaXNzQnV0dG9uU3R5bGUsIGhlYWRlclN0eWxlLCBpZnJhbWVTdHlsZSwgbXNnU3R5bGVzLCBtc2dUZXh0U3R5bGUsIG1zZ1R5cGVTdHlsZSB9IGZyb20gXCIuL292ZXJsYXkvc3R5bGVzLmpzXCI7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogW1widHJhbnNwYXJlbnRcIiwgXCJ0cmFuc3BhcmVudFwiXSxcbiAgYmxhY2s6IFwiMTgxODE4XCIsXG4gIHJlZDogXCJFMzYwNDlcIixcbiAgZ3JlZW46IFwiQjNDQjc0XCIsXG4gIHllbGxvdzogXCJGRkQwODBcIixcbiAgYmx1ZTogXCI3Q0FGQzJcIixcbiAgbWFnZW50YTogXCI3RkFDQ0FcIixcbiAgY3lhbjogXCJDM0MyRUZcIixcbiAgbGlnaHRncmV5OiBcIkVCRTdFM1wiLFxuICBkYXJrZ3JleTogXCI2RDc4OTFcIlxufTtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZyAgfCB7IGZpbGU/OiBzdHJpbmcsIG1vZHVsZU5hbWU/OiBzdHJpbmcsIGxvYz86IHN0cmluZywgbWVzc2FnZT86IHN0cmluZzsgc3RhY2s/OiBzdHJpbmdbXSB9fSBpdGVtXG4gKiBAcmV0dXJucyB7eyBoZWFkZXI6IHN0cmluZywgYm9keTogc3RyaW5nIH19XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFByb2JsZW0odHlwZSwgaXRlbSkge1xuICB2YXIgaGVhZGVyID0gdHlwZSA9PT0gXCJ3YXJuaW5nXCIgPyBcIldBUk5JTkdcIiA6IFwiRVJST1JcIjtcbiAgdmFyIGJvZHkgPSBcIlwiO1xuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICBib2R5ICs9IGl0ZW07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpbGUgPSBpdGVtLmZpbGUgfHwgXCJcIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICB2YXIgbW9kdWxlTmFtZSA9IGl0ZW0ubW9kdWxlTmFtZSA/IGl0ZW0ubW9kdWxlTmFtZS5pbmRleE9mKFwiIVwiKSAhPT0gLTEgPyBcIlwiLmNvbmNhdChpdGVtLm1vZHVsZU5hbWUucmVwbGFjZSgvXihcXHN8XFxTKSohLywgXCJcIiksIFwiIChcIikuY29uY2F0KGl0ZW0ubW9kdWxlTmFtZSwgXCIpXCIpIDogXCJcIi5jb25jYXQoaXRlbS5tb2R1bGVOYW1lKSA6IFwiXCI7XG4gICAgdmFyIGxvYyA9IGl0ZW0ubG9jO1xuICAgIGhlYWRlciArPSBcIlwiLmNvbmNhdChtb2R1bGVOYW1lIHx8IGZpbGUgPyBcIiBpbiBcIi5jb25jYXQobW9kdWxlTmFtZSA/IFwiXCIuY29uY2F0KG1vZHVsZU5hbWUpLmNvbmNhdChmaWxlID8gXCIgKFwiLmNvbmNhdChmaWxlLCBcIilcIikgOiBcIlwiKSA6IGZpbGUpLmNvbmNhdChsb2MgPyBcIiBcIi5jb25jYXQobG9jKSA6IFwiXCIpIDogXCJcIik7XG4gICAgYm9keSArPSBpdGVtLm1lc3NhZ2UgfHwgXCJcIjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtLnN0YWNrKSkge1xuICAgIGl0ZW0uc3RhY2suZm9yRWFjaChmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYm9keSArPSBcIlxcclxcblwiLmNvbmNhdChzdGFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBib2R5OiBib2R5XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ3JlYXRlT3ZlcmxheU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbH0gdHJ1c3RlZFR5cGVzUG9saWN5TmFtZVxuICogQHByb3BlcnR5IHtib29sZWFuIHwgKGVycm9yOiBFcnJvcikgPT4gdm9pZH0gW2NhdGNoUnVudGltZUVycm9yXVxuICovXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Q3JlYXRlT3ZlcmxheU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xudmFyIGNyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiBjcmVhdGVPdmVybGF5KG9wdGlvbnMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWR9ICovXG4gIHZhciBpZnJhbWVDb250YWluZXJFbGVtZW50O1xuICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cbiAgdmFyIGNvbnRhaW5lckVsZW1lbnQ7XG4gIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xuICB2YXIgaGVhZGVyRWxlbWVudDtcbiAgLyoqIEB0eXBlIHtBcnJheTwoZWxlbWVudDogSFRNTERpdkVsZW1lbnQpID0+IHZvaWQ+fSAqL1xuICB2YXIgb25Mb2FkUXVldWUgPSBbXTtcbiAgLyoqIEB0eXBlIHtUcnVzdGVkVHlwZVBvbGljeSB8IHVuZGVmaW5lZH0gKi9cbiAgdmFyIG92ZXJsYXlUcnVzdGVkVHlwZXNQb2xpY3k7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlTdHlsZShlbGVtZW50LCBzdHlsZSkge1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDb250YWluZXIodHJ1c3RlZFR5cGVzUG9saWN5TmFtZSkge1xuICAgIC8vIEVuYWJsZSBUcnVzdGVkIFR5cGVzIGlmIHRoZXkgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgIGlmICh3aW5kb3cudHJ1c3RlZFR5cGVzKSB7XG4gICAgICBvdmVybGF5VHJ1c3RlZFR5cGVzUG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kodHJ1c3RlZFR5cGVzUG9saWN5TmFtZSB8fCBcIndlYnBhY2stZGV2LXNlcnZlciNvdmVybGF5XCIsIHtcbiAgICAgICAgY3JlYXRlSFRNTDogZnVuY3Rpb24gY3JlYXRlSFRNTCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuaWQgPSBcIndlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheVwiO1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuc3JjID0gXCJhYm91dDpibGFua1wiO1xuICAgIGFwcGx5U3R5bGUoaWZyYW1lQ29udGFpbmVyRWxlbWVudCwgaWZyYW1lU3R5bGUpO1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRlbnRFbGVtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICAgIC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovXG4gICAgICBpZnJhbWVDb250YWluZXJFbGVtZW50LmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGFpbmVyRWxlbWVudCA9IC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG4gICAgICAvKiogQHR5cGUge0hUTUxJRnJhbWVFbGVtZW50fSAqL1xuICAgICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnRFbGVtZW50LmlkID0gXCJ3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2XCI7XG4gICAgICBhcHBseVN0eWxlKGNvbnRlbnRFbGVtZW50LCBjb250YWluZXJTdHlsZSk7XG4gICAgICBoZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGhlYWRlckVsZW1lbnQuaW5uZXJUZXh0ID0gXCJDb21waWxlZCB3aXRoIHByb2JsZW1zOlwiO1xuICAgICAgYXBwbHlTdHlsZShoZWFkZXJFbGVtZW50LCBoZWFkZXJTdHlsZSk7XG4gICAgICB2YXIgY2xvc2VCdXR0b25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGFwcGx5U3R5bGUoY2xvc2VCdXR0b25FbGVtZW50LCBkaXNtaXNzQnV0dG9uU3R5bGUpO1xuICAgICAgY2xvc2VCdXR0b25FbGVtZW50LmlubmVyVGV4dCA9IFwiw5dcIjtcbiAgICAgIGNsb3NlQnV0dG9uRWxlbWVudC5hcmlhTGFiZWwgPSBcIkRpc21pc3NcIjtcbiAgICAgIGNsb3NlQnV0dG9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgb3ZlcmxheVNlcnZpY2Uuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJESVNNSVNTXCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKGhlYWRlckVsZW1lbnQpO1xuICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b25FbGVtZW50KTtcbiAgICAgIGNvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lckVsZW1lbnQpO1xuXG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgLyoqIEB0eXBlIHtIVE1MSUZyYW1lRWxlbWVudH0gKi9cbiAgICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGVudEVsZW1lbnQpO1xuICAgICAgb25Mb2FkUXVldWUuZm9yRWFjaChmdW5jdGlvbiAob25Mb2FkKSB7XG4gICAgICAgIG9uTG9hZCggLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9jb250ZW50RWxlbWVudCk7XG4gICAgICB9KTtcbiAgICAgIG9uTG9hZFF1ZXVlID0gW107XG5cbiAgICAgIC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovXG4gICAgICBpZnJhbWVDb250YWluZXJFbGVtZW50Lm9ubG9hZCA9IG51bGw7XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50KSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHRydXN0ZWRUeXBlc1BvbGljeU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlFeGlzdHMoY2FsbGJhY2ssIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUpIHtcbiAgICBpZiAoY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgY29udGFpbmVyRWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cbiAgICAgIGNhbGxiYWNrKGNvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbkxvYWRRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICBpZiAoaWZyYW1lQ29udGFpbmVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIodHJ1c3RlZFR5cGVzUG9saWN5TmFtZSk7XG4gIH1cblxuICAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuICBmdW5jdGlvbiBoaWRlKCkge1xuICAgIGlmICghaWZyYW1lQ29udGFpbmVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpO1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICAgIGNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZyAgfCB7IG1vZHVsZUlkZW50aWZpZXI/OiBzdHJpbmcsIG1vZHVsZU5hbWU/OiBzdHJpbmcsIGxvYz86IHN0cmluZywgbWVzc2FnZT86IHN0cmluZyB9Pn0gbWVzc2FnZXNcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lXG4gICAqIEBwYXJhbSB7J2J1aWxkJyB8ICdydW50aW1lJ30gbWVzc2FnZVNvdXJjZVxuICAgKi9cbiAgZnVuY3Rpb24gc2hvdyh0eXBlLCBtZXNzYWdlcywgdHJ1c3RlZFR5cGVzUG9saWN5TmFtZSwgbWVzc2FnZVNvdXJjZSkge1xuICAgIGVuc3VyZU92ZXJsYXlFeGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgaGVhZGVyRWxlbWVudC5pbm5lclRleHQgPSBtZXNzYWdlU291cmNlID09PSBcInJ1bnRpbWVcIiA/IFwiVW5jYXVnaHQgcnVudGltZSBlcnJvcnM6XCIgOiBcIkNvbXBpbGVkIHdpdGggcHJvYmxlbXM6XCI7XG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlbnRyeUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbXNnU3R5bGUgPSB0eXBlID09PSBcIndhcm5pbmdcIiA/IG1zZ1N0eWxlcy53YXJuaW5nIDogbXNnU3R5bGVzLmVycm9yO1xuICAgICAgICBhcHBseVN0eWxlKGVudHJ5RWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtc2dTdHlsZSksIHt9LCB7XG4gICAgICAgICAgcGFkZGluZzogXCIxcmVtIDFyZW0gMS41cmVtIDFyZW1cIlxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB0eXBlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBfZm9ybWF0UHJvYmxlbSA9IGZvcm1hdFByb2JsZW0odHlwZSwgbWVzc2FnZSksXG4gICAgICAgICAgaGVhZGVyID0gX2Zvcm1hdFByb2JsZW0uaGVhZGVyLFxuICAgICAgICAgIGJvZHkgPSBfZm9ybWF0UHJvYmxlbS5ib2R5O1xuICAgICAgICB0eXBlRWxlbWVudC5pbm5lclRleHQgPSBoZWFkZXI7XG4gICAgICAgIGFwcGx5U3R5bGUodHlwZUVsZW1lbnQsIG1zZ1R5cGVTdHlsZSk7XG4gICAgICAgIGlmIChtZXNzYWdlLm1vZHVsZUlkZW50aWZpZXIpIHtcbiAgICAgICAgICBhcHBseVN0eWxlKHR5cGVFbGVtZW50LCB7XG4gICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gZWxlbWVudC5kYXRhc2V0IG5vdCBzdXBwb3J0ZWQgaW4gSUVcbiAgICAgICAgICB0eXBlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNhbi1vcGVuXCIsIHRydWUpO1xuICAgICAgICAgIHR5cGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmZXRjaChcIi93ZWJwYWNrLWRldi1zZXJ2ZXIvb3Blbi1lZGl0b3I/ZmlsZU5hbWU9XCIuY29uY2F0KG1lc3NhZ2UubW9kdWxlSWRlbnRpZmllcikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgICAgICB2YXIgdGV4dCA9IGFuc2lIVE1MKGVuY29kZShib2R5KSk7XG4gICAgICAgIHZhciBtZXNzYWdlVGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBhcHBseVN0eWxlKG1lc3NhZ2VUZXh0Tm9kZSwgbXNnVGV4dFN0eWxlKTtcbiAgICAgICAgbWVzc2FnZVRleHROb2RlLmlubmVySFRNTCA9IG92ZXJsYXlUcnVzdGVkVHlwZXNQb2xpY3kgPyBvdmVybGF5VHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwodGV4dCkgOiB0ZXh0O1xuICAgICAgICBlbnRyeUVsZW1lbnQuYXBwZW5kQ2hpbGQodHlwZUVsZW1lbnQpO1xuICAgICAgICBlbnRyeUVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZVRleHROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50fSAqL1xuICAgICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGVudHJ5RWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9LCB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lKTtcbiAgfVxuICB2YXIgb3ZlcmxheVNlcnZpY2UgPSBjcmVhdGVPdmVybGF5TWFjaGluZSh7XG4gICAgc2hvd092ZXJsYXk6IGZ1bmN0aW9uIHNob3dPdmVybGF5KF9yZWYpIHtcbiAgICAgIHZhciBfcmVmJGxldmVsID0gX3JlZi5sZXZlbCxcbiAgICAgICAgbGV2ZWwgPSBfcmVmJGxldmVsID09PSB2b2lkIDAgPyBcImVycm9yXCIgOiBfcmVmJGxldmVsLFxuICAgICAgICBtZXNzYWdlcyA9IF9yZWYubWVzc2FnZXMsXG4gICAgICAgIG1lc3NhZ2VTb3VyY2UgPSBfcmVmLm1lc3NhZ2VTb3VyY2U7XG4gICAgICByZXR1cm4gc2hvdyhsZXZlbCwgbWVzc2FnZXMsIG9wdGlvbnMudHJ1c3RlZFR5cGVzUG9saWN5TmFtZSwgbWVzc2FnZVNvdXJjZSk7XG4gICAgfSxcbiAgICBoaWRlT3ZlcmxheTogaGlkZVxuICB9KTtcbiAgaWYgKG9wdGlvbnMuY2F0Y2hSdW50aW1lRXJyb3IpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yIHwgdW5kZWZpbmVkfSBlcnJvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmYWxsYmFja01lc3NhZ2VcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgZmFsbGJhY2tNZXNzYWdlKSB7XG4gICAgICB2YXIgZXJyb3JPYmplY3QgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IgfHwgZmFsbGJhY2tNZXNzYWdlKTtcbiAgICAgIHZhciBzaG91bGREaXNwbGF5ID0gdHlwZW9mIG9wdGlvbnMuY2F0Y2hSdW50aW1lRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuY2F0Y2hSdW50aW1lRXJyb3IoZXJyb3JPYmplY3QpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgIG92ZXJsYXlTZXJ2aWNlLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiUlVOVElNRV9FUlJPUlwiLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JPYmplY3QubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrOiBwYXJzZUVycm9yVG9TdGFja3MoZXJyb3JPYmplY3QpXG4gICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsaXN0ZW5Ub1J1bnRpbWVFcnJvcihmdW5jdGlvbiAoZXJyb3JFdmVudCkge1xuICAgICAgLy8gZXJyb3IgcHJvcGVydHkgbWF5IGJlIGVtcHR5IGluIG9sZGVyIGJyb3dzZXIgbGlrZSBJRVxuICAgICAgdmFyIGVycm9yID0gZXJyb3JFdmVudC5lcnJvcixcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yRXZlbnQubWVzc2FnZTtcbiAgICAgIGlmICghZXJyb3IgJiYgIW1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UpO1xuICAgIH0pO1xuICAgIGxpc3RlblRvVW5oYW5kbGVkUmVqZWN0aW9uKGZ1bmN0aW9uIChwcm9taXNlUmVqZWN0aW9uRXZlbnQpIHtcbiAgICAgIHZhciByZWFzb24gPSBwcm9taXNlUmVqZWN0aW9uRXZlbnQucmVhc29uO1xuICAgICAgaGFuZGxlRXJyb3IocmVhc29uLCBcIlVua25vd24gcHJvbWlzZSByZWplY3Rpb24gcmVhc29uXCIpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvdmVybGF5U2VydmljZTtcbn07XG5leHBvcnQgeyBmb3JtYXRQcm9ibGVtLCBjcmVhdGVPdmVybGF5IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/fsm.js":
/*!***************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/fsm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/**\n * @typedef {Object} StateDefinitions\n * @property {{[event: string]: { target: string; actions?: Array<string> }}} [on]\n */\n\n/**\n * @typedef {Object} Options\n * @property {{[state: string]: StateDefinitions}} states\n * @property {object} context;\n * @property {string} initial\n */\n\n/**\n * @typedef {Object} Implementation\n * @property {{[actionName: string]: (ctx: object, event: any) => object}} actions\n */\n\n/**\n * A simplified `createMachine` from `@xstate/fsm` with the following differences:\n *\n *  - the returned machine is technically a \"service\". No `interpret(machine).start()` is needed.\n *  - the state definition only support `on` and target must be declared with { target: 'nextState', actions: [] } explicitly.\n *  - event passed to `send` must be an object with `type` property.\n *  - actions implementation will be [assign action](https://xstate.js.org/docs/guides/context.html#assign-action) if you return any value.\n *  Do not return anything if you just want to invoke side effect.\n *\n * The goal of this custom function is to avoid installing the entire `'xstate/fsm'` package, while enabling modeling using\n * state machine. You can copy the first parameter into the editor at https://stately.ai/viz to visualize the state machine.\n *\n * @param {Options} options\n * @param {Implementation} implementation\n */\nfunction createMachine(_ref, _ref2) {\n  var states = _ref.states,\n    context = _ref.context,\n    initial = _ref.initial;\n  var actions = _ref2.actions;\n  var currentState = initial;\n  var currentContext = context;\n  return {\n    send: function send(event) {\n      var currentStateOn = states[currentState].on;\n      var transitionConfig = currentStateOn && currentStateOn[event.type];\n      if (transitionConfig) {\n        currentState = transitionConfig.target;\n        if (transitionConfig.actions) {\n          transitionConfig.actions.forEach(function (actName) {\n            var actionImpl = actions[actName];\n            var nextContextValue = actionImpl && actionImpl(currentContext, event);\n            if (nextContextValue) {\n              currentContext = _objectSpread(_objectSpread({}, currentContext), nextContextValue);\n            }\n          });\n        }\n      }\n    }\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createMachine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L2ZzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxtQkFBbUIsZ0JBQWdCLDRCQUE0QjtBQUM5RTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG9DQUFvQztBQUNuRCxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsNERBQTREO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1DQUFtQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L2ZzbS5qcz9jYzZmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXRlRGVmaW5pdGlvbnNcbiAqIEBwcm9wZXJ0eSB7e1tldmVudDogc3RyaW5nXTogeyB0YXJnZXQ6IHN0cmluZzsgYWN0aW9ucz86IEFycmF5PHN0cmluZz4gfX19IFtvbl1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7e1tzdGF0ZTogc3RyaW5nXTogU3RhdGVEZWZpbml0aW9uc319IHN0YXRlc1xuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQ7XG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW5pdGlhbFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW1wbGVtZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7e1thY3Rpb25OYW1lOiBzdHJpbmddOiAoY3R4OiBvYmplY3QsIGV2ZW50OiBhbnkpID0+IG9iamVjdH19IGFjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEEgc2ltcGxpZmllZCBgY3JlYXRlTWFjaGluZWAgZnJvbSBgQHhzdGF0ZS9mc21gIHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbiAqXG4gKiAgLSB0aGUgcmV0dXJuZWQgbWFjaGluZSBpcyB0ZWNobmljYWxseSBhIFwic2VydmljZVwiLiBObyBgaW50ZXJwcmV0KG1hY2hpbmUpLnN0YXJ0KClgIGlzIG5lZWRlZC5cbiAqICAtIHRoZSBzdGF0ZSBkZWZpbml0aW9uIG9ubHkgc3VwcG9ydCBgb25gIGFuZCB0YXJnZXQgbXVzdCBiZSBkZWNsYXJlZCB3aXRoIHsgdGFyZ2V0OiAnbmV4dFN0YXRlJywgYWN0aW9uczogW10gfSBleHBsaWNpdGx5LlxuICogIC0gZXZlbnQgcGFzc2VkIHRvIGBzZW5kYCBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGB0eXBlYCBwcm9wZXJ0eS5cbiAqICAtIGFjdGlvbnMgaW1wbGVtZW50YXRpb24gd2lsbCBiZSBbYXNzaWduIGFjdGlvbl0oaHR0cHM6Ly94c3RhdGUuanMub3JnL2RvY3MvZ3VpZGVzL2NvbnRleHQuaHRtbCNhc3NpZ24tYWN0aW9uKSBpZiB5b3UgcmV0dXJuIGFueSB2YWx1ZS5cbiAqICBEbyBub3QgcmV0dXJuIGFueXRoaW5nIGlmIHlvdSBqdXN0IHdhbnQgdG8gaW52b2tlIHNpZGUgZWZmZWN0LlxuICpcbiAqIFRoZSBnb2FsIG9mIHRoaXMgY3VzdG9tIGZ1bmN0aW9uIGlzIHRvIGF2b2lkIGluc3RhbGxpbmcgdGhlIGVudGlyZSBgJ3hzdGF0ZS9mc20nYCBwYWNrYWdlLCB3aGlsZSBlbmFibGluZyBtb2RlbGluZyB1c2luZ1xuICogc3RhdGUgbWFjaGluZS4gWW91IGNhbiBjb3B5IHRoZSBmaXJzdCBwYXJhbWV0ZXIgaW50byB0aGUgZWRpdG9yIGF0IGh0dHBzOi8vc3RhdGVseS5haS92aXogdG8gdmlzdWFsaXplIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHBhcmFtIHtJbXBsZW1lbnRhdGlvbn0gaW1wbGVtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFjaGluZShfcmVmLCBfcmVmMikge1xuICB2YXIgc3RhdGVzID0gX3JlZi5zdGF0ZXMsXG4gICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICBpbml0aWFsID0gX3JlZi5pbml0aWFsO1xuICB2YXIgYWN0aW9ucyA9IF9yZWYyLmFjdGlvbnM7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBpbml0aWFsO1xuICB2YXIgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICByZXR1cm4ge1xuICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZXZlbnQpIHtcbiAgICAgIHZhciBjdXJyZW50U3RhdGVPbiA9IHN0YXRlc1tjdXJyZW50U3RhdGVdLm9uO1xuICAgICAgdmFyIHRyYW5zaXRpb25Db25maWcgPSBjdXJyZW50U3RhdGVPbiAmJiBjdXJyZW50U3RhdGVPbltldmVudC50eXBlXTtcbiAgICAgIGlmICh0cmFuc2l0aW9uQ29uZmlnKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IHRyYW5zaXRpb25Db25maWcudGFyZ2V0O1xuICAgICAgICBpZiAodHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb25JbXBsID0gYWN0aW9uc1thY3ROYW1lXTtcbiAgICAgICAgICAgIHZhciBuZXh0Q29udGV4dFZhbHVlID0gYWN0aW9uSW1wbCAmJiBhY3Rpb25JbXBsKGN1cnJlbnRDb250ZXh0LCBldmVudCk7XG4gICAgICAgICAgICBpZiAobmV4dENvbnRleHRWYWx1ZSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VycmVudENvbnRleHQpLCBuZXh0Q29udGV4dFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1hY2hpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/fsm.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/runtime-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/runtime-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   listenToRuntimeError: () => (/* binding */ listenToRuntimeError),\n/* harmony export */   listenToUnhandledRejection: () => (/* binding */ listenToUnhandledRejection),\n/* harmony export */   parseErrorToStacks: () => (/* binding */ parseErrorToStacks)\n/* harmony export */ });\n/**\n *\n * @param {Error} error\n */\nfunction parseErrorToStacks(error) {\n  if (!error || !(error instanceof Error)) {\n    throw new Error(\"parseErrorToStacks expects Error object\");\n  }\n  if (typeof error.stack === \"string\") {\n    return error.stack.split(\"\\n\").filter(function (stack) {\n      return stack !== \"Error: \".concat(error.message);\n    });\n  }\n}\n\n/**\n * @callback ErrorCallback\n * @param {ErrorEvent} error\n * @returns {void}\n */\n\n/**\n * @param {ErrorCallback} callback\n */\nfunction listenToRuntimeError(callback) {\n  window.addEventListener(\"error\", callback);\n  return function cleanup() {\n    window.removeEventListener(\"error\", callback);\n  };\n}\n\n/**\n * @callback UnhandledRejectionCallback\n * @param {PromiseRejectionEvent} rejectionEvent\n * @returns {void}\n */\n\n/**\n * @param {UnhandledRejectionCallback} callback\n */\nfunction listenToUnhandledRejection(callback) {\n  window.addEventListener(\"unhandledrejection\", callback);\n  return function cleanup() {\n    window.removeEventListener(\"unhandledrejection\", callback);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3J1bnRpbWUtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkvcnVudGltZS1lcnJvci5qcz8wMDZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRXJyb3JUb1N0YWNrcyhlcnJvcikge1xuICBpZiAoIWVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJzZUVycm9yVG9TdGFja3MgZXhwZWN0cyBFcnJvciBvYmplY3RcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvci5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICByZXR1cm4gc3RhY2sgIT09IFwiRXJyb3I6IFwiLmNvbmNhdChlcnJvci5tZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBFcnJvckNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGVycm9yXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3JDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gbGlzdGVuVG9SdW50aW1lRXJyb3IoY2FsbGJhY2spIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBjYWxsYmFjayk7XG4gIHJldHVybiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgY2FsbGJhY2spO1xuICB9O1xufVxuXG4vKipcbiAqIEBjYWxsYmFjayBVbmhhbmRsZWRSZWplY3Rpb25DYWxsYmFja1xuICogQHBhcmFtIHtQcm9taXNlUmVqZWN0aW9uRXZlbnR9IHJlamVjdGlvbkV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VW5oYW5kbGVkUmVqZWN0aW9uQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvVW5oYW5kbGVkUmVqZWN0aW9uKGNhbGxiYWNrKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1bmhhbmRsZWRyZWplY3Rpb25cIiwgY2FsbGJhY2spO1xuICB9O1xufVxuZXhwb3J0IHsgbGlzdGVuVG9SdW50aW1lRXJyb3IsIGxpc3RlblRvVW5oYW5kbGVkUmVqZWN0aW9uLCBwYXJzZUVycm9yVG9TdGFja3MgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/runtime-error.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/state-machine.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/state-machine.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _fsm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fsm.js */ \"./node_modules/webpack-dev-server/client/overlay/fsm.js\");\n\n\n/**\n * @typedef {Object} ShowOverlayData\n * @property {'warning' | 'error'} level\n * @property {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string }>} messages\n * @property {'build' | 'runtime'} messageSource\n */\n\n/**\n * @typedef {Object} CreateOverlayMachineOptions\n * @property {(data: ShowOverlayData) => void} showOverlay\n * @property {() => void} hideOverlay\n */\n\n/**\n * @param {CreateOverlayMachineOptions} options\n */\nvar createOverlayMachine = function createOverlayMachine(options) {\n  var hideOverlay = options.hideOverlay,\n    showOverlay = options.showOverlay;\n  var overlayMachine = (0,_fsm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    initial: \"hidden\",\n    context: {\n      level: \"error\",\n      messages: [],\n      messageSource: \"build\"\n    },\n    states: {\n      hidden: {\n        on: {\n          BUILD_ERROR: {\n            target: \"displayBuildError\",\n            actions: [\"setMessages\", \"showOverlay\"]\n          },\n          RUNTIME_ERROR: {\n            target: \"displayRuntimeError\",\n            actions: [\"setMessages\", \"showOverlay\"]\n          }\n        }\n      },\n      displayBuildError: {\n        on: {\n          DISMISS: {\n            target: \"hidden\",\n            actions: [\"dismissMessages\", \"hideOverlay\"]\n          },\n          BUILD_ERROR: {\n            target: \"displayBuildError\",\n            actions: [\"appendMessages\", \"showOverlay\"]\n          }\n        }\n      },\n      displayRuntimeError: {\n        on: {\n          DISMISS: {\n            target: \"hidden\",\n            actions: [\"dismissMessages\", \"hideOverlay\"]\n          },\n          RUNTIME_ERROR: {\n            target: \"displayRuntimeError\",\n            actions: [\"appendMessages\", \"showOverlay\"]\n          },\n          BUILD_ERROR: {\n            target: \"displayBuildError\",\n            actions: [\"setMessages\", \"showOverlay\"]\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      dismissMessages: function dismissMessages() {\n        return {\n          messages: [],\n          level: \"error\",\n          messageSource: \"build\"\n        };\n      },\n      appendMessages: function appendMessages(context, event) {\n        return {\n          messages: context.messages.concat(event.messages),\n          level: event.level || context.level,\n          messageSource: event.type === \"RUNTIME_ERROR\" ? \"runtime\" : \"build\"\n        };\n      },\n      setMessages: function setMessages(context, event) {\n        return {\n          messages: event.messages,\n          level: event.level || context.level,\n          messageSource: event.type === \"RUNTIME_ERROR\" ? \"runtime\" : \"build\"\n        };\n      },\n      hideOverlay: hideOverlay,\n      showOverlay: showOverlay\n    }\n  });\n  return overlayMachine;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createOverlayMachine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3N0YXRlLW1hY2hpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMsa0JBQWtCLGdGQUFnRixHQUFHO0FBQ25ILGNBQWMscUJBQXFCO0FBQ25DOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpRUFBZSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS9zdGF0ZS1tYWNoaW5lLmpzPzg0YWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZU1hY2hpbmUgZnJvbSBcIi4vZnNtLmpzXCI7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2hvd092ZXJsYXlEYXRhXG4gKiBAcHJvcGVydHkgeyd3YXJuaW5nJyB8ICdlcnJvcid9IGxldmVsXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZyAgfCB7IG1vZHVsZUlkZW50aWZpZXI/OiBzdHJpbmcsIG1vZHVsZU5hbWU/OiBzdHJpbmcsIGxvYz86IHN0cmluZywgbWVzc2FnZT86IHN0cmluZyB9Pn0gbWVzc2FnZXNcbiAqIEBwcm9wZXJ0eSB7J2J1aWxkJyB8ICdydW50aW1lJ30gbWVzc2FnZVNvdXJjZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ3JlYXRlT3ZlcmxheU1hY2hpbmVPcHRpb25zXG4gKiBAcHJvcGVydHkgeyhkYXRhOiBTaG93T3ZlcmxheURhdGEpID0+IHZvaWR9IHNob3dPdmVybGF5XG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGhpZGVPdmVybGF5XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0NyZWF0ZU92ZXJsYXlNYWNoaW5lT3B0aW9uc30gb3B0aW9uc1xuICovXG52YXIgY3JlYXRlT3ZlcmxheU1hY2hpbmUgPSBmdW5jdGlvbiBjcmVhdGVPdmVybGF5TWFjaGluZShvcHRpb25zKSB7XG4gIHZhciBoaWRlT3ZlcmxheSA9IG9wdGlvbnMuaGlkZU92ZXJsYXksXG4gICAgc2hvd092ZXJsYXkgPSBvcHRpb25zLnNob3dPdmVybGF5O1xuICB2YXIgb3ZlcmxheU1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAgICBpbml0aWFsOiBcImhpZGRlblwiLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBtZXNzYWdlU291cmNlOiBcImJ1aWxkXCJcbiAgICB9LFxuICAgIHN0YXRlczoge1xuICAgICAgaGlkZGVuOiB7XG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgQlVJTERfRVJST1I6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJkaXNwbGF5QnVpbGRFcnJvclwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wic2V0TWVzc2FnZXNcIiwgXCJzaG93T3ZlcmxheVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgUlVOVElNRV9FUlJPUjoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImRpc3BsYXlSdW50aW1lRXJyb3JcIixcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcInNldE1lc3NhZ2VzXCIsIFwic2hvd092ZXJsYXlcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5QnVpbGRFcnJvcjoge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIERJU01JU1M6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcImRpc21pc3NNZXNzYWdlc1wiLCBcImhpZGVPdmVybGF5XCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBCVUlMRF9FUlJPUjoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImRpc3BsYXlCdWlsZEVycm9yXCIsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXCJhcHBlbmRNZXNzYWdlc1wiLCBcInNob3dPdmVybGF5XCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheVJ1bnRpbWVFcnJvcjoge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIERJU01JU1M6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcImRpc21pc3NNZXNzYWdlc1wiLCBcImhpZGVPdmVybGF5XCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBSVU5USU1FX0VSUk9SOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZGlzcGxheVJ1bnRpbWVFcnJvclwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wiYXBwZW5kTWVzc2FnZXNcIiwgXCJzaG93T3ZlcmxheVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgQlVJTERfRVJST1I6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJkaXNwbGF5QnVpbGRFcnJvclwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wic2V0TWVzc2FnZXNcIiwgXCJzaG93T3ZlcmxheVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgIGRpc21pc3NNZXNzYWdlczogZnVuY3Rpb24gZGlzbWlzc01lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICAgIG1lc3NhZ2VTb3VyY2U6IFwiYnVpbGRcIlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFwcGVuZE1lc3NhZ2VzOiBmdW5jdGlvbiBhcHBlbmRNZXNzYWdlcyhjb250ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBjb250ZXh0Lm1lc3NhZ2VzLmNvbmNhdChldmVudC5tZXNzYWdlcyksXG4gICAgICAgICAgbGV2ZWw6IGV2ZW50LmxldmVsIHx8IGNvbnRleHQubGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZVNvdXJjZTogZXZlbnQudHlwZSA9PT0gXCJSVU5USU1FX0VSUk9SXCIgPyBcInJ1bnRpbWVcIiA6IFwiYnVpbGRcIlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNldE1lc3NhZ2VzOiBmdW5jdGlvbiBzZXRNZXNzYWdlcyhjb250ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBldmVudC5tZXNzYWdlcyxcbiAgICAgICAgICBsZXZlbDogZXZlbnQubGV2ZWwgfHwgY29udGV4dC5sZXZlbCxcbiAgICAgICAgICBtZXNzYWdlU291cmNlOiBldmVudC50eXBlID09PSBcIlJVTlRJTUVfRVJST1JcIiA/IFwicnVudGltZVwiIDogXCJidWlsZFwiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaGlkZU92ZXJsYXk6IGhpZGVPdmVybGF5LFxuICAgICAgc2hvd092ZXJsYXk6IHNob3dPdmVybGF5XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG92ZXJsYXlNYWNoaW5lO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU92ZXJsYXlNYWNoaW5lOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/state-machine.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/styles.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/styles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   containerStyle: () => (/* binding */ containerStyle),\n/* harmony export */   dismissButtonStyle: () => (/* binding */ dismissButtonStyle),\n/* harmony export */   headerStyle: () => (/* binding */ headerStyle),\n/* harmony export */   iframeStyle: () => (/* binding */ iframeStyle),\n/* harmony export */   msgStyles: () => (/* binding */ msgStyles),\n/* harmony export */   msgTextStyle: () => (/* binding */ msgTextStyle),\n/* harmony export */   msgTypeStyle: () => (/* binding */ msgTypeStyle)\n/* harmony export */ });\n// styles are inspired by `react-error-overlay`\n\nvar msgStyles = {\n  error: {\n    backgroundColor: \"rgba(206, 17, 38, 0.1)\",\n    color: \"#fccfcf\"\n  },\n  warning: {\n    backgroundColor: \"rgba(251, 245, 180, 0.1)\",\n    color: \"#fbf5b4\"\n  }\n};\nvar iframeStyle = {\n  position: \"fixed\",\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: \"100vw\",\n  height: \"100vh\",\n  border: \"none\",\n  \"z-index\": 9999999999\n};\nvar containerStyle = {\n  position: \"fixed\",\n  boxSizing: \"border-box\",\n  left: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  width: \"100vw\",\n  height: \"100vh\",\n  fontSize: \"large\",\n  padding: \"2rem 2rem 4rem 2rem\",\n  lineHeight: \"1.2\",\n  whiteSpace: \"pre-wrap\",\n  overflow: \"auto\",\n  backgroundColor: \"rgba(0, 0, 0, 0.9)\",\n  color: \"white\"\n};\nvar headerStyle = {\n  color: \"#e83b46\",\n  fontSize: \"2em\",\n  whiteSpace: \"pre-wrap\",\n  fontFamily: \"sans-serif\",\n  margin: \"0 2rem 2rem 0\",\n  flex: \"0 0 auto\",\n  maxHeight: \"50%\",\n  overflow: \"auto\"\n};\nvar dismissButtonStyle = {\n  color: \"#ffffff\",\n  lineHeight: \"1rem\",\n  fontSize: \"1.5rem\",\n  padding: \"1rem\",\n  cursor: \"pointer\",\n  position: \"absolute\",\n  right: 0,\n  top: 0,\n  backgroundColor: \"transparent\",\n  border: \"none\"\n};\nvar msgTypeStyle = {\n  color: \"#e83b46\",\n  fontSize: \"1.2em\",\n  marginBottom: \"1rem\",\n  fontFamily: \"sans-serif\"\n};\nvar msgTextStyle = {\n  lineHeight: \"1.5\",\n  fontSize: \"1rem\",\n  fontFamily: \"Menlo, Consolas, monospace\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5L3N0eWxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkvc3R5bGVzLmpzPzgyMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGVzIGFyZSBpbnNwaXJlZCBieSBgcmVhY3QtZXJyb3Itb3ZlcmxheWBcblxudmFyIG1zZ1N0eWxlcyA9IHtcbiAgZXJyb3I6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyMDYsIDE3LCAzOCwgMC4xKVwiLFxuICAgIGNvbG9yOiBcIiNmY2NmY2ZcIlxuICB9LFxuICB3YXJuaW5nOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMjUxLCAyNDUsIDE4MCwgMC4xKVwiLFxuICAgIGNvbG9yOiBcIiNmYmY1YjRcIlxuICB9XG59O1xudmFyIGlmcmFtZVN0eWxlID0ge1xuICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIHdpZHRoOiBcIjEwMHZ3XCIsXG4gIGhlaWdodDogXCIxMDB2aFwiLFxuICBib3JkZXI6IFwibm9uZVwiLFxuICBcInotaW5kZXhcIjogOTk5OTk5OTk5OVxufTtcbnZhciBjb250YWluZXJTdHlsZSA9IHtcbiAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgbGVmdDogMCxcbiAgdG9wOiAwLFxuICByaWdodDogMCxcbiAgYm90dG9tOiAwLFxuICB3aWR0aDogXCIxMDB2d1wiLFxuICBoZWlnaHQ6IFwiMTAwdmhcIixcbiAgZm9udFNpemU6IFwibGFyZ2VcIixcbiAgcGFkZGluZzogXCIycmVtIDJyZW0gNHJlbSAycmVtXCIsXG4gIGxpbmVIZWlnaHQ6IFwiMS4yXCIsXG4gIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgb3ZlcmZsb3c6IFwiYXV0b1wiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjkpXCIsXG4gIGNvbG9yOiBcIndoaXRlXCJcbn07XG52YXIgaGVhZGVyU3R5bGUgPSB7XG4gIGNvbG9yOiBcIiNlODNiNDZcIixcbiAgZm9udFNpemU6IFwiMmVtXCIsXG4gIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gIG1hcmdpbjogXCIwIDJyZW0gMnJlbSAwXCIsXG4gIGZsZXg6IFwiMCAwIGF1dG9cIixcbiAgbWF4SGVpZ2h0OiBcIjUwJVwiLFxuICBvdmVyZmxvdzogXCJhdXRvXCJcbn07XG52YXIgZGlzbWlzc0J1dHRvblN0eWxlID0ge1xuICBjb2xvcjogXCIjZmZmZmZmXCIsXG4gIGxpbmVIZWlnaHQ6IFwiMXJlbVwiLFxuICBmb250U2l6ZTogXCIxLjVyZW1cIixcbiAgcGFkZGluZzogXCIxcmVtXCIsXG4gIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHJpZ2h0OiAwLFxuICB0b3A6IDAsXG4gIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBib3JkZXI6IFwibm9uZVwiXG59O1xudmFyIG1zZ1R5cGVTdHlsZSA9IHtcbiAgY29sb3I6IFwiI2U4M2I0NlwiLFxuICBmb250U2l6ZTogXCIxLjJlbVwiLFxuICBtYXJnaW5Cb3R0b206IFwiMXJlbVwiLFxuICBmb250RmFtaWx5OiBcInNhbnMtc2VyaWZcIlxufTtcbnZhciBtc2dUZXh0U3R5bGUgPSB7XG4gIGxpbmVIZWlnaHQ6IFwiMS41XCIsXG4gIGZvbnRTaXplOiBcIjFyZW1cIixcbiAgZm9udEZhbWlseTogXCJNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZVwiXG59O1xuZXhwb3J0IHsgbXNnU3R5bGVzLCBpZnJhbWVTdHlsZSwgY29udGFpbmVyU3R5bGUsIGhlYWRlclN0eWxlLCBkaXNtaXNzQnV0dG9uU3R5bGUsIG1zZ1R5cGVTdHlsZSwgbXNnVGV4dFN0eWxlIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/overlay/styles.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   client: () => (/* binding */ client),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clients/WebSocketClient.js */ \"./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\");\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\n/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js */ \"./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\");\n/* global __webpack_dev_server_client__ */\n\n\n\n\n// this WebsocketClient is here as a default fallback, in case the client is not injected\n/* eslint-disable camelcase */\nvar Client =\n// eslint-disable-next-line no-nested-ternary\ntypeof __webpack_dev_server_client__ !== \"undefined\" ? typeof __webpack_dev_server_client__.default !== \"undefined\" ? __webpack_dev_server_client__.default : __webpack_dev_server_client__ : _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* eslint-enable camelcase */\n\nvar retries = 0;\nvar maxRetries = 10;\n\n// Initialized client is exported so external consumers can utilize the same instance\n// It is mutable to enforce singleton\n// eslint-disable-next-line import/no-mutable-exports\nvar client = null;\n\n/**\n * @param {string} url\n * @param {{ [handler: string]: (data?: any, params?: any) => any }} handlers\n * @param {number} [reconnect]\n */\nvar socket = function initSocket(url, handlers, reconnect) {\n  client = new Client(url);\n  client.onOpen(function () {\n    retries = 0;\n    if (typeof reconnect !== \"undefined\") {\n      maxRetries = reconnect;\n    }\n  });\n  client.onClose(function () {\n    if (retries === 0) {\n      handlers.close();\n    }\n\n    // Try to reconnect.\n    client = null;\n\n    // After 10 retries stop trying, to prevent logspam.\n    if (retries < maxRetries) {\n      // Exponentially increase timeout to reconnect.\n      // Respectfully copied from the package `got`.\n      // eslint-disable-next-line no-restricted-properties\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\n      retries += 1;\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_1__.log.info(\"Trying to reconnect...\");\n      setTimeout(function () {\n        socket(url, handlers, reconnect);\n      }, retryInMs);\n    }\n  });\n  client.onMessage(\n  /**\n   * @param {any} data\n   */\n  function (data) {\n    var message = JSON.parse(data);\n    if (handlers[message.type]) {\n      handlers[message.type](message.data, message.params);\n    }\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socket);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFFMkQ7QUFDdEI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2QkFBNkIsMEJBQTBCLDZCQUE2QiwyQkFBMkIsNkJBQTZCLFdBQVcsNkJBQTZCLEdBQUcsbUVBQWU7QUFDN007O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLHdEQUF3RDtBQUNyRSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4Q0FBRztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpRUFBZSxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcz8wOWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuXG5pbXBvcnQgV2ViU29ja2V0Q2xpZW50IGZyb20gXCIuL2NsaWVudHMvV2ViU29ja2V0Q2xpZW50LmpzXCI7XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi91dGlscy9sb2cuanNcIjtcblxuLy8gdGhpcyBXZWJzb2NrZXRDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgdGhlIGNsaWVudCBpcyBub3QgaW5qZWN0ZWRcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xudmFyIENsaWVudCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbnR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXy5kZWZhdWx0ICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18uZGVmYXVsdCA6IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogV2ViU29ja2V0Q2xpZW50O1xuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxudmFyIHJldHJpZXMgPSAwO1xudmFyIG1heFJldHJpZXMgPSAxMDtcblxuLy8gSW5pdGlhbGl6ZWQgY2xpZW50IGlzIGV4cG9ydGVkIHNvIGV4dGVybmFsIGNvbnN1bWVycyBjYW4gdXRpbGl6ZSB0aGUgc2FtZSBpbnN0YW5jZVxuLy8gSXQgaXMgbXV0YWJsZSB0byBlbmZvcmNlIHNpbmdsZXRvblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcbmV4cG9ydCB2YXIgY2xpZW50ID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge3sgW2hhbmRsZXI6IHN0cmluZ106IChkYXRhPzogYW55LCBwYXJhbXM/OiBhbnkpID0+IGFueSB9fSBoYW5kbGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtyZWNvbm5lY3RdXG4gKi9cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMsIHJlY29ubmVjdCkge1xuICBjbGllbnQgPSBuZXcgQ2xpZW50KHVybCk7XG4gIGNsaWVudC5vbk9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICAgIGlmICh0eXBlb2YgcmVjb25uZWN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBtYXhSZXRyaWVzID0gcmVjb25uZWN0O1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcmVjb25uZWN0LlxuICAgIGNsaWVudCA9IG51bGw7XG5cbiAgICAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG4gICAgaWYgKHJldHJpZXMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHJldHJ5SW5NcyA9IDEwMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICByZXRyaWVzICs9IDE7XG4gICAgICBsb2cuaW5mbyhcIlRyeWluZyB0byByZWNvbm5lY3QuLi5cIik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc29ja2V0KHVybCwgaGFuZGxlcnMsIHJlY29ubmVjdCk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgaWYgKGhhbmRsZXJzW21lc3NhZ2UudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21lc3NhZ2UudHlwZV0obWVzc2FnZS5kYXRhLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgfVxuICB9KTtcbn07XG5leHBvcnQgZGVmYXVsdCBzb2NrZXQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/socket.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketURL.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @param {{ protocol?: string, auth?: string, hostname?: string, port?: string, pathname?: string, search?: string, hash?: string, slashes?: boolean }} objURL\n * @returns {string}\n */\nfunction format(objURL) {\n  var protocol = objURL.protocol || \"\";\n  if (protocol && protocol.substr(-1) !== \":\") {\n    protocol += \":\";\n  }\n  var auth = objURL.auth || \"\";\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \":\");\n    auth += \"@\";\n  }\n  var host = \"\";\n  if (objURL.hostname) {\n    host = auth + (objURL.hostname.indexOf(\":\") === -1 ? objURL.hostname : \"[\".concat(objURL.hostname, \"]\"));\n    if (objURL.port) {\n      host += \":\".concat(objURL.port);\n    }\n  }\n  var pathname = objURL.pathname || \"\";\n  if (objURL.slashes) {\n    host = \"//\".concat(host || \"\");\n    if (pathname && pathname.charAt(0) !== \"/\") {\n      pathname = \"/\".concat(pathname);\n    }\n  } else if (!host) {\n    host = \"\";\n  }\n  var search = objURL.search || \"\";\n  if (search && search.charAt(0) !== \"?\") {\n    search = \"?\".concat(search);\n  }\n  var hash = objURL.hash || \"\";\n  if (hash && hash.charAt(0) !== \"#\") {\n    hash = \"#\".concat(hash);\n  }\n  pathname = pathname.replace(/[?#]/g,\n  /**\n   * @param {string} match\n   * @returns {string}\n   */\n  function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\"#\", \"%23\");\n  return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n}\n\n/**\n * @param {URL & { fromCurrentScript?: boolean }} parsedURL\n * @returns {string}\n */\nfunction createSocketURL(parsedURL) {\n  var hostname = parsedURL.hostname;\n\n  // Node.js module parses it as `::`\n  // `new URL(urlString, [baseURLString])` parses it as '[::]'\n  var isInAddrAny = hostname === \"0.0.0.0\" || hostname === \"::\" || hostname === \"[::]\";\n\n  // why do we need this check?\n  // hostname n/a for file protocol (example, when using electron, ionic)\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\n  if (isInAddrAny && self.location.hostname && self.location.protocol.indexOf(\"http\") === 0) {\n    hostname = self.location.hostname;\n  }\n  var socketURLProtocol = parsedURL.protocol || self.location.protocol;\n\n  // When https is used in the app, secure web sockets are always necessary because the browser doesn't accept non-secure web sockets.\n  if (socketURLProtocol === \"auto:\" || hostname && isInAddrAny && self.location.protocol === \"https:\") {\n    socketURLProtocol = self.location.protocol;\n  }\n  socketURLProtocol = socketURLProtocol.replace(/^(?:http|.+-extension|file)/i, \"ws\");\n  var socketURLAuth = \"\";\n\n  // `new URL(urlString, [baseURLstring])` doesn't have `auth` property\n  // Parse authentication credentials in case we need them\n  if (parsedURL.username) {\n    socketURLAuth = parsedURL.username;\n\n    // Since HTTP basic authentication does not allow empty username,\n    // we only include password if the username is not empty.\n    if (parsedURL.password) {\n      // Result: <username>:<password>\n      socketURLAuth = socketURLAuth.concat(\":\", parsedURL.password);\n    }\n  }\n\n  // In case the host is a raw IPv6 address, it can be enclosed in\n  // the brackets as the brackets are needed in the final URL string.\n  // Need to remove those as url.format blindly adds its own set of brackets\n  // if the host string contains colons. That would lead to non-working\n  // double brackets (e.g. [[::]]) host\n  //\n  // All of these web socket url params are optionally passed in through resourceQuery,\n  // so we need to fall back to the default if they are not provided\n  var socketURLHostname = (hostname || self.location.hostname || \"localhost\").replace(/^\\[(.*)\\]$/, \"$1\");\n  var socketURLPort = parsedURL.port;\n  if (!socketURLPort || socketURLPort === \"0\") {\n    socketURLPort = self.location.port;\n  }\n\n  // If path is provided it'll be passed in via the resourceQuery as a\n  // query param so it has to be parsed out of the querystring in order for the\n  // client to open the socket to the correct location.\n  var socketURLPathname = \"/ws\";\n  if (parsedURL.pathname && !parsedURL.fromCurrentScript) {\n    socketURLPathname = parsedURL.pathname;\n  }\n  return format({\n    protocol: socketURLProtocol,\n    auth: socketURLAuth,\n    hostname: socketURLHostname,\n    port: socketURLPort,\n    pathname: socketURLPathname,\n    slashes: true\n  });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSocketURL);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9jcmVhdGVTb2NrZXRVUkwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsYUFBYSw0SUFBNEk7QUFDekosYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUSwrQkFBK0I7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpRUFBZSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVSTC5qcz82YzE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhcmFtIHt7IHByb3RvY29sPzogc3RyaW5nLCBhdXRoPzogc3RyaW5nLCBob3N0bmFtZT86IHN0cmluZywgcG9ydD86IHN0cmluZywgcGF0aG5hbWU/OiBzdHJpbmcsIHNlYXJjaD86IHN0cmluZywgaGFzaD86IHN0cmluZywgc2xhc2hlcz86IGJvb2xlYW4gfX0gb2JqVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmb3JtYXQob2JqVVJMKSB7XG4gIHZhciBwcm90b2NvbCA9IG9ialVSTC5wcm90b2NvbCB8fCBcIlwiO1xuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gXCI6XCIpIHtcbiAgICBwcm90b2NvbCArPSBcIjpcIjtcbiAgfVxuICB2YXIgYXV0aCA9IG9ialVSTC5hdXRoIHx8IFwiXCI7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgXCI6XCIpO1xuICAgIGF1dGggKz0gXCJAXCI7XG4gIH1cbiAgdmFyIGhvc3QgPSBcIlwiO1xuICBpZiAob2JqVVJMLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAob2JqVVJMLmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSA/IG9ialVSTC5ob3N0bmFtZSA6IFwiW1wiLmNvbmNhdChvYmpVUkwuaG9zdG5hbWUsIFwiXVwiKSk7XG4gICAgaWYgKG9ialVSTC5wb3J0KSB7XG4gICAgICBob3N0ICs9IFwiOlwiLmNvbmNhdChvYmpVUkwucG9ydCk7XG4gICAgfVxuICB9XG4gIHZhciBwYXRobmFtZSA9IG9ialVSTC5wYXRobmFtZSB8fCBcIlwiO1xuICBpZiAob2JqVVJMLnNsYXNoZXMpIHtcbiAgICBob3N0ID0gXCIvL1wiLmNvbmNhdChob3N0IHx8IFwiXCIpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiLmNvbmNhdChwYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9IFwiXCI7XG4gIH1cbiAgdmFyIHNlYXJjaCA9IG9ialVSTC5zZWFyY2ggfHwgXCJcIjtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSBcIj9cIikge1xuICAgIHNlYXJjaCA9IFwiP1wiLmNvbmNhdChzZWFyY2gpO1xuICB9XG4gIHZhciBoYXNoID0gb2JqVVJMLmhhc2ggfHwgXCJcIjtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09IFwiI1wiKSB7XG4gICAgaGFzaCA9IFwiI1wiLmNvbmNhdChoYXNoKTtcbiAgfVxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZyxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZShcIiNcIiwgXCIlMjNcIik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChwcm90b2NvbCkuY29uY2F0KGhvc3QpLmNvbmNhdChwYXRobmFtZSkuY29uY2F0KHNlYXJjaCkuY29uY2F0KGhhc2gpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VVJMICYgeyBmcm9tQ3VycmVudFNjcmlwdD86IGJvb2xlYW4gfX0gcGFyc2VkVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjcmVhdGVTb2NrZXRVUkwocGFyc2VkVVJMKSB7XG4gIHZhciBob3N0bmFtZSA9IHBhcnNlZFVSTC5ob3N0bmFtZTtcblxuICAvLyBOb2RlLmpzIG1vZHVsZSBwYXJzZXMgaXQgYXMgYDo6YFxuICAvLyBgbmV3IFVSTCh1cmxTdHJpbmcsIFtiYXNlVVJMU3RyaW5nXSlgIHBhcnNlcyBpdCBhcyAnWzo6XSdcbiAgdmFyIGlzSW5BZGRyQW55ID0gaG9zdG5hbWUgPT09IFwiMC4wLjAuMFwiIHx8IGhvc3RuYW1lID09PSBcIjo6XCIgfHwgaG9zdG5hbWUgPT09IFwiWzo6XVwiO1xuXG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG4gIGlmIChpc0luQWRkckFueSAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBcIikgPT09IDApIHtcbiAgICBob3N0bmFtZSA9IHNlbGYubG9jYXRpb24uaG9zdG5hbWU7XG4gIH1cbiAgdmFyIHNvY2tldFVSTFByb3RvY29sID0gcGFyc2VkVVJMLnByb3RvY29sIHx8IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG5cbiAgLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWIgc29ja2V0cyBhcmUgYWx3YXlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2ViIHNvY2tldHMuXG4gIGlmIChzb2NrZXRVUkxQcm90b2NvbCA9PT0gXCJhdXRvOlwiIHx8IGhvc3RuYW1lICYmIGlzSW5BZGRyQW55ICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICBzb2NrZXRVUkxQcm90b2NvbCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG4gIH1cbiAgc29ja2V0VVJMUHJvdG9jb2wgPSBzb2NrZXRVUkxQcm90b2NvbC5yZXBsYWNlKC9eKD86aHR0cHwuKy1leHRlbnNpb258ZmlsZSkvaSwgXCJ3c1wiKTtcbiAgdmFyIHNvY2tldFVSTEF1dGggPSBcIlwiO1xuXG4gIC8vIGBuZXcgVVJMKHVybFN0cmluZywgW2Jhc2VVUkxzdHJpbmddKWAgZG9lc24ndCBoYXZlIGBhdXRoYCBwcm9wZXJ0eVxuICAvLyBQYXJzZSBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBpbiBjYXNlIHdlIG5lZWQgdGhlbVxuICBpZiAocGFyc2VkVVJMLnVzZXJuYW1lKSB7XG4gICAgc29ja2V0VVJMQXV0aCA9IHBhcnNlZFVSTC51c2VybmFtZTtcblxuICAgIC8vIFNpbmNlIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb24gZG9lcyBub3QgYWxsb3cgZW1wdHkgdXNlcm5hbWUsXG4gICAgLy8gd2Ugb25seSBpbmNsdWRlIHBhc3N3b3JkIGlmIHRoZSB1c2VybmFtZSBpcyBub3QgZW1wdHkuXG4gICAgaWYgKHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgLy8gUmVzdWx0OiA8dXNlcm5hbWU+OjxwYXNzd29yZD5cbiAgICAgIHNvY2tldFVSTEF1dGggPSBzb2NrZXRVUkxBdXRoLmNvbmNhdChcIjpcIiwgcGFyc2VkVVJMLnBhc3N3b3JkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbiBjYXNlIHRoZSBob3N0IGlzIGEgcmF3IElQdjYgYWRkcmVzcywgaXQgY2FuIGJlIGVuY2xvc2VkIGluXG4gIC8vIHRoZSBicmFja2V0cyBhcyB0aGUgYnJhY2tldHMgYXJlIG5lZWRlZCBpbiB0aGUgZmluYWwgVVJMIHN0cmluZy5cbiAgLy8gTmVlZCB0byByZW1vdmUgdGhvc2UgYXMgdXJsLmZvcm1hdCBibGluZGx5IGFkZHMgaXRzIG93biBzZXQgb2YgYnJhY2tldHNcbiAgLy8gaWYgdGhlIGhvc3Qgc3RyaW5nIGNvbnRhaW5zIGNvbG9ucy4gVGhhdCB3b3VsZCBsZWFkIHRvIG5vbi13b3JraW5nXG4gIC8vIGRvdWJsZSBicmFja2V0cyAoZS5nLiBbWzo6XV0pIGhvc3RcbiAgLy9cbiAgLy8gQWxsIG9mIHRoZXNlIHdlYiBzb2NrZXQgdXJsIHBhcmFtcyBhcmUgb3B0aW9uYWxseSBwYXNzZWQgaW4gdGhyb3VnaCByZXNvdXJjZVF1ZXJ5LFxuICAvLyBzbyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWRcbiAgdmFyIHNvY2tldFVSTEhvc3RuYW1lID0gKGhvc3RuYW1lIHx8IHNlbGYubG9jYXRpb24uaG9zdG5hbWUgfHwgXCJsb2NhbGhvc3RcIikucmVwbGFjZSgvXlxcWyguKilcXF0kLywgXCIkMVwiKTtcbiAgdmFyIHNvY2tldFVSTFBvcnQgPSBwYXJzZWRVUkwucG9ydDtcbiAgaWYgKCFzb2NrZXRVUkxQb3J0IHx8IHNvY2tldFVSTFBvcnQgPT09IFwiMFwiKSB7XG4gICAgc29ja2V0VVJMUG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcbiAgfVxuXG4gIC8vIElmIHBhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gIC8vIHF1ZXJ5IHBhcmFtIHNvIGl0IGhhcyB0byBiZSBwYXJzZWQgb3V0IG9mIHRoZSBxdWVyeXN0cmluZyBpbiBvcmRlciBmb3IgdGhlXG4gIC8vIGNsaWVudCB0byBvcGVuIHRoZSBzb2NrZXQgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gIHZhciBzb2NrZXRVUkxQYXRobmFtZSA9IFwiL3dzXCI7XG4gIGlmIChwYXJzZWRVUkwucGF0aG5hbWUgJiYgIXBhcnNlZFVSTC5mcm9tQ3VycmVudFNjcmlwdCkge1xuICAgIHNvY2tldFVSTFBhdGhuYW1lID0gcGFyc2VkVVJMLnBhdGhuYW1lO1xuICB9XG4gIHJldHVybiBmb3JtYXQoe1xuICAgIHByb3RvY29sOiBzb2NrZXRVUkxQcm90b2NvbCxcbiAgICBhdXRoOiBzb2NrZXRVUkxBdXRoLFxuICAgIGhvc3RuYW1lOiBzb2NrZXRVUkxIb3N0bmFtZSxcbiAgICBwb3J0OiBzb2NrZXRVUkxQb3J0LFxuICAgIHBhdGhuYW1lOiBzb2NrZXRVUkxQYXRobmFtZSxcbiAgICBzbGFzaGVzOiB0cnVlXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU29ja2V0VVJMOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/createSocketURL.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to find the current script,\n  // but is not supported in all browsers.\n  if (document.currentScript) {\n    return document.currentScript.getAttribute(\"src\");\n  }\n\n  // Fallback to getting all scripts running in the document.\n  var scriptElements = document.scripts || [];\n  var scriptElementsWithSrc = Array.prototype.filter.call(scriptElements, function (element) {\n    return element.getAttribute(\"src\");\n  });\n  if (scriptElementsWithSrc.length > 0) {\n    var currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute(\"src\");\n  }\n\n  // Fail as there was no script to use.\n  throw new Error(\"[webpack-dev-server] Failed to get current script source.\");\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getCurrentScriptSource);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qcz9jZjJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgcnVubmluZyBpbiB0aGUgZG9jdW1lbnQuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBzY3JpcHRFbGVtZW50c1dpdGhTcmMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoc2NyaXB0RWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICB9KTtcbiAgaWYgKHNjcmlwdEVsZW1lbnRzV2l0aFNyYy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1dpdGhTcmNbc2NyaXB0RWxlbWVudHNXaXRoU3JjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfVxuXG4gIC8vIEZhaWwgYXMgdGhlcmUgd2FzIG5vIHNjcmlwdCB0byB1c2UuXG4gIHRocm93IG5ldyBFcnJvcihcIlt3ZWJwYWNrLWRldi1zZXJ2ZXJdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLlwiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGdldEN1cnJlbnRTY3JpcHRTb3VyY2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   logEnabledFeatures: () => (/* binding */ logEnabledFeatures),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logger/index.js */ \"./node_modules/webpack-dev-server/client/modules/logger/index.js\");\n/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\nvar name = \"webpack-dev-server\";\n// default level is set on the client side, so it does not need\n// to be set by the CLI or API\nvar defaultLevel = \"info\";\n\n// options new options, merge with old options\n/**\n * @param {false | true | \"none\" | \"error\" | \"warn\" | \"info\" | \"log\" | \"verbose\"} level\n * @returns {void}\n */\nfunction setLogLevel(level) {\n  _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().configureDefaultLogger({\n    level: level\n  });\n}\nsetLogLevel(defaultLevel);\nvar log = _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().getLogger(name);\nvar logEnabledFeatures = function logEnabledFeatures(features) {\n  var enabledFeatures = Object.keys(features);\n  if (!features || enabledFeatures.length === 0) {\n    return;\n  }\n  var logString = \"Server started:\";\n\n  // Server started: Hot Module Replacement enabled, Live Reloading enabled, Overlay disabled.\n  for (var i = 0; i < enabledFeatures.length; i++) {\n    var key = enabledFeatures[i];\n    logString += \" \".concat(key, \" \").concat(features[key] ? \"enabled\" : \"disabled\", \",\");\n  }\n  // replace last comma with a period\n  logString = logString.slice(0, -1).concat(\".\");\n  log.info(logString);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUVBQXVFO0FBQ2xGLGFBQWE7QUFDYjtBQUNBO0FBQ0EsRUFBRSxzRkFBNkI7QUFDL0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUseUVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzPzYyMjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZ2dlciBmcm9tIFwiLi4vbW9kdWxlcy9sb2dnZXIvaW5kZXguanNcIjtcbnZhciBuYW1lID0gXCJ3ZWJwYWNrLWRldi1zZXJ2ZXJcIjtcbi8vIGRlZmF1bHQgbGV2ZWwgaXMgc2V0IG9uIHRoZSBjbGllbnQgc2lkZSwgc28gaXQgZG9lcyBub3QgbmVlZFxuLy8gdG8gYmUgc2V0IGJ5IHRoZSBDTEkgb3IgQVBJXG52YXIgZGVmYXVsdExldmVsID0gXCJpbmZvXCI7XG5cbi8vIG9wdGlvbnMgbmV3IG9wdGlvbnMsIG1lcmdlIHdpdGggb2xkIG9wdGlvbnNcbi8qKlxuICogQHBhcmFtIHtmYWxzZSB8IHRydWUgfCBcIm5vbmVcIiB8IFwiZXJyb3JcIiB8IFwid2FyblwiIHwgXCJpbmZvXCIgfCBcImxvZ1wiIHwgXCJ2ZXJib3NlXCJ9IGxldmVsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgbG9nZ2VyLmNvbmZpZ3VyZURlZmF1bHRMb2dnZXIoe1xuICAgIGxldmVsOiBsZXZlbFxuICB9KTtcbn1cbnNldExvZ0xldmVsKGRlZmF1bHRMZXZlbCk7XG52YXIgbG9nID0gbG9nZ2VyLmdldExvZ2dlcihuYW1lKTtcbnZhciBsb2dFbmFibGVkRmVhdHVyZXMgPSBmdW5jdGlvbiBsb2dFbmFibGVkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgdmFyIGVuYWJsZWRGZWF0dXJlcyA9IE9iamVjdC5rZXlzKGZlYXR1cmVzKTtcbiAgaWYgKCFmZWF0dXJlcyB8fCBlbmFibGVkRmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsb2dTdHJpbmcgPSBcIlNlcnZlciBzdGFydGVkOlwiO1xuXG4gIC8vIFNlcnZlciBzdGFydGVkOiBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQsIExpdmUgUmVsb2FkaW5nIGVuYWJsZWQsIE92ZXJsYXkgZGlzYWJsZWQuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5hYmxlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGVuYWJsZWRGZWF0dXJlc1tpXTtcbiAgICBsb2dTdHJpbmcgKz0gXCIgXCIuY29uY2F0KGtleSwgXCIgXCIpLmNvbmNhdChmZWF0dXJlc1trZXldID8gXCJlbmFibGVkXCIgOiBcImRpc2FibGVkXCIsIFwiLFwiKTtcbiAgfVxuICAvLyByZXBsYWNlIGxhc3QgY29tbWEgd2l0aCBhIHBlcmlvZFxuICBsb2dTdHJpbmcgPSBsb2dTdHJpbmcuc2xpY2UoMCwgLTEpLmNvbmNhdChcIi5cIik7XG4gIGxvZy5pbmZvKGxvZ1N0cmluZyk7XG59O1xuZXhwb3J0IHsgbG9nLCBsb2dFbmFibGVkRmVhdHVyZXMsIHNldExvZ0xldmVsIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/log.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/parseURL.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/parseURL.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCurrentScriptSource.js */ \"./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\");\n\n\n/**\n * @param {string} resourceQuery\n * @returns {{ [key: string]: string | boolean }}\n */\nfunction parseURL(resourceQuery) {\n  /** @type {{ [key: string]: string }} */\n  var options = {};\n  if (typeof resourceQuery === \"string\" && resourceQuery !== \"\") {\n    var searchParams = resourceQuery.slice(1).split(\"&\");\n    for (var i = 0; i < searchParams.length; i++) {\n      var pair = searchParams[i].split(\"=\");\n      options[pair[0]] = decodeURIComponent(pair[1]);\n    }\n  } else {\n    // Else, get the url from the <script> this file was called with.\n    var scriptSource = (0,_getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    var scriptSourceURL;\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      scriptSourceURL = new URL(scriptSource, self.location.href);\n    } catch (error) {\n      // URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    }\n    if (scriptSourceURL) {\n      options = scriptSourceURL;\n      options.fromCurrentScript = true;\n    }\n  }\n  return options;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseURL);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9wYXJzZVVSTC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTs7QUFFakU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHVCQUF1QixzRUFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9wYXJzZVVSTC5qcz9lYzVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRDdXJyZW50U2NyaXB0U291cmNlIGZyb20gXCIuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UuanNcIjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VRdWVyeVxuICogQHJldHVybnMge3sgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB9fVxuICovXG5mdW5jdGlvbiBwYXJzZVVSTChyZXNvdXJjZVF1ZXJ5KSB7XG4gIC8qKiBAdHlwZSB7eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfX0gKi9cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIHJlc291cmNlUXVlcnkgIT09IFwiXCIpIHtcbiAgICB2YXIgc2VhcmNoUGFyYW1zID0gcmVzb3VyY2VRdWVyeS5zbGljZSgxKS5zcGxpdChcIiZcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWFyY2hQYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYWlyID0gc2VhcmNoUGFyYW1zW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgIG9wdGlvbnNbcGFpclswXV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdFNvdXJjZSA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcbiAgICB2YXIgc2NyaXB0U291cmNlVVJMO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgcGxhY2Vob2xkZXIgYGJhc2VVUkxgIHdpdGggYHdpbmRvdy5sb2NhdGlvbi5ocmVmYCxcbiAgICAgIC8vIGlzIHRvIGFsbG93IHBhcnNpbmcgb2YgcGF0aC1yZWxhdGl2ZSBvciBwcm90b2NvbC1yZWxhdGl2ZSBVUkxzLFxuICAgICAgLy8gYW5kIHdpbGwgaGF2ZSBubyBlZmZlY3QgaWYgYHNjcmlwdFNvdXJjZWAgaXMgYSBmdWxseSB2YWxpZCBVUkwuXG4gICAgICBzY3JpcHRTb3VyY2VVUkwgPSBuZXcgVVJMKHNjcmlwdFNvdXJjZSwgc2VsZi5sb2NhdGlvbi5ocmVmKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVVJMIHBhcnNpbmcgZmFpbGVkLCBkbyBub3RoaW5nLlxuICAgICAgLy8gV2Ugd2lsbCBzdGlsbCBwcm9jZWVkIHRvIHNlZSBpZiB3ZSBjYW4gcmVjb3ZlciB1c2luZyBgcmVzb3VyY2VRdWVyeWBcbiAgICB9XG4gICAgaWYgKHNjcmlwdFNvdXJjZVVSTCkge1xuICAgICAgb3B0aW9ucyA9IHNjcmlwdFNvdXJjZVVSTDtcbiAgICAgIG9wdGlvbnMuZnJvbUN1cnJlbnRTY3JpcHQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydCBkZWZhdWx0IHBhcnNlVVJMOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/parseURL.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/emitter.js */ \"./node_modules/webpack/hot/emitter.js\");\n/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\n\n\n\n/** @typedef {import(\"../index\").Options} Options\n/** @typedef {import(\"../index\").Status} Status\n\n/**\n * @param {Options} options\n * @param {Status} status\n */\nfunction reloadApp(_ref, status) {\n  var hot = _ref.hot,\n    liveReload = _ref.liveReload;\n  if (status.isUnloading) {\n    return;\n  }\n  var currentHash = status.currentHash,\n    previousHash = status.previousHash;\n  var isInitial = currentHash.indexOf( /** @type {string} */previousHash) >= 0;\n  if (isInitial) {\n    return;\n  }\n\n  /**\n   * @param {Window} rootWindow\n   * @param {number} intervalId\n   */\n  function applyReload(rootWindow, intervalId) {\n    clearInterval(intervalId);\n    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info(\"App updated. Reloading...\");\n    rootWindow.location.reload();\n  }\n  var search = self.location.search.toLowerCase();\n  var allowToHot = search.indexOf(\"webpack-dev-server-hot=false\") === -1;\n  var allowToLiveReload = search.indexOf(\"webpack-dev-server-live-reload=false\") === -1;\n  if (hot && allowToHot) {\n    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info(\"App hot update...\");\n    webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default().emit(\"webpackHotUpdate\", status.currentHash);\n    if (typeof self !== \"undefined\" && self.window) {\n      // broadcast update to window\n      self.postMessage(\"webpackHotUpdate\".concat(status.currentHash), \"*\");\n    }\n  }\n  // allow refreshing the page only if liveReload isn't disabled\n  else if (liveReload && allowToLiveReload) {\n    var rootWindow = self;\n\n    // use parent window for reload (in case we're in an iframe with no valid src)\n    var intervalId = self.setInterval(function () {\n      if (rootWindow.location.protocol !== \"about:\") {\n        // reload immediately if protocol is valid\n        applyReload(rootWindow, intervalId);\n      } else {\n        rootWindow = rootWindow.parent;\n        if (rootWindow.parent === rootWindow) {\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n          applyReload(rootWindow, intervalId);\n        }\n      }\n    });\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reloadApp);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRDtBQUNqQjs7QUFFL0IsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYywyQkFBMkI7O0FBRXpDO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdDQUFHO0FBQ1AsSUFBSSxrRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3JlbG9hZEFwcC5qcz81YzUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBob3RFbWl0dGVyIGZyb20gXCJ3ZWJwYWNrL2hvdC9lbWl0dGVyLmpzXCI7XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi9sb2cuanNcIjtcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9pbmRleFwiKS5PcHRpb25zfSBPcHRpb25zXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL2luZGV4XCIpLlN0YXR1c30gU3RhdHVzXG5cbi8qKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBzdGF0dXMpIHtcbiAgdmFyIGhvdCA9IF9yZWYuaG90LFxuICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG4gIGlmIChzdGF0dXMuaXNVbmxvYWRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGN1cnJlbnRIYXNoID0gc3RhdHVzLmN1cnJlbnRIYXNoLFxuICAgIHByZXZpb3VzSGFzaCA9IHN0YXR1cy5wcmV2aW91c0hhc2g7XG4gIHZhciBpc0luaXRpYWwgPSBjdXJyZW50SGFzaC5pbmRleE9mKCAvKiogQHR5cGUge3N0cmluZ30gKi9wcmV2aW91c0hhc2gpID49IDA7XG4gIGlmIChpc0luaXRpYWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtXaW5kb3d9IHJvb3RXaW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSWRcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKFwiQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLlwiKTtcbiAgICByb290V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG4gIHZhciBzZWFyY2ggPSBzZWxmLmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWxsb3dUb0hvdCA9IHNlYXJjaC5pbmRleE9mKFwid2VicGFjay1kZXYtc2VydmVyLWhvdD1mYWxzZVwiKSA9PT0gLTE7XG4gIHZhciBhbGxvd1RvTGl2ZVJlbG9hZCA9IHNlYXJjaC5pbmRleE9mKFwid2VicGFjay1kZXYtc2VydmVyLWxpdmUtcmVsb2FkPWZhbHNlXCIpID09PSAtMTtcbiAgaWYgKGhvdCAmJiBhbGxvd1RvSG90KSB7XG4gICAgbG9nLmluZm8oXCJBcHAgaG90IHVwZGF0ZS4uLlwiKTtcbiAgICBob3RFbWl0dGVyLmVtaXQoXCJ3ZWJwYWNrSG90VXBkYXRlXCIsIHN0YXR1cy5jdXJyZW50SGFzaCk7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoc3RhdHVzLmN1cnJlbnRIYXNoKSwgXCIqXCIpO1xuICAgIH1cbiAgfVxuICAvLyBhbGxvdyByZWZyZXNoaW5nIHRoZSBwYWdlIG9ubHkgaWYgbGl2ZVJlbG9hZCBpc24ndCBkaXNhYmxlZFxuICBlbHNlIGlmIChsaXZlUmVsb2FkICYmIGFsbG93VG9MaXZlUmVsb2FkKSB7XG4gICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmO1xuXG4gICAgLy8gdXNlIHBhcmVudCB3aW5kb3cgZm9yIHJlbG9hZCAoaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUgd2l0aCBubyB2YWxpZCBzcmMpXG4gICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSBcImFib3V0OlwiKSB7XG4gICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IHJlbG9hZEFwcDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/reloadApp.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* global __resourceQuery WorkerGlobalScope */\n\n// Send messages to the outside, so plugins can consume it.\n/**\n * @param {string} type\n * @param {any} [data]\n */\nfunction sendMsg(type, data) {\n  if (typeof self !== \"undefined\" && (typeof WorkerGlobalScope === \"undefined\" || !(self instanceof WorkerGlobalScope))) {\n    self.postMessage({\n      type: \"webpack\".concat(type),\n      data: data\n    }, \"*\");\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendMsg);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpRUFBZSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3NlbmRNZXNzYWdlLmpzPzgwNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSAqL1xuXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHthbnl9IFtkYXRhXVxuICovXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09IFwidW5kZWZpbmVkXCIgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sIFwiKlwiKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgc2VuZE1zZzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/sendMessage.js\n");

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/stripAnsi.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/stripAnsi.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar ansiRegex = new RegExp([\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))\"].join(\"|\"), \"g\");\n\n/**\n *\n * Strip [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from a string.\n * Adapted from code originally released by Sindre Sorhus\n * Licensed the MIT License\n *\n * @param {string} string\n * @return {string}\n */\nfunction stripAnsi(string) {\n  if (typeof string !== \"string\") {\n    throw new TypeError(\"Expected a `string`, got `\".concat(typeof string, \"`\"));\n  }\n  return string.replace(ansiRegex, \"\");\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stripAnsi);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zdHJpcEFuc2kuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHNEQUFzRCxnQkFBZ0IsNkNBQTZDLG9EQUFvRCxJQUFJLElBQUksSUFBSSxJQUFJOztBQUV2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zdHJpcEFuc2kuanM/NGZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYW5zaVJlZ2V4ID0gbmV3IFJlZ0V4cChbXCJbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpXCIsIFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1ucS11eT0+PH5dKSlcIl0uam9pbihcInxcIiksIFwiZ1wiKTtcblxuLyoqXG4gKlxuICogU3RyaXAgW0FOU0kgZXNjYXBlIGNvZGVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlKSBmcm9tIGEgc3RyaW5nLlxuICogQWRhcHRlZCBmcm9tIGNvZGUgb3JpZ2luYWxseSByZWxlYXNlZCBieSBTaW5kcmUgU29yaHVzXG4gKiBMaWNlbnNlZCB0aGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwQW5zaShzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBgc3RyaW5nYCwgZ290IGBcIi5jb25jYXQodHlwZW9mIHN0cmluZywgXCJgXCIpKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4LCBcIlwiKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHN0cmlwQW5zaTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/stripAnsi.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/dev-server.js":
/*!************************************************!*\
  !*** ./node_modules/webpack/hot/dev-server.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/* globals __webpack_hash__ */\nif (true) {\n  /** @type {undefined|string} */\n  var lastHash;\n  var upToDate = function upToDate() {\n    return /** @type {string} */lastHash.indexOf(__webpack_require__.h()) >= 0;\n  };\n  var log = __webpack_require__(/*! ./log */ \"./node_modules/webpack/hot/log.js\");\n  var check = function check() {\n    module.hot.check(true).then(function (updatedModules) {\n      if (!updatedModules) {\n        log(\"warning\", \"[HMR] Cannot find update. \" + (typeof window !== \"undefined\" ? \"Need to do a full reload!\" : \"Please reload manually!\"));\n        log(\"warning\", \"[HMR] (Probably because of restarting the webpack-dev-server)\");\n        if (typeof window !== \"undefined\") {\n          window.location.reload();\n        }\n        return;\n      }\n      if (!upToDate()) {\n        check();\n      }\n      __webpack_require__(/*! ./log-apply-result */ \"./node_modules/webpack/hot/log-apply-result.js\")(updatedModules, updatedModules);\n      if (upToDate()) {\n        log(\"info\", \"[HMR] App is up to date.\");\n      }\n    }).catch(function (err) {\n      var status = module.hot.status();\n      if ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n        log(\"warning\", \"[HMR] Cannot apply update. \" + (typeof window !== \"undefined\" ? \"Need to do a full reload!\" : \"Please reload manually!\"));\n        log(\"warning\", \"[HMR] \" + log.formatError(err));\n        if (typeof window !== \"undefined\") {\n          window.location.reload();\n        }\n      } else {\n        log(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n      }\n    });\n  };\n  var hotEmitter = __webpack_require__(/*! ./emitter */ \"./node_modules/webpack/hot/emitter.js\");\n  hotEmitter.on(\"webpackHotUpdate\", function (currentHash) {\n    lastHash = currentHash;\n    if (!upToDate() && module.hot.status() === \"idle\") {\n      log(\"info\", \"[HMR] Checking for updates on the server...\");\n      check();\n    }\n  });\n  log(\"info\", \"[HMR] Waiting for update signal from WDS...\");\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZGV2LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFVO0FBQ2QsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixRQUFRLG1CQUFtQix1QkFBZ0I7QUFDakU7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0RBQU87QUFDM0I7QUFDQSxJQUFJLFVBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQkFBTyxDQUFDLDBFQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx3REFBVztBQUN0QztBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9kZXYtc2VydmVyLmpzPzEyYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8qIGdsb2JhbHMgX193ZWJwYWNrX2hhc2hfXyAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgLyoqIEB0eXBlIHt1bmRlZmluZWR8c3RyaW5nfSAqL1xuICB2YXIgbGFzdEhhc2g7XG4gIHZhciB1cFRvRGF0ZSA9IGZ1bmN0aW9uIHVwVG9EYXRlKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge3N0cmluZ30gKi9sYXN0SGFzaC5pbmRleE9mKF9fd2VicGFja19oYXNoX18pID49IDA7XG4gIH07XG4gIHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIG1vZHVsZS5ob3QuY2hlY2sodHJ1ZSkudGhlbihmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmICghdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZS4gXCIgKyAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IFwiTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiIDogXCJQbGVhc2UgcmVsb2FkIG1hbnVhbGx5IVwiKSk7XG4gICAgICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSB3ZWJwYWNrLWRldi1zZXJ2ZXIpXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXVwVG9EYXRlKCkpIHtcbiAgICAgICAgY2hlY2soKTtcbiAgICAgIH1cbiAgICAgIHJlcXVpcmUoXCIuL2xvZy1hcHBseS1yZXN1bHRcIikodXBkYXRlZE1vZHVsZXMsIHVwZGF0ZWRNb2R1bGVzKTtcbiAgICAgIGlmICh1cFRvRGF0ZSgpKSB7XG4gICAgICAgIGxvZyhcImluZm9cIiwgXCJbSE1SXSBBcHAgaXMgdXAgdG8gZGF0ZS5cIik7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgdmFyIHN0YXR1cyA9IG1vZHVsZS5ob3Quc3RhdHVzKCk7XG4gICAgICBpZiAoW1wiYWJvcnRcIiwgXCJmYWlsXCJdLmluZGV4T2Yoc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBDYW5ub3QgYXBwbHkgdXBkYXRlLiBcIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCJOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIgOiBcIlBsZWFzZSByZWxvYWQgbWFudWFsbHkhXCIpKTtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKFwid2FybmluZ1wiLCBcIltITVJdIFVwZGF0ZSBmYWlsZWQ6IFwiICsgbG9nLmZvcm1hdEVycm9yKGVycikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoXCIuL2VtaXR0ZXJcIik7XG4gIGhvdEVtaXR0ZXIub24oXCJ3ZWJwYWNrSG90VXBkYXRlXCIsIGZ1bmN0aW9uIChjdXJyZW50SGFzaCkge1xuICAgIGxhc3RIYXNoID0gY3VycmVudEhhc2g7XG4gICAgaWYgKCF1cFRvRGF0ZSgpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XG4gICAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgb24gdGhlIHNlcnZlci4uLlwiKTtcbiAgICAgIGNoZWNrKCk7XG4gICAgfVxuICB9KTtcbiAgbG9nKFwiaW5mb1wiLCBcIltITVJdIFdhaXRpbmcgZm9yIHVwZGF0ZSBzaWduYWwgZnJvbSBXRFMuLi5cIik7XG59IGVsc2Uge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/dev-server.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nmodule.exports = new EventEmitter();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZW1pdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQywrQ0FBUTtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZW1pdHRlci5qcz8xMjBmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/emitter.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/**\n * @param {(string | number)[]} updatedModules updated modules\n * @param {(string | number)[] | null} renewedModules renewed modules\n */\nmodule.exports = function (updatedModules, renewedModules) {\n  var unacceptedModules = updatedModules.filter(function (moduleId) {\n    return renewedModules && renewedModules.indexOf(moduleId) < 0;\n  });\n  var log = __webpack_require__(/*! ./log */ \"./node_modules/webpack/hot/log.js\");\n  if (unacceptedModules.length > 0) {\n    log(\"warning\", \"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\");\n    unacceptedModules.forEach(function (moduleId) {\n      log(\"warning\", \"[HMR]  - \" + moduleId);\n    });\n  }\n  if (!renewedModules || renewedModules.length === 0) {\n    log(\"info\", \"[HMR] Nothing hot updated.\");\n  } else {\n    log(\"info\", \"[HMR] Updated modules:\");\n    renewedModules.forEach(function (moduleId) {\n      if (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\n        var parts = moduleId.split(\"!\");\n        log.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\n        log(\"info\", \"[HMR]  - \" + moduleId);\n        log.groupEnd(\"info\");\n      } else {\n        log(\"info\", \"[HMR]  - \" + moduleId);\n      }\n    });\n    var numberIds = renewedModules.every(function (moduleId) {\n      return typeof moduleId === \"number\";\n    });\n    if (numberIds) log(\"info\", '[HMR] Consider using the optimization.moduleIds: \"named\" for module names.');\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksbUJBQU8sQ0FBQyxnREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcz9mZjM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgbnVtYmVyKVtdfSB1cGRhdGVkTW9kdWxlcyB1cGRhdGVkIG1vZHVsZXNcbiAqIEBwYXJhbSB7KHN0cmluZyB8IG51bWJlcilbXSB8IG51bGx9IHJlbmV3ZWRNb2R1bGVzIHJlbmV3ZWQgbW9kdWxlc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cGRhdGVkTW9kdWxlcywgcmVuZXdlZE1vZHVsZXMpIHtcbiAgdmFyIHVuYWNjZXB0ZWRNb2R1bGVzID0gdXBkYXRlZE1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgIHJldHVybiByZW5ld2VkTW9kdWxlcyAmJiByZW5ld2VkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDA7XG4gIH0pO1xuICB2YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xuICBpZiAodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuICAgIGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IChUaGV5IHdvdWxkIG5lZWQgYSBmdWxsIHJlbG9hZCEpXCIpO1xuICAgIHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgICBsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFyZW5ld2VkTW9kdWxlcyB8fCByZW5ld2VkTW9kdWxlcy5sZW5ndGggPT09IDApIHtcbiAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gTm90aGluZyBob3QgdXBkYXRlZC5cIik7XG4gIH0gZWxzZSB7XG4gICAgbG9nKFwiaW5mb1wiLCBcIltITVJdIFVwZGF0ZWQgbW9kdWxlczpcIik7XG4gICAgcmVuZXdlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlSWQgPT09IFwic3RyaW5nXCIgJiYgbW9kdWxlSWQuaW5kZXhPZihcIiFcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IG1vZHVsZUlkLnNwbGl0KFwiIVwiKTtcbiAgICAgICAgbG9nLmdyb3VwQ29sbGFwc2VkKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgcGFydHMucG9wKCkpO1xuICAgICAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG4gICAgICAgIGxvZy5ncm91cEVuZChcImluZm9cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2coXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG51bWJlcklkcyA9IHJlbmV3ZWRNb2R1bGVzLmV2ZXJ5KGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJudW1iZXJcIjtcbiAgICB9KTtcbiAgICBpZiAobnVtYmVySWRzKSBsb2coXCJpbmZvXCIsICdbSE1SXSBDb25zaWRlciB1c2luZyB0aGUgb3B0aW1pemF0aW9uLm1vZHVsZUlkczogXCJuYW1lZFwiIGZvciBtb2R1bGUgbmFtZXMuJyk7XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log-apply-result.js\n");

/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/** @typedef {\"info\" | \"warning\" | \"error\"} LogLevel */\n\n/** @type {LogLevel} */\nvar logLevel = \"info\";\nfunction dummy() {}\n\n/**\n * @param {LogLevel} level log level\n * @returns {boolean} true, if should log\n */\nfunction shouldLog(level) {\n  var shouldLog = logLevel === \"info\" && level === \"info\" || [\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\" || [\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\";\n  return shouldLog;\n}\n\n/**\n * @param {(msg?: string) => void} logFn log function\n * @returns {(level: LogLevel, msg?: string) => void} function that logs when log level is sufficient\n */\nfunction logGroup(logFn) {\n  return function (level, msg) {\n    if (shouldLog(level)) {\n      logFn(msg);\n    }\n  };\n}\n\n/**\n * @param {LogLevel} level log level\n * @param {string|Error} msg message\n */\nmodule.exports = function (level, msg) {\n  if (shouldLog(level)) {\n    if (level === \"info\") {\n      console.log(msg);\n    } else if (level === \"warning\") {\n      console.warn(msg);\n    } else if (level === \"error\") {\n      console.error(msg);\n    }\n  }\n};\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\nmodule.exports.group = logGroup(group);\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\nmodule.exports.groupEnd = logGroup(groupEnd);\n\n/**\n * @param {LogLevel} level log level\n */\nmodule.exports.setLogLevel = function (level) {\n  logLevel = level;\n};\n\n/**\n * @param {Error} err error\n * @returns {string} formatted error\n */\nmodule.exports.formatError = function (err) {\n  var message = err.message;\n  var stack = err.stack;\n  if (!stack) {\n    return message;\n  } else if (stack.indexOf(message) < 0) {\n    return message + \"\\n\" + stack;\n  } else {\n    return stack;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsOEJBQThCOztBQUU1QyxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWEseUNBQXlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLHVCQUF1Qjs7QUFFdkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2cuanM/OTNkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHR5cGVkZWYge1wiaW5mb1wiIHwgXCJ3YXJuaW5nXCIgfCBcImVycm9yXCJ9IExvZ0xldmVsICovXG5cbi8qKiBAdHlwZSB7TG9nTGV2ZWx9ICovXG52YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcbmZ1bmN0aW9uIGR1bW15KCkge31cblxuLyoqXG4gKiBAcGFyYW0ge0xvZ0xldmVsfSBsZXZlbCBsb2cgbGV2ZWxcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlLCBpZiBzaG91bGQgbG9nXG4gKi9cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuICB2YXIgc2hvdWxkTG9nID0gbG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIiB8fCBbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIiB8fCBbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIjtcbiAgcmV0dXJuIHNob3VsZExvZztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyhtc2c/OiBzdHJpbmcpID0+IHZvaWR9IGxvZ0ZuIGxvZyBmdW5jdGlvblxuICogQHJldHVybnMgeyhsZXZlbDogTG9nTGV2ZWwsIG1zZz86IHN0cmluZykgPT4gdm9pZH0gZnVuY3Rpb24gdGhhdCBsb2dzIHdoZW4gbG9nIGxldmVsIGlzIHN1ZmZpY2llbnRcbiAqL1xuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG4gICAgaWYgKHNob3VsZExvZyhsZXZlbCkpIHtcbiAgICAgIGxvZ0ZuKG1zZyk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TG9nTGV2ZWx9IGxldmVsIGxvZyBsZXZlbFxuICogQHBhcmFtIHtzdHJpbmd8RXJyb3J9IG1zZyBtZXNzYWdlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxldmVsLCBtc2cpIHtcbiAgaWYgKHNob3VsZExvZyhsZXZlbCkpIHtcbiAgICBpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9XG4gIH1cbn07XG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbi8qKlxuICogQHBhcmFtIHtMb2dMZXZlbH0gbGV2ZWwgbG9nIGxldmVsXG4gKi9cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gIGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBlcnJvclxuICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIGVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICB2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG4gIGlmICghc3RhY2spIHtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSBlbHNlIGlmIChzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDwgMCkge1xuICAgIHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGFjaztcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log.js\n");

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/dist/index.js\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\");\n/* harmony import */ var _pages_home__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pages/home */ \"./src/pages/home.js\");\n/* harmony import */ var _pages_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/login */ \"./src/pages/login.js\");\n\n\n\n\n\n\nconst mainDiv = document.getElementById('a');\nconst root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(mainDiv);\nfunction App() {\n  const [loggedIn, setLoggedIn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [email, setEmail] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"App\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_4__.BrowserRouter, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Routes, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {\n    path: \"/main_window\",\n    element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_pages_home__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n      email: email,\n      loggedIn: loggedIn,\n      setLoggedIn: setLoggedIn\n    })\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {\n    path: \"/login\",\n    element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_pages_login__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n      setLoggedIn: setLoggedIn,\n      setEmail: setEmail\n    })\n  }))));\n}\n;\nroot.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(App, null));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStCO0FBQzJDO0FBQzVCO0FBQ2Q7QUFFWTtBQUNWO0FBRWxDLE1BQU1VLE9BQU8sR0FBR0MsUUFBUSxDQUFDQyxjQUFjLENBQUMsR0FBRyxDQUFDO0FBQzVDLE1BQU1DLElBQUksR0FBR1IsNERBQVUsQ0FBQ0ssT0FBTyxDQUFDO0FBRWhCLFNBQVNJLEdBQUdBLENBQUEsRUFBRTtFQUM1QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsV0FBVyxDQUFDLEdBQUdSLCtDQUFRLENBQUMsS0FBSyxDQUFDO0VBQy9DLE1BQU0sQ0FBQ1MsS0FBSyxFQUFFQyxRQUFRLENBQUMsR0FBR1YsK0NBQVEsQ0FBQyxFQUFFLENBQUM7RUFFdEMsb0JBQ0VSLGdEQUFBO0lBQUtvQixTQUFTLEVBQUM7RUFBSyxnQkFDbEJwQixnREFBQSxDQUFDRSwyREFBTSxxQkFDTEYsZ0RBQUEsQ0FBQ0ksb0RBQU0scUJBQ0xKLGdEQUFBLENBQUNHLG1EQUFLO0lBQUNrQixJQUFJLEVBQUMsY0FBYztJQUFDQyxPQUFPLGVBQUV0QixnREFBQSxDQUFDTSxtREFBSTtNQUFDVyxLQUFLLEVBQUVBLEtBQU07TUFBQ0YsUUFBUSxFQUFFQSxRQUFTO01BQUNDLFdBQVcsRUFBRUE7SUFBWSxDQUFFO0VBQUUsQ0FBRSxDQUFDLGVBQzVHaEIsZ0RBQUEsQ0FBQ0csbURBQUs7SUFBQ2tCLElBQUksRUFBQyxRQUFRO0lBQUNDLE9BQU8sZUFBRXRCLGdEQUFBLENBQUNTLG9EQUFLO01BQUNPLFdBQVcsRUFBRUEsV0FBWTtNQUFDRSxRQUFRLEVBQUVBO0lBQVMsQ0FBRTtFQUFFLENBQUUsQ0FDbEYsQ0FDRixDQUNMLENBQUM7QUFFVjtBQUFDO0FBRURMLElBQUksQ0FBQ1UsTUFBTSxlQUFDdkIsZ0RBQUEsQ0FBQ2MsR0FBRyxNQUFFLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VsZWN0cm9uanMvLi9zcmMvQXBwLmpzP2JlOTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBCcm93c2VyUm91dGVyIGFzIFJvdXRlciwgUm91dGUsIFJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xyXG5pbXBvcnQgeyBjcmVhdGVSb290IH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XHJcbmltcG9ydCBIb21lIGZyb20gJy4vcGFnZXMvaG9tZSc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgTG9naW4gZnJvbSAnLi9wYWdlcy9sb2dpbic7XHJcblxyXG5jb25zdCBtYWluRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2EnKTtcclxuY29uc3Qgcm9vdCA9IGNyZWF0ZVJvb3QobWFpbkRpdik7XHJcblxyXG4gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKCl7XHJcbiAgY29uc3QgW2xvZ2dlZEluLCBzZXRMb2dnZWRJbl0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbZW1haWwsIHNldEVtYWlsXSA9IHVzZVN0YXRlKCcnKVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJBcHBcIj5cclxuICAgICAgPFJvdXRlcj5cclxuICAgICAgICA8Um91dGVzPlxyXG4gICAgICAgICAgPFJvdXRlIHBhdGg9XCIvbWFpbl93aW5kb3dcIiBlbGVtZW50PXs8SG9tZSBlbWFpbD17ZW1haWx9IGxvZ2dlZEluPXtsb2dnZWRJbn0gc2V0TG9nZ2VkSW49e3NldExvZ2dlZElufSAvPn0gLz5cclxuICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL2xvZ2luXCIgZWxlbWVudD17PExvZ2luIHNldExvZ2dlZEluPXtzZXRMb2dnZWRJbn0gc2V0RW1haWw9e3NldEVtYWlsfSAvPn0gLz5cclxuICAgICAgICA8L1JvdXRlcz5cclxuICAgICAgPC9Sb3V0ZXI+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxucm9vdC5yZW5kZXIoPEFwcCAvPik7XHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQnJvd3NlclJvdXRlciIsIlJvdXRlciIsIlJvdXRlIiwiUm91dGVzIiwiY3JlYXRlUm9vdCIsIkhvbWUiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkxvZ2luIiwibWFpbkRpdiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyb290IiwiQXBwIiwibG9nZ2VkSW4iLCJzZXRMb2dnZWRJbiIsImVtYWlsIiwic2V0RW1haWwiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicGF0aCIsImVsZW1lbnQiLCJyZW5kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/App.js\n");

/***/ }),

/***/ "./src/pages/home.js":
/*!***************************!*\
  !*** ./src/pages/home.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router/dist/index.js\");\n\n\nfunction Home(props) {\n  const {\n    loggedIn,\n    email\n  } = props;\n  const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();\n  const onButtonClick = () => {\n    if (loggedIn) {\n      props.setLoggedIn(false);\n    } else {\n      navigate('/login');\n    }\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: \"mainContainer\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'titleContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"Welcome!\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'buttonContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    className: 'inputButton',\n    type: \"button\",\n    onClick: onButtonClick,\n    value: loggedIn ? 'Log out' : 'Log in'\n  }), loggedIn ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"Your email address is \", email) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null)));\n}\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaG9tZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlCO0FBQ3FCO0FBRS9CLFNBQVNFLElBQUlBLENBQUNDLEtBQUssRUFBQztFQUNqQyxNQUFNO0lBQUVDLFFBQVE7SUFBRUM7RUFBTSxDQUFDLEdBQUdGLEtBQUs7RUFFakMsTUFBTUcsUUFBUSxHQUFHTCw2REFBVyxDQUFDLENBQUM7RUFDOUIsTUFBTU0sYUFBYSxHQUFHQSxDQUFBLEtBQU07SUFDMUIsSUFBR0gsUUFBUSxFQUFDO01BQ1ZELEtBQUssQ0FBQ0ssV0FBVyxDQUFDLEtBQUssQ0FBQztJQUMxQixDQUFDLE1BQUk7TUFDSEYsUUFBUSxDQUFDLFFBQVEsQ0FBQztJQUNwQjtFQUVGLENBQUM7RUFFRCxvQkFDRU4sMERBQUE7SUFBS1UsU0FBUyxFQUFDO0VBQWUsZ0JBQzVCViwwREFBQTtJQUFLVSxTQUFTLEVBQUU7RUFBaUIsZ0JBQy9CViwwREFBQSxjQUFLLFVBQWEsQ0FDZixDQUFDLGVBQ05BLDBEQUFBO0lBQUtVLFNBQVMsRUFBRTtFQUFrQixnQkFDaENWLDBEQUFBO0lBQ0VVLFNBQVMsRUFBRSxhQUFjO0lBQ3pCQyxJQUFJLEVBQUMsUUFBUTtJQUNiQyxPQUFPLEVBQUVMLGFBQWM7SUFDdkJNLEtBQUssRUFBRVQsUUFBUSxHQUFHLFNBQVMsR0FBRztFQUFTLENBQ3hDLENBQUMsRUFDREEsUUFBUSxnQkFBR0osMERBQUEsY0FBSyx3QkFBc0IsRUFBQ0ssS0FBVyxDQUFDLGdCQUFHTCwwREFBQSxZQUFNLENBQzFELENBQ0YsQ0FBQztBQUVWO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbGVjdHJvbmpzLy4vc3JjL3BhZ2VzL2hvbWUuanM/ODA3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHVzZU5hdmlnYXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUocHJvcHMpe1xyXG4gIGNvbnN0IHsgbG9nZ2VkSW4sIGVtYWlsIH0gPSBwcm9wc1xyXG5cclxuICBjb25zdCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKClcclxuICBjb25zdCBvbkJ1dHRvbkNsaWNrID0gKCkgPT4ge1xyXG4gICAgaWYobG9nZ2VkSW4pe1xyXG4gICAgICBwcm9wcy5zZXRMb2dnZWRJbihmYWxzZSlcclxuICAgIH1lbHNle1xyXG4gICAgICBuYXZpZ2F0ZSgnL2xvZ2luJyk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWFpbkNvbnRhaW5lclwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17J3RpdGxlQ29udGFpbmVyJ30+XHJcbiAgICAgICAgPGRpdj5XZWxjb21lITwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9eydidXR0b25Db250YWluZXInfT5cclxuICAgICAgICA8aW5wdXRcclxuICAgICAgICAgIGNsYXNzTmFtZT17J2lucHV0QnV0dG9uJ31cclxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgb25DbGljaz17b25CdXR0b25DbGlja31cclxuICAgICAgICAgIHZhbHVlPXtsb2dnZWRJbiA/ICdMb2cgb3V0JyA6ICdMb2cgaW4nfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICAge2xvZ2dlZEluID8gPGRpdj5Zb3VyIGVtYWlsIGFkZHJlc3MgaXMge2VtYWlsfTwvZGl2PiA6IDxkaXYgLz59XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcblxyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VOYXZpZ2F0ZSIsIkhvbWUiLCJwcm9wcyIsImxvZ2dlZEluIiwiZW1haWwiLCJuYXZpZ2F0ZSIsIm9uQnV0dG9uQ2xpY2siLCJzZXRMb2dnZWRJbiIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ0eXBlIiwib25DbGljayIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/home.js\n");

/***/ }),

/***/ "./src/pages/login.js":
/*!****************************!*\
  !*** ./src/pages/login.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router/dist/index.js\");\n\n\nconst Login = props => {\n  const [email, setEmail] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  const [password, setPassword] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  const [emailError, setEmailError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  const [passwordError, setPasswordError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();\n  const onButtonClick = () => {\n    // Set initial error values to empty\n    setEmailError('');\n    setPasswordError('');\n\n    // Check if the user has entered both fields correctly\n    if ('' === email) {\n      setEmailError('Please enter your email');\n      return;\n    }\n    if (!/^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/.test(email)) {\n      setEmailError('Please enter a valid email');\n      return;\n    }\n    if ('' === password) {\n      setPasswordError('Please enter a password');\n      return;\n    }\n    if (password.length < 7) {\n      setPasswordError('The password must be 8 characters or longer');\n      return;\n    }\n\n    // Authentication calls will be made here...\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'mainContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'titleContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"Login\")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"br\", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'inputContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    value: email,\n    placeholder: \"Enter your email here\",\n    onChange: ev => setEmail(ev.target.value),\n    className: 'inputBox'\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"label\", {\n    className: \"errorLabel\"\n  }, emailError)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"br\", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'inputContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    value: password,\n    placeholder: \"Enter your password here\",\n    onChange: ev => setPassword(ev.target.value),\n    className: 'inputBox'\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"label\", {\n    className: \"errorLabel\"\n  }, passwordError)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"br\", null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: 'inputContainer'\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    className: 'inputButton',\n    type: \"button\",\n    onClick: onButtonClick,\n    value: 'Log in'\n  })));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Login);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyB1c2VOYXZpZ2F0ZSB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nXHJcblxyXG5jb25zdCBMb2dpbiA9IChwcm9wcykgPT4ge1xyXG4gIGNvbnN0IFtlbWFpbCwgc2V0RW1haWxdID0gdXNlU3RhdGUoJycpXHJcbiAgY29uc3QgW3Bhc3N3b3JkLCBzZXRQYXNzd29yZF0gPSB1c2VTdGF0ZSgnJylcclxuICBjb25zdCBbZW1haWxFcnJvciwgc2V0RW1haWxFcnJvcl0gPSB1c2VTdGF0ZSgnJylcclxuICBjb25zdCBbcGFzc3dvcmRFcnJvciwgc2V0UGFzc3dvcmRFcnJvcl0gPSB1c2VTdGF0ZSgnJylcclxuXHJcbiAgY29uc3QgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpXHJcblxyXG4gIGNvbnN0IG9uQnV0dG9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAvLyBTZXQgaW5pdGlhbCBlcnJvciB2YWx1ZXMgdG8gZW1wdHlcclxuICAgIHNldEVtYWlsRXJyb3IoJycpXHJcbiAgICBzZXRQYXNzd29yZEVycm9yKCcnKVxyXG4gIFxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaGFzIGVudGVyZWQgYm90aCBmaWVsZHMgY29ycmVjdGx5XHJcbiAgICBpZiAoJycgPT09IGVtYWlsKSB7XHJcbiAgICAgIHNldEVtYWlsRXJyb3IoJ1BsZWFzZSBlbnRlciB5b3VyIGVtYWlsJylcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgXHJcbiAgICBpZiAoIS9eW1xcdy1cXC5dK0AoW1xcdy1dK1xcLikrW1xcdy1dezIsNH0kLy50ZXN0KGVtYWlsKSkge1xyXG4gICAgICBzZXRFbWFpbEVycm9yKCdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCcpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gIFxyXG4gICAgaWYgKCcnID09PSBwYXNzd29yZCkge1xyXG4gICAgICBzZXRQYXNzd29yZEVycm9yKCdQbGVhc2UgZW50ZXIgYSBwYXNzd29yZCcpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gIFxyXG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IDcpIHtcclxuICAgICAgc2V0UGFzc3dvcmRFcnJvcignVGhlIHBhc3N3b3JkIG11c3QgYmUgOCBjaGFyYWN0ZXJzIG9yIGxvbmdlcicpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gQXV0aGVudGljYXRpb24gY2FsbHMgd2lsbCBiZSBtYWRlIGhlcmUuLi5cclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT17J21haW5Db250YWluZXInfT5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9eyd0aXRsZUNvbnRhaW5lcid9PlxyXG4gICAgICAgIDxkaXY+TG9naW48L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxiciAvPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17J2lucHV0Q29udGFpbmVyJ30+XHJcbiAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICB2YWx1ZT17ZW1haWx9XHJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgZW1haWwgaGVyZVwiXHJcbiAgICAgICAgICBvbkNoYW5nZT17KGV2KSA9PiBzZXRFbWFpbChldi50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXsnaW5wdXRCb3gnfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImVycm9yTGFiZWxcIj57ZW1haWxFcnJvcn08L2xhYmVsPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGJyIC8+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsnaW5wdXRDb250YWluZXInfT5cclxuICAgICAgICA8aW5wdXRcclxuICAgICAgICAgIHZhbHVlPXtwYXNzd29yZH1cclxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgeW91ciBwYXNzd29yZCBoZXJlXCJcclxuICAgICAgICAgIG9uQ2hhbmdlPXsoZXYpID0+IHNldFBhc3N3b3JkKGV2LnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9eydpbnB1dEJveCd9XHJcbiAgICAgICAgLz5cclxuICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZXJyb3JMYWJlbFwiPntwYXNzd29yZEVycm9yfTwvbGFiZWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8YnIgLz5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9eydpbnB1dENvbnRhaW5lcid9PlxyXG4gICAgICAgIDxpbnB1dCBjbGFzc05hbWU9eydpbnB1dEJ1dHRvbid9IHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXtvbkJ1dHRvbkNsaWNrfSB2YWx1ZT17J0xvZyBpbid9IC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMb2dpbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlTmF2aWdhdGUiLCJMb2dpbiIsInByb3BzIiwiZW1haWwiLCJzZXRFbWFpbCIsInBhc3N3b3JkIiwic2V0UGFzc3dvcmQiLCJlbWFpbEVycm9yIiwic2V0RW1haWxFcnJvciIsInBhc3N3b3JkRXJyb3IiLCJzZXRQYXNzd29yZEVycm9yIiwibmF2aWdhdGUiLCJvbkJ1dHRvbkNsaWNrIiwidGVzdCIsImxlbmd0aCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ2YWx1ZSIsInBsYWNlaG9sZGVyIiwib25DaGFuZ2UiLCJldiIsInRhcmdldCIsInR5cGUiLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/login.js\n");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.js */ \"./src/App.js\");\n/**\r\n * This file will automatically be loaded by webpack and run in the \"renderer\" context.\r\n * To learn more about the differences between the \"main\" and the \"renderer\" context in\r\n * Electron, visit:\r\n *\r\n * https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes\r\n *\r\n * By default, Node.js integration in this file is disabled. When enabling Node.js integration\r\n * in a renderer process, please be aware of potential security implications. You can read\r\n * more about security risks here:\r\n *\r\n * https://electronjs.org/docs/tutorial/security\r\n *\r\n * To enable Node.js integration in this file, open up `main.js` and enable the `nodeIntegration`\r\n * flag:\r\n *\r\n * ```\r\n *  // Create the browser window.\r\n *  mainWindow = new BrowserWindow({\r\n *    width: 800,\r\n *    height: 600,\r\n *    webPreferences: {\r\n *      nodeIntegration: true\r\n *    }\r\n *  });\r\n * ```\r\n */\n// Add this to the end of the existing file\n\n\nconsole.log(' This message is being logged by \"renderer.js\", included via webpack');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0I7QUFJbEJBLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHdFQUF3RSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWxlY3Ryb25qcy8uL3NyYy9yZW5kZXJlci5qcz84OGMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGZpbGUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGxvYWRlZCBieSB3ZWJwYWNrIGFuZCBydW4gaW4gdGhlIFwicmVuZGVyZXJcIiBjb250ZXh0LlxyXG4gKiBUbyBsZWFybiBtb3JlIGFib3V0IHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBcIm1haW5cIiBhbmQgdGhlIFwicmVuZGVyZXJcIiBjb250ZXh0IGluXHJcbiAqIEVsZWN0cm9uLCB2aXNpdDpcclxuICpcclxuICogaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL3R1dG9yaWFsL2FwcGxpY2F0aW9uLWFyY2hpdGVjdHVyZSNtYWluLWFuZC1yZW5kZXJlci1wcm9jZXNzZXNcclxuICpcclxuICogQnkgZGVmYXVsdCwgTm9kZS5qcyBpbnRlZ3JhdGlvbiBpbiB0aGlzIGZpbGUgaXMgZGlzYWJsZWQuIFdoZW4gZW5hYmxpbmcgTm9kZS5qcyBpbnRlZ3JhdGlvblxyXG4gKiBpbiBhIHJlbmRlcmVyIHByb2Nlc3MsIHBsZWFzZSBiZSBhd2FyZSBvZiBwb3RlbnRpYWwgc2VjdXJpdHkgaW1wbGljYXRpb25zLiBZb3UgY2FuIHJlYWRcclxuICogbW9yZSBhYm91dCBzZWN1cml0eSByaXNrcyBoZXJlOlxyXG4gKlxyXG4gKiBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvdHV0b3JpYWwvc2VjdXJpdHlcclxuICpcclxuICogVG8gZW5hYmxlIE5vZGUuanMgaW50ZWdyYXRpb24gaW4gdGhpcyBmaWxlLCBvcGVuIHVwIGBtYWluLmpzYCBhbmQgZW5hYmxlIHRoZSBgbm9kZUludGVncmF0aW9uYFxyXG4gKiBmbGFnOlxyXG4gKlxyXG4gKiBgYGBcclxuICogIC8vIENyZWF0ZSB0aGUgYnJvd3NlciB3aW5kb3cuXHJcbiAqICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xyXG4gKiAgICB3aWR0aDogODAwLFxyXG4gKiAgICBoZWlnaHQ6IDYwMCxcclxuICogICAgd2ViUHJlZmVyZW5jZXM6IHtcclxuICogICAgICBub2RlSW50ZWdyYXRpb246IHRydWVcclxuICogICAgfVxyXG4gKiAgfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuLy8gQWRkIHRoaXMgdG8gdGhlIGVuZCBvZiB0aGUgZXhpc3RpbmcgZmlsZVxyXG5cclxuaW1wb3J0ICcuL0FwcC5qcyc7XHJcblxyXG5cclxuXHJcbmNvbnNvbGUubG9nKCfwn5GLIFRoaXMgbWVzc2FnZSBpcyBiZWluZyBsb2dnZWQgYnkgXCJyZW5kZXJlci5qc1wiLCBpbmNsdWRlZCB2aWEgd2VicGFjaycpO1xyXG4iXSwibmFtZXMiOlsiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/renderer.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 		__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 		module = execOptions.module;
/******/ 		execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main_window." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("df708ce1bdf96aea1b0c")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "electronjs:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = "C:\\Users\\maugo\\OneDrive\\Documentos\\GitHub\\Electronjs\\.webpack\\renderer" + "/native_modules/";
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main_window": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateelectronjs"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=true&reconnect=10&hot=true&live-reload=true");
/******/ 	__webpack_require__("./node_modules/webpack/hot/dev-server.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/renderer.js");
/******/ 	
/******/ })()
;